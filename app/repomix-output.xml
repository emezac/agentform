This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/*.log, tmp/, venv, *.md, tmp/cache, *.css, **.css, /doc/, /docs/
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
agents/
  admin/
    dashboard_agent.rb
  forms/
    management_agent.rb
    response_agent.rb
  application_agent.rb
channels/
  application_cable/
    channel.rb
    connection.rb
  form_response_channel.rb
  session_channel.rb
controllers/
  admin/
    base_controller.rb
    dashboard_controller.rb
    discount_codes_controller.rb
    notifications_controller.rb
    payment_analytics_controller.rb
    security_controller.rb
    users_controller.rb
  api/
    v1/
      analytics_controller.rb
      discount_codes_controller.rb
      forms_controller.rb
      payment_setup_controller.rb
      responses_controller.rb
    base_controller.rb
  concerns/
    admin_security.rb
    payment_error_handling.rb
    safe_pagination.rb
  forms/
    exports_controller.rb
  integrations/
    google_sheets_controller.rb
  users/
    registrations_controller.rb
    sessions_controller.rb
  analytics_controller.rb
  application_controller.rb
  billings_controller.rb
  blogs_controller.rb
  dynamic_questions_controller.rb
  form_questions_controller.rb
  forms_controller.rb
  google_integrations_controller.rb
  google_oauth_controller.rb
  health_controller.rb
  landing_controller.rb
  payment_setup_controller.rb
  payments_controller.rb
  profile_controller.rb
  profiles_controller.rb
  reports_controller.rb
  responses_controller.rb
  stripe_settings_controller.rb
  stripe_webhooks_controller.rb
  subscription_management_controller.rb
  subscription_upgrades_controller.rb
  subscriptions_controller.rb
  templates_controller.rb
helpers/
  admin_helper.rb
  application_helper.rb
  content_security_policy_helper.rb
  google_integration_helper.rb
  payment_error_helper.rb
javascript/
  channels/
    form_response_channel.js
    session_channel.js
  controllers/
    admin_notifications_controller.js
    ai_form_generator_controller.js
    auto_dismiss_controller.js
    debug_controller.js
    discount_code_controller.js
    dropdown_controller.js
    dynamic_question_controller.js
    error_recovery_controller.js
    file_upload_controller.js
    form_animation_controller.js
    form_builder_controller.js
    form_preview_controller.js
    form_response_controller.js
    google_connection_controller.js
    google_sheets_integration_controller.js
    hello_controller.js
    payment_error_controller.js
    payment_error_flash_controller.js
    payment_setup_controller.js
    payment_setup_guidance_controller.js
    payment_setup_required_button_controller.js
    payment_setup_status_controller.js
    question_response_controller.js
    rating_controller.js
    sortable_controller.js
    stripe_settings_controller.js
    subscription_checkout_controller.js
    tabs_controller.js
    template_gallery_controller.js
    template_preview_controller.js
  application.js
  payment_integration.js
jobs/
  ai/
    cache_warming_job.rb
    database_performance_monitoring_job.rb
  forms/
    budget_adaptation_job.rb
    completion_workflow_job.rb
    data_enrichment_job.rb
    dynamic_question_generation_job.rb
    integration_trigger_job.rb
    lead_scoring_job.rb
    process_a_i_workflow_job.rb
    report_generation_job.rb
    response_analysis_job.rb
    workflow_generation_job.rb
  admin_maintenance_job.rb
  admin_security_monitoring_job.rb
  application_job.rb
  discount_code_cleanup_job.rb
  google_sheets_export_job.rb
  google_sheets_sync_job.rb
  google_token_refresh_job.rb
  notification_cleanup_job.rb
  payment_analytics_job.rb
  payment_setup_validation_job.rb
  response_volume_check_job.rb
  template_payment_analysis_job.rb
  trial_expiration_check_job.rb
  trial_expiration_job.rb
  user_invitation_job.rb
  user_reactivation_job.rb
  user_suspension_job.rb
lib/
  circuit_breaker/
    job_integration.rb
mailers/
  application_mailer.rb
  user_mailer.rb
models/
  concerns/
    admin_cacheable.rb
    cacheable.rb
    encryptable.rb
    payment_analytics_trackable.rb
    payment_validation_error.rb
    payment_validation_errors.rb
  admin_notification.rb
  analysis_report.rb
  api_token.rb
  application_record.rb
  audit_log.rb
  current.rb
  discount_code_usage.rb
  discount_code.rb
  dynamic_question.rb
  export_job.rb
  form_analytic.rb
  form_question.rb
  form_response.rb
  form_template.rb
  form.rb
  google_integration.rb
  google_sheets_integration.rb
  lead_routing.rb
  lead_scoring.rb
  payment_analytic.rb
  payment_transaction.rb
  question_response.rb
  user.rb
policies/
  application_policy.rb
  form_policy.rb
  form_question_policy.rb
  form_response_policy.rb
  form_template_policy.rb
  google_integration_policy.rb
  google_sheets_integration_policy.rb
  user_policy.rb
services/
  ai/
    api_key_management_service.rb
    cache_management_service.rb
    caching_service.rb
    connection_pool_service.rb
    database_optimization_service.rb
    document_processor.rb
    error_message_service.rb
    error_tracking_service.rb
    llm_monitoring_service.rb
    prompt_security_service.rb
    rate_limiting_service.rb
    retry_mechanism_service.rb
    security_service.rb
    usage_analytics_service.rb
    usage_monitoring_service.rb
    user_behavior_tracking_service.rb
  forms/
    answer_processing_service.rb
    navigation_service.rb
    workflow_generator_service.rb
  google_sheets/
    base_service.rb
    config_service.rb
    connection_test_service.rb
    export_service.rb
    rate_limiter.rb
    spreadsheet_creator_service.rb
    token_refresh_service.rb
  integrations/
    google_sheets_service.rb
  stripe/
    checkout_completed_service.rb
    invoice_payment_failed_service.rb
    invoice_payment_succeeded_service.rb
    setup_intent_succeeded_service.rb
    subscription_deleted_service.rb
    subscription_updated_service.rb
  admin_cache_service.rb
  admin_monitoring_service.rb
  admin_notification_service.rb
  application_service.rb
  discount_code_service.rb
  form_publish_validation_service.rb
  lead_scoring_calculator.rb
  payment_analytics_service.rb
  payment_configuration_service.rb
  payment_error_recovery_service.rb
  payment_fallback_validation_service.rb
  payment_readiness_checker.rb
  payment_requirement_detector.rb
  payment_setup_validation_service.rb
  redis_error_logger.rb
  service_object.rb
  stripe_configuration_checker.rb
  stripe_payment_service.rb
  subscription_management_service.rb
  template_analysis_service.rb
  user_management_service.rb
views/
  admin/
    dashboard/
      index.html.erb
    discount_codes/
      edit.html.erb
      index.html.erb
      new.html.erb
      show.html.erb
    notifications/
      _notification.html.erb
      _notifications_list.html.erb
      index.html.erb
    payment_analytics/
      index.html.erb
    security/
      index.html.erb
    users/
      edit.html.erb
      index.html.erb
      new.html.erb
      show.html.erb
  billings/
    index.html.erb
  blogs/
    index.html.erb
    show.html.erb
  devise/
    confirmations/
      new.html.erb
    mailer/
      confirmation_instructions.html.erb
      email_changed.html.erb
      password_change.html.erb
      reset_password_instructions.html.erb
      unlock_instructions.html.erb
    passwords/
      edit.html.erb
      new.html.erb
    registrations/
      edit.html.erb
      new.html.erb
    sessions/
      new.html.erb
    shared/
      _error_messages.html.erb
      _links.html.erb
    unlocks/
      new.html.erb
  errors/
    404.html.erb
    form_error.html.erb
  form_questions/
    analytics.html.erb
    edit.html.erb
    index.html.erb
    new.html.erb
    preview.html.erb
    show.html.erb
  forms/
    _configuration_panel.html.erb
    _configuration_tabs.html.erb
    _form_card.html.erb
    _form_header.html.erb
    _form.html.erb
    _google_sheets_integration.html.erb
    _lead_routing_status.html.erb
    _payment_notification_bar.html.erb
    _payment_setup_modal.html.erb
    _payment_status_indicator.html.erb
    _publish_section_with_payment_guidance.html.erb
    _question_card_ajax.html.erb
    _question_card.html.erb
    _questions_panel.html.erb
    _status_indicator.html.erb
    ai_generation_error.html.erb
    ai_generation_result.html.erb
    analytics.html.erb
    edit.html.erb
    index.html.erb
    new_from_ai.html.erb
    new.html.erb
    preview.html.erb
    responses.html.erb
    show.html.erb
  google_integrations/
    show.html.erb
  landing/
    index.html.erb
  layouts/
    admin.html.erb
    application.html.erb
    devise.html.erb
    error.html.erb
    form_builder.html.erb
    form_response.html.erb
    landing.html.erb
    mailer.html.erb
    mailer.text.erb
    public_form.html.erb
  payment_setup/
    index.html.erb
  profile/
    show.html.erb
  profiles/
    show.html.erb
  pwa/
    manifest.json.erb
    service-worker.js
  question_types/
    _address.html.erb
    _boolean.html.erb
    _checkbox.html.erb
    _date.html.erb
    _datetime.html.erb
    _drag_drop.html.erb
    _email.html.erb
    _file_upload.html.erb
    _image_upload.html.erb
    _location.html.erb
    _matrix.html.erb
    _multiple_choice.html.erb
    _nps_score.html.erb
    _number.html.erb
    _payment.html.erb
    _phone.html.erb
    _ranking.html.erb
    _rating.html.erb
    _scale.html.erb
    _signature.html.erb
    _single_choice.html.erb
    _slider.html.erb
    _text_long.html.erb
    _text_short.html.erb
    _time.html.erb
    _url.html.erb
    _yes_no.html.erb
  reports/
    show.html.erb
  responses/
    _budget_adaptation_question.html.erb
    _dynamic_question_error.html.erb
    _dynamic_question_success.html.erb
    _dynamic_question.html.erb
    _enrichment_data.html.erb
    show.html.erb
    thank_you.html.erb
  shared/
    _flash_message.html.erb
    _google_connection_status.html.erb
    _google_setup_instructions.html.erb
    _payment_badge.html.erb
    _payment_error_education.html.erb
    _payment_error_flash.html.erb
    _payment_requirements_modal.html.erb
    _payment_setup_guidance.html.erb
    _payment_setup_required_button.html.erb
    _payment_setup_status.html.erb
    _payment_validation_error.html.erb
    _setup_completion_notification.html.erb
    _template_analysis_complete.html.erb
    _template_analysis_error.html.erb
  stripe_settings/
    show.html.erb
  subscription_management/
    show.html.erb
  subscription_upgrades/
    new.html.erb
  subscriptions/
    new.html.erb
  templates/
    _template_card.html.erb
    index.html.erb
    show.html.erb
  user_mailer/
    account_confirmation.html.erb
    account_confirmation.text.erb
    account_reactivated.html.erb
    account_reactivated.text.erb
    account_suspended.html.erb
    account_suspended.text.erb
    admin_invitation.html.erb
    admin_invitation.text.erb
    premium_welcome.html.erb
    premium_welcome.text.erb
    trial_welcome.html.erb
    trial_welcome.text.erb
workflows/
  forms/
    ai_form_generation_workflow.rb
    analysis_workflow.rb
    budget_adaptation_workflow.rb
    dynamic_question_workflow.rb
    enrichment_workflow.rb
    lead_scoring_workflow.rb
    report_generation_workflow.rb
    response_processing_workflow.rb
  application_workflow.rb
  payment_validation_workflow.rb
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="agents/admin/dashboard_agent.rb">
class Admin::DashboardAgent < ApplicationAgent
  def get_dashboard_stats
    # Use caching service for better performance
    {
      user_stats: AdminCacheService.user_statistics,
      subscription_stats: get_subscription_statistics,
      discount_code_stats: AdminCacheService.discount_code_statistics,
      recent_activity: AdminCacheService.analytics_data('recent_activity'),
      quick_actions: get_quick_actions
    }
  end

  private

  def get_user_statistics
    # Use a single optimized query for all user statistics
    one_month_ago = 1.month.ago.strftime('%Y-%m-%d %H:%M:%S')
    
    stats = User.connection.select_one(<<~SQL)
      SELECT 
        COUNT(*) as total_users,
        COUNT(CASE WHEN suspended_at IS NULL THEN 1 END) as active_users,
        COUNT(CASE WHEN suspended_at IS NOT NULL THEN 1 END) as suspended_users,
        COUNT(CASE WHEN created_at >= '#{one_month_ago}' THEN 1 END) as new_users_this_month,
        COUNT(CASE WHEN subscription_tier = 'premium' THEN 1 END) as premium_users,
        COUNT(CASE WHEN subscription_tier = 'basic' THEN 1 END) as basic_users
      FROM users
    SQL

    total_users = stats['total_users'].to_i
    premium_users = stats['premium_users'].to_i

    {
      total: total_users,
      active: stats['active_users'].to_i,
      suspended: stats['suspended_users'].to_i,
      new_this_month: stats['new_users_this_month'].to_i,
      premium: premium_users,
      basic: stats['basic_users'].to_i,
      premium_percentage: total_users > 0 ? (premium_users.to_f / total_users * 100).round(1) : 0
    }
  end

  def get_subscription_statistics
    total_subscriptions = User.where(subscription_tier: 'premium').count
    active_subscriptions = User.where(subscription_tier: 'premium', suspended_at: nil).count
    
    # Calculate monthly recurring revenue (assuming $35/month for premium)
    mrr = active_subscriptions * 35
    
    # Get subscription growth this month
    new_subscriptions_this_month = User.where(
      subscription_tier: 'premium',
      created_at: 1.month.ago..Time.current
    ).count

    {
      total: total_subscriptions,
      active: active_subscriptions,
      mrr: mrr,
      new_this_month: new_subscriptions_this_month,
      conversion_rate: calculate_conversion_rate
    }
  end

  def get_discount_code_statistics
    # Use optimized queries with caching
    Rails.cache.fetch('admin_dashboard_discount_stats', expires_in: 5.minutes) do
      # Single query for discount code statistics
      code_stats = DiscountCode.connection.select_one(<<~SQL)
        SELECT 
          COUNT(*) as total_codes,
          COUNT(CASE WHEN active = true AND (expires_at IS NULL OR expires_at > NOW()) THEN 1 END) as active_codes,
          COUNT(CASE WHEN expires_at < NOW() THEN 1 END) as expired_codes,
          SUM(current_usage_count) as total_usage
        FROM discount_codes
      SQL

      # Single query for usage statistics
      usage_stats = DiscountCodeUsage.connection.select_one(<<~SQL)
        SELECT 
          SUM(discount_amount) as total_discount_amount,
          COUNT(*) as usage_count
        FROM discount_code_usages
      SQL

      # Get most popular discount code
      most_popular_code = DiscountCode.select('code, current_usage_count')
                                     .order(current_usage_count: :desc)
                                     .first

      total_usage = usage_stats['usage_count'].to_i
      total_discount_amount = usage_stats['total_discount_amount'].to_i

      {
        total_codes: code_stats['total_codes'].to_i,
        active_codes: code_stats['active_codes'].to_i,
        expired_codes: code_stats['expired_codes'].to_i,
        total_usage: total_usage,
        total_discount_amount: total_discount_amount,
        most_popular_code: most_popular_code&.code,
        average_discount_per_use: total_usage > 0 ? (total_discount_amount.to_f / total_usage).round(2) : 0
      }
    end
  end

  def get_recent_activity
    activities = []

    # Recent user registrations
    recent_users = User.order(created_at: :desc).limit(5)
    recent_users.each do |user|
      activities << {
        type: 'user_registration',
        message: "New user registered: #{user.email}",
        timestamp: user.created_at,
        icon: 'user-plus',
        color: 'text-green-600'
      }
    end

    # Recent discount code usage
    recent_usages = DiscountCodeUsage.includes(:user, :discount_code)
                                    .order(created_at: :desc)
                                    .limit(5)
    recent_usages.each do |usage|
      activities << {
        type: 'discount_usage',
        message: "Discount code '#{usage.discount_code.code}' used by #{usage.user.email}",
        timestamp: usage.created_at,
        icon: 'tag',
        color: 'text-purple-600'
      }
    end

    # Recent user suspensions
    recent_suspensions = User.where.not(suspended_at: nil)
                            .order(suspended_at: :desc)
                            .limit(3)
    recent_suspensions.each do |user|
      activities << {
        type: 'user_suspension',
        message: "User suspended: #{user.email} - #{user.suspended_reason}",
        timestamp: user.suspended_at,
        icon: 'user-x',
        color: 'text-red-600'
      }
    end

    # Sort all activities by timestamp and return the most recent 10
    activities.sort_by { |activity| activity[:timestamp] }.reverse.first(10)
  end

  def get_quick_actions
    [
      {
        title: 'Create Discount Code',
        description: 'Add a new promotional discount code',
        url: '/admin/discount_codes/new',
        icon: 'plus-circle',
        color: 'bg-purple-600 hover:bg-purple-700'
      },
      {
        title: 'Manage Users',
        description: 'View and manage user accounts',
        url: '/admin/users',
        icon: 'users',
        color: 'bg-indigo-600 hover:bg-indigo-700'
      },
      {
        title: 'View Discount Codes',
        description: 'Manage promotional codes',
        url: '/admin/discount_codes',
        icon: 'tag',
        color: 'bg-green-600 hover:bg-green-700'
      },
      {
        title: 'Export Data',
        description: 'Export user and usage data',
        url: '#',
        icon: 'download',
        color: 'bg-gray-600 hover:bg-gray-700'
      }
    ]
  end

  def calculate_conversion_rate
    total_users = User.count
    premium_users = User.where(subscription_tier: 'premium').count
    
    return 0 if total_users == 0
    
    (premium_users.to_f / total_users * 100).round(2)
  end
end
</file>

<file path="agents/forms/management_agent.rb">
# frozen_string_literal: true

module Forms
  # Agent responsible for managing form lifecycle operations
  # Handles form creation, analysis, optimization, and management tasks
  class ManagementAgent < ApplicationAgent
    
    # Supported task types for this agent
    SUPPORTED_TASKS = %w[
      create_form
      analyze_form_performance
      optimize_form
      generate_form_from_template
      duplicate_form
      duplicate_question
      export_form_data
      publish_form
    ].freeze
    
    def initialize(context = {})
      super(context)
      @supported_tasks = SUPPORTED_TASKS
    end
    
    # Create a new form for a user with the provided form data
    # @param user [User] The user who will own the form
    # @param form_data [Hash] Form configuration and settings
    # @return [Hash] Success/error response with form data
    def create_form(user, form_data)
      validate_context(:user_id) if @context[:user_id]
      
      log_activity("create_form", { user_id: user.id, form_name: form_data[:name] })
      
      safe_db_operation do
        # Validate user permissions
        unless authorized?('write')
          return error_response("User not authorized to create forms", 'authorization_error')
        end
        
        # Validate form data
        validation_result = validate_form_data(form_data)
        unless validation_result[:valid]
          return error_response(validation_result[:errors].join(', '), 'validation_error')
        end
        
        # Create the form
        form = Form.new(prepare_form_attributes(user, form_data))
        
        if form.save
          # Generate workflow class if AI features are enabled
          if form.ai_enhanced?
            generate_workflow_for_form(form)
          end
          
          # Track form creation
          track_form_creation(form)
          
          success_response({
            form: form,
            form_id: form.id,
            share_token: form.share_token,
            public_url: form.public_url
          })
        else
          error_response(form.errors.full_messages.join(', '), 'creation_error')
        end
      end
    end
    
    # Analyze form performance and generate insights
    # @param form [Form] The form to analyze
    # @return [Hash] Analysis results and recommendations
    def analyze_form_performance(form)
      log_activity("analyze_form_performance", { form_id: form.id })
      
      # Validate form ownership
      unless owns_resource?(form)
        return error_response("Not authorized to analyze this form", 'authorization_error')
      end
      
      # Check if form has enough data for analysis
      if form.responses_count < 10
        return error_response("Form needs at least 10 responses for analysis", 'insufficient_data')
      end
      
      # Execute analysis workflow
      workflow_result = execute_workflow(
        Forms::AnalysisWorkflow,
        { form_id: form.id }
      )
      
      if workflow_result[:success]
        success_response({
          analysis: workflow_result[:data],
          form_id: form.id,
          analyzed_at: Time.current
        })
      else
        error_response("Analysis failed: #{workflow_result[:error_message]}", 'analysis_error')
      end
    end
    
    # Optimize form based on performance data and AI recommendations
    # @param form [Form] The form to optimize
    # @param optimization_preferences [Hash] User preferences for optimization
    # @return [Hash] Optimization results and applied changes
    def optimize_form(form, optimization_preferences = {})
      log_activity("optimize_form", { form_id: form.id, preferences: optimization_preferences })
      
      # Validate form ownership
      unless owns_resource?(form)
        return error_response("Not authorized to optimize this form", 'authorization_error')
      end
      
      # Check AI credits availability
      estimated_cost = calculate_optimization_cost(form)
      unless current_user&.can_use_ai_features? && ai_budget_available?(@context, estimated_cost)
        return error_response("Insufficient AI credits for optimization", 'insufficient_credits')
      end
      
      safe_db_operation do
        # Get current form analytics
        analytics = form.analytics_summary
        
        # Generate optimization recommendations
        optimization_result = generate_optimization_recommendations(form, analytics, optimization_preferences)
        
        if optimization_result[:success]
          # Apply approved optimizations
          applied_changes = apply_optimizations(form, optimization_result[:recommendations])
          
          # Track AI usage
          track_ai_usage(@context, estimated_cost, 'form_optimization')
          
          success_response({
            optimizations_applied: applied_changes,
            recommendations: optimization_result[:recommendations],
            estimated_improvement: optimization_result[:estimated_improvement],
            form_id: form.id
          })
        else
          error_response("Optimization failed: #{optimization_result[:error]}", 'optimization_error')
        end
      end
    end
    
    # Generate a new form from a template
    # @param user [User] The user who will own the new form
    # @param template_id [String] ID of the template to use
    # @param customizations [Hash] Custom modifications to apply
    # @return [Hash] Success/error response with new form data
    def generate_form_from_template(user, template_id, customizations = {})
      log_activity("generate_form_from_template", { 
        user_id: user.id, 
        template_id: template_id,
        customizations: customizations.keys
      })
      
      safe_db_operation do
        # Find and validate template
        template = FormTemplate.find_by(id: template_id)
        unless template
          return error_response("Template not found", 'not_found_error')
        end
        
        # Check template visibility permissions
        unless template.visibility == 'public' || template.creator == user
          return error_response("Template not accessible", 'authorization_error')
        end
        
        # Generate form from template
        form = template.instantiate_for_user(user, customizations)
        
        if form.persisted?
          # Update template usage count
          template.increment!(:usage_count)
          
          # Generate workflow if needed
          if form.ai_enhanced?
            generate_workflow_for_form(form)
          end
          
          success_response({
            form: form,
            form_id: form.id,
            template_id: template_id,
            customizations_applied: customizations.keys
          })
        else
          error_response(form.errors.full_messages.join(', '), 'creation_error')
        end
      end
    end
    
    # Duplicate an existing form with optional modifications
    # @param source_form [Form] The form to duplicate
    # @param target_user [User] The user who will own the duplicate
    # @param modifications [Hash] Changes to apply to the duplicate
    # @return [Hash] Success/error response with duplicated form data
    def duplicate_form(source_form, target_user, modifications = {})
      log_activity("duplicate_form", { 
        source_form_id: source_form.id,
        target_user_id: target_user.id,
        modifications: modifications.keys
      })
      
      # Validate source form access
      unless owns_resource?(source_form) || source_form.status == 'template'
        return error_response("Not authorized to duplicate this form", 'authorization_error')
      end
      
      safe_db_operation do
        # Create duplicate form
        duplicate_attributes = prepare_duplicate_attributes(source_form, target_user, modifications)
        duplicate_form = Form.new(duplicate_attributes)
        
        if duplicate_form.save
          # Duplicate questions
          duplicate_questions(source_form, duplicate_form)
          
          # Apply modifications
          apply_form_modifications(duplicate_form, modifications) if modifications.any?
          
          # Generate workflow if AI features enabled
          if duplicate_form.ai_enhanced?
            generate_workflow_for_form(duplicate_form)
          end
          
          success_response({
            duplicate_form: duplicate_form,
            source_form_id: source_form.id,
            duplicate_form_id: duplicate_form.id,
            modifications_applied: modifications.keys
          })
        else
          error_response(duplicate_form.errors.full_messages.join(', '), 'duplication_error')
        end
      end
    end
    
    # Export form data in various formats
    # @param form [Form] The form to export
    # @param export_options [Hash] Export configuration and format options
    # @return [Hash] Export results with download links or data
    def export_form_data(form, export_options = {})
      log_activity("export_form_data", { 
        form_id: form.id, 
        format: export_options[:format],
        include_responses: export_options[:include_responses]
      })
      
      # Validate form ownership
      unless owns_resource?(form)
        return error_response("Not authorized to export this form", 'authorization_error')
      end
      
      begin
        # Prepare export data
        export_data = prepare_export_data(form, export_options)
        
        # Generate export file based on format
        export_result = generate_export_file(export_data, export_options)
        
        if export_result[:success]
          success_response({
            export_url: export_result[:download_url],
            export_format: export_options[:format] || 'json',
            exported_at: Time.current,
            record_count: export_result[:record_count]
          })
        else
          error_response("Export failed: #{export_result[:error]}", 'export_error')
        end
      rescue StandardError => e
        logger.error "Export failed for form #{form.id}: #{e.message}"
        error_response("Export processing failed", 'export_error')
      end
    end
    
    # Publish a form and make it available for responses
    # @param form [Form] The form to publish
    # @return [Hash] Success/error response with publication details
    def publish_form(form)
      log_activity("publish_form", { form_id: form.id })
      
      # Validate form ownership
      unless owns_resource?(form)
        return error_response("Not authorized to publish this form", 'authorization_error')
      end
      
      safe_db_operation do
        # Validate form is ready for publication
        validation_result = validate_form_for_publication(form)
        unless validation_result[:valid]
          return error_response(validation_result[:errors].join(', '), 'validation_error')
        end
        
        # Update form status
        form.status = 'published'
        
        if form.save
          # Generate or regenerate workflow if needed
          if form.ai_enhanced?
            generate_workflow_for_form(form)
          end
          
          # Track publication
          track_form_publication(form)
          
          success_response({
            form_id: form.id,
            status: form.status,
            public_url: form.public_url,
            share_token: form.share_token,
            published_at: Time.current
          })
        else
          error_response(form.errors.full_messages.join(', '), 'publication_error')
        end
      end
    end
    
    # Duplicate a question within a form
    # @param source_question [FormQuestion] The question to duplicate
    # @param modifications [Hash] Changes to apply to the duplicate
    # @return [FormQuestion] The duplicated question
    def duplicate_question(source_question, modifications = {})
      log_activity("duplicate_question", { 
        source_question_id: source_question.id,
        form_id: source_question.form_id,
        modifications: modifications.keys
      })
      
      # Validate question access
      unless owns_resource?(source_question.form)
        raise StandardError, "Not authorized to duplicate this question"
      end
      
      safe_db_operation do
        # Prepare duplicate attributes
        question_attributes = source_question.attributes.except(
          'id', 'created_at', 'updated_at'
        )
        
        # Apply modifications
        question_attributes.merge!(modifications)
        
        # Create duplicate question
        duplicate_question = source_question.form.form_questions.create!(question_attributes)
        
        logger.info "Question duplicated: #{source_question.id} -> #{duplicate_question.id}"
        
        duplicate_question
      end
    end
    
    # Get list of supported tasks
    def supported_tasks
      SUPPORTED_TASKS
    end
    
    private
    
    # Validate form data structure and required fields
    def validate_form_data(form_data)
      errors = []
      
      # Required fields validation
      errors << "Name is required" if form_data[:name].blank?
      errors << "Name must be less than 255 characters" if form_data[:name]&.length&.> 255
      
      # Validate AI configuration if present
      if form_data[:ai_configuration].present?
        ai_errors = validate_ai_configuration(form_data[:ai_configuration])
        errors.concat(ai_errors)
      end
      
      # Validate style configuration if present
      if form_data[:style_configuration].present?
        style_errors = validate_style_configuration(form_data[:style_configuration])
        errors.concat(style_errors)
      end
      
      {
        valid: errors.empty?,
        errors: errors
      }
    end
    
    # Validate AI configuration parameters
    def validate_ai_configuration(ai_config)
      errors = []
      
      if ai_config[:enabled] && ai_config[:model].blank?
        errors << "AI model must be specified when AI is enabled"
      end
      
      if ai_config[:temperature] && (ai_config[:temperature] < 0 || ai_config[:temperature] > 2)
        errors << "AI temperature must be between 0 and 2"
      end
      
      errors
    end
    
    # Validate style configuration parameters
    def validate_style_configuration(style_config)
      errors = []
      
      # Validate color format if present
      if style_config[:primary_color] && !valid_color_format?(style_config[:primary_color])
        errors << "Invalid primary color format"
      end
      
      errors
    end
    
    # Check if color is in valid hex format
    def valid_color_format?(color)
      color.match?(/\A#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})\z/)
    end
    
    # Prepare form attributes for creation
    def prepare_form_attributes(user, form_data)
      {
        user: user,
        name: form_data[:name],
        description: form_data[:description],
        category: form_data[:category] || 'general',
        form_settings: form_data[:form_settings] || {},
        ai_configuration: form_data[:ai_configuration] || {},
        style_configuration: form_data[:style_configuration] || {},
        integration_settings: form_data[:integration_settings] || {}
      }
    end
    
    # Generate workflow class for form with AI features
    def generate_workflow_for_form(form)
      return unless form.ai_enhanced?
      
      begin
        # Execute workflow generation job asynchronously
        Forms::WorkflowGenerationJob.perform_async(form.id)
        logger.info "Workflow generation queued for form #{form.id}"
      rescue StandardError => e
        logger.error "Failed to queue workflow generation for form #{form.id}: #{e.message}"
      end
    end
    
    # Track form creation metrics
    def track_form_creation(form)
      # Track in analytics
      logger.info "Form created: #{form.id} by user #{form.user_id}"
      
      # Update user stats if needed
      form.user.increment!(:forms_count) if form.user.respond_to?(:forms_count)
    end
    
    # Calculate estimated cost for form optimization
    def calculate_optimization_cost(form)
      # Base cost for analysis
      base_cost = 0.05
      
      # Additional cost based on form complexity
      question_cost = form.form_questions.count * 0.01
      response_cost = [form.responses_count, 100].min * 0.001
      
      base_cost + question_cost + response_cost
    end
    
    # Generate AI-powered optimization recommendations
    def generate_optimization_recommendations(form, analytics, preferences)
      # This would integrate with the optimization workflow
      # For now, return a placeholder structure
      {
        success: true,
        recommendations: [
          {
            type: 'question_order',
            description: 'Reorder questions to improve completion rate',
            impact: 'medium',
            estimated_improvement: '15%'
          }
        ],
        estimated_improvement: '15%'
      }
    end
    
    # Apply optimization recommendations to form
    def apply_optimizations(form, recommendations)
      applied_changes = []
      
      recommendations.each do |recommendation|
        case recommendation[:type]
        when 'question_order'
          # Apply question reordering logic
          applied_changes << "Reordered questions for better flow"
        when 'conditional_logic'
          # Apply conditional logic improvements
          applied_changes << "Improved conditional logic"
        end
      end
      
      applied_changes
    end
    
    # Prepare attributes for form duplication
    def prepare_duplicate_attributes(source_form, target_user, modifications)
      attributes = source_form.attributes.except(
        'id', 'created_at', 'updated_at', 'share_token', 
        'views_count', 'responses_count', 'completions_count'
      )
      
      attributes.merge!(
        user: target_user,
        name: "#{source_form.name} (Copy)",
        status: 'draft'
      )
      
      # Apply name modification if provided
      if modifications[:name]
        attributes[:name] = modifications[:name]
      end
      
      attributes
    end
    
    # Duplicate questions from source to target form
    def duplicate_questions(source_form, target_form)
      source_form.form_questions.order(:position).each do |question|
        question_attributes = question.attributes.except('id', 'form_id', 'created_at', 'updated_at')
        target_form.form_questions.create!(question_attributes)
      end
    end
    
    # Apply modifications to duplicated form
    def apply_form_modifications(form, modifications)
      modifications.each do |key, value|
        case key.to_s
        when 'ai_configuration'
          form.update!(ai_configuration: value)
        when 'style_configuration'
          form.update!(style_configuration: value)
        when 'form_settings'
          form.update!(form_settings: value)
        end
      end
    end
    
    # Prepare data for export
    def prepare_export_data(form, options)
      data = {
        form: form.as_json(include: [:form_questions]),
        exported_at: Time.current,
        export_options: options
      }
      
      # Include responses if requested
      if options[:include_responses]
        data[:responses] = form.form_responses.includes(:question_responses)
                              .as_json(include: [:question_responses])
      end
      
      data
    end
    
    # Generate export file in requested format
    def generate_export_file(data, options)
      format = options[:format] || 'json'
      
      case format.downcase
      when 'json'
        generate_json_export(data)
      when 'csv'
        generate_csv_export(data)
      when 'xlsx'
        generate_xlsx_export(data)
      else
        { success: false, error: "Unsupported export format: #{format}" }
      end
    end
    
    # Generate JSON export
    def generate_json_export(data)
      {
        success: true,
        download_url: "/exports/#{SecureRandom.uuid}.json",
        record_count: data[:responses]&.count || 0
      }
    end
    
    # Generate CSV export
    def generate_csv_export(data)
      {
        success: true,
        download_url: "/exports/#{SecureRandom.uuid}.csv",
        record_count: data[:responses]&.count || 0
      }
    end
    
    # Generate Excel export
    def generate_xlsx_export(data)
      {
        success: true,
        download_url: "/exports/#{SecureRandom.uuid}.xlsx",
        record_count: data[:responses]&.count || 0
      }
    end
    
    # Validate form is ready for publication
    def validate_form_for_publication(form)
      errors = []
      
      # Must have at least one question
      errors << "Form must have at least one question" if form.form_questions.empty?
      
      # Validate all questions have required fields
      form.form_questions.each do |question|
        if question.title.blank?
          errors << "Question #{question.position} must have a title"
        end
      end
      
      # Validate AI configuration if AI features are enabled
      if form.ai_enhanced?
        ai_errors = validate_ai_configuration(form.ai_configuration)
        errors.concat(ai_errors)
      end
      
      {
        valid: errors.empty?,
        errors: errors
      }
    end
    
    # Track form publication metrics
    def track_form_publication(form)
      logger.info "Form published: #{form.id} by user #{form.user_id}"
      
      # Could integrate with analytics service here
      # AnalyticsService.track_event('form_published', form_id: form.id)
    end
  end
end
</file>

<file path="agents/forms/response_agent.rb">
# frozen_string_literal: true

module Forms
  # Agent responsible for processing form responses and managing response lifecycle
  # Handles response processing, quality analysis, insights generation, and integrations
  class ResponseAgent < ApplicationAgent
    
    # Supported task types for this agent
    SUPPORTED_TASKS = %w[
      process_form_response
      complete_form_response
      analyze_response_quality
      generate_response_insights
      trigger_integrations
      recover_abandoned_response
    ].freeze
    
    def initialize(context = {})
      super(context)
      @supported_tasks = SUPPORTED_TASKS
    end
    
    # Process a form response with AI analysis and workflow execution
    # @param form_response [FormResponse] The response being processed
    # @param question [FormQuestion] The question being answered
    # @param answer_data [Hash] The answer data from the user
    # @param metadata [Hash] Additional metadata about the response
    # @return [Hash] Success/error response with processing results
    def process_form_response(form_response, question, answer_data, metadata = {})
      validate_context(:user_id) if @context[:user_id]
      
      log_activity("process_form_response", { 
        form_response_id: form_response.id,
        question_id: question.id,
        has_answer_data: answer_data.present?
      })
      
      safe_db_operation do
        # Validate inputs
        unless valid_response_inputs?(form_response, question, answer_data)
          return error_response("Invalid response inputs", 'validation_error')
        end
        
        # Check if form is still accepting responses
        unless form_accepting_responses?(form_response.form)
          return error_response("Form is no longer accepting responses", 'form_closed_error')
        end
        
        # Execute response processing workflow
        workflow_result = execute_workflow(
          Forms::ResponseProcessingWorkflow,
          {
            form_response_id: form_response.id,
            question_id: question.id,
            answer_data: answer_data,
            metadata: metadata,
            processing_context: @context
          }
        )
        
        if workflow_result[:success]
          # Update response activity timestamp
          form_response.touch(:last_activity_at)
          
          # Track response processing
          track_response_processing(form_response, question)
          
          success_response({
            form_response_id: form_response.id,
            question_id: question.id,
            processing_result: workflow_result[:data],
            ai_analysis: workflow_result[:data][:ai_analysis],
            dynamic_questions: workflow_result[:data][:dynamic_questions],
            processed_at: Time.current
          })
        else
          error_response("Response processing failed: #{workflow_result[:error_message]}", 'processing_error')
        end
      end
    end
    
    # Complete a form response and trigger completion workflows
    # @param form_response [FormResponse] The response to complete
    # @return [Hash] Success/error response with completion results
    def complete_form_response(form_response)
      log_activity("complete_form_response", { form_response_id: form_response.id })
      
      # Validate form response ownership or access
      unless can_access_response?(form_response)
        return error_response("Not authorized to complete this response", 'authorization_error')
      end
      
      safe_db_operation do
        # Validate response is ready for completion
        validation_result = validate_response_for_completion(form_response)
        unless validation_result[:valid]
          return error_response(validation_result[:errors].join(', '), 'validation_error')
        end
        
        # Mark response as completed
        completion_data = {
          completed_at: Time.current,
          completion_duration: calculate_completion_duration(form_response),
          final_quality_score: calculate_final_quality_score(form_response)
        }
        
        form_response.mark_completed!(completion_data)
        
        # Execute completion workflow for integrations and analysis
        completion_result = execute_completion_workflow(form_response)
        
        # Update form statistics
        update_form_completion_stats(form_response.form)
        
        success_response({
          form_response_id: form_response.id,
          status: form_response.status,
          completion_data: completion_data,
          integrations_triggered: completion_result[:integrations_triggered],
          analysis_queued: completion_result[:analysis_queued],
          completed_at: Time.current
        })
      end
    end
    
    # Analyze response quality using AI and statistical methods
    # @param form_response [FormResponse] The response to analyze
    # @return [Hash] Quality analysis results and recommendations
    def analyze_response_quality(form_response)
      log_activity("analyze_response_quality", { form_response_id: form_response.id })
      
      # Validate access to response
      unless can_access_response?(form_response)
        return error_response("Not authorized to analyze this response", 'authorization_error')
      end
      
      # Check if response has enough data for analysis
      if form_response.question_responses.empty?
        return error_response("Response has no answers to analyze", 'insufficient_data')
      end
      
      # Check AI credits if AI analysis is requested
      estimated_cost = calculate_analysis_cost(form_response)
      if form_response.form.ai_enhanced? && !ai_budget_available?(@context, estimated_cost)
        return error_response("Insufficient AI credits for quality analysis", 'insufficient_credits')
      end
      
      begin
        # Perform quality analysis
        quality_metrics = calculate_quality_metrics(form_response)
        
        # AI-powered analysis if enabled
        ai_analysis = nil
        if form_response.form.ai_enhanced?
          ai_analysis = perform_ai_quality_analysis(form_response)
          track_ai_usage(@context, estimated_cost, 'response_quality_analysis')
        end
        
        # Generate quality insights
        insights = generate_quality_insights(quality_metrics, ai_analysis)
        
        # Update response with analysis results
        update_response_quality_data(form_response, quality_metrics, ai_analysis)
        
        success_response({
          form_response_id: form_response.id,
          quality_score: quality_metrics[:overall_score],
          quality_metrics: quality_metrics,
          ai_analysis: ai_analysis,
          insights: insights,
          recommendations: generate_quality_recommendations(quality_metrics),
          analyzed_at: Time.current
        })
      rescue StandardError => e
        logger.error "Quality analysis failed for response #{form_response.id}: #{e.message}"
        error_response("Quality analysis failed: #{e.message}", 'analysis_error')
      end
    end
    
    # Generate insights from form response data using AI
    # @param form_response [FormResponse] The response to generate insights for
    # @return [Hash] Generated insights and analysis
    def generate_response_insights(form_response)
      log_activity("generate_response_insights", { form_response_id: form_response.id })
      
      # Validate access to response
      unless can_access_response?(form_response)
        return error_response("Not authorized to generate insights for this response", 'authorization_error')
      end
      
      # Check if AI features are enabled
      unless form_response.form.ai_enhanced?
        return error_response("AI insights not enabled for this form", 'feature_disabled')
      end
      
      # Check AI credits availability
      estimated_cost = calculate_insights_cost(form_response)
      unless ai_budget_available?(@context, estimated_cost)
        return error_response("Insufficient AI credits for insight generation", 'insufficient_credits')
      end
      
      begin
        # Prepare response data for analysis
        response_context = prepare_response_context(form_response)
        
        # Generate AI insights
        insights_result = generate_ai_insights(form_response, response_context)
        
        if insights_result[:success]
          # Store insights in response
          store_response_insights(form_response, insights_result[:insights])
          
          # Track AI usage
          track_ai_usage(@context, estimated_cost, 'response_insights_generation')
          
          success_response({
            form_response_id: form_response.id,
            insights: insights_result[:insights],
            confidence_score: insights_result[:confidence],
            categories: insights_result[:categories],
            key_findings: insights_result[:key_findings],
            generated_at: Time.current
          })
        else
          error_response("Insight generation failed: #{insights_result[:error]}", 'insights_error')
        end
      rescue StandardError => e
        logger.error "Insight generation failed for response #{form_response.id}: #{e.message}"
        error_response("Insight generation failed: #{e.message}", 'insights_error')
      end
    end
    
    # Trigger integrations for a completed form response
    # @param form_response [FormResponse] The completed response
    # @return [Hash] Integration trigger results
    def trigger_integrations(form_response)
      log_activity("trigger_integrations", { 
        form_response_id: form_response.id,
        form_id: form_response.form.id
      })
      
      # Validate access to response
      unless can_access_response?(form_response)
        return error_response("Not authorized to trigger integrations for this response", 'authorization_error')
      end
      
      # Check if response is completed
      unless form_response.completed?
        return error_response("Response must be completed before triggering integrations", 'invalid_status')
      end
      
      begin
        form = form_response.form
        integration_settings = form.integration_settings || {}
        triggered_integrations = []
        failed_integrations = []
        
        # Process each enabled integration
        integration_settings.each do |integration_type, config|
          next unless config['enabled']
          
          integration_result = trigger_single_integration(
            integration_type, 
            config, 
            form_response
          )
          
          if integration_result[:success]
            triggered_integrations << {
              type: integration_type,
              status: 'triggered',
              job_id: integration_result[:job_id]
            }
          else
            failed_integrations << {
              type: integration_type,
              status: 'failed',
              error: integration_result[:error]
            }
          end
        end
        
        # Update response with integration status
        update_integration_status(form_response, triggered_integrations, failed_integrations)
        
        success_response({
          form_response_id: form_response.id,
          triggered_integrations: triggered_integrations,
          failed_integrations: failed_integrations,
          total_integrations: integration_settings.count,
          success_count: triggered_integrations.count,
          triggered_at: Time.current
        })
      rescue StandardError => e
        logger.error "Integration triggering failed for response #{form_response.id}: #{e.message}"
        error_response("Integration triggering failed: #{e.message}", 'integration_error')
      end
    end
    
    # Attempt to recover an abandoned form response
    # @param form_response [FormResponse] The abandoned response to recover
    # @return [Hash] Recovery attempt results
    def recover_abandoned_response(form_response)
      log_activity("recover_abandoned_response", { form_response_id: form_response.id })
      
      # Validate access to response
      unless can_access_response?(form_response)
        return error_response("Not authorized to recover this response", 'authorization_error')
      end
      
      # Check if response is actually abandoned
      unless form_response.abandoned? || form_response.is_stale?
        return error_response("Response is not abandoned", 'invalid_status')
      end
      
      safe_db_operation do
        # Analyze abandonment context
        abandonment_analysis = analyze_abandonment_context(form_response)
        
        # Generate recovery strategy
        recovery_strategy = generate_recovery_strategy(form_response, abandonment_analysis)
        
        # Execute recovery actions
        recovery_result = execute_recovery_actions(form_response, recovery_strategy)
        
        if recovery_result[:success]
          # Update response status
          form_response.resume!
          
          success_response({
            form_response_id: form_response.id,
            recovery_strategy: recovery_strategy,
            actions_taken: recovery_result[:actions_taken],
            abandonment_analysis: abandonment_analysis,
            recovery_probability: recovery_result[:recovery_probability],
            recovered_at: Time.current
          })
        else
          error_response("Recovery failed: #{recovery_result[:error]}", 'recovery_error')
        end
      end
    end
    
    # Enrich response data with external company information
    # @param form_response [FormResponse] The response to enrich
    # @param email [String] Email address to extract domain from
    # @return [Hash] Success/error response with enrichment results
    def enrich_response(form_response, email)
      log_activity("enrich_response", { 
        form_response_id: form_response.id,
        email: email
      })
      
      # Validate inputs
      unless form_response.is_a?(FormResponse) && email.present?
        return error_response("Invalid response or email", 'validation_error')
      end
      
      # Check if form has AI enhancement enabled
      unless form_response.form.ai_enhanced?
        return error_response("AI enrichment not enabled for this form", 'feature_disabled')
      end
      
      # Check authorization
      unless can_access_response?(form_response)
        return error_response("Not authorized to enrich this response", 'authorization_error')
      end
      
      # Check if already enriched
      if form_response.enrichment_data.present?
        return success_response({
          form_response_id: form_response.id,
          status: 'already_enriched',
          enrichment_data: form_response.enrichment_data,
          enriched_at: form_response.enriched_at
        })
      end
      
      safe_db_operation do
        # Queue enrichment job
        job_id = Forms::DataEnrichmentJob.perform_async(form_response.id, email)
        
        success_response({
          form_response_id: form_response.id,
          status: 'enrichment_queued',
          job_id: job_id,
          queued_at: Time.current
        })
      end
    end

    # Get list of supported tasks
    def supported_tasks
      SUPPORTED_TASKS + ['enrich_response']
    end
    
    private
    
    # Validate response processing inputs
    def valid_response_inputs?(form_response, question, answer_data)
      return false unless form_response.is_a?(FormResponse)
      return false unless question.is_a?(FormQuestion)
      return false unless answer_data.is_a?(Hash)
      return false unless question.form_id == form_response.form_id
      
      true
    end
    
    # Check if form is still accepting responses
    def form_accepting_responses?(form)
      form.published? && !form.archived?
    end
    
    # Check if current context can access the response
    def can_access_response?(form_response)
      # Public access for response submission
      return true if @context[:public_access]
      
      # Owner access
      return true if current_user && owns_resource?(form_response.form)
      
      # Session-based access for the responder
      return true if @context[:session_id] == form_response.session_id
      
      false
    end
    
    # Validate response is ready for completion
    def validate_response_for_completion(form_response)
      errors = []
      
      # Check if already completed
      errors << "Response is already completed" if form_response.completed?
      
      # Check required questions are answered
      required_questions = form_response.form.form_questions.where(required: true)
      answered_question_ids = form_response.question_responses.pluck(:form_question_id)
      
      missing_required = required_questions.where.not(id: answered_question_ids)
      if missing_required.exists?
        errors << "Required questions not answered: #{missing_required.pluck(:title).join(', ')}"
      end
      
      {
        valid: errors.empty?,
        errors: errors
      }
    end
    
    # Calculate completion duration in seconds
    def calculate_completion_duration(form_response)
      return 0 unless form_response.started_at
      
      Time.current - form_response.started_at
    end
    
    # Calculate final quality score for response
    def calculate_final_quality_score(form_response)
      # Base score from completeness
      completeness_score = (form_response.question_responses.count.to_f / 
                           form_response.form.form_questions.count) * 100
      
      # Adjust for response quality metrics
      quality_adjustments = 0
      
      form_response.question_responses.each do |qr|
        # Add points for detailed responses
        if (qr.answer_text&.length || 0) > 50
          quality_adjustments += 5
        end
        
        # Subtract points for very short responses to open questions
        if qr.form_question.question_type.in?(['text_long']) && (qr.answer_text&.length || 0) < 10
          quality_adjustments -= 10
        end
      end
      
      # Ensure score is between 0 and 100
      [[completeness_score + quality_adjustments, 0].max, 100].min
    end
    
    # Execute completion workflow
    def execute_completion_workflow(form_response)
      # Queue completion job for async processing
      job_id = Forms::CompletionWorkflowJob.perform_async(form_response.id)
      
      {
        integrations_triggered: true,
        analysis_queued: true,
        job_id: job_id
      }
    rescue StandardError => e
      logger.error "Failed to queue completion workflow: #{e.message}"
      {
        integrations_triggered: false,
        analysis_queued: false,
        error: e.message
      }
    end
    
    # Update form completion statistics
    def update_form_completion_stats(form)
      form.increment!(:completions_count)
      form.update!(last_response_at: Time.current)
    end
    
    # Calculate cost for response analysis
    def calculate_analysis_cost(form_response)
      base_cost = 0.02
      question_count_cost = form_response.question_responses.count * 0.005
      
      base_cost + question_count_cost
    end
    
    # Calculate quality metrics for response
    def calculate_quality_metrics(form_response)
      metrics = {
        completeness_score: calculate_completeness_score(form_response),
        response_time_score: calculate_response_time_score(form_response),
        consistency_score: calculate_consistency_score(form_response),
        engagement_score: calculate_engagement_score(form_response)
      }
      
      # Calculate overall score as weighted average
      metrics[:overall_score] = (
        metrics[:completeness_score] * 0.4 +
        metrics[:response_time_score] * 0.2 +
        metrics[:consistency_score] * 0.2 +
        metrics[:engagement_score] * 0.2
      ).round(2)
      
      metrics
    end
    
    # Perform AI-powered quality analysis
    def perform_ai_quality_analysis(form_response)
      # This would integrate with an AI analysis workflow
      # For now, return a structured placeholder
      {
        sentiment: 'positive',
        confidence: 0.85,
        key_themes: ['satisfaction', 'engagement'],
        quality_indicators: {
          coherence: 0.9,
          relevance: 0.8,
          completeness: 0.95
        },
        flags: []
      }
    end
    
    # Generate quality insights from metrics and AI analysis
    def generate_quality_insights(quality_metrics, ai_analysis)
      insights = []
      
      # Completeness insights
      if quality_metrics[:completeness_score] < 70
        insights << {
          type: 'completeness',
          message: 'Response appears incomplete',
          severity: 'medium'
        }
      end
      
      # Response time insights
      if quality_metrics[:response_time_score] < 50
        insights << {
          type: 'response_time',
          message: 'Unusually fast responses detected',
          severity: 'low'
        }
      end
      
      # AI insights
      if ai_analysis && ai_analysis[:confidence] < 0.7
        insights << {
          type: 'ai_confidence',
          message: 'AI analysis confidence is low',
          severity: 'medium'
        }
      end
      
      insights
    end
    
    # Generate quality recommendations
    def generate_quality_recommendations(quality_metrics)
      recommendations = []
      
      if quality_metrics[:overall_score] < 70
        recommendations << "Consider following up with respondent for clarification"
      end
      
      if quality_metrics[:completeness_score] < 80
        recommendations << "Review form design to improve completion rates"
      end
      
      recommendations
    end
    
    # Update response with quality analysis data
    def update_response_quality_data(form_response, quality_metrics, ai_analysis)
      form_response.update!(
        quality_score: quality_metrics[:overall_score],
        ai_analysis_data: {
          quality_metrics: quality_metrics,
          ai_analysis: ai_analysis,
          analyzed_at: Time.current
        }
      )
    end
    
    # Calculate cost for insights generation
    def calculate_insights_cost(form_response)
      base_cost = 0.03
      complexity_cost = form_response.question_responses.count * 0.01
      
      base_cost + complexity_cost
    end
    
    # Prepare response context for AI analysis
    def prepare_response_context(form_response)
      {
        form_title: form_response.form.name,
        form_category: form_response.form.category,
        response_count: form_response.form.responses_count,
        questions_and_answers: form_response.question_responses.includes(:form_question).map do |qr|
          {
            question: qr.form_question.title,
            question_type: qr.form_question.question_type,
            answer: qr.formatted_answer
          }
        end
      }
    end
    
    # Generate AI insights for response
    def generate_ai_insights(form_response, context)
      # This would integrate with an AI insights workflow
      # For now, return a structured placeholder
      {
        success: true,
        insights: {
          summary: "Respondent shows high engagement with detailed answers",
          sentiment: "positive",
          key_points: ["Detailed feedback provided", "Clear preferences expressed"],
          recommendations: ["Follow up within 24 hours", "Prioritize for sales contact"]
        },
        confidence: 0.88,
        categories: ["high_quality", "sales_qualified"],
        key_findings: [
          "Strong interest in product features",
          "Budget authority indicated",
          "Timeline specified"
        ]
      }
    end
    
    # Store insights in response record
    def store_response_insights(form_response, insights)
      current_data = form_response.ai_analysis_data || {}
      current_data[:insights] = insights
      current_data[:insights_generated_at] = Time.current
      
      form_response.update!(ai_analysis_data: current_data)
    end
    
    # Trigger a single integration
    def trigger_single_integration(integration_type, config, form_response)
      case integration_type.to_s
      when 'webhook'
        trigger_webhook_integration(config, form_response)
      when 'email'
        trigger_email_integration(config, form_response)
      when 'slack'
        trigger_slack_integration(config, form_response)
      when 'salesforce'
        trigger_salesforce_integration(config, form_response)
      else
        { success: false, error: "Unknown integration type: #{integration_type}" }
      end
    end
    
    # Trigger webhook integration
    def trigger_webhook_integration(config, form_response)
      job_id = Forms::IntegrationTriggerJob.perform_async(
        'webhook',
        config,
        form_response.id
      )
      
      { success: true, job_id: job_id }
    rescue StandardError => e
      { success: false, error: e.message }
    end
    
    # Trigger email integration
    def trigger_email_integration(config, form_response)
      job_id = Forms::IntegrationTriggerJob.perform_async(
        'email',
        config,
        form_response.id
      )
      
      { success: true, job_id: job_id }
    rescue StandardError => e
      { success: false, error: e.message }
    end
    
    # Trigger Slack integration
    def trigger_slack_integration(config, form_response)
      job_id = Forms::IntegrationTriggerJob.perform_async(
        'slack',
        config,
        form_response.id
      )
      
      { success: true, job_id: job_id }
    rescue StandardError => e
      { success: false, error: e.message }
    end
    
    # Trigger Salesforce integration
    def trigger_salesforce_integration(config, form_response)
      job_id = Forms::IntegrationTriggerJob.perform_async(
        'salesforce',
        config,
        form_response.id
      )
      
      { success: true, job_id: job_id }
    rescue StandardError => e
      { success: false, error: e.message }
    end
    
    # Update response with integration status
    def update_integration_status(form_response, triggered, failed)
      integration_data = {
        triggered_integrations: triggered,
        failed_integrations: failed,
        last_integration_attempt: Time.current
      }
      
      current_data = form_response.metadata || {}
      current_data[:integrations] = integration_data
      
      form_response.update!(metadata: current_data)
    end
    
    # Analyze abandonment context
    def analyze_abandonment_context(form_response)
      {
        abandonment_point: calculate_abandonment_point(form_response),
        time_spent: form_response.duration_minutes,
        questions_answered: form_response.question_responses.count,
        total_questions: form_response.form.form_questions.count,
        last_activity: form_response.last_activity_at,
        device_info: extract_device_info(form_response),
        abandonment_patterns: identify_abandonment_patterns(form_response)
      }
    end
    
    # Generate recovery strategy
    def generate_recovery_strategy(form_response, analysis)
      strategies = []
      
      # Email recovery if contact info available
      if has_contact_info?(form_response)
        strategies << {
          type: 'email_recovery',
          priority: 'high',
          timing: '2_hours'
        }
      end
      
      # Session recovery
      strategies << {
        type: 'session_recovery',
        priority: 'medium',
        timing: 'immediate'
      }
      
      # Simplified form version
      if analysis[:questions_answered] < 3
        strategies << {
          type: 'simplified_form',
          priority: 'low',
          timing: '24_hours'
        }
      end
      
      strategies
    end
    
    # Execute recovery actions
    def execute_recovery_actions(form_response, strategies)
      actions_taken = []
      
      strategies.each do |strategy|
        case strategy[:type]
        when 'email_recovery'
          if execute_email_recovery(form_response)
            actions_taken << 'email_sent'
          end
        when 'session_recovery'
          if execute_session_recovery(form_response)
            actions_taken << 'session_restored'
          end
        when 'simplified_form'
          if execute_simplified_form_recovery(form_response)
            actions_taken << 'simplified_form_created'
          end
        end
      end
      
      {
        success: actions_taken.any?,
        actions_taken: actions_taken,
        recovery_probability: calculate_recovery_probability(form_response, actions_taken)
      }
    end
    
    # Helper methods for quality scoring
    def calculate_completeness_score(form_response)
      total_questions = form_response.form.form_questions.count
      answered_questions = form_response.question_responses.count
      
      return 0 if total_questions.zero?
      
      (answered_questions.to_f / total_questions * 100).round(2)
    end
    
    def calculate_response_time_score(form_response)
      # Analyze response times for each question
      response_times = form_response.question_responses.pluck(:response_time_ms).compact
      return 50 if response_times.empty?
      
      avg_time = response_times.sum / response_times.count
      
      # Score based on reasonable response times (not too fast, not too slow)
      case avg_time
      when 0..1000 # Too fast (< 1 second)
        20
      when 1000..5000 # Good range (1-5 seconds)
        100
      when 5000..30000 # Acceptable (5-30 seconds)
        80
      else # Too slow (> 30 seconds)
        60
      end
    end
    
    def calculate_consistency_score(form_response)
      # Analyze consistency across similar questions
      # This is a simplified implementation
      80 # Placeholder score
    end
    
    def calculate_engagement_score(form_response)
      # Analyze engagement based on answer length and detail
      text_responses = form_response.question_responses.joins(:form_question)
                                  .where(form_questions: { question_type: ['text_short', 'text_long'] })
      
      return 50 if text_responses.empty?
      
      avg_length = text_responses.sum { |qr| qr.answer_text&.length || 0 } / text_responses.count
      
      # Score based on average response length
      case avg_length
      when 0..10
        30
      when 10..50
        70
      when 50..200
        100
      else
        90
      end
    end
    
    # Helper methods for abandonment recovery
    def calculate_abandonment_point(form_response)
      last_question = form_response.question_responses.order(:created_at).last
      return 0 unless last_question
      
      last_question.form_question.position
    end
    
    def extract_device_info(form_response)
      form_response.metadata&.dig('device_info') || {}
    end
    
    def identify_abandonment_patterns(form_response)
      # Analyze patterns that led to abandonment
      patterns = []
      
      # Check if abandoned on a specific question type
      last_question = form_response.question_responses.order(:created_at).last
      if last_question
        patterns << "abandoned_after_#{last_question.form_question.question_type}"
      end
      
      # Check timing patterns
      if form_response.duration_minutes < 1
        patterns << 'quick_abandonment'
      elsif form_response.duration_minutes > 30
        patterns << 'long_session_abandonment'
      end
      
      patterns
    end
    
    def has_contact_info?(form_response)
      # Check if response contains email or phone
      form_response.question_responses.joins(:form_question)
                  .where(form_questions: { question_type: ['email', 'phone'] })
                  .exists?
    end
    
    def execute_email_recovery(form_response)
      # Queue email recovery job
      # This would integrate with email service
      true
    end
    
    def execute_session_recovery(form_response)
      # Extend session or create recovery link
      # This would integrate with session management
      true
    end
    
    def execute_simplified_form_recovery(form_response)
      # Create a simplified version of the form
      # This would integrate with form duplication service
      true
    end
    
    def calculate_recovery_probability(form_response, actions_taken)
      base_probability = 0.15 # 15% base recovery rate
      
      # Increase probability based on actions taken
      actions_taken.each do |action|
        case action
        when 'email_sent'
          base_probability += 0.25
        when 'session_restored'
          base_probability += 0.10
        when 'simplified_form_created'
          base_probability += 0.15
        end
      end
      
      # Cap at 80% maximum probability
      [base_probability, 0.80].min
    end
    
    # Track response processing metrics
    def track_response_processing(form_response, question)
      logger.info "Response processed: form_response_id=#{form_response.id}, question_id=#{question.id}"
      
      # Could integrate with analytics service here
      # AnalyticsService.track_event('response_processed', {
      #   form_id: form_response.form_id,
      #   question_type: question.question_type
      # })
    end
  end
end
</file>

<file path="agents/application_agent.rb">
# frozen_string_literal: true

# Base agent class for all SuperAgent agents in this application
class ApplicationAgent
  # TODO: Include SuperAgent::AgentHelpers when SuperAgent gem is fully configured
  
  attr_reader :context, :logger
  
  def initialize(context = {})
    @context = context.is_a?(Hash) ? context : {}
    @logger = defined?(Rails) ? Rails.logger : Logger.new(STDOUT)
    @agent_id = SecureRandom.uuid
    
    # Initialize agent-specific context
    @context[:agent_id] = @agent_id
    @context[:agent_class] = self.class.name
    @context[:created_at] = defined?(Rails) ? Time.current : Time.now
    
    setup_agent if respond_to?(:setup_agent, true)
  end
  
  # Main execution method - to be overridden by subclasses
  def execute(input = {})
    raise NotImplementedError, "Subclasses must implement the execute method"
  end
  
  # Execute a workflow with error handling
  def execute_workflow(workflow_class, inputs = {})
    logger.info "Agent #{self.class.name} executing workflow #{workflow_class.name}"
    
    begin
      context = SuperAgent::Workflow::Context.new(inputs.merge(agent_context))
      engine = SuperAgent::WorkflowEngine.new
      result = engine.execute(workflow_class, context)
      
      log_workflow_result(workflow_class, result)
      result
    rescue StandardError => e
      logger.error "Workflow execution failed in #{self.class.name}: #{e.message}"
      handle_workflow_error(workflow_class, e)
    end
  end
  
  # Get agent context for workflows
  def agent_context
    {
      agent_id: @agent_id,
      agent_class: self.class.name,
      context: @context
    }
  end
  
  # Update agent context
  def update_context(new_context)
    @context.merge!(new_context)
  end
  
  # Get context value
  def get_context(key)
    @context[key]
  end
  
  # Set context value
  def set_context(key, value)
    @context[key] = value
  end
  
  # Check if agent can handle a specific task
  def can_handle?(task_type)
    supported_tasks.include?(task_type.to_s)
  end
  
  # Get list of supported tasks - to be overridden by subclasses
  def supported_tasks
    []
  end
  
  # Validate required context keys
  def validate_context(*required_keys)
    missing_keys = required_keys.select { |key| @context[key].nil? }
    
    if missing_keys.any?
      error_message = "Missing required context: #{missing_keys.join(', ')}"
      logger.error error_message
      raise ArgumentError, error_message
    end
    
    true
  end
  
  # Execute with timeout and retry logic
  def execute_with_retry(max_retries: 3, timeout: 30.seconds)
    retries = 0
    
    begin
      Timeout.timeout(timeout) do
        yield
      end
    rescue StandardError => e
      retries += 1
      
      if retries <= max_retries
        logger.warn "Agent execution failed (attempt #{retries}/#{max_retries}): #{e.message}"
        sleep(retries * 0.5) # Exponential backoff
        retry
      else
        logger.error "Agent execution failed after #{max_retries} retries: #{e.message}"
        raise e
      end
    end
  end
  
  # Format success response
  def success_response(data = {})
    {
      success: true,
      agent: self.class.name,
      agent_id: @agent_id,
      timestamp: (defined?(Rails) ? Time.current : Time.now).iso8601,
      data: data
    }
  end
  
  # Format error response
  def error_response(message, error_type = 'agent_error', data = {})
    {
      success: false,
      error: true,
      error_message: message,
      error_type: error_type,
      agent: self.class.name,
      agent_id: @agent_id,
      timestamp: (defined?(Rails) ? Time.current : Time.now).iso8601,
      data: data
    }
  end
  
  # Log agent activity
  def log_activity(action, details = {})
    logger.info "Agent #{self.class.name} (#{@agent_id}): #{action}"
    logger.debug "Details: #{details.inspect}" if details.any?
  end
  
  # Check if agent is in valid state
  def valid_state?
    @context.present? && @agent_id.present?
  end
  
  # Get agent status
  def status
    {
      agent_id: @agent_id,
      agent_class: self.class.name,
      created_at: @context[:created_at],
      context_keys: @context.keys,
      valid_state: valid_state?,
      supported_tasks: supported_tasks
    }
  end
  
  protected
  
  # Handle workflow execution errors
  def handle_workflow_error(workflow_class, error)
    logger.error "Workflow #{workflow_class.name} failed: #{error.message}"
    
    # Track error in Sentry if available
    if defined?(Sentry)
      Sentry.capture_exception(error, extra: {
        agent: self.class.name,
        agent_id: @agent_id,
        workflow: workflow_class.name,
        context: @context
      })
    end
    
    error_response(
      "Workflow execution failed: #{error.message}",
      'workflow_error',
      { workflow: workflow_class.name }
    )
  end
  
  # Log workflow execution results
  def log_workflow_result(workflow_class, result)
    if result.is_a?(Hash) && result[:error]
      logger.error "Workflow #{workflow_class.name} completed with error: #{result[:error_message]}"
    else
      logger.info "Workflow #{workflow_class.name} completed successfully"
    end
  end
  
  # Validate input parameters
  def validate_input(input, required_keys = [])
    return false unless input.is_a?(Hash)
    
    missing_keys = required_keys.select { |key| input[key].nil? }
    
    if missing_keys.any?
      logger.error "Missing required input keys: #{missing_keys.join(', ')}"
      return false
    end
    
    true
  end
  
  # Safe database operation execution
  def safe_db_operation
    ActiveRecord::Base.transaction do
      yield
    end
  rescue ActiveRecord::RecordInvalid => e
    logger.error "Database validation error: #{e.message}"
    error_response(e.message, 'validation_error')
  rescue ActiveRecord::RecordNotFound => e
    logger.error "Record not found: #{e.message}"
    error_response(e.message, 'not_found_error')
  rescue StandardError => e
    logger.error "Database operation failed: #{e.message}"
    error_response(e.message, 'database_error')
  end
  
  # Get current user from context
  def current_user
    user_id = @context[:user_id]
    return nil unless user_id
    
    @current_user ||= User.find_by(id: user_id)
  end
  
  # Check if user has permission for action
  def authorized?(action, resource = nil)
    user = current_user
    return false unless user
    
    # Basic authorization - can be extended with Pundit policies
    case action.to_s
    when 'read'
      true # All authenticated users can read
    when 'write', 'update', 'delete'
      user.role != 'user' || owns_resource?(resource)
    else
      false
    end
  end
  
  # Check if current user owns the resource
  def owns_resource?(resource)
    return false unless current_user && resource
    
    if resource.respond_to?(:user_id)
      resource.user_id == current_user.id
    elsif resource.respond_to?(:user)
      resource.user == current_user
    else
      false
    end
  end
  
  # Helper methods that would normally come from SuperAgent::AgentHelpers
  
  # Track AI usage and costs
  def track_ai_usage(context, cost, operation)
    logger.info "AI Usage: operation=#{operation}, cost=#{cost}, context=#{context[:agent_id]}"
    
    # Update user's AI credit usage if user is available
    if current_user&.respond_to?(:consume_ai_credit)
      current_user.consume_ai_credit(cost)
    end
  end
  
  # Check if AI budget is available for operation
  def ai_budget_available?(context, estimated_cost)
    # If no user context, assume budget is available (for system operations)
    return true unless current_user
    
    # Check if user can use AI features and has sufficient credits
    current_user.can_use_ai_features? && 
      (current_user.ai_credits_remaining || Float::INFINITY) >= estimated_cost
  end
end
</file>

<file path="channels/application_cable/channel.rb">
# app/channels/application_cable/channel.rb
module ApplicationCable
    class Channel < ActionCable::Channel::Base
    end
end
</file>

<file path="channels/application_cable/connection.rb">
# app/channels/application_cable/connection.rb
module ApplicationCable
    class Connection < ActionCable::Connection::Base
      # Aqu puedes agregar autenticacin si la necesitas
      # identified_by :current_user
      
      # def connect
      #   self.current_user = find_verified_user
      # end
      
      # private
      
      # def find_verified_user
      #   # Lgica de autenticacin
      # end
    end
  end
</file>

<file path="channels/form_response_channel.rb">
# app/channels/form_response_channel.rb
class FormResponseChannel < ApplicationCable::Channel
  def subscribed
    form_response_id = params[:form_response_id]
    
    if form_response_id.present?
      # Find the form response to verify access
      form_response = FormResponse.find_by(id: form_response_id)
      
      if form_response
        stream_from "form_response_#{form_response_id}"
        Rails.logger.info "FormResponseChannel: Subscribed to form_response_#{form_response_id}"
      else
        Rails.logger.error "FormResponseChannel: FormResponse not found: #{form_response_id}"
        reject
      end
    else
      Rails.logger.error "FormResponseChannel: No form_response_id provided"
      reject
    end
  end

  def unsubscribed
    Rails.logger.info "FormResponseChannel: Unsubscribed"
  end
end
</file>

<file path="channels/session_channel.rb">
# app/channels/session_channel.rb
class SessionChannel < ApplicationCable::Channel
  def subscribed
    session_id = connection.current_session_id
    if session_id.present?
      stream_from "session_#{session_id}"
      
      # Also subscribe to form response updates if we have one
      form_response = FormResponse.find_by(session_id: session_id)
      if form_response
        stream_from "form_response_#{form_response.id}"
      end
      
      Rails.logger.info "SessionChannel subscribed to session_#{session_id}"
    else
      reject
    end
  end

  def unsubscribed
    # Any cleanup needed when channel is unsubscribed
  end
end
</file>

<file path="controllers/admin/base_controller.rb">
class Admin::BaseController < ApplicationController
  include AdminSecurity
  
  before_action :authenticate_user!
  before_action :ensure_superadmin!
  before_action :set_admin_session_timeout
  
  # Ensure CSRF protection is enabled for admin actions
  protect_from_forgery with: :exception
  
  # Skip Pundit for admin controllers since we have custom authorization
  skip_after_action :verify_policy_scoped, raise: false
  skip_after_action :verify_authorized, raise: false
  
  layout 'admin'

  private

  def ensure_superadmin!
    unless current_user&.superadmin?
      Rails.logger.warn "Unauthorized admin access attempt by user #{current_user&.id || 'anonymous'}"
      redirect_to root_path, alert: 'Access denied. Superadmin privileges required.'
    end
  end

  def set_admin_session_timeout
    # Enhanced admin session security
    current_time = Time.current.to_i
    last_activity = session[:admin_last_activity]
    session_ip = session[:admin_session_ip]
    
    # Check for session hijacking (IP change)
    if session_ip.present? && session_ip != request.remote_ip
      safe_create_audit_log(
        user: current_user,
        event_type: 'suspicious_admin_activity',
        details: {
          reason: 'ip_address_change',
          original_ip: session_ip,
          new_ip: request.remote_ip,
          user_agent: request.user_agent
        },
        ip_address: request.remote_ip
      )
      
      reset_session
      redirect_to new_user_session_path, alert: 'Security alert: Session terminated due to suspicious activity.'
      return
    end
    
    # Set/update session tracking
    session[:admin_last_activity] = current_time
    session[:admin_session_ip] = request.remote_ip
    
    # Check session timeout (2 hours for admin)
    if last_activity && (current_time - last_activity) > 2.hours
      AuditLog.create!(
        user: current_user,
        event_type: 'admin_session_expired',
        details: {
          last_activity: Time.at(last_activity),
          timeout_duration: current_time - last_activity
        },
        ip_address: request.remote_ip
      )
      
      reset_session
      redirect_to new_user_session_path, alert: 'Admin session expired. Please log in again.'
      return
    end
  end

  def current_admin
    current_user if current_user&.superadmin?
  end
  helper_method :current_admin

  def admin_breadcrumbs
    @admin_breadcrumbs ||= [
      { name: 'Dashboard', path: admin_dashboard_path }
    ]
  end
  helper_method :admin_breadcrumbs

  def add_breadcrumb(name, path = nil)
    admin_breadcrumbs << { name: name, path: path }
  end
  helper_method :add_breadcrumb
end
</file>

<file path="controllers/admin/dashboard_controller.rb">
class Admin::DashboardController < Admin::BaseController
  def index
    @dashboard_stats = Admin::DashboardAgent.new.get_dashboard_stats
  end
end
</file>

<file path="controllers/admin/discount_codes_controller.rb">
# frozen_string_literal: true

class Admin::DiscountCodesController < Admin::BaseController
  before_action :set_discount_code, only: [:show, :edit, :update, :destroy, :toggle_status]

  def index
    # Build optimized query with selective includes
    @discount_codes = DiscountCode.includes(:created_by)
                                  .select('discount_codes.*, COUNT(discount_code_usages.id) as usage_count')
                                  .left_joins(:discount_code_usages)
                                  .group('discount_codes.id')
                                  .order(created_at: :desc)
    
    # Apply filters if present
    if params[:status].present?
      case params[:status]
      when 'active'
        @discount_codes = @discount_codes.where(active: true)
      when 'inactive'
        @discount_codes = @discount_codes.where(active: false)
      when 'expired'
        @discount_codes = @discount_codes.where('expires_at < ?', Time.current)
      end
    end
    
    if params[:search].present?
      @discount_codes = @discount_codes.where('code ILIKE ?', "%#{params[:search]}%")
    end
    
    # Apply pagination
    @discount_codes = @discount_codes.page(params[:page]).per(20)
    
    # Load analytics data with caching
    @analytics = Rails.cache.fetch('admin_discount_analytics', expires_in: 5.minutes) do
      DiscountCode.usage_stats_summary
    end
    
    @top_codes = Rails.cache.fetch('admin_top_discount_codes', expires_in: 10.minutes) do
      DiscountCode.most_used(5)
    end
    
    @highest_revenue = Rails.cache.fetch('admin_highest_revenue_codes', expires_in: 10.minutes) do
      DiscountCode.highest_revenue_impact(5)
    end
  end

  def show
    @usage_stats = DiscountCodeService.new.get_usage_statistics(@discount_code)
    @recent_usages = @discount_code.discount_code_usages
                                   .includes(:user)
                                   .recent
                                   .limit(10)
  end

  def new
    @discount_code = DiscountCode.new
  end

  def create
    @discount_code = DiscountCode.new(discount_code_params)
    @discount_code.created_by = current_user

    if @discount_code.save
      # Log the creation
      AuditLog.create!(
        user: current_user,
        event_type: 'discount_code_created',
        details: {
          discount_code_id: @discount_code.id,
          code: @discount_code.code,
          discount_percentage: @discount_code.discount_percentage
        },
        ip_address: request.remote_ip
      )
      
      redirect_to admin_discount_code_path(@discount_code), 
                  notice: 'Discount code was successfully created.'
    else
      render :new, status: :unprocessable_entity
    end
  end

  def edit
  end

  def update
    old_attributes = @discount_code.attributes.dup
    
    if @discount_code.update(discount_code_params.except(:code))
      # Log the update
      changes = @discount_code.previous_changes.except('updated_at')
      if changes.any?
        AuditLog.create!(
          user: current_user,
          event_type: 'discount_code_updated',
          details: {
            discount_code_id: @discount_code.id,
            code: @discount_code.code,
            changes: changes
          },
          ip_address: request.remote_ip
        )
      end
      
      redirect_to admin_discount_code_path(@discount_code), 
                  notice: 'Discount code was successfully updated.'
    else
      render :edit, status: :unprocessable_entity
    end
  end

  def destroy
    if @discount_code.discount_code_usages.exists?
      redirect_to admin_discount_codes_path, 
                  alert: 'Cannot delete discount code that has been used.'
    else
      # Log the deletion
      AuditLog.create!(
        user: current_user,
        event_type: 'discount_code_deleted',
        details: {
          discount_code_id: @discount_code.id,
          code: @discount_code.code,
          discount_percentage: @discount_code.discount_percentage,
          usage_count: @discount_code.current_usage_count
        },
        ip_address: request.remote_ip
      )
      
      @discount_code.destroy
      redirect_to admin_discount_codes_path, 
                  notice: 'Discount code was successfully deleted.'
    end
  end

  def toggle_status
    old_status = @discount_code.active?
    @discount_code.update!(active: !@discount_code.active?)
    
    # Log the status change
    AuditLog.create!(
      user: current_user,
      event_type: 'discount_code_status_changed',
      details: {
        discount_code_id: @discount_code.id,
        code: @discount_code.code,
        from_status: old_status ? 'active' : 'inactive',
        to_status: @discount_code.active? ? 'active' : 'inactive'
      },
      ip_address: request.remote_ip
    )
    
    status_text = @discount_code.active? ? 'activated' : 'deactivated'
    redirect_to admin_discount_codes_path, 
                notice: "Discount code was successfully #{status_text}."
  end

  private

  def set_discount_code
    @discount_code = DiscountCode.find(params[:id])
  end

  def discount_code_params
    permitted = params.require(:discount_code).permit(:code, :discount_percentage, :max_usage_count, :expires_at, :active)
    
    # Validate required parameters for creation
    if action_name == 'create'
      validate_admin_params(permitted, [:code, :discount_percentage])
    end
    
    # Additional validation
    validate_admin_params(permitted)
    
    # Normalize and validate expires_at
    if permitted[:expires_at].present?
      begin
        expires_at = Time.zone.parse(permitted[:expires_at])
        if expires_at < Time.current
          raise ActionController::BadRequest.new("Expiration date cannot be in the past")
        end
        permitted[:expires_at] = expires_at
      rescue ArgumentError
        raise ActionController::BadRequest.new("Invalid expiration date format")
      end
    end
    
    permitted
  end
end
</file>

<file path="controllers/admin/notifications_controller.rb">
class Admin::NotificationsController < Admin::BaseController
  before_action :set_notification, only: [:show, :mark_as_read, :destroy]

  def index
    @notifications = AdminNotification.includes(:user)
                                    .recent
                                    .page(params[:page])
                                    .per(20)

    # Apply filters
    @notifications = @notifications.by_event_type(params[:event_type]) if params[:event_type].present?
    @notifications = @notifications.by_priority(params[:priority]) if params[:priority].present?
    @notifications = @notifications.unread if params[:status] == 'unread'
    @notifications = @notifications.read if params[:status] == 'read'

    # Stats for dashboard
    @stats = {
      total: AdminNotification.count,
      unread: AdminNotification.unread.count,
      today: AdminNotification.today.count,
      this_week: AdminNotification.this_week.count,
      critical: AdminNotification.by_priority('critical').unread.count
    }

    # Event type counts for filters
    @event_type_counts = AdminNotification.group(:event_type).count
    @priority_counts = AdminNotification.group(:priority).count

    respond_to do |format|
      format.html
      format.turbo_stream
    end
  end

  def show
    @notification.mark_as_read! if @notification.unread?
  end

  def mark_as_read
    @notification.mark_as_read!
    
    respond_to do |format|
      format.turbo_stream do
        render turbo_stream: [
          turbo_stream.replace("notification_#{@notification.id}", 
            partial: "admin/notifications/notification", 
            locals: { notification: @notification }
          ),
          turbo_stream.update("notification-counter", 
            AdminNotification.unread.count > 0 ? AdminNotification.unread.count.to_s : ""
          )
        ]
      end
      format.json { head :ok }
    end
  end

  def mark_all_as_read
    AdminNotification.unread.update_all(read_at: Time.current)
    
    respond_to do |format|
      format.turbo_stream do
        render turbo_stream: [
          turbo_stream.replace("notifications-list", 
            partial: "admin/notifications/notifications_list", 
            locals: { notifications: AdminNotification.recent.limit(20) }
          ),
          turbo_stream.update("notification-counter", "")
        ]
      end
      format.json { head :ok }
    end
  end

  def destroy
    @notification.destroy
    
    respond_to do |format|
      format.turbo_stream do
        render turbo_stream: [
          turbo_stream.remove("notification_#{@notification.id}"),
          turbo_stream.update("notification-counter", 
            AdminNotification.unread.count > 0 ? AdminNotification.unread.count.to_s : ""
          )
        ]
      end
      format.json { head :ok }
    end
  end

  def stats
    @daily_stats = AdminNotification
      .where(created_at: 30.days.ago..Time.current)
      .group_by_day(:created_at)
      .group(:event_type)
      .count

    @priority_distribution = AdminNotification
      .where(created_at: 7.days.ago..Time.current)
      .group(:priority)
      .count

    @user_activity = AdminNotification
      .joins(:user)
      .where(created_at: 7.days.ago..Time.current)
      .group("users.subscription_tier")
      .count

    respond_to do |format|
      format.json do
        render json: {
          daily_stats: @daily_stats,
          priority_distribution: @priority_distribution,
          user_activity: @user_activity
        }
      end
    end
  end

  private

  def set_notification
    @notification = AdminNotification.find(params[:id])
  end
end
</file>

<file path="controllers/admin/payment_analytics_controller.rb">
# frozen_string_literal: true

class Admin::PaymentAnalyticsController < ApplicationController
  before_action :authenticate_user!
  before_action :ensure_admin!

  def index
    @date_range = parse_date_range
    @metrics = PaymentAnalyticsService.new.get_dashboard_metrics(date_range: @date_range)
    @recent_events = recent_payment_events
  end

  def export
    @date_range = parse_date_range
    
    respond_to do |format|
      format.csv do
        csv_data = generate_csv_export(@date_range)
        send_data csv_data, filename: "payment_analytics_#{Date.current}.csv"
      end
      format.json do
        metrics = PaymentAnalyticsService.new.get_dashboard_metrics(date_range: @date_range)
        render json: metrics
      end
    end
  end

  private

  def parse_date_range
    start_date = params[:start_date]&.to_date || 30.days.ago
    end_date = params[:end_date]&.to_date || Date.current
    start_date..end_date.end_of_day
  end

  def recent_payment_events
    PaymentAnalytic.includes(:user)
                   .by_date_range(@date_range)
                   .order(timestamp: :desc)
                   .limit(50)
  end

  def generate_csv_export(date_range)
    require 'csv'
    
    CSV.generate(headers: true) do |csv|
      csv << ['Event Type', 'User ID', 'User Tier', 'Timestamp', 'Context']
      
      PaymentAnalytic.by_date_range(date_range).find_each do |analytic|
        csv << [
          analytic.event_type,
          analytic.user_id,
          analytic.user_subscription_tier,
          analytic.timestamp,
          analytic.context.to_json
        ]
      end
    end
  end

  def ensure_admin!
    redirect_to root_path unless current_user.admin?
  end
end
</file>

<file path="controllers/admin/security_controller.rb">
# frozen_string_literal: true

class Admin::SecurityController < Admin::BaseController
  before_action :set_monitoring_service

  def index
    @dashboard_data = @monitoring_service.security_dashboard_data
    @alerts = @monitoring_service.check_security_alerts
  end

  def audit_logs
    @audit_logs = AuditLog.includes(:user)
                          .order(created_at: :desc)
                          .page(params[:page])
                          .per(50)
    
    # Apply filters
    @audit_logs = @audit_logs.where(event_type: params[:event_type]) if params[:event_type].present?
    @audit_logs = @audit_logs.where(user_id: params[:user_id]) if params[:user_id].present?
    @audit_logs = @audit_logs.by_ip(params[:ip_address]) if params[:ip_address].present?
    
    if params[:date_from].present?
      @audit_logs = @audit_logs.where('created_at >= ?', Date.parse(params[:date_from]))
    end
    
    if params[:date_to].present?
      @audit_logs = @audit_logs.where('created_at <= ?', Date.parse(params[:date_to]).end_of_day)
    end
    
    # Get filter options
    @event_types = AuditLog.distinct.pluck(:event_type).compact.sort
    @users = User.where(role: ['admin', 'superadmin']).pluck(:id, :email)
  end

  def security_report
    start_date = params[:start_date]&.to_date || 7.days.ago
    end_date = params[:end_date]&.to_date || Date.current
    
    @report = @monitoring_service.generate_security_report(start_date, end_date)
    
    respond_to do |format|
      format.html
      format.json { render json: @report }
      format.csv { send_csv_report(@report, start_date, end_date) }
    end
  end

  def user_activity
    @user = User.find(params[:user_id]) if params[:user_id].present?
    @days = (params[:days] || 7).to_i
    
    if @user
      @activity_data = @monitoring_service.monitor_user_activity(@user.id, @days)
    end
    
    @users = User.where(role: ['admin', 'superadmin']).order(:email)
  end

  def block_ip
    ip_address = params[:ip_address]
    
    if ip_address.present?
      # Log the IP blocking action
      AuditLog.create!(
        user: current_user,
        event_type: 'ip_blocked_manually',
        details: {
          ip_address: ip_address,
          blocked_by: current_user.email,
          reason: params[:reason] || 'Manual admin action'
        },
        ip_address: ip_address
      )
      
      # In a real implementation, you would add the IP to a blocklist
      # For now, we'll just log it
      flash[:success] = "IP #{ip_address} has been flagged for blocking"
    else
      flash[:error] = "Invalid IP address"
    end
    
    redirect_to admin_security_index_path
  end

  def alerts
    @alerts = @monitoring_service.check_security_alerts
    @recent_alerts = AuditLog.where(event_type: 'security_alert_generated')
                            .order(created_at: :desc)
                            .limit(50)
                            .includes(:user)
  end

  private

  def set_monitoring_service
    @monitoring_service = AdminMonitoringService.new
  end

  def send_csv_report(report, start_date, end_date)
    csv_data = generate_csv_report(report)
    filename = "security_report_#{start_date.strftime('%Y%m%d')}_#{end_date.strftime('%Y%m%d')}.csv"
    
    send_data csv_data, 
              filename: filename,
              type: 'text/csv',
              disposition: 'attachment'
  end

  def generate_csv_report(report)
    require 'csv'
    
    CSV.generate(headers: true) do |csv|
      csv << ['Report Period', report[:period]]
      csv << []
      
      csv << ['Security Events Summary']
      csv << ['Total Security Events', report[:total_security_events]]
      csv << []
      
      csv << ['Security Events by Type']
      csv << ['Event Type', 'Count']
      report[:security_events_by_type].each do |event_type, count|
        csv << [event_type, count]
      end
      csv << []
      
      csv << ['Top Targeted IPs']
      csv << ['IP Address', 'Failed Attempts']
      report[:top_targeted_ips].each do |ip, count|
        csv << [ip, count]
      end
      csv << []
      
      csv << ['Recommendations']
      report[:recommendations].each do |recommendation|
        csv << [recommendation]
      end
    end
  end
end
</file>

<file path="controllers/admin/users_controller.rb">
# frozen_string_literal: true

# Admin controller for managing users
class Admin::UsersController < Admin::BaseController
  before_action :set_user, only: [:show, :edit, :update, :suspend, :reactivate, :send_password_reset, :destroy]

  # GET /admin/users
  def index
    @service = UserManagementService.new(
      current_user: current_user,
      filters: filter_params
    )
    
    result = @service.list_users
    
    if result.success?
      @users = result.result[:users]
      @total_count = result.result[:total_count]
      @current_page = result.result[:current_page]
      @per_page = result.result[:per_page]
      @total_pages = result.result[:total_pages]
    else
      flash[:error] = result.errors.full_messages.join(', ')
      @users = User.none.page(1)
      @total_count = 0
      @current_page = 1
      @per_page = 25
      @total_pages = 0
    end
  end

  # GET /admin/users/:id
  def show
    @service = UserManagementService.new(
      current_user: current_user,
      user_id: @user.id
    )
    
    result = @service.get_user_details
    
    if result.success?
      @user_details = result.result
    else
      flash[:error] = result.errors.full_messages.join(', ')
      redirect_to admin_users_path
    end
  end

  # GET /admin/users/new
  def new
    @user = User.new
  end

  # POST /admin/users
  def create
    @service = UserManagementService.new(
      current_user: current_user,
      user_params: user_params
    )
    
    result = @service.create_user
    
    if result.success?
      flash[:success] = result.result[:message]
      redirect_to admin_user_path(result.result[:user])
    else
      @user = User.new(user_params)
      flash.now[:error] = result.errors.full_messages.join(', ')
      render :new, status: :unprocessable_entity
    end
  end

  # GET /admin/users/:id/edit
  def edit
    # @user is set by before_action
  end

  # PATCH/PUT /admin/users/:id
  def update
    @service = UserManagementService.new(
      current_user: current_user,
      user_id: @user.id,
      user_params: user_params
    )
    
    result = @service.update_user
    
    if result.success?
      flash[:success] = result.result[:message]
      redirect_to admin_user_path(@user)
    else
      flash.now[:error] = result.errors.full_messages.join(', ')
      render :edit, status: :unprocessable_entity
    end
  end

  # POST /admin/users/:id/suspend
  def suspend
    @service = UserManagementService.new(
      current_user: current_user,
      user_id: @user.id,
      suspension_reason: params[:suspension_reason]
    )
    
    result = @service.suspend_user
    
    if result.success?
      flash[:success] = result.result[:message]
    else
      flash[:error] = result.errors.full_messages.join(', ')
    end
    
    redirect_to admin_user_path(@user)
  end

  # POST /admin/users/:id/reactivate
  def reactivate
    @service = UserManagementService.new(
      current_user: current_user,
      user_id: @user.id
    )
    
    result = @service.reactivate_user
    
    if result.success?
      flash[:success] = result.result[:message]
    else
      flash[:error] = result.errors.full_messages.join(', ')
    end
    
    redirect_to admin_user_path(@user)
  end

  # POST /admin/users/:id/send_password_reset
  def send_password_reset
    @service = UserManagementService.new(
      current_user: current_user,
      user_id: @user.id
    )
    
    result = @service.send_password_reset
    
    respond_to do |format|
      format.json do
        if result.success?
          render json: { success: true, message: result.result[:message] }
        else
          render json: { success: false, error: result.errors.full_messages.join(', ') }
        end
      end
    end
  end

  # DELETE /admin/users/:id
  def destroy
    @service = UserManagementService.new(
      current_user: current_user,
      user_id: @user.id,
      transfer_data: params[:transfer_data] == 'true'
    )
    
    result = @service.delete_user
    
    if result.success?
      flash[:success] = result.result[:message]
      redirect_to admin_users_path
    else
      flash[:error] = result.errors.full_messages.join(', ')
      redirect_to admin_user_path(@user)
    end
  end

  private

  def set_user
    @user = User.find(params[:id])
  rescue ActiveRecord::RecordNotFound
    flash[:error] = 'User not found'
    redirect_to admin_users_path
  end

  def user_params
    permitted = params.require(:user).permit(
      :email, :first_name, :last_name, :role, :subscription_tier,
      :password, :password_confirmation
    )
    
    # Validate required parameters for creation
    if action_name == 'create'
      validate_admin_params(permitted, [:email, :first_name, :last_name, :role])
    end
    
    # Additional validation
    validate_admin_params(permitted)
    
    permitted
  end

  def filter_params
    permitted = params.permit(:search, :role, :tier, :status, :page, :per_page, :created_after, :created_before)
    
    # Validate filter parameters
    if permitted[:page].present?
      permitted[:page] = [permitted[:page].to_i, 1].max
    end
    
    if permitted[:per_page].present?
      permitted[:per_page] = [permitted[:per_page].to_i.clamp(1, 100), 25].min
    end
    
    if permitted[:role].present?
      validate_role(permitted[:role])
    end
    
    if permitted[:tier].present?
      validate_subscription_tier(permitted[:tier])
    end
    
    permitted
  end
end
</file>

<file path="controllers/api/v1/analytics_controller.rb">
class Api::V1::AnalyticsController < Api::BaseController
  before_action :authenticate_user!

  # POST /api/v1/analytics/payment_setup
  def payment_setup
    event_data = params.require(:event).permit(
      :has_payment_questions,
      :stripe_configured,
      :is_premium,
      :event_type,
      :timestamp,
      :action,
      required_features: []
    )

    # Log the event (in a real app, this would go to an analytics service)
    Rails.logger.info "Payment Setup Event: #{event_data.to_h}"

    # You could also store this in a database table for analytics
    # AnalyticsEvent.create!(
    #   user: current_user,
    #   event_type: 'payment_setup_interaction',
    #   event_data: event_data.to_h
    # )

    render json: { success: true }
  rescue ActionController::ParameterMissing => e
    render json: {
      success: false,
      error: "Missing required parameter: #{e.param}"
    }, status: :bad_request
  rescue StandardError => e
    render json: {
      success: false,
      error: e.message
    }, status: :internal_server_error
  end

  # POST /api/v1/analytics/payment_errors
  def payment_errors
    event_data = params.require(:event).permit(
      :error_type,
      :event_type,
      :timestamp,
      :action,
      required_actions: []
    )

    # Log the error event
    Rails.logger.info "Payment Error Event: #{event_data.to_h}"

    render json: { success: true }
  rescue ActionController::ParameterMissing => e
    render json: {
      success: false,
      error: "Missing required parameter: #{e.param}"
    }, status: :bad_request
  rescue StandardError => e
    render json: {
      success: false,
      error: e.message
    }, status: :internal_server_error
  end
end
</file>

<file path="controllers/api/v1/discount_codes_controller.rb">
class Api::V1::DiscountCodesController < ApplicationController
  before_action :authenticate_user!
  
  # Skip CSRF protection for API endpoints
  skip_before_action :verify_authenticity_token
  
  # Skip Pundit callbacks for API endpoints
  skip_after_action :verify_authorized
  skip_after_action :verify_policy_scoped

  # POST /api/v1/discount_codes/validate
  def validate
    service = DiscountCodeService.new(
      user: current_user,
      code: params[:code]
    )

    result = service.validate_code

    if service.success?
      discount_code = service.result[:discount_code]
      
      # Calculate discount for the requested plan
      original_amount = calculate_plan_amount(params[:billing_cycle])
      discount_calculation = service.calculate_discount(discount_code, original_amount)

      render json: {
        valid: true,
        discount_code: {
          code: discount_code.code,
          discount_percentage: discount_code.discount_percentage
        },
        pricing: {
          original_amount: original_amount,
          discount_amount: discount_calculation[:discount_amount],
          final_amount: discount_calculation[:final_amount],
          currency: 'USD'
        }
      }
    else
      render json: {
        valid: false,
        error: service.errors.full_messages.first || 'Invalid discount code'
      }, status: :unprocessable_entity
    end
  end

  private

  def calculate_plan_amount(billing_cycle)
    plans = SubscriptionManagementService.plans
    case billing_cycle
    when 'yearly'
      plans['premium'][:price_yearly]
    else
      plans['premium'][:price_monthly]
    end
  end
end
</file>

<file path="controllers/api/v1/forms_controller.rb">
# frozen_string_literal: true

class Api::V1::FormsController < Api::BaseController
  before_action :set_form, only: [:show, :update, :destroy, :publish, :unpublish, :duplicate, :analytics, :export, :preview, :test_ai_feature, :embed_code]
  before_action :authorize_form_access, only: [:show, :update, :destroy, :publish, :unpublish, :duplicate, :analytics, :export, :preview, :test_ai_feature, :embed_code]

  # GET /api/v1/forms
  def index
    authorize_token!('forms', 'read') || return

    @forms = policy_scope(Form)
                        .includes(:form_questions, :form_responses)
                        .order(created_at: :desc)

    # Apply search filter
    if search_params[:query].present?
      @forms = @forms.where("name ILIKE ? OR description ILIKE ?", 
                           "%#{search_params[:query]}%", 
                           "%#{search_params[:query]}%")
    end

    # Apply status filter
    if search_params[:status].present? && Form.statuses.key?(search_params[:status])
      @forms = @forms.where(status: search_params[:status])
    end

    # Apply category filter
    if search_params[:category].present? && Form.categories.key?(search_params[:category])
      @forms = @forms.where(category: search_params[:category])
    end

    # Apply sorting
    case sort_params[:sort_by]
    when 'name'
      @forms = @forms.order(:name)
    when 'responses'
      @forms = @forms.order(:responses_count)
    when 'completion_rate'
      @forms = @forms.order(:completions_count)
    else
      @forms = @forms.order(created_at: :desc)
    end

    # Pagination
    @forms = paginate_collection(@forms)

    render json: {
      success: true,
      data: {
        forms: serialize_forms(@forms),
        pagination: pagination_meta(@forms)
      }
    }
  end

  # GET /api/v1/forms/:id
  def show
    authorize_token!('forms', 'read') || return

    render json: {
      success: true,
      data: {
        form: serialize_form(@form, include_questions: true, include_analytics: true)
      }
    }
  end

  # POST /api/v1/forms
  def create
    authorize_token!('forms', 'write') || return

    @form = current_user.forms.build(form_params)
    authorize @form
    
    @form.assign_attributes(default_form_settings) if @form.form_settings.blank?
    @form.assign_attributes(default_ai_configuration) if @form.ai_configuration.blank?

    if @form.save
      # Trigger workflow generation if AI is enabled
      if @form.ai_enabled?
        Forms::WorkflowGenerationJob.perform_later(@form.id)
      end

      render_created(
        { form: serialize_form(@form) },
        message: 'Form created successfully'
      )
    else
      render_unprocessable_entity
    end
  end

  # PATCH/PUT /api/v1/forms/:id
  def update
    authorize_token!('forms', 'write') || return

    old_ai_config = @form.ai_configuration.dup
    old_structure = @form.form_questions.pluck(:id, :position, :question_type)

    if @form.update(form_params)
      handle_form_update(old_ai_config, old_structure)

      render_updated(
        { form: serialize_form(@form) },
        message: 'Form updated successfully'
      )
    else
      render_unprocessable_entity
    end
  end

  # DELETE /api/v1/forms/:id
  def destroy
    authorize_token!('forms', 'delete') || return

    @form.destroy!

    render_deleted(message: 'Form deleted successfully')
  end

  # POST /api/v1/forms/:id/publish
  def publish
    authorize_token!('forms', 'write') || return

    unless @form.form_questions.any?
      return render json: {
        success: false,
        error: 'Cannot publish form without questions',
        code: 'FORM_VALIDATION_ERROR'
      }, status: :unprocessable_entity
    end

    @form.update!(status: 'published', published_at: Time.current)
    
    render json: {
      success: true,
      message: 'Form published successfully',
      data: {
        form: serialize_form(@form),
        public_url: @form.public_url
      }
    }
  end

  # POST /api/v1/forms/:id/unpublish
  def unpublish
    authorize_token!('forms', 'write') || return

    @form.update!(status: 'draft', published_at: nil)
    
    render json: {
      success: true,
      message: 'Form unpublished successfully',
      data: {
        form: serialize_form(@form)
      }
    }
  end

  # POST /api/v1/forms/:id/duplicate
  def duplicate
    authorize_token!('forms', 'write') || return

    begin
      duplicated_form = Forms::ManagementAgent.new.duplicate_form(@form, current_user, {
        name: "#{@form.name} (Copy)",
        status: 'draft'
      })

      render_created(
        { form: serialize_form(duplicated_form) },
        message: 'Form duplicated successfully'
      )
    rescue StandardError => e
      render json: {
        success: false,
        error: 'Duplication failed',
        message: e.message,
        code: 'DUPLICATION_ERROR'
      }, status: :unprocessable_entity
    end
  end

  # GET /api/v1/forms/:id/analytics
  def analytics
    authorize_token!('forms', 'read') || return

    analytics_period = params[:period]&.to_i&.days || 30.days
    analytics_data = @form.cached_analytics_summary(period: analytics_period)
    
    question_analytics = @form.form_questions.includes(:question_responses)
                              .map { |q| [q.id, q.analytics_summary(analytics_period)] }
                              .to_h

    response_trends = @form.form_analytics
                           .for_period(analytics_period.ago.to_date, Date.current)
                           .where(period_type: 'daily')
                           .order(:date)

    render json: {
      success: true,
      data: {
        summary: analytics_data,
        questions: question_analytics,
        trends: serialize_analytics_trends(response_trends),
        period: analytics_period.to_i
      }
    }
  end

  # GET /api/v1/forms/:id/export
  def export
    authorize_token!('forms', 'read') || return

    export_format = params[:format] || 'csv'
    export_options = {
      format: export_format,
      include_metadata: params[:include_metadata] == 'true',
      date_range: params[:date_range]
    }

    begin
      export_data = Forms::ManagementAgent.new.export_form_data(@form, export_options)
      
      render json: {
        success: true,
        data: {
          download_url: export_data[:download_url],
          filename: export_data[:filename],
          expires_at: export_data[:expires_at],
          format: export_format
        }
      }
    rescue StandardError => e
      render json: {
        success: false,
        error: 'Export failed',
        message: e.message,
        code: 'EXPORT_ERROR'
      }, status: :unprocessable_entity
    end
  end

  # GET /api/v1/forms/:id/preview
  def preview
    authorize_token!('forms', 'read') || return

    render json: {
      success: true,
      data: {
        form: serialize_form(@form, include_questions: true),
        preview_url: Rails.application.routes.url_helpers.public_form_preview_url(@form.share_token)
      }
    }
  end

  # POST /api/v1/forms/:id/test_ai_feature
  def test_ai_feature
    authorize_token!('forms', 'write') || return

    feature_type = params[:feature_type]
    test_data = params[:test_data] || {}

    unless @form.ai_enhanced?
      return render json: {
        success: false,
        error: 'AI features not enabled',
        message: 'AI features are not enabled for this form',
        code: 'AI_NOT_ENABLED'
      }, status: :unprocessable_entity
    end

    begin
      case feature_type
      when 'response_analysis'
        result = test_response_analysis(test_data)
      when 'dynamic_questions'
        result = test_dynamic_question_generation(test_data)
      when 'sentiment_analysis'
        result = test_sentiment_analysis(test_data)
      else
        return render json: {
          success: false,
          error: 'Unknown AI feature type',
          message: "Feature type '#{feature_type}' is not supported",
          code: 'INVALID_FEATURE_TYPE'
        }, status: :bad_request
      end

      render json: {
        success: true,
        data: {
          feature_type: feature_type,
          result: result
        }
      }
    rescue StandardError => e
      render json: {
        success: false,
        error: 'AI test failed',
        message: e.message,
        code: 'AI_TEST_ERROR'
      }, status: :unprocessable_entity
    end
  end

  # GET /api/v1/forms/:id/embed_code
  def embed_code
    authorize_token!('forms', 'read') || return

    width = params[:width] || '100%'
    height = params[:height] || '600px'
    
    render json: {
      success: true,
      data: {
        embed_code: @form.embed_code(width: width, height: height),
        public_url: @form.public_url,
        share_token: @form.share_token
      }
    }
  end

  # GET /api/v1/forms/templates
  def templates
    authorize_token!('forms', 'read') || return

    # This will be implemented when FormTemplate model is fully developed
    templates = [] # FormTemplate.public_templates.featured
    
    render json: {
      success: true,
      data: {
        templates: templates
      }
    }
  end

  private

  def set_form
    @form = Form.find(params[:id])
  rescue ActiveRecord::RecordNotFound
    render_not_found
  end

  def authorize_form_access
    authorize @form
  rescue Pundit::NotAuthorizedError
    render_unauthorized
  end

  def form_params
    params.require(:form).permit(
      :name, :description, :category, :ai_enabled,
      form_settings: {},
      ai_configuration: {},
      style_configuration: {},
      integration_settings: {}
    )
  end

  def search_params
    params.permit(:query, :status, :category)
  end

  def sort_params
    params.permit(:sort_by, :sort_direction)
  end

  def default_form_settings
    {
      form_settings: {
        one_question_per_page: true,
        show_progress_bar: true,
        allow_multiple_submissions: false,
        require_login: false,
        collect_email: true,
        thank_you_message: "Thank you for your response!",
        redirect_url: nil
      }
    }
  end

  def default_ai_configuration
    {
      ai_configuration: {
        enabled: false,
        features: [],
        model: 'gpt-4o-mini',
        temperature: 0.7,
        max_tokens: 500,
        confidence_threshold: 0.7
      }
    }
  end

  def handle_form_update(old_ai_config, old_structure)
    # Check if AI configuration changed
    if ai_configuration_changed?(old_ai_config)
      # Regenerate workflow if AI settings changed
      if @form.ai_enabled?
        Forms::WorkflowGenerationJob.perform_later(@form.id)
      end
    end

    # Check if form structure changed
    if form_structure_changed?(old_structure)
      # Update form cache and analytics
      @form.update_form_cache
      
      # Trigger analytics recalculation if form has responses
      if @form.form_responses.any?
        # TODO: Fix this to use the correct workflow execution method
        # Forms::AnalysisWorkflow.execute(@form.id)
      end
    end
  end

  def form_structure_changed?(old_structure)
    current_structure = @form.form_questions.pluck(:id, :position, :question_type)
    old_structure != current_structure
  end

  def ai_configuration_changed?(old_config)
    @form.ai_configuration != old_config
  end

  # AI Testing Methods
  def test_response_analysis(test_data)
    sample_answer = test_data[:sample_answer] || "This is a test response"
    
    # For now, return mock data since SuperAgent workflows are not fully implemented
    {
      sentiment: analyze_sentiment(sample_answer),
      confidence: 0.85,
      insights: ["Sample analysis for: #{sample_answer}"]
    }
  end

  def test_dynamic_question_generation(test_data)
    _context_answer = test_data[:context_answer] || "I'm interested in your premium features"
    
    # For now, return mock data since SuperAgent workflows are not fully implemented
    {
      generated_question: "What specific features are you most interested in?",
      question_type: "multiple_choice",
      reasoning: "Generated follow-up based on interest in premium features"
    }
  end

  def test_sentiment_analysis(test_data)
    sample_text = test_data[:sample_text] || "I love this product, it's amazing!"
    
    {
      sentiment: analyze_sentiment(sample_text),
      confidence: 0.85,
      keywords: extract_keywords(sample_text)
    }
  end

  def analyze_sentiment(text)
    positive_words = %w[love amazing great excellent wonderful fantastic good]
    negative_words = %w[hate terrible awful bad horrible disappointing poor]
    
    positive_count = positive_words.count { |word| text.downcase.include?(word) }
    negative_count = negative_words.count { |word| text.downcase.include?(word) }
    
    if positive_count > negative_count
      'positive'
    elsif negative_count > positive_count
      'negative'
    else
      'neutral'
    end
  end

  def extract_keywords(text)
    words = text.downcase.gsub(/[^\w\s]/, '').split
    stop_words = %w[the a an and or but in on at to for of with by]
    
    (words - stop_words).tally.sort_by { |_, count| -count }.first(5).to_h
  end

  # Serialization Methods
  def serialize_forms(forms)
    forms.map { |form| serialize_form(form) }
  end

  def serialize_form(form, include_questions: false, include_analytics: false)
    result = {
      id: form.id,
      name: form.name,
      description: form.description,
      status: form.status,
      category: form.category,
      share_token: form.share_token,
      public_url: form.public_url,
      ai_enabled: form.ai_enabled?,
      ai_enhanced: form.ai_enhanced?,
      created_at: form.created_at,
      updated_at: form.updated_at,
      published_at: form.published_at,
      form_settings: form.form_settings,
      ai_configuration: form.ai_configuration,
      style_configuration: form.style_configuration,
      integration_settings: form.integration_settings,
      questions_count: form.form_questions.count,
      responses_count: form.responses_count || 0,
      completion_rate: form.cached_completion_rate
    }

    if include_questions
      result[:questions] = form.form_questions.order(:position).map do |question|
        serialize_question(question)
      end
    end

    if include_analytics
      result[:analytics] = form.cached_analytics_summary
    end

    result
  end

  def serialize_question(question)
    {
      id: question.id,
      title: question.title,
      description: question.description,
      question_type: question.question_type,
      position: question.position,
      required: question.required?,
      ai_enhanced: question.ai_enhanced?,
      options: question.options,
      validation_rules: question.validation_rules,
      conditional_logic: question.conditional_logic,
      created_at: question.created_at,
      updated_at: question.updated_at
    }
  end

  def serialize_analytics_trends(trends)
    trends.map do |trend|
      {
        date: trend.date,
        period_type: trend.period_type,
        views_count: trend.views_count,
        started_responses_count: trend.started_responses_count,
        completed_responses_count: trend.completed_responses_count,
        completion_rate: trend.completion_rate,
        conversion_rate: trend.conversion_rate
      }
    end
  end
end
</file>

<file path="controllers/api/v1/payment_setup_controller.rb">
class Api::V1::PaymentSetupController < Api::BaseController
  before_action :authenticate_user!

  # GET /api/v1/payment_setup/status
  def status
    setup_status = {
      stripe_configured: current_user.stripe_configured?,
      premium_subscription: current_user.premium?,
      can_accept_payments: current_user.stripe_configured? && current_user.premium?,
      setup_completion_percentage: calculate_setup_completion
    }

    render json: {
      success: true,
      setup_status: setup_status
    }
  rescue StandardError => e
    render json: {
      success: false,
      error: e.message
    }, status: :internal_server_error
  end

  private

  def calculate_setup_completion
    total_steps = 2 # Stripe + Premium
    completed_steps = 0
    completed_steps += 1 if current_user.stripe_configured?
    completed_steps += 1 if current_user.premium?
    (completed_steps.to_f / total_steps * 100).round
  end
end
</file>

<file path="controllers/api/v1/responses_controller.rb">
# frozen_string_literal: true

class Api::V1::ResponsesController < Api::BaseController
  before_action :set_form, only: [:index, :show, :create, :update, :destroy, :analytics, :export]
  before_action :set_response, only: [:show, :update, :destroy, :resume, :abandon, :submit_answer, :complete, :answers]
  before_action :authorize_form_access, only: [:index, :show, :create, :update, :destroy, :analytics, :export]

  # GET /api/v1/forms/:form_id/responses
  def index
    authorize_token!('responses', 'read') || return

    @responses = policy_scope(@form.form_responses)
                        .includes(:question_responses)
                        .order(created_at: :desc)

    # Apply filters
    apply_response_filters

    # Apply sorting
    apply_response_sorting

    # Pagination
    @responses = paginate_collection(@responses)

    render json: {
      success: true,
      data: {
        responses: serialize_responses(@responses),
        pagination: pagination_meta(@responses),
        summary: response_summary_stats
      }
    }
  end

  # GET /api/v1/responses/:id
  def show
    authorize_token!('responses', 'read') || return

    render json: {
      success: true,
      data: {
        response: serialize_response(@response, include_answers: true, include_analytics: true)
      }
    }
  end

  # POST /api/v1/forms/:form_id/responses
  def create
    authorize_token!('responses', 'write') || return

    @response = @form.form_responses.build(response_params)
    @response.session_id = generate_api_session_id
    @response.ip_address = request.remote_ip
    @response.user_agent = request.user_agent

    if @response.save
      render_created(
        { response: serialize_response(@response) },
        message: 'Response created successfully'
      )
    else
      render_unprocessable_entity
    end
  end

  # PATCH/PUT /api/v1/responses/:id
  def update
    authorize_token!('responses', 'write') || return

    if @response.update(response_params)
      render_updated(
        { response: serialize_response(@response) },
        message: 'Response updated successfully'
      )
    else
      render_unprocessable_entity
    end
  end

  # DELETE /api/v1/responses/:id
  def destroy
    authorize_token!('responses', 'delete') || return

    @response.destroy!

    render_deleted(message: 'Response deleted successfully')
  end

  # POST /api/v1/responses/:id/submit_answer
  def submit_answer
    authorize_token!('responses', 'write') || return

    @question = find_question_by_id(params[:question_id])
    
    unless @question
      return render json: {
        success: false,
        error: 'Question not found',
        code: 'QUESTION_NOT_FOUND'
      }, status: :not_found
    end

    # Process the answer submission
    result = process_answer_submission(@question)

    if result[:success]
      render json: {
        success: true,
        data: {
          question_response: serialize_question_response(result[:question_response]),
          next_question: result[:next_question] ? serialize_question(result[:next_question]) : nil,
          progress: @response.progress_percentage,
          completed: result[:completed] || false
        }
      }
    else
      render json: {
        success: false,
        error: 'Answer submission failed',
        errors: result[:errors],
        code: 'ANSWER_VALIDATION_ERROR'
      }, status: :unprocessable_entity
    end
  end

  # POST /api/v1/responses/:id/complete
  def complete
    authorize_token!('responses', 'write') || return

    unless @response.can_be_completed?
      return render json: {
        success: false,
        error: 'Response cannot be completed',
        message: 'Not all required questions have been answered',
        code: 'INCOMPLETE_RESPONSE'
      }, status: :unprocessable_entity
    end

    completion_data = {
      completed_at: Time.current,
      completion_method: 'api',
      api_token_id: current_api_token.id
    }

    if @response.mark_completed!(completion_data)
      render json: {
        success: true,
        message: 'Response completed successfully',
        data: {
          response: serialize_response(@response),
          completion_data: completion_data
        }
      }
    else
      render json: {
        success: false,
        error: 'Failed to complete response',
        code: 'COMPLETION_ERROR'
      }, status: :unprocessable_entity
    end
  end

  # POST /api/v1/responses/:id/abandon
  def abandon
    authorize_token!('responses', 'write') || return

    abandonment_reason = params[:reason] || 'api_abandoned'
    
    @response.mark_abandoned!(abandonment_reason)

    render json: {
      success: true,
      message: 'Response marked as abandoned',
      data: {
        response: serialize_response(@response)
      }
    }
  end

  # POST /api/v1/responses/:id/resume
  def resume
    authorize_token!('responses', 'write') || return

    unless @response.paused?
      return render json: {
        success: false,
        error: 'Response is not paused',
        message: 'Only paused responses can be resumed',
        code: 'INVALID_STATUS'
      }, status: :unprocessable_entity
    end

    if @response.resume!
      render json: {
        success: true,
        message: 'Response resumed successfully',
        data: {
          response: serialize_response(@response),
          next_question: serialize_question(@response.next_question)
        }
      }
    else
      render json: {
        success: false,
        error: 'Failed to resume response',
        code: 'RESUME_ERROR'
      }, status: :unprocessable_entity
    end
  end

  # GET /api/v1/forms/:form_id/responses/analytics
  def analytics
    authorize_token!('responses', 'read') || return

    analytics_period = params[:period]&.to_i&.days || 30.days
    
    analytics_data = {
      summary: calculate_response_analytics(analytics_period),
      trends: calculate_response_trends(analytics_period),
      completion_funnel: calculate_completion_funnel,
      question_analytics: calculate_question_analytics(analytics_period)
    }

    render json: {
      success: true,
      data: analytics_data
    }
  end

  # GET /api/v1/forms/:form_id/responses/export
  def export
    authorize_token!('responses', 'read') || return

    export_format = params[:format] || 'csv'
    export_options = {
      format: export_format,
      include_metadata: params[:include_metadata] == 'true',
      date_range: params[:date_range],
      status_filter: params[:status]
    }

    begin
      export_data = generate_response_export(export_options)
      
      render json: {
        success: true,
        data: {
          download_url: export_data[:download_url],
          filename: export_data[:filename],
          expires_at: export_data[:expires_at],
          format: export_format,
          record_count: export_data[:record_count]
        }
      }
    rescue StandardError => e
      render json: {
        success: false,
        error: 'Export failed',
        message: e.message,
        code: 'EXPORT_ERROR'
      }, status: :unprocessable_entity
    end
  end

  # GET /api/v1/responses/:id/answers
  def answers
    authorize_token!('responses', 'read') || return

    answers = @response.question_responses
                      .includes(:form_question)
                      .order('form_questions.position')

    render json: {
      success: true,
      data: {
        answers: serialize_question_responses(answers),
        response_summary: @response.response_summary
      }
    }
  end

  private

  def set_form
    @form = current_user.forms.find(params[:form_id])
  rescue ActiveRecord::RecordNotFound
    render_not_found
  end

  def set_response
    if params[:form_id] && @form
      @response = @form.form_responses.find(params[:id])
    else
      @response = FormResponse.joins(:form)
                             .where(forms: { user: current_user })
                             .find(params[:id])
      @form = @response.form if @response
    end
  rescue ActiveRecord::RecordNotFound
    render_not_found
  end

  def authorize_form_access
    authorize @form
  rescue Pundit::NotAuthorizedError
    render_unauthorized
  end

  def response_params
    params.require(:response).permit(
      :status, :referrer_url, :draft_data,
      utm_parameters: {}, metadata: {}
    )
  end

  def answer_params
    params.require(:answer).permit(:value, :started_at, :completed_at, metadata: {})
  end

  def generate_api_session_id
    "api_#{current_api_token.id}_#{SecureRandom.hex(16)}_#{Time.current.to_i}"
  end

  def find_question_by_id(question_id)
    @form.form_questions.find_by(id: question_id)
  end

  def process_answer_submission(question)
    answer_data = extract_answer_data
    
    # Validate the answer
    validation_result = validate_answer_data(question, answer_data)
    return validation_result unless validation_result[:valid]

    # Create or update question response
    question_response = @response.question_responses
                                .find_or_initialize_by(form_question: question)
    
    question_response.assign_attributes(
      answer_data: answer_data,
      response_time_ms: calculate_response_time(answer_data)
    )

    if question_response.save
      # Update response activity
      @response.touch(:last_activity_at)

      # Find next question
      next_question = find_next_question

      # Check if response should be completed
      completed = next_question.nil? && @response.can_be_completed?
      
      if completed
        @response.mark_completed!({
          completed_at: Time.current,
          completion_method: 'api_auto',
          api_token_id: current_api_token.id
        })
      end

      {
        success: true,
        question_response: question_response,
        next_question: next_question,
        completed: completed
      }
    else
      {
        success: false,
        errors: question_response.errors.full_messages
      }
    end
  end

  def extract_answer_data
    answer_data = answer_params.to_h
    
    # Add API-specific metadata
    answer_data[:metadata] ||= {}
    answer_data[:metadata][:submitted_via] = 'api'
    answer_data[:metadata][:api_token_id] = current_api_token.id
    answer_data[:metadata][:ip_address] = request.remote_ip
    answer_data[:metadata][:user_agent] = request.user_agent
    
    answer_data
  end

  def validate_answer_data(question, answer_data)
    # Basic validation
    if question.required? && answer_data[:value].blank?
      return { valid: false, errors: ['Answer is required'] }
    end

    # Type-specific validation would go here
    # For now, return valid
    { valid: true }
  end

  def calculate_response_time(answer_data)
    return 0 unless answer_data[:started_at] && answer_data[:completed_at]

    started = Time.parse(answer_data[:started_at])
    completed = Time.parse(answer_data[:completed_at])
    ((completed - started) * 1000).to_i
  rescue
    0
  end

  def find_next_question
    answered_question_ids = @response.question_responses
                                   .joins(:form_question)
                                   .pluck('form_questions.id')
    
    @form.form_questions
         .where.not(id: answered_question_ids)
         .order(:position)
         .first
  end

  def apply_response_filters
    # Status filter
    if params[:status].present? && FormResponse.statuses.key?(params[:status])
      @responses = @responses.where(status: params[:status])
    end

    # Date range filter
    if params[:start_date].present?
      start_date = Date.parse(params[:start_date])
      @responses = @responses.where('form_responses.created_at >= ?', start_date)
    end

    if params[:end_date].present?
      end_date = Date.parse(params[:end_date])
      @responses = @responses.where('form_responses.created_at <= ?', end_date.end_of_day)
    end

    # Quality score filter
    if params[:min_quality_score].present?
      @responses = @responses.where('quality_score >= ?', params[:min_quality_score].to_f)
    end
  end

  def apply_response_sorting
    case params[:sort_by]
    when 'created_at'
      @responses = @responses.order(created_at: params[:sort_direction] == 'asc' ? :asc : :desc)
    when 'completed_at'
      @responses = @responses.order(completed_at: params[:sort_direction] == 'asc' ? :asc : :desc)
    when 'progress'
      # This would require a calculated field or subquery
      @responses = @responses.order(created_at: :desc)
    when 'quality_score'
      @responses = @responses.order(quality_score: params[:sort_direction] == 'asc' ? :asc : :desc)
    else
      @responses = @responses.order(created_at: :desc)
    end
  end

  def response_summary_stats
    {
      total_responses: @form.form_responses.count,
      completed_responses: @form.form_responses.completed.count,
      in_progress_responses: @form.form_responses.in_progress.count,
      abandoned_responses: @form.form_responses.abandoned.count,
      completion_rate: @form.cached_completion_rate || 0.0,
      average_completion_time: calculate_average_completion_time
    }
  end

  def calculate_average_completion_time
    completed_responses = @form.form_responses.completed
                               .where.not(started_at: nil, completed_at: nil)
    
    return 0.0 if completed_responses.empty?

    total_time = completed_responses.sum do |response|
      next 0 unless response.started_at && response.completed_at
      (response.completed_at - response.started_at) / 60.0 # in minutes
    end

    (total_time / completed_responses.count).round(2)
  end

  def calculate_response_analytics(period)
    responses = @form.form_responses.where('created_at >= ?', period.ago)
    
    {
      total_responses: responses.count,
      completed_responses: responses.completed.count,
      completion_rate: responses.count > 0 ? (responses.completed.count.to_f / responses.count * 100).round(2) : 0.0,
      average_completion_time: calculate_period_completion_time(responses.completed),
      abandonment_rate: responses.count > 0 ? (responses.abandoned.count.to_f / responses.count * 100).round(2) : 0.0
    }
  end

  def calculate_response_trends(period)
    # This would typically involve grouping by date and calculating daily metrics
    # For now, return a simple structure
    []
  end

  def calculate_completion_funnel
    questions = @form.form_questions.order(:position)
    funnel_data = []

    questions.each_with_index do |question, index|
      responses_reached = @form.form_responses
                               .joins(:question_responses)
                               .where(question_responses: { form_question: question })
                               .distinct
                               .count

      funnel_data << {
        step: index + 1,
        question_title: question.title,
        responses_reached: responses_reached,
        drop_off_rate: index > 0 ? calculate_drop_off_rate(funnel_data[index - 1][:responses_reached], responses_reached) : 0.0
      }
    end

    funnel_data
  end

  def calculate_drop_off_rate(previous_count, current_count)
    return 0.0 if previous_count.zero?
    
    ((previous_count - current_count).to_f / previous_count * 100).round(2)
  end

  def calculate_question_analytics(period)
    @form.form_questions.includes(:question_responses).map do |question|
      responses = question.question_responses
                         .joins(:form_response)
                         .where('form_responses.created_at >= ?', period.ago)

      {
        question_id: question.id,
        question_title: question.title,
        question_type: question.question_type,
        total_responses: responses.count,
        average_response_time: responses.average(:response_time_ms) || 0,
        skip_rate: calculate_question_skip_rate(question, period)
      }
    end
  end

  def calculate_question_skip_rate(question, period)
    total_reached = @form.form_responses
                         .where('created_at >= ?', period.ago)
                         .joins(:question_responses)
                         .where('form_questions.position <= ?', question.position)
                         .distinct
                         .count

    answered = question.question_responses
                      .joins(:form_response)
                      .where('form_responses.created_at >= ?', period.ago)
                      .where.not(answer_data: {})
                      .count

    return 0.0 if total_reached.zero?
    
    ((total_reached - answered).to_f / total_reached * 100).round(2)
  end

  def calculate_period_completion_time(responses)
    return 0.0 if responses.empty?

    total_time = responses.sum do |response|
      next 0 unless response.started_at && response.completed_at
      (response.completed_at - response.started_at) / 60.0
    end

    (total_time / responses.count).round(2)
  end

  def generate_response_export(options)
    # This would typically generate a file and return a download URL
    # For now, return mock data
    {
      download_url: "https://example.com/exports/responses_#{SecureRandom.hex(8)}.#{options[:format]}",
      filename: "form_#{@form.id}_responses_#{Date.current.strftime('%Y%m%d')}.#{options[:format]}",
      expires_at: 24.hours.from_now,
      record_count: @form.form_responses.count
    }
  end

  # Serialization Methods
  def serialize_responses(responses)
    responses.map { |response| serialize_response(response) }
  end

  def serialize_response(response, include_answers: false, include_analytics: false)
    result = {
      id: response.id,
      form_id: response.form_id,
      session_id: response.session_id,
      status: response.status,
      progress_percentage: response.progress_percentage,
      started_at: response.started_at,
      completed_at: response.completed_at,
      last_activity_at: response.last_activity_at,
      duration_minutes: response.duration_minutes,
      quality_score: response.quality_score,
      sentiment_score: response.sentiment_score,
      ip_address: response.ip_address,
      user_agent: response.user_agent,
      referrer_url: response.referrer_url,
      utm_parameters: response.utm_parameters,
      created_at: response.created_at,
      updated_at: response.updated_at
    }

    if include_answers
      result[:answers] = serialize_question_responses(response.question_responses.includes(:form_question))
    end

    if include_analytics
      result[:analytics] = {
        quality_score: response.quality_score,
        sentiment_score: response.sentiment_score,
        duration_minutes: response.duration_minutes,
        progress_percentage: response.progress_percentage
      }
    end

    result
  end

  def serialize_question_responses(question_responses)
    question_responses.map { |qr| serialize_question_response(qr) }
  end

  def serialize_question_response(question_response)
    {
      id: question_response.id,
      question_id: question_response.form_question_id,
      question_title: question_response.form_question.title,
      question_type: question_response.form_question.question_type,
      answer_data: question_response.answer_data,
      formatted_answer: question_response.formatted_answer,
      response_time_ms: question_response.response_time_ms,
      skipped: question_response.skipped?,
      ai_confidence_score: question_response.ai_confidence_score,
      created_at: question_response.created_at,
      updated_at: question_response.updated_at
    }
  end

  def serialize_question(question)
    return nil unless question
    
    {
      id: question.id,
      title: question.title,
      description: question.description,
      question_type: question.question_type,
      position: question.position,
      required: question.required?,
      options: question.options,
      validation_rules: question.validation_rules
    }
  end
end
</file>

<file path="controllers/api/base_controller.rb">
# frozen_string_literal: true

class Api::BaseController < ActionController::API
  # Include Pundit for authorization
  include Pundit::Authorization

  # API-specific callbacks
  before_action :authenticate_api_user!
  before_action :set_current_user
  before_action :set_default_format

  # Note: ActionController::API doesn't include CSRF protection by default

  protected

  # Token-based authentication
  def authenticate_api_user!
    token = extract_token_from_header
    
    if token.blank?
      render_authentication_required
      return
    end

    @current_api_token = ApiToken.authenticate(token)
    
    if @current_api_token.nil?
      render_invalid_token
      return
    end

    @current_user = @current_api_token.user
  end

  public

  # Current user for Pundit
  def current_user
    @current_user
  end

  # Current API token
  def current_api_token
    @current_api_token
  end

  protected

  # Pundit user
  def pundit_user
    current_user
  end

  # Check if current token has permission for resource and action
  def authorize_token!(resource, action)
    unless current_api_token.can_access?(resource, action)
      render_insufficient_permissions(resource, action)
      return false
    end
    true
  end

  # Set current user and request context
  def set_current_user
    Current.user = current_user
    Current.request_id = request.uuid
    Current.user_agent = request.user_agent
    Current.ip_address = request.remote_ip
    Current.api_token = current_api_token
  end

  # Set default format to JSON
  def set_default_format
    request.format = :json
  end

  # Extract token from Authorization header
  def extract_token_from_header
    auth_header = request.headers['Authorization']
    return nil if auth_header.blank?
    
    # Support both "Bearer token" and "token" formats
    if auth_header.start_with?('Bearer ')
      auth_header.sub('Bearer ', '')
    else
      auth_header
    end
  end

  # API Error Response Methods
  def render_authentication_required
    render json: {
      error: 'Authentication required',
      message: 'API token must be provided in Authorization header',
      code: 'AUTHENTICATION_REQUIRED'
    }, status: :unauthorized
  end

  def render_invalid_token
    render json: {
      error: 'Invalid token',
      message: 'The provided API token is invalid, expired, or revoked',
      code: 'INVALID_TOKEN'
    }, status: :unauthorized
  end

  def render_insufficient_permissions(resource, action)
    render json: {
      error: 'Insufficient permissions',
      message: "Token does not have permission to #{action} #{resource}",
      code: 'INSUFFICIENT_PERMISSIONS',
      required_permission: "#{resource}:#{action}"
    }, status: :forbidden
  end

  def render_not_found(exception = nil)
    log_error(exception) if exception
    
    render json: {
      error: 'Resource not found',
      message: 'The requested resource could not be found',
      code: 'NOT_FOUND'
    }, status: :not_found
  end

  def render_unauthorized(exception = nil)
    log_error(exception) if exception
    
    render json: {
      error: 'Unauthorized',
      message: 'You are not authorized to perform this action',
      code: 'UNAUTHORIZED'
    }, status: :unauthorized
  end

  def render_bad_request(exception = nil)
    log_error(exception) if exception
    
    render json: {
      error: 'Bad request',
      message: exception&.message || 'Invalid request parameters',
      code: 'BAD_REQUEST'
    }, status: :bad_request
  end

  def render_unprocessable_entity(exception = nil)
    log_error(exception) if exception
    
    errors = if exception&.record&.errors&.any?
               exception.record.errors.full_messages
             else
               [exception&.message || 'Validation failed']
             end

    render json: {
      error: 'Unprocessable entity',
      message: 'The request could not be processed due to validation errors',
      code: 'VALIDATION_ERROR',
      errors: errors
    }, status: :unprocessable_entity
  end

  def render_conflict(exception = nil)
    log_error(exception) if exception
    
    render json: {
      error: 'Conflict',
      message: 'The request conflicts with the current state of the resource',
      code: 'CONFLICT',
      details: exception&.message
    }, status: :conflict
  end

  def render_workflow_error(exception = nil)
    log_error(exception) if exception
    
    render json: {
      error: 'Workflow error',
      message: 'There was an error processing the workflow',
      code: 'WORKFLOW_ERROR',
      details: exception&.message,
      workflow_id: exception&.respond_to?(:workflow_id) ? exception.workflow_id : nil
    }, status: :unprocessable_entity
  end

  def render_timeout_error(exception = nil)
    log_error(exception) if exception
    
    render json: {
      error: 'Request timeout',
      message: 'The operation took too long to complete',
      code: 'TIMEOUT_ERROR'
    }, status: :request_timeout
  end

  def render_network_error(exception = nil)
    log_error(exception) if exception
    
    render json: {
      error: 'Network error',
      message: 'Unable to connect to external service',
      code: 'NETWORK_ERROR',
      details: exception&.message
    }, status: :service_unavailable
  end

  def render_internal_server_error(exception = nil)
    log_error(exception) if exception
    
    # Don't expose internal error details in production
    message = Rails.env.production? ? 'An internal error occurred' : exception&.message
    
    render json: {
      error: 'Internal server error',
      message: message,
      code: 'INTERNAL_ERROR'
    }, status: :internal_server_error
  end

  def render_rate_limit_exceeded
    render json: {
      error: 'Rate limit exceeded',
      message: 'Too many requests. Please try again later.',
      code: 'RATE_LIMIT_EXCEEDED'
    }, status: :too_many_requests
  end

  private

  # Centralized error logging for API
  def log_error(exception)
    Rails.logger.error "[API] #{exception.class}: #{exception.message}"
    Rails.logger.error exception.backtrace.join("\n") if exception.backtrace
    
    # Report to Sentry if configured
    if defined?(Sentry)
      Sentry.capture_exception(exception, extra: {
        user_id: current_user&.id,
        api_token_id: current_api_token&.id,
        controller: controller_name,
        action: action_name,
        params: params.except(:password, :password_confirmation, :current_password).to_unsafe_h,
        request_id: request.uuid,
        user_agent: request.user_agent,
        ip_address: request.remote_ip
      })
    end
  end

  # Helper methods for common API responses
  def render_success(data = {}, message: nil, status: :ok)
    response = { success: true }
    response[:message] = message if message
    response[:data] = data if data.present?
    
    render json: response, status: status
  end

  def render_created(data = {}, message: 'Resource created successfully')
    render_success(data, message: message, status: :created)
  end

  def render_updated(data = {}, message: 'Resource updated successfully')
    render_success(data, message: message, status: :ok)
  end

  def render_deleted(message: 'Resource deleted successfully')
    render_success({}, message: message, status: :ok)
  end

  # Pagination helpers
  def paginate_collection(collection, per_page: 25)
    page = params[:page]&.to_i || 1
    per_page = [params[:per_page]&.to_i || per_page, 100].min # Max 100 per page
    
    # Check if Kaminari is available
    if collection.respond_to?(:page)
      collection.page(page).per(per_page)
    else
      # Fallback to manual pagination
      offset = (page - 1) * per_page
      collection.limit(per_page).offset(offset)
    end
  end

  def pagination_meta(collection)
    if collection.respond_to?(:current_page)
      # Kaminari pagination
      {
        current_page: collection.current_page,
        per_page: collection.limit_value,
        total_pages: collection.total_pages,
        total_count: collection.total_count,
        has_next_page: collection.next_page.present?,
        has_prev_page: collection.prev_page.present?
      }
    else
      # Manual pagination fallback
      page = params[:page]&.to_i || 1
      per_page = [params[:per_page]&.to_i || 25, 100].min
      total_count = collection.is_a?(ActiveRecord::Relation) ? collection.count(:all) : collection.count
      total_pages = (total_count.to_f / per_page).ceil
      
      {
        current_page: page,
        per_page: per_page,
        total_pages: total_pages,
        total_count: total_count,
        has_next_page: page < total_pages,
        has_prev_page: page > 1
      }
    end
  end

  # Global rescue handlers for API (most specific first)
  
  # SuperAgent specific error handling (conditional and safer)
  begin
    # Only define these rescue_from blocks if the constants exist
    if defined?(SuperAgent) && defined?(SuperAgent::WorkflowError)
      rescue_from SuperAgent::WorkflowError, with: :render_workflow_error
    end
    
    if defined?(SuperAgent) && defined?(SuperAgent::TaskError)
      rescue_from SuperAgent::TaskError, with: :render_workflow_error
    end
    
    # Check for A2A module and its error classes more safely
    if defined?(SuperAgent::A2A)
      if SuperAgent::A2A.const_defined?(:TimeoutError)
        rescue_from SuperAgent::A2A::TimeoutError, with: :render_timeout_error
      end
      
      if SuperAgent::A2A.const_defined?(:NetworkError)
        rescue_from SuperAgent::A2A::NetworkError, with: :render_network_error
      end
      
      if SuperAgent::A2A.const_defined?(:AuthenticationError)
        rescue_from SuperAgent::A2A::AuthenticationError, with: :render_unauthorized
      end
    end
  rescue NameError => e
    # Silently ignore if SuperAgent constants are not available
    Rails.logger.debug "[API] SuperAgent error classes not available: #{e.message}"
  end

  # ActiveRecord specific errors
  rescue_from ActiveRecord::RecordNotFound, with: :render_not_found
  rescue_from ActiveRecord::RecordInvalid, with: :render_unprocessable_entity
  rescue_from ActiveRecord::RecordNotUnique, with: :render_conflict
  
  # Pundit authorization errors
  rescue_from Pundit::NotAuthorizedError, with: :render_unauthorized
  
  # Controller parameter errors
  rescue_from ActionController::ParameterMissing, with: :render_bad_request

  # Additional common errors
  rescue_from ArgumentError, with: :render_bad_request
  rescue_from JSON::ParserError, with: :render_bad_request
end
</file>

<file path="controllers/concerns/admin_security.rb">
# frozen_string_literal: true

# Security concern for admin controllers
module AdminSecurity
  extend ActiveSupport::Concern

  included do
    # Rate limiting for admin operations
    before_action :check_admin_rate_limit
    
    # Enhanced CSRF protection for admin forms
    protect_from_forgery with: :exception, prepend: true
    
    # Input sanitization
    before_action :sanitize_params
    
    # Audit logging
    after_action :log_admin_action
  end

  private

  def check_admin_rate_limit
    return unless current_user

    cache_key = "admin_rate_limit:#{current_user.id}:#{request.remote_ip}"
    current_count = Rails.cache.read(cache_key) || 0
    
    # Allow 100 admin actions per hour per user/IP combination
    if current_count >= 100
      AuditLog.create!(
        user: current_user,
        event_type: 'admin_rate_limit_exceeded',
        details: {
          ip_address: request.remote_ip,
          user_agent: request.user_agent,
          controller: controller_name,
          action: action_name,
          current_count: current_count
        },
        ip_address: request.remote_ip
      )
      
      respond_to do |format|
        format.html do
          flash[:error] = 'Rate limit exceeded. Please wait before making more requests.'
          redirect_to admin_dashboard_path
        end
        format.json do
          render json: { error: 'Rate limit exceeded' }, status: :too_many_requests
        end
      end
      return
    end
    
    # Increment counter with 1 hour expiry
    Rails.cache.write(cache_key, current_count + 1, expires_in: 1.hour)
  end

  def sanitize_params
    return unless params.present?
    
    # Recursively sanitize all string parameters
    sanitize_hash(params)
  end

  def sanitize_hash(hash)
    hash.each do |key, value|
      case value
      when String
        # Remove potentially dangerous characters and scripts
        sanitized = sanitize_string(value)
        hash[key] = sanitized
      when Hash
        sanitize_hash(value)
      when Array
        value.each_with_index do |item, index|
          if item.is_a?(String)
            value[index] = sanitize_string(item)
          elsif item.is_a?(Hash)
            sanitize_hash(item)
          end
        end
      end
    end
  end

  def sanitize_string(str)
    return str if str.blank?
    
    # Remove null bytes
    str = str.delete("\0")
    
    # Remove or escape potentially dangerous HTML/JS
    str = ActionController::Base.helpers.strip_tags(str)
    
    # Remove SQL injection patterns (basic protection)
    dangerous_patterns = [
      /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION)\b)/i,
      /(--|\/\*|\*\/|;)/,
      /(\bOR\b.*=.*\bOR\b)/i,
      /(\bAND\b.*=.*\bAND\b)/i
    ]
    
    dangerous_patterns.each do |pattern|
      if str.match?(pattern)
        AuditLog.create!(
          user: current_user,
          event_type: 'sql_injection_attempt',
          details: {
            original_input: str,
            pattern_matched: pattern.source,
            ip_address: request.remote_ip,
            user_agent: request.user_agent,
            controller: controller_name,
            action: action_name
          },
          ip_address: request.remote_ip
        )
        
        # Replace with safe placeholder
        str = str.gsub(pattern, '[FILTERED]')
      end
    end
    
    # Remove XSS patterns
    xss_patterns = [
      /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/mi,
      /javascript:/i,
      /on\w+\s*=/i,
      /<iframe\b[^>]*>/i,
      /<object\b[^>]*>/i,
      /<embed\b[^>]*>/i
    ]
    
    xss_patterns.each do |pattern|
      if str.match?(pattern)
        AuditLog.create!(
          user: current_user,
          event_type: 'xss_attempt',
          details: {
            original_input: str,
            pattern_matched: pattern.source,
            ip_address: request.remote_ip,
            user_agent: request.user_agent,
            controller: controller_name,
            action: action_name
          },
          ip_address: request.remote_ip
        )
        
        str = str.gsub(pattern, '[FILTERED]')
      end
    end
    
    # Trim whitespace
    str.strip
  end

  def log_admin_action
    return unless current_user&.admin?
    return if action_name == 'index' && request.get? # Skip logging for simple index views
    
    # Don't log if response was an error (already logged elsewhere)
    return if response.status >= 400
    
    AuditLog.create!(
      user: current_user,
      event_type: 'admin_action',
      details: {
        controller: controller_name,
        action: action_name,
        method: request.method,
        path: request.path,
        params: filtered_params,
        user_agent: request.user_agent,
        response_status: response.status
      },
      ip_address: request.remote_ip
    )
  rescue => e
    # Don't let audit logging break the request
    Rails.logger.error "Failed to log admin action: #{e.message}"
  end

  def filtered_params
    # Remove sensitive parameters from logging
    params.except(:password, :password_confirmation, :current_password, 
                  :stripe_secret_key, :stripe_webhook_secret, :authenticity_token)
          .to_unsafe_h
  end

  # Strong parameter validation helpers
  def validate_admin_params(permitted_params, required_params = [])
    # Check for required parameters
    required_params.each do |param|
      unless permitted_params.key?(param) && permitted_params[param].present?
        raise ActionController::ParameterMissing.new(param)
      end
    end
    
    # Validate parameter types and formats
    permitted_params.each do |key, value|
      next if value.blank?
      
      case key.to_s
      when 'email'
        validate_email_format(value)
      when 'code'
        validate_discount_code_format(value)
      when 'discount_percentage'
        validate_percentage(value)
      when 'max_usage_count'
        validate_positive_integer(value)
      when 'role'
        validate_role(value)
      when 'subscription_tier'
        validate_subscription_tier(value)
      end
    end
    
    permitted_params
  end

  def validate_email_format(email)
    unless email.match?(URI::MailTo::EMAIL_REGEXP)
      raise ActionController::BadRequest.new("Invalid email format: #{email}")
    end
  end

  def validate_discount_code_format(code)
    # Discount codes should be alphanumeric, 3-20 characters
    unless code.match?(/\A[A-Z0-9]{3,20}\z/)
      raise ActionController::BadRequest.new("Invalid discount code format. Use 3-20 alphanumeric characters.")
    end
  end

  def validate_percentage(percentage)
    value = percentage.to_i
    unless value.between?(1, 99)
      raise ActionController::BadRequest.new("Discount percentage must be between 1 and 99")
    end
  end

  def validate_positive_integer(number)
    value = number.to_i
    unless value > 0
      raise ActionController::BadRequest.new("Value must be a positive integer")
    end
  end

  def validate_role(role)
    unless %w[user admin superadmin].include?(role)
      raise ActionController::BadRequest.new("Invalid role: #{role}")
    end
  end

  def validate_subscription_tier(tier)
    unless %w[basic premium].include?(tier)
      raise ActionController::BadRequest.new("Invalid subscription tier: #{tier}")
    end
  end
end
</file>

<file path="controllers/concerns/payment_error_handling.rb">
# frozen_string_literal: true

# Controller concern for handling PaymentValidationError exceptions
# Provides consistent error responses and user guidance across controllers
module PaymentErrorHandling
  extend ActiveSupport::Concern

  included do
    rescue_from PaymentValidationError, with: :handle_payment_validation_error
  end

  private

  # Handles PaymentValidationError exceptions with appropriate responses
  def handle_payment_validation_error(error)
    Rails.logger.warn "Payment validation error: #{error.message}"
    Rails.logger.warn "Error details: #{error.to_hash}"

    respond_to do |format|
      format.html { handle_payment_error_html(error) }
      format.json { handle_payment_error_json(error) }
      format.turbo_stream { handle_payment_error_turbo_stream(error) }
    end
  end

  # Handles HTML responses for payment validation errors
  def handle_payment_error_html(error)
    flash[:error] = error.message
    flash[:payment_error] = error.to_hash

    # Redirect to appropriate setup page if action URL is available
    if error.primary_action_url.present?
      redirect_to error.primary_action_url, 
                  notice: "#{error.message} Click here to complete setup."
    else
      redirect_back(fallback_location: root_path)
    end
  end

  # Handles JSON responses for payment validation errors
  def handle_payment_error_json(error)
    render json: {
      success: false,
      error: error.to_hash,
      status: 'payment_validation_failed'
    }, status: :unprocessable_entity
  end

  # Handles Turbo Stream responses for payment validation errors
  def handle_payment_error_turbo_stream(error)
    render turbo_stream: [
      turbo_stream.replace('flash-messages', 
        partial: 'shared/payment_error_flash', 
        locals: { error: error }
      ),
      turbo_stream.update('form-publish-button', 
        partial: 'shared/payment_setup_required_button',
        locals: { error: error }
      )
    ]
  end

  # Checks if the current request is for payment-related functionality
  def payment_related_request?
    params[:controller]&.include?('payment') || 
    params[:action]&.include?('payment') ||
    request.path.include?('payment')
  end

  # Adds payment error context to flash messages
  def add_payment_error_context(error)
    flash[:payment_error_context] = {
      error_type: error.error_type,
      required_actions: error.required_actions,
      action_url: error.primary_action_url,
      action_text: error.primary_action_text
    }
  end

  # Renders payment setup guidance partial
  def render_payment_setup_guidance(error)
    render partial: 'shared/payment_setup_guidance', 
           locals: { 
             error: error,
             show_actions: true,
             context: controller_name
           }
  end
end
</file>

<file path="controllers/concerns/safe_pagination.rb">
# frozen_string_literal: true

# SafePagination provides resilient pagination that gracefully degrades
# when Kaminari is not available, preventing NoMethodError exceptions
module SafePagination
  extend ActiveSupport::Concern

  # Safely paginate an ActiveRecord relation with fallback support
  # 
  # @param relation [ActiveRecord::Relation] The relation to paginate
  # @param page [String, Integer, nil] The page number (defaults to 1)
  # @param per_page [Integer] Number of records per page (defaults to 20)
  # @return [ActiveRecord::Relation] Paginated relation with metadata methods
  def safe_paginate(relation, page: nil, per_page: 20)
    page_num = normalize_page_number(page)
    per_page = normalize_per_page(per_page)

    if kaminari_available?(relation)
      use_kaminari_pagination(relation, page_num, per_page)
    else
      use_fallback_pagination(relation, page_num, per_page)
    end
  end

  private

  # Check if Kaminari is available and the relation supports pagination
  def kaminari_available?(relation)
    defined?(Kaminari) && relation.respond_to?(:page)
  end

  # Use Kaminari for pagination (optimal path)
  def use_kaminari_pagination(relation, page, per_page)
    Rails.logger.debug "Using Kaminari pagination (page: #{page}, per_page: #{per_page})"
    relation.page(page).per(per_page)
  end

  # Use fallback pagination with LIMIT/OFFSET
  def use_fallback_pagination(relation, page, per_page)
    log_fallback_usage(page, per_page)
    
    offset = (page - 1) * per_page
    limited_relation = relation.limit(per_page).offset([offset, 0].max)
    
    add_pagination_metadata(limited_relation, relation, page, per_page)
  end

  # Add pagination metadata methods to the relation
  def add_pagination_metadata(limited_relation, original_relation, page, per_page)
    # Cache the total count to avoid multiple queries
    total_count = original_relation.count
    total_pages = (total_count.to_f / per_page).ceil
    
    # Add pagination methods to the relation instance
    limited_relation.define_singleton_method(:current_page) { page }
    limited_relation.define_singleton_method(:total_pages) { total_pages }
    limited_relation.define_singleton_method(:total_count) { total_count }
    limited_relation.define_singleton_method(:limit_value) { per_page }
    limited_relation.define_singleton_method(:total_entries) { total_count } # Alias for compatibility
    
    # Add navigation helper methods
    limited_relation.define_singleton_method(:next_page) do
      page < total_pages ? page + 1 : nil
    end
    
    limited_relation.define_singleton_method(:prev_page) do
      page > 1 ? page - 1 : nil
    end
    
    limited_relation.define_singleton_method(:first_page?) { page == 1 }
    limited_relation.define_singleton_method(:last_page?) { page >= total_pages }
    
    # Add range information
    limited_relation.define_singleton_method(:offset_value) { (page - 1) * per_page }
    limited_relation.define_singleton_method(:size) { limited_relation.to_a.size }
    
    limited_relation
  end

  # Normalize page number to ensure it's a positive integer
  def normalize_page_number(page)
    page_num = page.to_i
    page_num > 0 ? page_num : 1
  end

  # Normalize per_page to ensure it's within reasonable bounds
  def normalize_per_page(per_page)
    per_page = per_page.to_i
    
    # Ensure per_page is between 1 and 100 for performance
    case per_page
    when 0..1
      20 # Default
    when 2..100
      per_page
    else
      100 # Maximum
    end
  end

  # Log when fallback pagination is used for monitoring
  def log_fallback_usage(page, per_page)
    Rails.logger.warn "  Using fallback pagination - Kaminari not available (page: #{page}, per_page: #{per_page})"
    
    # Send to error tracking if available
    if defined?(Sentry)
      Sentry.capture_message(
        "Pagination fallback used",
        level: :warning,
        extra: {
          page: page,
          per_page: per_page,
          controller: self.class.name,
          action: action_name,
          kaminari_defined: defined?(Kaminari),
          timestamp: Time.current
        }
      )
    end
    
    # Increment metrics if available
    if defined?(StatsD)
      StatsD.increment('pagination.fallback_used')
    end
  end
end
</file>

<file path="controllers/forms/exports_controller.rb">
# frozen_string_literal: true

class Forms::ExportsController < ApplicationController
  before_action :authenticate_user!
  before_action :set_form
  before_action :ensure_premium_user
  before_action :ensure_google_connected
  
  def google_sheets
    if @form.form_responses.empty?
      return redirect_to form_responses_path(@form), 
                         alert: 'No responses available for export.'
    end
    
    result = GoogleSheets::ExportService.call(
      user: current_user,
      form: @form,
      options: export_options
    )
    
    if result.success?
      redirect_to form_responses_path(@form), 
                  notice: 'Export to Google Sheets has started. You will be notified when complete.'
    else
      redirect_to form_responses_path(@form), 
                  alert: "Export failed: #{result.errors.join(', ')}"
    end
  end
  
  def status
    export_job = current_user.export_jobs.find_by(job_id: params[:job_id])
    
    if export_job
      render json: {
        status: export_job.status,
        progress: export_job.progress_percentage,
        spreadsheet_url: export_job.spreadsheet_url,
        records_exported: export_job.records_exported,
        error_message: export_job.error_details&.dig('message')
      }
    else
      render json: { error: 'Export job not found' }, status: :not_found
    end
  end
  
  private
  
  def set_form
    @form = current_user.forms.find(params[:form_id])
  end
  
  def ensure_premium_user
    unless current_user.premium?
      redirect_to subscription_management_path, 
                  alert: 'Google Sheets export requires a Premium subscription.'
    end
  end
  
  def ensure_google_connected
    unless current_user.google_integration&.active?
      redirect_to google_integration_path, 
                  alert: 'Please connect your Google account first.'
    end
  end
  
  def export_options
    {
      include_metadata: params[:include_metadata] == '1',
      include_timestamps: params[:include_timestamps] == '1',
      include_dynamic_questions: params[:include_dynamic_questions] == '1',
      date_format: params[:date_format] || '%Y-%m-%d %H:%M:%S'
    }
  end
end
</file>

<file path="controllers/integrations/google_sheets_controller.rb">
class Integrations::GoogleSheetsController < ApplicationController
  before_action :authenticate_user!
  before_action :set_form
  before_action :validate_premium_access
  before_action :set_integration, only: [:show, :update, :destroy, :export, :toggle_auto_sync]

  def show
    authorize @integration, :show?
    
    render json: {
      integration: @integration,
      spreadsheet_url: @integration&.spreadsheet_url,
      last_sync: @integration&.last_sync_at,
      sync_count: @integration&.sync_count || 0,
      error_message: @integration&.error_message
    }
  end

  def create
    authorize @form, :create?
    
    @integration = @form.build_google_sheets_integration(integration_params)
    
    if params[:create_new_spreadsheet]
      service = Integrations::GoogleSheetsService.new(@form)
      result = service.create_spreadsheet(params[:spreadsheet_title])
      
      if result.success?
        @integration.spreadsheet_id = result.value[:spreadsheet_id]
      else
        render json: { error: result.error }, status: :unprocessable_entity
        return
      end
    end

    if @integration.save
      # Initial export if requested
      if params[:export_existing]
        GoogleSheetsSyncJob.perform_later(@form.id, 'export_all')
      end

      render json: {
        integration: @integration,
        spreadsheet_url: @integration.spreadsheet_url,
        message: 'Google Sheets integration configured successfully'
      }
    else
      render json: { errors: @integration.errors }, status: :unprocessable_entity
    end
  end

  def update
    authorize @integration, :update?
    
    if @integration.update(integration_params)
      render json: {
        integration: @integration,
        message: 'Integration updated successfully'
      }
    else
      render json: { errors: @integration.errors }, status: :unprocessable_entity
    end
  end

  def destroy
    authorize @integration, :destroy?
    
    @integration.destroy
    render json: { message: 'Google Sheets integration removed' }
  end

  def export
    authorize @integration, :export?
    
    unless @integration.can_sync?
      render json: { error: 'Integration is not active or properly configured' }, status: :unprocessable_entity
      return
    end

    GoogleSheetsSyncJob.perform_later(@form.id, 'export_all')
    
    render json: { 
      message: 'Export started. Your responses will be synced to Google Sheets shortly.',
      spreadsheet_url: @integration.spreadsheet_url
    }
  end

  def toggle_auto_sync
    authorize @integration, :toggle_auto_sync?
    
    @integration.update!(auto_sync: !@integration.auto_sync)
    
    render json: {
      auto_sync: @integration.auto_sync,
      message: @integration.auto_sync? ? 'Auto-sync enabled' : 'Auto-sync disabled'
    }
  end

  def test_connection
    authorize @form, :test_connection?
    
    service = Integrations::GoogleSheetsService.new(@form)
    
    begin
      # Try to create a test spreadsheet to verify credentials
      result = service.create_spreadsheet("Test - #{Time.current.to_i}")
      
      if result.success?
        render json: { 
          success: true, 
          message: 'Connection successful! Test spreadsheet created.',
          test_spreadsheet_url: "https://docs.google.com/spreadsheets/d/#{result.value[:spreadsheet_id]}/edit"
        }
      else
        render json: { success: false, error: result.error }
      end
    rescue => e
      render json: { success: false, error: "Connection failed: #{e.message}" }
    end
  end

  private

  def set_form
    @form = current_user.forms.find(params[:form_id])
  end

  def validate_premium_access
    unless current_user.can_use_google_sheets?
      render json: { 
        error: 'Premium subscription required',
        message: 'Google Sheets integration requires a Premium subscription',
        upgrade_url: subscription_management_path,
        required_plan: 'Premium'
      }, status: :forbidden
      return
    end
  end

  def set_integration
    @integration = @form.google_sheets_integration
    
    unless @integration
      render json: { error: 'No Google Sheets integration found' }, status: :not_found
    end
  end

  def integration_params
    params.require(:google_sheets_integration).permit(
      :spreadsheet_id, 
      :sheet_name, 
      :auto_sync,
      field_mapping: {}
    )
  end
end
</file>

<file path="controllers/users/registrations_controller.rb">
# frozen_string_literal: true

class Users::RegistrationsController < Devise::RegistrationsController

  def update_resource(resource, params)
    resource.update_without_password(params)
  end
end
</file>

<file path="controllers/users/sessions_controller.rb">
class Users::SessionsController < Devise::SessionsController
  # Handle CSRF more gracefully
  protect_from_forgery with: :null_session, only: [:create]
  before_action :configure_sign_in_params, only: [:create]
  
  def new
    # Ensure we have a fresh CSRF token
    self.response.headers['Cache-Control'] = 'no-cache, no-store, max-age=0, must-revalidate'
    super
  end
  
  def create
    Rails.logger.info "Processing sign in for: #{params.dig(:user, :email)}"
    Rails.logger.info "CSRF token present: #{params[:authenticity_token].present?}"
    
    super do |resource|
      if resource.persisted?
        Rails.logger.info "User #{resource.email} signed in successfully"
      else
        Rails.logger.warn "Sign in failed for: #{params.dig(:user, :email)}"
      end
    end
  end
  
  protected
  
  def after_sign_in_path_for(resource)
    stored_location_for(resource) || root_path
  end
  
  def after_sign_out_path_for(resource_or_scope)
    new_user_session_path
  end
  
  private
  
  def configure_sign_in_params
    devise_parameter_sanitizer.permit(:sign_in, keys: [:email, :password, :remember_me])
  end
end
</file>

<file path="controllers/analytics_controller.rb">
class AnalyticsController < ApplicationController
  before_action :authenticate_user!
  
  # Skip Pundit authorization for this controller
  skip_after_action :verify_authorized
  skip_after_action :verify_policy_scoped

  # POST /analytics/payment_setup
  def payment_setup
    event_data = params.require(:event).permit(
      :has_payment_questions,
      :stripe_configured,
      :is_premium,
      :event_type,
      :timestamp,
      :action,
      required_features: []
    )

    # Log the event (in a real app, this would go to an analytics service)
    Rails.logger.info "Payment Setup Event: #{event_data.to_h}"

    # You could also store this in a database table for analytics
    # AnalyticsEvent.create!(
    #   user: current_user,
    #   event_type: 'payment_setup_interaction',
    #   event_data: event_data.to_h
    # )

    render json: { success: true }
  rescue ActionController::ParameterMissing => e
    render json: {
      success: false,
      error: "Missing required parameter: #{e.param}"
    }, status: :bad_request
  rescue StandardError => e
    render json: {
      success: false,
      error: e.message
    }, status: :internal_server_error
  end

  # POST /analytics/payment_errors
  def payment_errors
    event_data = params.require(:event).permit(
      :error_type,
      :event_type,
      :timestamp,
      :action,
      required_actions: []
    )

    # Log the error event
    Rails.logger.info "Payment Error Event: #{event_data.to_h}"

    render json: { success: true }
  rescue ActionController::ParameterMissing => e
    render json: {
      success: false,
      error: "Missing required parameter: #{e.param}"
    }, status: :bad_request
  rescue StandardError => e
    render json: {
      success: false,
      error: e.message
    }, status: :internal_server_error
  end
end
</file>

<file path="controllers/application_controller.rb">
class ApplicationController < ActionController::Base
  # Only allow modern browsers supporting webp images, web push, badges, import maps, CSS nesting, and CSS :has.
  allow_browser versions: :modern

  # Pundit authorization
  include Pundit::Authorization
  
  # Payment validation error handling
  include PaymentErrorHandling

  # CSRF protection with custom handling
  protect_from_forgery with: :exception
  
  # Devise authentication
  before_action :authenticate_user!
  before_action :configure_permitted_parameters, if: :devise_controller?
  after_action :set_current_user
  
  # Nueva verificacin del estado del trial - only for trial expiration
  before_action :check_trial_status, unless: -> { controller_name == 'billings' || controller_name == 'sessions' || controller_name == 'registrations' }

  # Global rescue handlers
  rescue_from ActiveRecord::RecordNotFound, with: :render_not_found
  rescue_from Pundit::NotAuthorizedError, with: :render_unauthorized
  rescue_from ActionController::ParameterMissing, with: :render_bad_request
  rescue_from ActiveRecord::RecordInvalid, with: :render_unprocessable_entity
  rescue_from ActionController::InvalidAuthenticityToken, with: :handle_csrf_failure

  # SuperAgent specific error handling (conditional on SuperAgent being loaded)
  if defined?(SuperAgent)
    rescue_from SuperAgent::WorkflowError, with: :render_workflow_error
    rescue_from SuperAgent::TaskError, with: :render_workflow_error
  end
  
  # Fixed: Check if the specific error classes exist before rescuing from them
  if defined?(SuperAgent::A2A) && defined?(SuperAgent::A2A::TimeoutError)
    rescue_from SuperAgent::A2A::TimeoutError, with: :render_timeout_error
  end
  
  if defined?(SuperAgent::A2A) && defined?(SuperAgent::A2A::NetworkError)
    rescue_from SuperAgent::A2A::NetworkError, with: :render_network_error
  end
  
  if defined?(SuperAgent::A2A) && defined?(SuperAgent::A2A::AuthenticationError)
    rescue_from SuperAgent::A2A::AuthenticationError, with: :render_unauthorized
  end

  # Global callbacks
  after_action :verify_authorized, except: [:index, :show], unless: :skip_authorization?
  after_action :verify_policy_scoped, only: [:index], unless: :skip_authorization?

  protected

  # Devise parameter configuration
  def configure_permitted_parameters
    devise_parameter_sanitizer.permit(:sign_up, keys: [:first_name, :last_name])
    devise_parameter_sanitizer.permit(:account_update, keys: [:first_name, :last_name, :preferences, :ai_settings])
  end

  # Current user helper for Pundit
  def pundit_user
    current_user
  end

  # Skip authorization for certain controllers
  def skip_authorization?
    devise_controller? || 
    controller_name == 'home' ||
    controller_name == 'health' ||
    controller_name == 'landing' ||
    controller_name == 'billings' ||
    action_name == 'public_form'
  end

  # Skip policy scoping for controllers that don't need it
  def should_verify_policy_scoped?
    false # Temporarily disable policy scoping verification
  end

  # CSRF failure handler
  def handle_csrf_failure(exception = nil)
    log_error(exception) if exception
    
    # Log CSRF failure for security monitoring
    AuditLog.create!(
      user: current_user,
      event_type: 'csrf_failure',
      details: {
        path: request.path,
        method: request.method,
        user_agent: request.user_agent,
        referer: request.referer,
        controller: controller_name,
        action: action_name
      },
      ip_address: request.remote_ip
    )
    
    # If user is trying to sign in and CSRF fails, redirect to fresh login page
    if request.path == new_user_session_path || request.path == user_session_path
      reset_session
      flash[:alert] = "Your session has expired. Please sign in again."
      redirect_to new_user_session_path
      return
    end
    
    respond_to do |format|
      format.html do
        if user_signed_in?
          flash[:alert] = "Security verification failed. Please try again."
          redirect_back(fallback_location: root_path)
        else
          reset_session
          flash[:alert] = "Your session has expired. Please sign in again."
          redirect_to new_user_session_path
        end
      end
      format.json do
        render json: { 
          error: "Invalid security token",
          message: "Please refresh the page and try again"
        }, status: :unprocessable_entity
      end
    end
  end

  # Error handling methods
  def render_not_found(exception = nil)
    log_error(exception) if exception
    
    respond_to do |format|
      format.html { render 'errors/404', status: :not_found, layout: 'error' }
      format.json { render json: { error: 'Resource not found' }, status: :not_found }
      format.any { head :not_found }
    end
  end

  def render_unauthorized(exception = nil)
    log_error(exception) if exception
    
    respond_to do |format|
      format.html { 
        flash[:alert] = 'You are not authorized to perform this action.'
        redirect_back(fallback_location: root_path)
      }
      format.json { render json: { error: 'Unauthorized' }, status: :unauthorized }
      format.any { head :unauthorized }
    end
  end

  def render_bad_request(exception = nil)
    log_error(exception) if exception
    
    respond_to do |format|
      format.html { 
        flash[:alert] = 'Invalid request parameters.'
        redirect_back(fallback_location: root_path)
      }
      format.json { render json: { error: 'Bad request', details: exception&.message }, status: :bad_request }
      format.any { head :bad_request }
    end
  end

  def render_unprocessable_entity(exception = nil)
    log_error(exception) if exception
    
    respond_to do |format|
      format.html { 
        flash[:alert] = 'There was an error processing your request.'
        redirect_back(fallback_location: root_path)
      }
      format.json { 
        render json: { 
          error: 'Unprocessable entity', 
          details: exception&.record&.errors&.full_messages || exception&.message 
        }, status: :unprocessable_entity 
      }
      format.any { head :unprocessable_entity }
    end
  end

  def render_workflow_error(exception = nil)
    log_error(exception) if exception
    
    respond_to do |format|
      format.html { 
        flash[:alert] = 'There was an error processing your workflow. Please try again.'
        redirect_back(fallback_location: root_path)
      }
      format.json { 
        render json: { 
          error: 'Workflow error', 
          details: exception&.message,
          workflow_id: exception&.workflow_id
        }, status: :unprocessable_entity 
      }
      format.any { head :unprocessable_entity }
    end
  end

  def render_timeout_error(exception = nil)
    log_error(exception) if exception
    
    respond_to do |format|
      format.html { 
        flash[:alert] = 'The request timed out. Please try again.'
        redirect_back(fallback_location: root_path)
      }
      format.json { 
        render json: { 
          error: 'Request timeout', 
          details: 'The operation took too long to complete'
        }, status: :request_timeout 
      }
      format.any { head :request_timeout }
    end
  end

  def render_network_error(exception = nil)
    log_error(exception) if exception
    
    respond_to do |format|
      format.html { 
        flash[:alert] = 'There was a network error. Please check your connection and try again.'
        redirect_back(fallback_location: root_path)
      }
      format.json { 
        render json: { 
          error: 'Network error', 
          details: exception&.message || 'Unable to connect to external service'
        }, status: :service_unavailable 
      }
      format.any { head :service_unavailable }
    end
  end

  private

  # --- NUEVO MTODO DE VERIFICACIN ---
  def check_trial_status
    return unless user_signed_in?
    return if current_user.superadmin?
    
    # Allow basic and premium users regardless of trial status
    return if ['basic', 'premium'].include?(current_user.subscription_tier)
    
    # Only check trial expiration for non-premium users
    return unless current_user.trial_expires_at.present? && current_user.trial_expired?
    
    redirect_to billing_path, alert: "Tu prueba gratuita de 14 das ha terminado. Por favor, elige un plan para continuar."
  end

  # Centralized error logging
  def log_error(exception)
    Rails.logger.error "#{exception.class}: #{exception.message}"
    Rails.logger.error exception.backtrace.join("\n") if exception.backtrace
    
    # Report to Sentry if configured
    if defined?(Sentry)
      Sentry.capture_exception(exception, extra: {
        user_id: current_user&.id,
        controller: controller_name,
        action: action_name,
        params: params.except(:password, :password_confirmation, :current_password).to_unsafe_h
      })
    end
  end

  # Helper method to check if user is admin
  def require_admin!
    render_unauthorized unless current_user&.admin?
  end

  # Helper method to check if user is premium or admin
  def require_premium!
    render_unauthorized unless current_user&.premium? || current_user&.admin?
  end

  # Set current user and request context for tracking purposes - MOVED TO AFTER_ACTION
  def set_current_user
    # Only set Current if user is authenticated to avoid interfering with Devise
    if user_signed_in?
      Current.user = current_user
      Current.request_id = request.uuid
      Current.user_agent = request.user_agent
      Current.ip_address = request.remote_ip
    end
  rescue => e
    # Log error but don't let it break the request
    Rails.logger.error "Error setting current user: #{e.message}"
  end
end
</file>

<file path="controllers/billings_controller.rb">
# frozen_string_literal: true

class BillingsController < ApplicationController
  # Important! We skip our new check here to avoid a redirect loop.
  skip_before_action :check_trial_status, only: [:show, :create]

  # Shows the plans page for a user with expired trial.
  def show
    # Here you can load your plan details to display in the view.
  end

  # Creates a new checkout session so an existing user can subscribe.
  def create
    plan = params[:plan] # 'basic' o 'professional'
    price_id = case plan
               when 'basic'
                 Rails.application.credentials.stripe[:basic_plan_price_id] # You'll need to add this
               when 'professional'
                 Rails.application.credentials.stripe[:professional_plan_price_id] # You already have this as 'premium_plan_price_id'
               else
                 flash[:alert] = "Invalid plan."
                 return redirect_to billing_path
               end

    checkout_session = Stripe::Checkout::Session.create({
      customer: current_user.stripe_customer_id, # Use the customer_id if it already exists
      payment_method_types: ['card'],
      line_items: [{ price: price_id, quantity: 1 }],
      mode: 'subscription',
      success_url: root_url, # Redirect to dashboard after successful payment
      cancel_url: billing_url,
      metadata: {
        user_id: current_user.id
      }
    })
    
    redirect_to checkout_session.url, allow_other_host: true, status: :see_other
  rescue Stripe::StripeError => e
    flash[:alert] = "There was an error with the payment: #{e.message}"
    redirect_to billing_path
  end
end
</file>

<file path="controllers/blogs_controller.rb">
class BlogsController < ApplicationController
  skip_before_action :authenticate_user!, only: [:index, :show]
  skip_after_action :verify_policy_scoped, only: [:index, :show], unless: :skip_authorization?
  skip_after_action :verify_authorized, only: [:index, :show], unless: :skip_authorization?
  
  def index
    @articles = [
      {
        id: 1,
        title: "How to Create Marketing Forms That Actually Convert",
        slug: "formularios-marketing-conversion",
        description: "Learn strategies and best practices for creating marketing forms that generate quality leads.",
        category: "Marketing",
        read_time: "6 min",
        author: "AgentForm Team",
        date: Date.current,
        content: content_marketing_forms
      },
      {
        id: 2,
        title: "Market Research: Forms That Reveal Valuable Insights",
        slug: "investigacion-mercados-formularios",
        description: "Discover how to design effective forms for collecting market data and better understanding your audience.",
        category: "Research",
        read_time: "8 min",
        author: "AgentForm Team",
        date: Date.current - 1.day,
        content: content_research_forms
      },
      {
        id: 3,
        title: "The 7 Essential Elements of Successful Forms",
        slug: "elementos-formulario-exitoso",
        description: "Conoce los componentes clave que todo formulario exitoso debe tener para maximizar las respuestas.",
        category: "Mejores Prcticas",
        read_time: "5 min",
        author: "AgentForm Team",
        date: Date.current - 2.days,
        content: content_essential_elements
      },
      {
        id: 4,
        title: "Formularios de Feedback: Cmo Medir la Satisfaccin del Cliente",
        slug: "formularios-feedback-satisfaccion",
        description: "Gua completa para crear formularios de feedback que te ayuden a mejorar tu producto o servicio.",
        category: "Feedback",
        read_time: "7 min",
        author: "AgentForm Team",
        date: Date.current - 3.days,
        content: content_feedback_forms
      },
      {
        id: 5,
        title: "Technical Guide to Creating Effective Surveys with AgentForm",
        slug: "technical-guide-creating-effective-surveys-agentform",
        description: "Comprehensive technical guide for designing, implementing, and analyzing surveys using AgentForm platform.",
        category: "Technical Guide",
        read_time: "12 min",
        author: "AgentForm Team",
        date: Date.current - 4.days,
        content: content_technical_surveys
      }
    ]
  end
  
  def show
    @article = [
      {
        id: 1,
        title: "How to Create Marketing Forms That Actually Convert",
        slug: "formularios-marketing-conversion",
        description: "Learn strategies and best practices for creating marketing forms that generate quality leads.",
        category: "Marketing",
        read_time: "6 min",
        author: "AgentForm Team",
        date: Date.current,
        content: content_marketing_forms
      },
      {
        id: 2,
        title: "Market Research: Forms That Reveal Valuable Insights",
        slug: "investigacion-mercados-formularios",
        description: "Discover how to design effective forms for collecting market data and better understanding your audience.",
        category: "Research",
        read_time: "8 min",
        author: "AgentForm Team",
        date: Date.current - 1.day,
        content: content_research_forms
      },
      {
        id: 3,
        title: "The 7 Essential Elements of Successful Forms",
        slug: "elementos-formulario-exitoso",
        description: "Conoce los componentes clave que todo formulario exitoso debe tener para maximizar las respuestas.",
        category: "Mejores Prcticas",
        read_time: "5 min",
        author: "AgentForm Team",
        date: Date.current - 2.days,
        content: content_essential_elements
      },
      {
        id: 4,
        title: "Formularios de Feedback: Cmo Medir la Satisfaccin del Cliente",
        slug: "formularios-feedback-satisfaccion",
        description: "Gua completa para crear formularios de feedback que te ayuden a mejorar tu producto o servicio.",
        category: "Feedback",
        read_time: "7 min",
        author: "AgentForm Team",
        date: Date.current - 3.days,
        content: content_feedback_forms
      },
      {
        id: 5,
        title: "Technical Guide to Creating Effective Surveys with AgentForm",
        slug: "technical-guide-creating-effective-surveys-agentform",
        description: "Comprehensive technical guide for designing, implementing, and analyzing surveys using AgentForm platform.",
        category: "Technical Guide",
        read_time: "12 min",
        author: "AgentForm Team",
        date: Date.current - 4.days,
        content: content_technical_surveys
      }
    ].find { |article| article[:slug] == params[:id] }
    
    redirect_to blogs_path, alert: "Article not found" unless @article
  end
  
  private
  
  def content_marketing_forms
    {
      introduction: "Marketing forms are powerful tools for capturing leads and converting visitors into potential customers. However, many forms fail in their main objective.",
      sections: [
        {
          title: "1. Define Your Objective Clearly",
          content: "Before creating your form, identify exactly what information you need to collect. Is it for a newsletter? For demos? For content downloads?"
        },
        {
          title: "2. Keep It Simple and Concise",
          content: "Each additional field reduces conversions. Only ask for essential information: name, email, and maybe company."
        },
        {
          title: "3. Use Smart Fields",
          content: "Implement conditional fields that only appear when relevant. This improves the experience and increases completion rates."
        },
        {
          title: "4. Provide Immediate Value",
          content: "Clearly explain what the user will get by completing the form: exclusive access, premium content, or free consultation."
        },
        {
          title: "5. Optimize for Mobile",
          content: "Over 60% of forms are completed on mobile devices. Make sure your form is fully responsive."
        }
      ],
      tips: [
        "Use descriptive placeholders instead of long labels",
        "Add real-time validation to avoid frustration",
        "Include a clear confirmation message after submission",
        "Test different versions with A/B testing"
      ]
    }
  end
  
  def content_research_forms
    {
      introduction: "Market research forms are fundamental for understanding your audience's needs, preferences, and behaviors.",
      sections: [
        {
          title: "1. Segment Your Audience",
          content: "Create specific forms for different segments. Questions for B2C consumers should be different from B2B questions."
        },
        {
          title: "2. Structure Your Research",
          content: "Divide your form into clear sections: demographic information, behavior, preferences, and specific feedback."
        },
        {
          title: "3. Use Response Scales",
          content: "Implement Likert scales (1-5) to measure attitudes and preferences quantitatively."
        },
        {
          title: "4. Include Open Questions",
          content: "Open-ended questions provide valuable qualitative insights you wouldn't get with closed options."
        },
        {
          title: "5. Incentivize Participation",
          content: "Offer incentives like discounts, exclusive access, or raffles to increase response rates."
        }
      ],
      tips: [
        "Keep the form between 5-10 minutes duration",
        "Test your form with a small group first",
        "Ensure compliance with privacy regulations",
        "Analyze data in real-time to adjust questions"
      ]
    }
  end
  
  def content_essential_elements
    {
      introduction: "A successful form combines design, functionality, and user psychology to maximize responses.",
      elements: [
        {
          name: "Attractive Title",
          description: "A clear and persuasive title that indicates exactly what to expect from the form."
        },
        {
          name: "Clear Instructions",
          description: "Brief explanation of why information is being collected and how it will be used."
        },
        {
          name: "Clean Visual Design",
          description: "Proper spacing, consistent colors, and readable typography."
        },
        {
          name: "Relevant Fields",
          description: "Only essential questions that provide real value to the process."
        },
        {
          name: "Smart Validation",
          description: "Friendly error messages and real-time validation."
        },
        {
          name: "Visible Progress",
          description: "Progress indicators for long forms."
        },
        {
          name: "Compelling CTA",
          description: "Clear and persuasive submit button with specific text."
        }
      ]
    }
  end
  
  def content_feedback_forms
    {
      introduction: "Feedback forms are essential tools for continuously improving your product or service.",
      sections: [
        {
          title: "1. Define the Purpose of Feedback",
          content: "Are you looking to improve a specific product, evaluate customer service, or measure overall satisfaction?"
        },
        {
          title: "2. Use Satisfaction Scales",
          content: "Implement 1-5 or 1-10 scales to measure satisfaction quantitatively."
        },
        {
          title: "3. Questions about Specific Experience",
          content: "Ask about concrete aspects: ease of use, product quality, response time."
        },
        {
          title: "4. Close with Action",
          content: "Ask if they would recommend your product and if they'd like to be contacted for more information."
        }
      ],
      questions: [
        "How satisfied are you with our product/service?",
        "What feature did you like the most?",
        "What would you improve?",
        "How likely are you to recommend our product?",
        "Would you like us to contact you?"
      ]
    }
  end
  
  def content_technical_surveys
    {
      introduction: "In today's dynamic business and organizational environment, the ability to understand consumers, employees, and the market as a whole is crucial for success. Surveys are a fundamental market research tool that allows collecting data from various aspects for subsequent interpretation and strategic decision-making. Whether it's to understand purchase intentions, evaluate job satisfaction, or understand customer preferences, a well-designed survey using AgentForm is an invaluable compass.",
      sections: [
        {
          title: "1. Planning and Survey Design (General Principles)",
          content: "The effectiveness of a survey lies in its planning, development, and direction. With AgentForm, you can implement these principles efficiently."
        },
        {
          title: "1.1 Decide if a Survey is the Right Tool",
          content: "Before starting, evaluate whether a survey is the most appropriate method for your situation. AgentForm provides templates to help you determine the best approach. Advantages include precision (5% margin of error), classification capabilities, valuable conclusions, easy result management, and immediate reception. Disadvantages include cost, expertise requirements, limited information, selection bias, potential errors, and fraud vulnerability."
        },
        {
          title: "1.2 Define Research Objectives",
          content: "This is the first and most crucial step. AgentForm's guided setup helps you formulate research problems correctly. Establish clear objectives using SMART framework (Specific, Measurable, Achievable, Relevant, Time-based). Analyze the situation including macro-environment, competition, and consumer profile."
        },
        {
          title: "1.3 Define Universe and Sample",
          content: "AgentForm's audience targeting features help you define representative samples. Universe is the total population for survey conclusions. Sample size can be estimated using built-in statistical tools, balancing cost with confidence level and expected error rate. For category classification, minimum sample should be 30 per category."
        },
        {
          title: "1.4 Questionnaire Design",
          content: "AgentForm's form builder provides templates for effective questionnaires. Scope your information needs, establish question order to avoid bias, use appropriate question types (closed for quantitative data, open for detailed insights), keep surveys short (under 30 questions), ensure clarity and neutrality, optimize for mobile, conduct pilot testing, guarantee confidentiality, and run awareness campaigns."
        },
        {
          title: "2. Segmentation for Effective Surveys",
          content: "AgentForm's advanced targeting features enable precise segmentation. Segmentation is creating subsets based on demographics, needs, priorities, common interests, and behavioral criteria. Benefits include reduced marketing costs, greater attention, better product development, and more satisfied customers."
        },
        {
          title: "2.1 Types of Segmentation",
          content: "Demographic (age, gender, income), Geographic (location-based), Behavioral (purchase habits, brand loyalty), Psychographic (attitudes, values, interests), Firmographic (B2B industry, size), and Technographic (technology usage). AgentForm allows you to implement all these segmentation types through custom fields and conditional logic."
        },
        {
          title: "2.2 Segmentation Mistakes to Avoid",
          content: "Avoid segmenting based on instincts rather than concrete data, using limited data, using 'dirty data', ignoring communication channels, not considering engagement timing, and not tracking segment performance over time. AgentForm's analytics help you avoid these pitfalls."
        },
        {
          title: "3. Survey Types and Specific Applications",
          content: "Different types of market research with distinct purposes that can be implemented using AgentForm."
        },
        {
          title: "3.1 Market Research Surveys",
          content: "AgentForm excels at market research helping understand purchase intentions, market growth, price estimation, and consumer behavior. Objectives include administrative (planning), social (customer needs), and economic (business success). Types include exploratory, descriptive, and explanatory research."
        },
        {
          title: "3.2 Customer Satisfaction Surveys (CX)",
          content: "AgentForm provides built-in NPS, CES, and satisfaction metrics. Essential metrics include Net Promoter Score (NPS), Customer Satisfaction Index, Customer Effort Score, Customer Health Score, churn rate, and customer reviews. AgentForm automatically calculates these metrics from your survey responses."
        },
        {
          title: "3.3 Employee Satisfaction Surveys (EX)",
          content: "AgentForm offers specialized templates for employee satisfaction including eNPS, ESI, happiness scales, pulse surveys, and 360-degree evaluations. Features include confidentiality controls, real-time reporting, and action plan creation based on results."
        },
        {
          title: "4. Data Collection and Analysis",
          content: "AgentForm's integrated analytics transform raw data into actionable insights. Define needed information before choosing methods. Collection methods include online surveys (AgentForm's primary strength), interviews, and observation. Data sources include sales data, web analytics, email marketing, CRM integration, and social media analytics."
        },
        {
          title: "4.1 Data Processing and Analysis",
          content: "AgentForm automatically processes and analyzes your survey data. Features include data cleaning, quantitative analysis with statistics, qualitative analysis of open responses, integration with statistical software, identification of improvement areas, and creation of SMART action plans."
        },
        {
          title: "5. Results Interpretation and Presentation",
          content: "AgentForm's reporting features help you interpret data and present results clearly. Generate reports and presentations highlighting key findings, use data visualization with charts and graphs, apply storytelling techniques, contextualize results with business objectives, and ensure follow-up with personalized action plans."
        },
        {
          title: "6. Recommended Tools and Integration",
          content: "AgentForm integrates with leading tools for comprehensive survey solutions. Recommended integrations include Google Analytics for user segmentation, CRM systems for customer data, email marketing platforms for distribution, and data visualization tools for advanced reporting. AgentForm serves as the central hub for all survey activities."
        }
      ],
      elements: [
        {
          name: "Smart Question Design",
          description: "Use AgentForm's AI-powered question suggestions to create effective, unbiased questions that yield actionable insights."
        },
        {
          name: "Mobile-First Approach",
          description: "AgentForm automatically optimizes all surveys for mobile devices, ensuring high completion rates across all platforms."
        },
        {
          name: "Real-Time Analytics",
          description: "Monitor responses as they come in with AgentForm's live dashboard, allowing immediate insights and quick adjustments."
        },
        {
          name: "Advanced Segmentation",
          description: "Leverage AgentForm's conditional logic and custom fields to create highly targeted surveys for specific audience segments."
        },
        {
          name: "Integration Capabilities",
          description: "Connect AgentForm with your existing tools through webhooks, API, and native integrations for seamless data flow."
        },
        {
          name: "Privacy and Security",
          description: "Ensure data protection with AgentForm's built-in privacy controls, GDPR compliance, and secure data handling."
        },
        {
          name: "Automated Follow-up",
          description: "Set up automated thank you messages, follow-up surveys, and action triggers based on responses using AgentForm workflows."
        }
      ],
      questions: [
        "How can AgentForm help reduce survey bias and improve data quality?",
        "What segmentation strategies work best with AgentForm's targeting features?",
        "How do I integrate AgentForm survey data with my existing CRM system?",
        "What are the best practices for mobile survey design using AgentForm?",
        "How can I use AgentForm's analytics to create actionable business insights?",
        "What privacy considerations should I implement when using AgentForm for sensitive surveys?"
      ],
      tips: [
        "Start with AgentForm's pre-built templates and customize them for your specific needs",
        "Use AgentForm's A/B testing features to optimize question wording and survey flow",
        "Implement progressive profiling with AgentForm to build customer profiles over time",
        "Leverage AgentForm's branching logic to create personalized survey experiences",
        "Set up automated reporting in AgentForm to share insights with stakeholders regularly",
        "Use AgentForm's collaboration features to involve team members in survey design and analysis"
      ]
    }
  end
end
</file>

<file path="controllers/dynamic_questions_controller.rb">
class DynamicQuestionsController < ApplicationController
  skip_before_action :authenticate_user!, raise: false
  skip_before_action :verify_authenticity_token
  skip_after_action :verify_authorized, unless: :skip_authorization?
  skip_after_action :verify_policy_scoped, unless: :skip_authorization?

  def answer
    Rails.logger.info "=== Procesando respuesta de pregunta dinmica ==="
    
    # Find form by share token
    form = Form.find_by!(share_token: params[:share_token])
    
    # Find the form response
    form_response = form.form_responses.find_by!(session_id: current_session_id)
    
    # Find the dynamic question
    dynamic_question = form_response.dynamic_questions.find(params[:id])
    
    answer_value = params.require(:answer).permit(:value)[:value]
    
    Rails.logger.info "Question ID: #{dynamic_question.id}"
    Rails.logger.info "Answer: '#{answer_value}'"

    if answer_value.present?
      # Update the dynamic question with the answer
      update_attributes = { 
        answer_data: { 
          value: answer_value,
          submitted_at: Time.current.iso8601
        }
      }
      
      # Add answered_at if the column exists
      if dynamic_question.respond_to?(:answered_at=)
        update_attributes[:answered_at] = Time.current
      end
      
      dynamic_question.update!(update_attributes)
      
      Rails.logger.info " Respuesta guardada exitosamente"
      
      # Create a visual success message and remove the form
      success_html = render_to_string(
        partial: 'responses/dynamic_question_success',
        locals: {
          dynamic_question: dynamic_question,
          answer_value: answer_value
        }
      )
      
      # Update the UI via Turbo Stream
      Turbo::StreamsChannel.broadcast_replace_to(
        form_response,
        target: "dynamic_question_#{dynamic_question.id}",
        html: success_html
      )
      
      # Store the dynamic question response for later access
      store_dynamic_response_in_session(dynamic_question, answer_value)
      
      respond_to do |format|
        format.turbo_stream do
          # This will automatically replace the target with the success partial
          render turbo_stream: turbo_stream.replace(
            "dynamic_question_#{dynamic_question.id}",
            partial: 'responses/dynamic_question_success',
            locals: { dynamic_question: dynamic_question, answer_value: answer_value }
          )
        end
        format.json do
          render json: { 
            success: true, 
            message: "Gracias por tu respuesta!",
            question_id: dynamic_question.id,
            ui_updated: true
          }
        end
      end
    else
      respond_to do |format|
        format.turbo_stream do
          render turbo_stream: turbo_stream.replace(
            "dynamic_question_#{dynamic_question.id}",
            partial: 'responses/dynamic_question_error',
            locals: { dynamic_question: dynamic_question, errors: ["La respuesta no puede estar vaca"] }
          )
        end
        format.json do
          render json: { 
            success: false, 
            errors: ["La respuesta no puede estar vaca"] 
          }, status: :unprocessable_content
        end
      end
    end
    
  rescue ActiveRecord::RecordNotFound => e
    Rails.logger.error "Dynamic question not found: #{e.message}"
    respond_to do |format|
      format.turbo_stream do
        render turbo_stream: turbo_stream.replace(
          "dynamic_question_#{params[:id]}",
          partial: 'responses/dynamic_question_error',
          locals: { errors: ["Pregunta no encontrada"] }
        )
      end
      format.json do
        render json: { 
          success: false, 
          errors: ["Pregunta no encontrada"] 
        }, status: :not_found
      end
    end
    
  rescue => e
    Rails.logger.error "Error guardando respuesta de pregunta dinmica: #{e.message}"
    respond_to do |format|
      format.turbo_stream do
        render turbo_stream: turbo_stream.replace(
          "dynamic_question_#{params[:id]}",
          partial: 'responses/dynamic_question_error',
          locals: { errors: ["Ocurri un error al guardar tu respuesta"] }
        )
      end
      format.json do
        render json: { 
          success: false, 
          errors: ["Ocurri un error al guardar tu respuesta"] 
        }, status: :unprocessable_content
      end
    end
  end

  private

  def current_session_id
    session[:form_session_id] || 
    request.headers['X-Session-Id'] ||
    cookies[:form_session_id]
  end

  def store_dynamic_response_in_session(dynamic_question, answer_value)
    # Store the dynamic question response so it can be accessed later
    session[:dynamic_responses] ||= {}
    session[:dynamic_responses][dynamic_question.id] = {
      question_title: dynamic_question.title,
      answer: answer_value,
      answered_at: Time.current.iso8601,
      trigger: dynamic_question.generation_context['trigger']
    }
    
    Rails.logger.info "Respuesta dinmica guardada en sesin"
  end

  def skip_authorization?
    true
  end
end
</file>

<file path="controllers/form_questions_controller.rb">
# frozen_string_literal: true

class FormQuestionsController < ApplicationController
  before_action :set_form
  before_action :set_question, only: [:show, :edit, :update, :destroy, :move_up, :move_down, :duplicate, :ai_enhance, :preview, :analytics]
  before_action :authorize_form_access
  before_action :authorize_question_access, only: [:show, :edit, :update, :destroy, :move_up, :move_down, :duplicate, :ai_enhance, :preview, :analytics]

  # GET /forms/:form_id/questions
  def index
    @questions = policy_scope(@form.form_questions)
                      .includes(:question_responses)
                      .order(:position)
    
    respond_to do |format|
      format.html
      format.json { render json: @questions }
    end
  end

  # Add this to your form_questions_controller.rb create method

def create
  @question = @form.form_questions.build(question_params)
  @question.position = @form.next_question_position if @question.position.blank?

  # Check if user can create payment questions
  if @question.question_type == 'payment' && !current_user.can_accept_payments?
    respond_to do |format|
      format.html { 
        redirect_to edit_form_path(@form), 
        alert: 'Payment questions are only available for Premium users. Please upgrade your account to accept payments.' 
      }
      format.json { 
        render json: { 
          error: 'Payment questions require Premium subscription',
          upgrade_required: true 
        }, status: :forbidden 
      }
    end
    return
  end

  if @question.save
    handle_form_structure_change

    respond_to do |format|
      format.html { redirect_to edit_form_path(@form), notice: 'Question was successfully created.' }
      format.json { render json: @question, status: :created }
    end
  else
    @question_types = FormQuestion::QUESTION_TYPES
    @ai_features = %w[smart_validation response_analysis dynamic_followup]
    
    respond_to do |format|
      format.html { render :new, status: :unprocessable_entity }
      format.json { render json: { errors: @question.errors.full_messages }, status: :unprocessable_entity }
    end
  end
end

  # GET /forms/:form_id/questions/:id
  def show
    @question_analytics = @question.analytics_summary(30.days)
    @recent_responses = @question.question_responses
                                 .includes(:form_response)
                                 .order(created_at: :desc)
                                 .limit(10)

    respond_to do |format|
      format.html
      format.json { render json: @question, include: [:question_responses] }
    end
  end

  # GET /forms/:form_id/questions/new
  def new
    @question = @form.form_questions.build
    @question.position = @form.next_question_position
    @question_types = FormQuestion::QUESTION_TYPES
    @ai_features = %w[smart_validation response_analysis dynamic_followup]
  end

  # POST /forms/:form_id/questions


  # GET /forms/:form_id/questions/:id/edit
  def edit
    @question_types = FormQuestion::QUESTION_TYPES
    @ai_features = %w[smart_validation response_analysis dynamic_followup]
    
    # Mejora: preparar preguntas con contexto enriquecido
    prepare_conditional_questions
    generate_conditional_suggestions
  end

  # PATCH/PUT /forms/:form_id/questions/:id
def update
  old_config = @question.question_config.dup if @question.question_config
  old_ai_config = @question.ai_config.dup if @question.ai_config

  # Check if user is trying to change to payment type and doesn't have premium
  if question_params[:question_type] == 'payment' && 
     @question.question_type != 'payment' && 
     !current_user.can_accept_payments?
    
    respond_to do |format|
      format.html { 
        redirect_to edit_form_path(@form), 
        alert: 'Payment questions are only available for Premium users. Please upgrade your account to accept payments.' 
      }
      format.json { 
        render json: { 
          error: 'Payment questions require Premium subscription',
          upgrade_required: true 
        }, status: :forbidden 
      }
    end
    return
  end

  if @question.update(question_params)
    handle_question_update(old_config, old_ai_config) if old_config || old_ai_config

    respond_to do |format|
      format.html { redirect_to edit_form_path(@form), notice: 'Question was successfully updated.' }
      format.json { render json: { success: true, question: @question } }
    end
  else
    @question_types = FormQuestion::QUESTION_TYPES
    @ai_features = %w[smart_validation response_analysis dynamic_followup]
    @conditional_questions = @form.form_questions.where.not(id: @question.id).order(:position)
    
    respond_to do |format|
      format.html { render :edit, status: :unprocessable_entity }
      format.json { render json: { errors: @question.errors.full_messages }, status: :unprocessable_entity }
    end
  end
end

  # DELETE /forms/:form_id/questions/:id
  def destroy
    position = @question.position
    @question.destroy!

    # Reorder remaining questions
    reorder_questions_after_deletion(position)
    handle_form_structure_change

    respond_to do |format|
      format.html { redirect_to edit_form_path(@form), notice: 'Question was successfully deleted.' }
      format.json { head :no_content }
    end
  end

  # POST /forms/:form_id/questions/:id/move_up
  def move_up
    if @question.position > 1
      swap_question_positions(@question, find_question_at_position(@question.position - 1))
      handle_form_structure_change

      respond_to do |format|
        format.html { redirect_to edit_form_path(@form), notice: 'Question moved up successfully.' }
        format.json { render json: { success: true, new_position: @question.reload.position } }
      end
    else
      respond_to do |format|
        format.html { redirect_to edit_form_path(@form), alert: 'Question is already at the top.' }
        format.json { render json: { error: 'Question is already at the top' }, status: :unprocessable_entity }
      end
    end
  end

  # POST /forms/:form_id/questions/:id/move_down
  def move_down
    max_position = @form.form_questions.maximum(:position)
    
    if @question.position < max_position
      swap_question_positions(@question, find_question_at_position(@question.position + 1))
      handle_form_structure_change

      respond_to do |format|
        format.html { redirect_to edit_form_path(@form), notice: 'Question moved down successfully.' }
        format.json { render json: { success: true, new_position: @question.reload.position } }
      end
    else
      respond_to do |format|
        format.html { redirect_to edit_form_path(@form), alert: 'Question is already at the bottom.' }
        format.json { render json: { error: 'Question is already at the bottom' }, status: :unprocessable_entity }
      end
    end
  end

  # POST /forms/:form_id/questions/:id/duplicate
def duplicate
  begin
    duplicated_question = @question.dup
    duplicated_question.title = "#{@question.title} (Copy)"
    duplicated_question.position = @form.next_question_position
    duplicated_question.save!

    handle_form_structure_change

    respond_to do |format|
      format.html { redirect_to edit_form_path(@form), notice: 'Question duplicated successfully.' }
      format.json { render json: duplicated_question, status: :created }
    end
  rescue StandardError => e
    respond_to do |format|
      format.html { redirect_to edit_form_path(@form), alert: "Failed to duplicate question: #{e.message}" }
      format.json { render json: { error: e.message }, status: :unprocessable_entity }
    end
  end
end

  # POST /forms/:form_id/questions/:id/ai_enhance
  def ai_enhance
    unless @form.ai_enhanced?
      return render json: { error: 'AI features not enabled for this form' }, status: :unprocessable_entity
    end

    unless current_user.can_use_ai_features?
      return render json: { error: 'AI features require a premium subscription' }, status: :forbidden
    end

    enhancement_type = params[:enhancement_type] || 'smart_validation'
    enhancement_options = params[:enhancement_options] || {}

    begin
      result = enhance_question_with_ai(enhancement_type, enhancement_options)

      respond_to do |format|
        format.html { redirect_to edit_form_path(@form), notice: 'Question enhanced with AI successfully.' }
        format.json { render json: { success: true, result: result } }
      end
    rescue StandardError => e
      respond_to do |format|
        format.html { redirect_to edit_form_path(@form), alert: "AI enhancement failed: #{e.message}" }
        format.json { render json: { error: e.message }, status: :unprocessable_entity }
      end
    end
  end

  # GET /forms/:form_id/questions/:id/preview
  def preview
    @preview_mode = true
    @sample_response = build_sample_response

    respond_to do |format|
      format.html { render 'form_questions/preview' }
      format.json { render json: { question: @question, sample_response: @sample_response } }
    end
  end

  # POST /forms/:form_id/questions/reorder
  def reorder
    question_ids = params[:question_ids]
    
    unless question_ids.is_a?(Array)
      return render json: { error: 'Invalid question_ids format' }, status: :bad_request
    end

    begin
      reorder_questions(question_ids)
      handle_form_structure_change

      respond_to do |format|
        format.html { redirect_to edit_form_path(@form), notice: 'Questions reordered successfully.' }
        format.json { render json: { success: true } }
      end
    rescue StandardError => e
      respond_to do |format|
        format.html { redirect_to edit_form_path(@form), alert: "Failed to reorder questions: #{e.message}" }
        format.json { render json: { error: e.message }, status: :unprocessable_entity }
      end
    end
  end

  # GET /forms/:form_id/questions/:id/analytics
  def analytics
    @analytics_period = params[:period]&.to_i&.days || 30.days
    @question_analytics = @question.analytics_summary(@analytics_period)
    @response_distribution = calculate_response_distribution
    @performance_metrics = calculate_performance_metrics

    respond_to do |format|
      format.html
      format.json do
        render json: {
          analytics: @question_analytics,
          distribution: @response_distribution,
          performance: @performance_metrics
        }
      end
    end
  end

  private

  def prepare_conditional_questions
    @conditional_questions = @form.form_questions
                                  .where.not(id: @question.id)
                                  .where('position < ?', @question.position)
                                  .order(:position)
  end

  def set_form
    @form = current_user.forms.find(params[:form_id])
  rescue ActiveRecord::RecordNotFound
    respond_to do |format|
      format.html { redirect_to forms_path, alert: 'Form not found.' }
      format.json { render json: { error: 'Form not found' }, status: :not_found }
    end
  end

  def set_question
    @question = @form.form_questions.find(params[:id])
    
    # Enrich conditional questions with additional context
    @conditional_questions = @form.form_questions
                                  .where.not(id: @question.id)
                                  .where('position < ?', @question.position)
                                  .order(:position)
                                  .map do |q|
      # Add helper data for the UI
      q.define_singleton_method(:choice_options) do
        case question_type
        when 'single_choice', 'multiple_choice', 'checkbox'
          question_config&.dig('options') || []
        when 'yes_no', 'boolean'
          ['Yes', 'No']
        when 'rating', 'scale'
          min_val = question_config&.dig('min_value') || 1
          max_val = question_config&.dig('max_value') || 5
          (min_val..max_val).to_a.map(&:to_s)
        else
          []
        end
      end
      
      q.define_singleton_method(:reference_id) do
        id
      end
      
      q
    end
  rescue ActiveRecord::RecordNotFound => e
    Rails.logger.error "Question not found: #{params[:id]} in form #{@form.id}"
    respond_to do |format|
      format.html { 
        redirect_to edit_form_path(@form), alert: "Question not found or has been deleted. (ID: #{params[:id]})" 
      }
      format.json { 
        render json: { error: "Question not found (ID: #{params[:id]})" }, status: :not_found 
      }
    end
    return
  end

  def validate_conditional_logic
    return unless @question.conditional_enabled? && @question.conditional_logic.present?
    
    rules = @question.conditional_logic['rules'] || []
    validation_errors = []
    
    rules.each_with_index do |rule, index|
      # Check if referenced question exists
      referenced_question = @form.form_questions.find_by(id: rule['question_id'])
      unless referenced_question
        validation_errors << "Rule #{index + 1}: Referenced question no longer exists"
        next
      end
      
      # Check if referenced question comes before current question
      if referenced_question.position >= @question.position
        validation_errors << "Rule #{index + 1}: Can only reference questions that appear before this one"
      end
      
      # Validate operator-value combinations
      case rule['operator']
      when 'is_empty', 'is_not_empty'
        # These operators don't need values
      when 'equals', 'not_equals', 'contains', 'starts_with', 'ends_with'
        if rule['value'].blank?
          validation_errors << "Rule #{index + 1}: Value is required for '#{rule['operator']}' condition"
        end
      when 'greater_than', 'less_than', 'greater_than_or_equal', 'less_than_or_equal'
        if rule['value'].blank? || !numeric?(rule['value'])
          validation_errors << "Rule #{index + 1}: Numeric value is required for '#{rule['operator']}' condition"
        end
      end
      
      # Validate value matches question type expectations
      if referenced_question.question_type == 'yes_no' && rule['value'].present?
        unless ['yes', 'no', 'true', 'false'].include?(rule['value'].downcase)
          validation_errors << "Rule #{index + 1}: Value should be 'Yes' or 'No' for yes/no questions"
        end
      end
    end
    
    if validation_errors.any?
      @question.errors.add(:conditional_logic, validation_errors.join('; '))
      return false
    end
    
    true
  end

  def numeric?(str)
    Float(str) != nil rescue false
  end

  def generate_conditional_suggestions
    @conditional_suggestions = {}
    
    @conditional_questions.each do |q|
      suggestions = case q.question_type
      when 'single_choice', 'multiple_choice'
        {
          operators: ['equals', 'not_equals', 'in_list', 'not_in_list'],
          values: q.choice_options,
          examples: [
            "Show when #{q.title} is exactly '#{q.choice_options.first}'",
            "Show when #{q.title} is any of: #{q.choice_options.first(2).join(', ')}"
          ]
        }
      when 'yes_no'
        {
          operators: ['equals', 'not_equals'],
          values: ['Yes', 'No'],
          examples: [
            "Show when #{q.title} is Yes",
            "Show when #{q.title} is No"
          ]
        }
      when 'text_long', 'text_short'
        {
          operators: ['contains', 'not_contains', 'is_empty', 'is_not_empty'],
          values: [],
          examples: [
            "Show when #{q.title} contains 'keyword'",
            "Show when #{q.title} is not empty"
          ]
        }
      when 'rating', 'scale'
        min_val = q.question_config&.dig('min_value') || 1
        max_val = q.question_config&.dig('max_value') || 5
        mid_val = (min_val + max_val) / 2
        
        {
          operators: ['equals', 'greater_than', 'less_than', 'greater_than_or_equal', 'less_than_or_equal'],
          values: (min_val..max_val).to_a.map(&:to_s),
          examples: [
            "Show when #{q.title} is greater than #{mid_val}",
            "Show when #{q.title} equals #{max_val}"
          ]
        }
      else
        {
          operators: ['equals', 'contains', 'is_empty'],
          values: [],
          examples: []
        }
      end
      
      @conditional_suggestions[q.id] = suggestions
    end
  end

  def preview_conditional_logic
    return unless request.xhr? && params[:conditional_preview]
    
    begin
      preview_rules = JSON.parse(params[:conditional_preview])
      preview_text = generate_preview_text(preview_rules)
      
      render json: { 
        success: true, 
        preview: preview_text,
        warnings: validate_preview_rules(preview_rules)
      }
    rescue JSON::ParserError
      render json: { success: false, error: 'Invalid rule format' }
    end
  end

  def generate_preview_text(rules)
    return "No rules configured" if rules.empty?
    
    rule_texts = rules.map.with_index do |rule, index|
      question = @conditional_questions.find { |q| q.id == rule['question_id'] }
      next "Rule #{index + 1}: Invalid question" unless question
      
      operator_text = case rule['operator']
      when 'equals' then 'is exactly'
      when 'not_equals' then 'is not'
      when 'contains' then 'contains'
      when 'not_contains' then 'does not contain'
      when 'is_empty' then 'is empty'
      when 'is_not_empty' then 'has any answer'
      when 'greater_than' then 'is greater than'
      when 'less_than' then 'is less than'
      else rule['operator']
      end
      
      value_text = rule['value'].present? ? " '#{rule['value']}'" : ""
      "when '#{question.title}' #{operator_text}#{value_text}"
    end.compact
    
    logic_operator = params[:logic_operator] || 'and'
    connector = logic_operator == 'and' ? ' AND ' : ' OR '
    
    "Show this question #{rule_texts.join(connector)}"
  end

  def validate_preview_rules(rules)
    warnings = []
    
    rules.each_with_index do |rule, index|
      question = @conditional_questions.find { |q| q.id == rule['question_id'] }
      next unless question
      
      # Check for potential issues
      if question.question_type == 'single_choice' && rule['operator'] == 'equals'
        available_options = question.choice_options
        if available_options.any? && rule['value'].present? && !available_options.include?(rule['value'])
          warnings << "Rule #{index + 1}: '#{rule['value']}' is not one of the available options"
        end
      end
      
      if question.question_type == 'yes_no' && rule['value'].present?
        unless ['yes', 'no'].include?(rule['value'].downcase)
          warnings << "Rule #{index + 1}: For yes/no questions, value should be 'Yes' or 'No'"
        end
      end
    end
    
    warnings
  end

  def authorize_form_access
    authorize @form, :edit?
  end

  def authorize_question_access
    authorize @question
  end


  def question_params
    params.require(:form_question).permit(
      :title, :description, :question_type, :required, :position,
      :ai_enhanced, :conditional_enabled, :hidden,
      question_config: [
        :min_value, :max_value, :step, :min_length, :max_length, :max_size_mb,
        :multiple, :placeholder, :format,
        options: [],
        items: [],
        categories: [],
        labels: {},
        allowed_types: []
      ],
      ai_config: {},
      conditional_logic: {}
    )
  end

  def handle_form_structure_change
    # Update form cache
    @form.update_form_cache if @form.respond_to?(:update_form_cache)
    
    # Regenerate workflow if AI is enabled
    if @form.ai_enhanced?
      Forms::WorkflowGenerationJob.perform_later(@form.id)
    end
  end

  def handle_question_update(old_config, old_ai_config)
    # Check if question configuration changed significantly
    if question_config_changed?(old_config) || ai_config_changed?(old_ai_config)
      handle_form_structure_change
      
      # Trigger analytics recalculation if question has responses
      if @question.question_responses.any?
        Forms::ResponseAnalysisJob.perform_later(@question.id)
      end
    end
  end

def question_config_changed?(old_config)
  return true if old_config.nil? && @question.question_config.present?
  return true if old_config.present? && @question.question_config.nil?
  return false if old_config.nil? && @question.question_config.nil?
  
  @question.question_config != old_config
end

def ai_config_changed?(old_ai_config)
  return true if old_ai_config.nil? && @question.ai_config.present?
  return true if old_ai_config.present? && @question.ai_config.nil?
  return false if old_ai_config.nil? && @question.ai_config.nil?
  
  @question.ai_config != old_ai_config
end

  def reorder_questions_after_deletion(deleted_position)
    @form.form_questions.where('position > ?', deleted_position)
         .update_all('position = position - 1')
  end

  def swap_question_positions(question1, question2)
    return unless question2

    ActiveRecord::Base.transaction do
      pos1 = question1.position
      pos2 = question2.position
      
      # Use a temporary position to avoid unique constraint issues
      temp_position = -1
      question1.update!(position: temp_position)
      question2.update!(position: pos1)
      question1.update!(position: pos2)
    end
  end

  def find_question_at_position(position)
    @form.form_questions.find_by(position: position)
  end

  def reorder_questions(question_ids)
    ActiveRecord::Base.transaction do
      question_ids.each_with_index do |question_id, index|
        question = @form.form_questions.find(question_id)
        question.update!(position: index + 1)
      end
    end
  end

  def enhance_question_with_ai(enhancement_type, options)
    case enhancement_type
    when 'smart_validation'
      enhance_with_smart_validation(options)
    when 'response_analysis'
      enhance_with_response_analysis(options)
    when 'dynamic_followup'
      enhance_with_dynamic_followup(options)
    else
      raise ArgumentError, "Unknown enhancement type: #{enhancement_type}"
    end
  end

  def enhance_with_smart_validation(options)
    # Enable AI-powered validation for the question
    ai_config = @question.ai_config || {}
    ai_config['features'] ||= []
    ai_config['features'] << 'smart_validation' unless ai_config['features'].include?('smart_validation')
    ai_config['validation_rules'] = generate_smart_validation_rules(options)
    
    @question.update!(
      ai_enhanced: true,
      ai_config: ai_config
    )

    { enhancement_type: 'smart_validation', features_added: ['smart_validation'] }
  end

  def enhance_with_response_analysis(options)
    # Enable AI-powered response analysis
    ai_config = @question.ai_config || {}
    ai_config['features'] ||= []
    ai_config['features'] << 'response_analysis' unless ai_config['features'].include?('response_analysis')
    ai_config['analysis_config'] = {
      sentiment_analysis: options[:sentiment_analysis] != false,
      keyword_extraction: options[:keyword_extraction] != false,
      quality_scoring: options[:quality_scoring] != false
    }
    
    @question.update!(
      ai_enhanced: true,
      ai_config: ai_config
    )

    { enhancement_type: 'response_analysis', features_added: ['response_analysis'] }
  end

  def enhance_with_dynamic_followup(options)
    # Enable AI-powered dynamic follow-up questions
    ai_config = @question.ai_config || {}
    ai_config['features'] ||= []
    ai_config['features'] << 'dynamic_followup' unless ai_config['features'].include?('dynamic_followup')
    ai_config['followup_config'] = {
      max_followups: options[:max_followups] || 2,
      trigger_conditions: options[:trigger_conditions] || ['interesting_response', 'incomplete_answer'],
      followup_style: options[:followup_style] || 'conversational'
    }
    
    @question.update!(
      ai_enhanced: true,
      ai_config: ai_config
    )

    { enhancement_type: 'dynamic_followup', features_added: ['dynamic_followup'] }
  end

  def generate_smart_validation_rules(options)
    # Generate AI-powered validation rules based on question type and options
    base_rules = {
      enabled: true,
      confidence_threshold: options[:confidence_threshold] || 0.7,
      validation_prompts: generate_validation_prompts
    }

    case @question.question_type
    when 'email'
      base_rules[:email_specific] = {
        check_disposable: options[:check_disposable] != false,
        check_format: true,
        check_domain: options[:check_domain] != false
      }
    when 'text_long'
      base_rules[:text_analysis] = {
        min_quality_score: options[:min_quality_score] || 0.6,
        check_coherence: options[:check_coherence] != false,
        check_relevance: options[:check_relevance] != false
      }
    end

    base_rules
  end

  def generate_validation_prompts
    {
      system_prompt: "You are an expert form validator. Analyze the response for quality, relevance, and completeness.",
      validation_prompt: "Validate this response for the question: '#{@question.title}'. Consider appropriateness, completeness, and quality."
    }
  end

  def build_sample_response
    # Build a sample response for preview purposes
    case @question.question_type
    when 'text_short'
      'Sample short text response'
    when 'text_long'
      'This is a sample long text response that demonstrates how the question would appear to users filling out the form.'
    when 'email'
      'user@example.com'
    when 'multiple_choice'
      @question.choice_options.first if @question.choice_options.any?
    when 'rating'
      config = @question.rating_config
      ((config[:min] + config[:max]) / 2).to_i
    else
      'Sample response'
    end
  end

  def calculate_response_distribution
    return {} unless @question.question_responses.any?

    case @question.question_type
    when 'multiple_choice', 'single_choice'
      calculate_choice_distribution
    when 'rating', 'scale', 'nps_score'
      calculate_rating_distribution
    when 'yes_no', 'boolean'
      calculate_boolean_distribution
    else
      calculate_text_distribution
    end
  end

  def calculate_choice_distribution
    responses = @question.question_responses.where.not(answer_text: [nil, ''])
    total = responses.count
    return {} if total.zero?

    distribution = responses.group(:answer_text).count
    distribution.transform_values { |count| (count.to_f / total * 100).round(2) }
  end

  def calculate_rating_distribution
    responses = @question.question_responses.where.not(answer_text: [nil, ''])
    total = responses.count
    return {} if total.zero?

    distribution = responses.group(:answer_text).count
    distribution.transform_values { |count| (count.to_f / total * 100).round(2) }
  end

  def calculate_boolean_distribution
    responses = @question.question_responses.where.not(answer_text: [nil, ''])
    total = responses.count
    return {} if total.zero?

    yes_count = responses.where(answer_text: ['yes', 'true', '1']).count
    no_count = total - yes_count

    {
      'Yes' => (yes_count.to_f / total * 100).round(2),
      'No' => (no_count.to_f / total * 100).round(2)
    }
  end

  def calculate_text_distribution
    responses = @question.question_responses.where.not(answer_text: [nil, ''])
    total = responses.count
    return {} if total.zero?

    # For text responses, show length distribution
    length_ranges = {
      'Short (1-50 chars)' => responses.where('LENGTH(answer_text) BETWEEN 1 AND 50').count,
      'Medium (51-200 chars)' => responses.where('LENGTH(answer_text) BETWEEN 51 AND 200').count,
      'Long (201+ chars)' => responses.where('LENGTH(answer_text) > 200').count
    }

    length_ranges.transform_values { |count| (count.to_f / total * 100).round(2) }
  end

  def calculate_performance_metrics
    responses = @question.question_responses
    total_responses = responses.count

    return {} if total_responses.zero?

    {
      completion_rate: @question.completion_rate,
      average_response_time: @question.average_response_time_seconds,
      skip_rate: calculate_skip_rate,
      quality_score: calculate_average_quality_score,
      engagement_score: calculate_engagement_score
    }
  end

  def calculate_skip_rate
    total_responses = @question.question_responses.count
    return 0.0 if total_responses.zero?

    skipped_responses = @question.question_responses.where(skipped: true).count
    (skipped_responses.to_f / total_responses * 100).round(2)
  end

  def calculate_average_quality_score
    responses_with_quality = @question.question_responses.where.not(quality_score: nil)
    return 0.0 if responses_with_quality.empty?

    responses_with_quality.average(:quality_score).to_f.round(2)
  end

  def calculate_engagement_score
    # Calculate engagement based on response time and completion
    responses = @question.question_responses.where.not(time_spent_seconds: [nil, 0])
    return 0.0 if responses.empty?

    avg_time = responses.average(:time_spent_seconds)
    completion_rate = @question.completion_rate

    # Normalize engagement score (0-100)
    time_score = [100 - (avg_time / 60.0 * 10), 0].max # Penalize very long times
    engagement = (completion_rate + time_score) / 2

    engagement.round(2)
  end
end
</file>

<file path="controllers/forms_controller.rb">
# frozen_string_literal: true

class FormsController < ApplicationController
  include PaymentErrorHandling
  include PaymentAnalyticsTrackable
  include SafePagination
  
  before_action :authenticate_user!
  before_action :set_form, only: [:show, :edit, :update, :destroy, :publish, :unpublish, :duplicate, :analytics, :export, :preview, :responses, :download_responses, :payment_setup_status, :has_payment_questions]
  before_action :authorize_form, only: [:show, :edit, :update, :destroy, :publish, :unpublish, :analytics, :preview]

  # GET /forms
  def index
    @forms = policy_scope(Form)
                        .includes(:form_questions, :form_responses)
                        .order(created_at: :desc)
    
    # Permit and extract parameters to avoid warnings
    permitted_params = params.permit(:user_id, :query, :status, :category, :sort_by, :sort_direction, :commit)
    
    # For superadmin, add user filtering capability
    if current_user.superadmin? && permitted_params[:user_id].present?
      @forms = @forms.where(user_id: permitted_params[:user_id])
    end

    # Apply search filter
    if permitted_params[:query].present?
      @forms = @forms.where("name ILIKE ? OR description ILIKE ?", 
                           "%#{permitted_params[:query]}%", 
                           "%#{permitted_params[:query]}%")
    end

    # Apply status filter
    if permitted_params[:status].present? && Form.statuses.key?(permitted_params[:status])
      @forms = @forms.where(status: permitted_params[:status])
    end

    # Apply category filter
    if permitted_params[:category].present? && Form.categories.key?(permitted_params[:category])
      @forms = @forms.where(category: permitted_params[:category])
    end

    # Apply sorting
    case permitted_params[:sort_by]
    when 'name'
      @forms = @forms.order(:name)
    when 'responses'
      @forms = @forms.order(:responses_count)
    when 'completion_rate'
      @forms = @forms.order(:completions_count)
    else
      @forms = @forms.order(created_at: :desc)
    end

    respond_to do |format|
      format.html
      format.json { render json: @forms }
    end
  end

  # GET /forms/:id
  def show
    @form_questions = @form.form_questions.includes(:question_responses)
    @recent_responses = @form.form_responses.includes(:question_responses)
                             .order(created_at: :desc)
                             .limit(10)

    respond_to do |format|
      format.html
      format.json { render json: @form, include: [:form_questions, :form_responses] }
    end
  end

  # GET /forms/new
  def new
    @form = current_user.forms.build
    authorize @form
    @form.assign_attributes(default_form_settings)
    @templates = [] # FormTemplate.public_templates.featured - will be implemented later
  end

  # GET /forms/new_from_ai
  def new_from_ai
    authorize Form, :create?
    
    # Check if user can use AI features
    unless current_user.can_use_ai_features?
      redirect_to new_form_path, alert: 'AI form generation requires a premium subscription.'
      return
    end

    # Check AI credits
    if current_user.ai_credits_remaining <= 0
      redirect_to new_form_path, alert: 'You have exceeded your monthly AI usage limit. Please upgrade your plan.'
      return
    end

    @ai_credits_remaining = current_user.ai_credits_remaining
    @estimated_cost = 0.05 # Base cost for form generation
  end

  # POST /forms
  def create
    @form = current_user.forms.build(form_params)
    authorize @form
    @form.assign_attributes(default_form_settings) if @form.form_settings.blank?
    @form.assign_attributes(default_ai_configuration) if @form.ai_configuration.blank?

    # Check subscription tier for AI features
    if @form.ai_enabled? && !current_user.can_use_ai_features?
      @form.ai_enabled = false
      flash.now[:alert] = 'AI features require a premium subscription. Form created without AI enhancements.'
    end

    if @form.save
      # Trigger workflow generation if AI is enabled and user has access
      if @form.ai_enabled? && current_user.can_use_ai_features?
        Forms::WorkflowGenerationJob.perform_later(@form.id)
      end

      respond_to do |format|
        format.html { redirect_to edit_form_path(@form), notice: 'Form was successfully created.' }
        format.json { render json: @form, status: :created }
      end
    else
      @templates = [] # FormTemplate.public_templates.featured - will be implemented later
      respond_to do |format|
        format.html { render :new, status: :unprocessable_entity }
        format.json { render json: @form.errors, status: :unprocessable_entity }
      end
    end
  end

  # POST /forms/generate_from_ai
  def generate_from_ai
    authorize Form, :create?
    
    # Check if user can use AI features
    unless current_user.can_use_ai_features?
      respond_to do |format|
        format.html { redirect_to new_from_ai_forms_path, alert: 'AI form generation requires a premium subscription.' }
        format.json { render json: { error: 'AI features require a premium subscription' }, status: :forbidden }
      end
      return
    end

    # Check AI credits
    if current_user.ai_credits_remaining <= 0
      respond_to do |format|
        format.html { redirect_to new_from_ai_forms_path, alert: 'You have exceeded your monthly AI usage limit. Please upgrade your plan.' }
        format.json { render json: { error: 'Monthly AI usage limit exceeded' }, status: :forbidden }
      end
      return
    end

    # Extract and validate parameters
    generation_params = ai_generation_params
    
    # Validate parameters before processing
    validation_errors = validate_generation_params(generation_params)
    if validation_errors.any?
      respond_to do |format|
        format.html { 
          flash[:alert] = validation_errors.join(', ')
          redirect_to new_from_ai_forms_path 
        }
        format.json { 
          render json: { 
            error: validation_errors.first,
            errors: validation_errors 
          }, status: :unprocessable_entity 
        }
      end
      return
    end
    
    begin
      # Use the real AI workflow for form generation
      Rails.logger.info "Invoking AI form generation workflow"
      
      # Determine input type and prepare parameters
      input_type = generation_params[:document].present? ? 'document' : 'prompt'
      content_input = input_type == 'document' ? generation_params[:document] : generation_params[:prompt]
      
      # Prepare metadata for the workflow
      metadata = {
        ip_address: request.remote_ip,
        user_agent: request.user_agent,
        max_questions: generation_params[:max_questions] || 10,
        complexity_preference: generation_params[:complexity] || 'moderate',
        session_id: session.id
      }
      
      # Execute the AI workflow
      workflow_result = Forms::AiFormGenerationWorkflow.execute(
        user_id: current_user.id,
        content_input: content_input,
        input_type: input_type,
        metadata: metadata
      )

      if workflow_result[:success]
        @form = workflow_result[:form]
        
        respond_to do |format|
          format.html { redirect_to edit_form_path(@form), notice: 'AI form generated successfully!' }
          format.json { 
            render json: { 
              success: true, 
              form: @form.as_json(include: :form_questions), 
              redirect_url: edit_form_path(@form),
              message: 'AI form generated successfully!'
            } 
          }
        end
      else
        respond_to do |format|
          format.html { 
            flash[:alert] = workflow_result[:message] || workflow_result[:error] || 'Failed to generate form'
            redirect_to new_from_ai_forms_path
          }
          format.json { 
            render json: { 
              error: workflow_result[:message] || workflow_result[:error] || 'Failed to generate form',
              error_type: workflow_result[:error_type] || 'generation_error'
            }, status: :unprocessable_entity 
          }
        end
      end

    rescue StandardError => e
      Rails.logger.error "AI form generation failed: #{e.message}"
      Rails.logger.error e.backtrace.join("\n")
      
      error_message = case e.message
      when /Monthly AI usage limit exceeded/
        'You have exceeded your monthly AI usage limit. Please upgrade your plan.'
      when /Content too long/
        'The provided content is too long. Please provide content with fewer than 5000 words.'
      when /Content too short/
        'Please provide more detailed information to generate a comprehensive form.'
      when /Unsupported file type/
        'Please upload a PDF, Markdown, or text file.'
      when /File too large/
        'The uploaded file is too large. Please upload a file smaller than 10MB.'
      else
        'An error occurred while generating your form. Please try again.'
      end

      respond_to do |format|
        format.html { 
          flash[:alert] = error_message
          redirect_to new_from_ai_forms_path
        }
        format.json { 
          render json: { 
            error: error_message,
            error_type: 'exception'
          }, status: :unprocessable_entity 
        }
      end
    end
  end

  # GET /forms/:id/edit
  def edit
    @form_questions = @form.form_questions.order(:position)
    @question_types = FormQuestion::QUESTION_TYPES
    @ai_features = %w[response_analysis dynamic_questions sentiment_analysis lead_scoring]
    @can_use_ai = current_user.can_use_ai_features?
  end

  # PATCH/PUT /forms/:id
  def update
    old_ai_config = @form.ai_configuration.dup
    old_structure = @form.form_questions.pluck(:id, :position, :question_type)

    # Check subscription tier for AI features
    if form_params[:ai_enabled] == 'true' && !current_user.can_use_ai_features?
      @form.errors.add(:ai_enabled, 'requires a premium subscription')
      @form_questions = @form.form_questions.order(:position)
      @question_types = FormQuestion::QUESTION_TYPES
      @ai_features = %w[response_analysis dynamic_questions sentiment_analysis lead_scoring]
      @can_use_ai = current_user.can_use_ai_features?
      
      respond_to do |format|
        format.html { render :edit, status: :unprocessable_entity }
        format.json { render json: { error: 'AI features require a premium subscription' }, status: :unprocessable_entity }
      end
      return
    end

    if @form.update(form_params)
      handle_form_update(old_ai_config, old_structure)

      respond_to do |format|
        format.html { redirect_to @form, notice: 'Form was successfully updated.' }
        format.json { render json: @form }
      end
    else
      @form_questions = @form.form_questions.order(:position)
      @question_types = FormQuestion::QUESTION_TYPES
      @ai_features = %w[response_analysis dynamic_questions sentiment_analysis lead_scoring]
      @can_use_ai = current_user.can_use_ai_features?
      
      respond_to do |format|
        format.html { render :edit, status: :unprocessable_entity }
        format.json { render json: @form.errors, status: :unprocessable_entity }
      end
    end
  end

  # DELETE /forms/:id
  def destroy
    @form.destroy!

    respond_to do |format|
      format.html { redirect_to forms_path, notice: 'Form was successfully deleted.' }
      format.json { head :no_content }
    end
  end

  # POST /forms/:id/publish
  def publish
    # Basic form validation
    if @form.form_questions.empty?
      error_message = if @form.ai_enabled?
        'This AI-generated form appears to be incomplete. Please regenerate the form or add questions manually before publishing.'
      else
        'Cannot publish form without questions. Please add at least one question before publishing.'
      end
      
      respond_to do |format|
        format.html { redirect_to edit_form_path(@form), alert: error_message }
        format.json { render json: { error: error_message }, status: :unprocessable_entity }
        format.turbo_stream { 
          render turbo_stream: turbo_stream.replace('flash-messages', 
            partial: 'shared/flash_message', 
            locals: { type: 'alert', message: error_message }
          )
        }
      end
      return
    end

    # Pre-publish payment validation - this will raise PaymentValidationError if validation fails
    perform_pre_publish_validation

    begin
      @form.update!(status: 'published', published_at: Time.current)
      
      redirect_to @form, notice: 'Form has been published successfully.'
    rescue ActiveRecord::RecordInvalid => e
      error_message = handle_publish_validation_error(e)
      redirect_to edit_form_path(@form), alert: error_message
    end
  end

  # POST /forms/:id/unpublish
  def unpublish
    @form.update!(status: 'draft', published_at: nil)
    
    respond_to do |format|
      format.html { redirect_to @form, notice: 'Form has been unpublished.' }
      format.json { render json: { status: 'draft' } }
    end
  end

  # POST /forms/:id/duplicate
  def duplicate
    begin
      duplicated_form = Forms::ManagementAgent.new.duplicate_form(@form, current_user, {
        name: "#{@form.name} (Copy)",
        status: 'draft'
      })

      respond_to do |format|
        format.html { redirect_to edit_form_path(duplicated_form), notice: 'Form duplicated successfully.' }
        format.json { render json: duplicated_form, status: :created }
      end
    rescue StandardError => e
      respond_to do |format|
        format.html { redirect_to @form, alert: "Failed to duplicate form: #{e.message}" }
        format.json { render json: { error: e.message }, status: :unprocessable_entity }
      end
    end
  end

  # GET /forms/:id/analytics
  def analytics
    @analytics_period = params[:period]&.to_i&.days || 30.days
    @analytics_data = @form.cached_analytics_summary(period: @analytics_period)
    
    @question_analytics = @form.form_questions.includes(:question_responses)
                               .map { |q| [q, q.analytics_summary(@analytics_period)] }
                               .to_h

    @response_trends = @form.form_analytics
                            .for_period(@analytics_period.ago.to_date, Date.current)
                            .daily
                            .order(:date)

    respond_to do |format|
      format.html
      format.json do
        render json: {
          summary: @analytics_data,
          questions: @question_analytics,
          trends: @response_trends
        }
      end
    end
  end

  # GET /forms/:id/export
  def export
    export_format = params[:format] || 'csv'
    export_options = {
      format: export_format,
      include_metadata: params[:include_metadata] == 'true',
      date_range: params[:date_range]
    }

    begin
      export_data = Forms::ManagementAgent.new.export_form_data(@form, export_options)
      
      respond_to do |format|
        format.csv do
          send_data export_data[:content], 
                    filename: export_data[:filename],
                    type: 'text/csv'
        end
        format.json do
          render json: {
            download_url: export_data[:download_url],
            expires_at: export_data[:expires_at]
          }
        end
      end
    rescue StandardError => e
      respond_to do |format|
        format.html { redirect_to analytics_form_path(@form), alert: "Export failed: #{e.message}" }
        format.json { render json: { error: e.message }, status: :unprocessable_entity }
      end
    end
  end

  # GET /forms/:id/preview
  def preview
    @preview_mode = true
    @form_response = @form.form_responses.build
    
    respond_to do |format|
      format.html { render 'forms/preview' }
      format.json { render json: @form, include: :form_questions }
    end
  end

  # GET /forms/:id/responses
  def responses
    authorize @form, :responses?
    
    @responses = safe_paginate(
      @form.form_responses
           .includes(:question_responses, :dynamic_questions)
           .order(created_at: :desc),
      page: params[:page],
      per_page: params[:per_page] || 20
    )

    respond_to do |format|
      format.html
      format.csv { download_responses_csv }
    end
  end

  # GET /forms/:id/download_responses
  def download_responses
    authorize @form, :download_responses?
    
    @responses = @form.form_responses
                      .completed
                      .includes(:question_responses, :dynamic_questions)
                      .order(completed_at: :desc)

    csv_data = download_responses_csv
    send_data csv_data,
              filename: "#{@form.name.parameterize}_responses_#{Date.current}.csv",
              type: 'text/csv'
  end

  # GET /forms/:id/payment_setup_status
  def payment_setup_status
    authorize @form, :show?
    
    setup_status = @form.user.payment_setup_status
    
    respond_to do |format|
      format.json do
        render json: {
          has_payment_questions: @form.has_payment_questions?,
          stripe_configured: setup_status[:stripe_configured],
          premium_subscription: setup_status[:premium_subscription],
          can_accept_payments: setup_status[:can_accept_payments],
          setup_complete: @form.payment_setup_complete?,
          completion_percentage: setup_status[:setup_completion_percentage],
          missing_requirements: @form.payment_setup_requirements
        }
      end
    end
  end

  # GET /forms/:id/has_payment_questions
  def has_payment_questions
    authorize @form, :show?
    
    respond_to do |format|
      format.json do
        render json: {
          has_payment_questions: @form.has_payment_questions?,
          payment_questions_count: @form.payment_questions.count
        }
      end
    end
  end

  # POST /forms/:id/track_setup_abandonment
  def track_setup_abandonment
    authorize @form, :show?
    
    if @form.has_payment_questions? && !@form.payment_setup_complete?
      track_payment_event(
        'payment_setup_abandoned',
        user: current_user,
        context: {
          form_id: @form.id,
          form_title: @form.title,
          abandonment_point: params[:abandonment_point] || 'form_editor',
          time_spent: params[:time_spent]&.to_i || 0,
          setup_progress: current_user.payment_setup_status[:setup_completion_percentage],
          missing_requirements: @form.payment_setup_requirements
        }
      )
    end
    
    head :ok
  end

  private

  def validate_generation_params(params)
    errors = []
    
    # Must have either prompt or document
    if params[:prompt].blank? && (params[:document].blank? || params[:document].size == 0)
      errors << "Please provide either a text prompt or upload a document"
      return errors
    end
    
    # Validate prompt if provided
    if params[:prompt].present?
      prompt = params[:prompt].strip
      if prompt.length < 20
        errors << "Prompt must be at least 20 characters long"
      elsif prompt.length > 10000
        errors << "Prompt is too long (maximum 10,000 characters)"
      end
      
      # Check for potentially problematic content
      if prompt.match?(/\A\s*\z/) # Only whitespace
        errors << "Prompt cannot be empty or contain only whitespace"
      end
    end
    
    # Validate document if provided
    if params[:document].present? && params[:document].respond_to?(:size)
      document = params[:document]
      
      # Check file size (10MB limit)
      if document.size > 10.megabytes
        errors << "File size must be less than 10MB"
      end
      
      # Check file type
      allowed_types = ['application/pdf', 'text/markdown', 'text/plain', 'text/md']
      allowed_extensions = ['.pdf', '.md', '.txt', '.markdown']
      
      content_type_valid = allowed_types.include?(document.content_type)
      extension_valid = allowed_extensions.any? { |ext| 
        document.original_filename&.downcase&.end_with?(ext) 
      }
      
      unless content_type_valid || extension_valid
        errors << "Please upload a PDF, Markdown (.md), or text (.txt) file"
      end
    end
    
    errors
  end

  def set_form
    if current_user.superadmin?
      @form = Form.find(params[:id])
    else
      @form = current_user.forms.find(params[:id])
    end
  rescue ActiveRecord::RecordNotFound
    respond_to do |format|
      format.html { redirect_to forms_path, alert: 'Form not found.' }
      format.json { render json: { error: 'Form not found' }, status: :not_found }
    end
  end

  def authorize_form
    authorize @form
  end

  def form_params
    params.require(:form).permit(
      :name, :description, :category, :ai_enabled,
      form_settings: {},
      ai_configuration: {},
      style_configuration: {},
      integration_settings: {}
    )
  end

  def default_form_settings
    {
      form_settings: {
        one_question_per_page: true,
        show_progress_bar: true,
        allow_multiple_submissions: false,
        require_login: false,
        collect_email: true,
        thank_you_message: "Thank you for your response!",
        redirect_url: nil
      }
    }
  end

  def default_ai_configuration
    {
      ai_configuration: {
        version: "1.0",
        enabled_features: [],
        rules_engine: {
          rule_sets: []
        },
        ai_engine: {
          primary_model: "gpt-4o-mini",
          fallback_model: "gpt-3.5-turbo",
          max_tokens: 500,
          temperature: 0.7,
          rate_limiting: {
            max_requests_per_minute: 60,
            max_requests_per_hour: 1000,
            backoff_strategy: "exponential"
          },
          response_validation: {
            enabled: true,
            required_fields: ["question", "type"],
            max_title_length: 100,
            allowed_question_types: ["text", "email", "phone", "number", "multiple_choice", "rating", "date"]
          }
        }
      }
    }
  end

  def handle_form_update(old_ai_config, old_structure)
    # Check if AI configuration changed
    if ai_configuration_changed?(old_ai_config)
      # Regenerate workflow if AI settings changed
      if @form.ai_enabled?
        Forms::WorkflowGenerationJob.perform_async(@form.id)
      end
    end

    # Check if form structure changed
    if form_structure_changed?(old_structure)
      # Update form cache and analytics
      @form.update_form_cache
      
      # Trigger analytics recalculation if form has responses
      if @form.form_responses.any?
        Forms::AnalysisWorkflow.perform_async(@form.id)
      end
    end
  end

  def form_structure_changed?(old_structure)
    current_structure = @form.form_questions.pluck(:id, :position, :question_type)
    old_structure != current_structure
  end

  def ai_configuration_changed?(old_config)
    @form.ai_configuration != old_config
  end

  def download_responses_csv
    require 'csv'
    
    CSV.generate(headers: true) do |csv|
      # Headers
      headers = ['ID', 'Completado en', 'Tiempo total (segundos)', 'Direccion IP', 'Agente de usuario']
      
      # Add form question headers
      @form.form_questions.order(:position).each do |question|
        headers << "#{question.title} (#{question.question_type})"
      end
      
      csv << headers
      
      # Data rows
      @responses.each do |response|
        # Calculate total time in seconds
        total_seconds = if response.completed_at && response.started_at
                          (response.completed_at - response.started_at).to_i
                        else
                          0
                        end
        
        row = [
          response.id,
          response.completed_at&.strftime('%Y-%m-%d %H:%M:%S'),
          total_seconds,
          response.ip_address,
          response.user_agent
        ]
        
        # Add form question answers
        @form.form_questions.order(:position).each do |question|
          answer = response.question_responses.find { |qr| qr.form_question_id == question.id }
          if answer
            row << format_answer_value(answer.answer_data['value'])
          else
            row << ''
          end
        end
        
        csv << row
      end
    end
  end

  def format_answer_value(value)
    case value
    when Array
      value.join(', ')
    when Hash
      value.to_json
    when nil
      ''
    else
      value.to_s
    end
  end

  def ai_generation_params
    params.permit(:prompt, :document, :max_questions, :complexity, :authenticity_token)
  end

  # Performs pre-publish validation including payment requirements
  def perform_pre_publish_validation
    # Always run validation service for forms with payment questions
    return unless @form.has_payment_questions?

    Rails.logger.info "Running pre-publish payment validation for form #{@form.id}"
    
    begin
      validation_service = FormPublishValidationService.new(form: @form)
      validation_result = validation_service.call

      # Check if validation service failed or returned negative result
      if validation_service.failure?
        Rails.logger.warn "FormPublishValidationService failed: #{validation_service.errors.full_messages}"
        handle_payment_validation_failure(validation_result.result)
      elsif !validation_result.result[:can_publish]
        Rails.logger.warn "Form cannot be published due to payment validation errors"
        handle_payment_validation_failure(validation_result.result)
      else
        Rails.logger.info "Payment validation passed for form #{@form.id}"
      end
    rescue StandardError => e
      Rails.logger.error "Payment validation service error: #{e.message}"
      Rails.logger.error e.backtrace.join("\n")
      
      # Fallback validation if service fails
      perform_fallback_payment_validation
    end
  end

  # Performs fallback payment validation when service fails
  def perform_fallback_payment_validation
    return unless @form&.has_payment_questions?
    
    Rails.logger.info "Performing fallback payment validation for form #{@form.id}"
    
    missing_requirements = []
    
    # Check basic requirements
    missing_requirements << 'stripe_configuration' unless @form.user.stripe_configured?
    missing_requirements << 'premium_subscription' unless @form.user.premium?
    
    # Check payment questions configuration
    payment_questions = @form.form_questions.where(question_type: 'payment')
    if payment_questions.any? { |q| q.question_config.blank? }
      missing_requirements << 'payment_question_configuration'
    end
    
    if missing_requirements.any?
      Rails.logger.warn "Fallback validation found missing requirements: #{missing_requirements}"
      raise PaymentValidationErrors.multiple_requirements(missing_requirements)
    end
  end

  # Handles payment validation failures by raising appropriate errors
  def handle_payment_validation_failure(validation_result)
    errors = validation_result[:validation_errors] || []
    actions = validation_result[:required_actions] || []

    Rails.logger.warn "Payment validation failure - Errors: #{errors.length}, Actions: #{actions.length}"
    
    # Determine the primary error type and create appropriate PaymentValidationError
    if errors.any?
      primary_error = errors.first
      error_type = primary_error[:type]

      Rails.logger.warn "Primary error type: #{error_type}"

      case error_type
      when 'stripe_not_configured'
        raise PaymentValidationErrors.stripe_not_configured(
          additional_actions: actions.map { |a| a[:type] }
        )
      when 'premium_subscription_required'
        raise PaymentValidationErrors.premium_required(
          additional_actions: actions.map { |a| a[:type] }
        )
      when 'payment_acceptance_disabled'
        missing_requirements = []
        missing_requirements << 'stripe_configuration' unless @form.user.stripe_configured?
        missing_requirements << 'premium_subscription' unless @form.user.premium?
        
        raise PaymentValidationErrors.multiple_requirements(
          missing_requirements,
          additional_actions: actions.map { |a| a[:type] }
        )
      when 'payment_question_configuration', 'payment_question_fields'
        raise PaymentValidationErrors.invalid_payment_configuration(
          details: errors.map { |e| e[:description] },
          additional_actions: actions.map { |a| a[:type] }
        )
      else
        # Generic payment validation error with enhanced context
        raise PaymentValidationErrors.custom_error(
          error_type: error_type,
          message: primary_error[:title] || primary_error[:description] || 'Payment validation failed',
          required_actions: actions.map { |a| a[:type] },
          description: primary_error[:description],
          action_url: actions.first&.dig(:action_url),
          action_text: actions.first&.dig(:action_text)
        )
      end
    else
      # Fallback error if no specific errors but validation failed
      Rails.logger.warn "No specific errors found, using fallback error"
      raise PaymentValidationErrors.multiple_requirements(
        ['payment_setup'],
        additional_actions: actions.map { |a| a[:type] }
      )
    end
  end

  # Handles ActiveRecord validation errors during publish
  def handle_publish_validation_error(exception)
    Rails.logger.error "Form publish validation error: #{exception.message}"
    Rails.logger.error exception.backtrace.join("\n")

    # Check if this is a payment-related validation error
    if exception.message.include?('payment') || exception.message.include?('stripe')
      'Payment configuration is required to publish this form. Please complete your payment setup.'
    elsif exception.message.include?('subscription') || exception.message.include?('premium')
      'A Premium subscription is required to publish forms with payment questions.'
    else
      # Generic validation error
      "Unable to publish form: #{exception.record&.errors&.full_messages&.join(', ') || exception.message}"
    end
  end

  # Override the PaymentErrorHandling concern method for forms-specific behavior
  def handle_payment_error_html(error)
    add_payment_error_context(error)
    
    Rails.logger.info "Handling payment error HTML response for form #{@form&.id}"
    
    # For forms, redirect back to the edit page with payment setup guidance
    redirect_to edit_form_path(@form), 
                alert: error.message,
                flash: { 
                  payment_error: error.to_hash,
                  show_payment_setup: true,
                  payment_error_context: {
                    form_id: @form.id,
                    has_payment_questions: @form.has_payment_questions?,
                    error_type: error.error_type
                  }
                }
  end

  # Override the PaymentErrorHandling concern method for forms-specific Turbo Stream responses
  def handle_payment_error_turbo_stream(error)
    Rails.logger.info "Handling payment error Turbo Stream response for form #{@form&.id}"
    
    # Add payment error context for enhanced guidance
    add_payment_error_context(error)
    
    streams = [
      turbo_stream.replace('flash-messages', 
        partial: 'shared/payment_error_flash', 
        locals: { error: error, context: 'form_publish' }
      ),
      turbo_stream.update('form-status-indicator',
        partial: 'forms/status_indicator',
        locals: { form: @form, error: error }
      )
    ]
    
    # Add form-specific payment guidance
    if @form.present?
      streams << turbo_stream.update('form-publish-section', 
        partial: 'forms/publish_section_with_payment_guidance',
        locals: { form: @form, error: error }
      )
      
      # Show payment setup checklist if available
      streams << turbo_stream.update('payment-setup-checklist',
        partial: 'shared/payment_setup_checklist',
        locals: { 
          user: current_user, 
          error: error, 
          form: @form,
          show_form_context: true 
        }
      )
      
      # Update publish button to show setup required state
      streams << turbo_stream.update('form-publish-button',
        partial: 'forms/publish_button_with_setup_guidance',
        locals: { form: @form, error: error }
      )
    end
    
    # Add payment setup status indicator
    streams << turbo_stream.update('payment-setup-status',
      partial: 'shared/payment_setup_status',
      locals: { user: current_user, error: error, context: 'form_editor' }
    )
    
    render turbo_stream: streams
  end

  # Override the PaymentErrorHandling concern method for forms-specific JSON responses
  def handle_payment_error_json(error)
    Rails.logger.info "Handling payment error JSON response for form #{@form&.id}"
    
    # Build comprehensive error response for API consumers
    error_response = {
      success: false,
      error: error.to_hash,
      context: {
        form_id: @form&.id,
        form_name: @form&.name,
        has_payment_questions: @form&.has_payment_questions?,
        payment_questions_count: @form&.form_questions&.where(question_type: 'payment')&.count || 0,
        user_setup_status: current_user&.payment_setup_status || {},
        validation_timestamp: Time.current.iso8601
      },
      guidance: {
        next_steps: error.required_actions,
        primary_action: {
          url: error.primary_action_url,
          text: error.primary_action_text,
          type: error.required_actions.first
        },
        estimated_setup_time: estimate_setup_time(error),
        help_resources: payment_help_resources
      },
      status: 'payment_validation_failed'
    }
    
    render json: error_response, status: :unprocessable_entity
  end

  # Estimates setup time based on error type and required actions
  def estimate_setup_time(error)
    case error.error_type
    when 'stripe_not_configured'
      '5-10 minutes'
    when 'premium_subscription_required'
      '2-3 minutes'
    when 'multiple_requirements_missing'
      '10-15 minutes'
    when 'invalid_payment_configuration'
      '3-5 minutes'
    else
      '5-10 minutes'
    end
  end

  # Provides help resources for payment setup
  def payment_help_resources
    [
      {
        title: 'Payment Setup Guide',
        url: '/help/payment-setup',
        type: 'documentation'
      },
      {
        title: 'Stripe Integration Tutorial',
        url: '/help/stripe-integration',
        type: 'tutorial'
      },
      {
        title: 'Premium Features Overview',
        url: '/help/premium-features',
        type: 'feature_guide'
      }
    ]
  end
end
</file>

<file path="controllers/google_integrations_controller.rb">
# frozen_string_literal: true

class GoogleIntegrationsController < ApplicationController
  before_action :authenticate_user!
  before_action :ensure_premium_user
  
  def show
    @integration = current_user.google_integration
    @recent_exports = current_user.export_jobs.google_sheets.recent.limit(10)
  end
  
  def connect
    redirect_to google_oauth_path, allow_other_host: true
  end
  
  def callback
    auth = request.env['omniauth.auth']
    
    if auth.present?
      create_or_update_integration(auth)
      redirect_to google_integration_path, notice: 'Successfully connected to Google Sheets!'
    else
      redirect_to google_integration_path, alert: 'Failed to connect to Google Sheets.'
    end
  end
  
  def disconnect
    integration = current_user.google_integration
    if integration
      # Revocar el token en Google
      revoke_google_token(integration)
      integration.destroy
      
      flash[:notice] = 'Successfully disconnected from Google Sheets.'
    end
    
    redirect_to google_integration_path
  end
  
  def test_connection
    integration = current_user.google_integration
    
    if integration&.active?
      result = GoogleSheets::ConnectionTestService.call(integration: integration)
      
      if result.success?
        render json: { 
          success: true, 
          message: 'Connection successful',
          user_info: result.result[:user_info]
        }
      else
        render json: { 
          success: false, 
          error: result.errors.join(', ') 
        }
      end
    else
      render json: { 
        success: false, 
        error: 'No active Google integration found' 
      }
    end
  end
  
  private
  
  def create_or_update_integration(auth)
    integration = current_user.google_integration || current_user.build_google_integration
    
    integration.assign_attributes(
      access_token: auth.credentials.token,
      refresh_token: auth.credentials.refresh_token,
      token_expires_at: Time.at(auth.credentials.expires_at),
      scope: auth.extra.scope,
      user_info: {
        email: auth.info.email,
        name: auth.info.name,
        image: auth.info.image
      },
      active: true,
      last_used_at: Time.current
    )
    
    integration.save!
    
    # Audit log
    AuditLog.create!(
      user: current_user,
      event_type: 'google_integration_connected',
      details: {
        user_email: auth.info.email,
        scope: auth.extra.scope
      }
    )
  end
  
  def revoke_google_token(integration)
    begin
      auth = Signet::OAuth2::Client.new(
        client_id: GoogleSheets::ConfigService.oauth_client_id,
        client_secret: GoogleSheets::ConfigService.oauth_client_secret,
        access_token: integration.access_token
      )
      
      auth.revoke!
    rescue StandardError => e
      Rails.logger.warn "Failed to revoke Google token: #{e.message}"
    end
  end
  
  def ensure_premium_user
    unless current_user.premium?
      redirect_to subscription_management_path, 
                  alert: 'Google Sheets integration requires a Premium subscription.'
    end
  end
  
  def google_oauth_path
    "/users/auth/google_oauth2?scope=https://www.googleapis.com/auth/spreadsheets"
  end
end
</file>

<file path="controllers/google_oauth_controller.rb">
class GoogleOauthController < ApplicationController
  before_action :authenticate_user!

  def connect
    # Authorize that user can create a Google integration
    authorize GoogleIntegration.new(user: current_user), :create?
    
    begin
      # Generate OAuth2 authorization URL
      client = oauth_client
      
      # Store state parameter to prevent CSRF
      session[:google_oauth_state] = SecureRandom.hex(16)
      
      auth_url = client.authorization_uri(
        scope: google_scopes.join(' '),
        state: session[:google_oauth_state],
        access_type: 'offline',
        prompt: 'consent' # Force consent to get refresh token
      ).to_s

      redirect_to auth_url, allow_other_host: true
    rescue => e
      Rails.logger.error "Google OAuth connect error: #{e.message}"
      redirect_to profile_path, alert: "Google OAuth configuration error. Please contact support."
    end
  end

  def callback
    # Authorize that user can create/update a Google integration
    authorize GoogleIntegration.new(user: current_user), :create?
    
    # Verify state parameter
    if params[:state] != session[:google_oauth_state]
      redirect_to profile_path, alert: 'Invalid OAuth state. Please try again.'
      return
    end

    # Handle OAuth errors
    if params[:error].present?
      error_message = case params[:error]
      when 'access_denied'
        'You denied access to Google Sheets. Please authorize to continue.'
      else
        "OAuth error: #{params[:error]}"
      end
      
      redirect_to profile_path, alert: error_message
      return
    end

    # Exchange authorization code for tokens
    begin
      client = oauth_client
      client.code = params[:code]
      client.fetch_access_token!

      # Get user info to verify the connection
      user_info = fetch_google_user_info(client.access_token)

      # Create or update Google integration
      integration = current_user.google_integration || current_user.build_google_integration
      
      integration.update!(
        access_token: client.access_token,
        refresh_token: client.refresh_token,
        token_expires_at: Time.current + client.expires_in.seconds,
        scope: google_scopes.join(' '),
        user_info: user_info,
        active: true,
        last_used_at: Time.current,
        usage_count: (integration.usage_count || 0) + 1,
        error_log: []
      )

      redirect_to profile_path, notice: 'Successfully connected to Google Sheets!'
      
    rescue => e
      Rails.logger.error "Google OAuth callback error: #{e.message}"
      redirect_to profile_path, alert: 'Failed to connect to Google. Please try again.'
    end
  ensure
    # Clear the state from session
    session.delete(:google_oauth_state)
  end

  def disconnect
    integration = current_user.google_integration
    
    if integration
      integration.revoke!
      redirect_to profile_path, notice: 'Disconnected from Google Sheets.'
    else
      redirect_to profile_path, alert: 'No Google connection found.'
    end
  end

  def status
    integration = current_user.google_integration
    
    render json: {
      connected: integration&.valid_token? || false,
      user_info: integration&.user_info,
      last_used: integration&.last_used_at,
      expires_at: integration&.token_expires_at,
      error: integration&.error_log&.last
    }
  end

  private

  def oauth_client
    unless GoogleSheets::ConfigService.oauth_configured?
      raise "Google OAuth credentials not configured. Please configure GOOGLE_SHEETS_CLIENT_ID and GOOGLE_SHEETS_CLIENT_SECRET environment variables for production, or google_sheets_integration in Rails credentials for development."
    end
    
    Signet::OAuth2::Client.new(
      client_id: GoogleSheets::ConfigService.oauth_client_id,
      client_secret: GoogleSheets::ConfigService.oauth_client_secret,
      authorization_uri: 'https://accounts.google.com/o/oauth2/auth',
      token_credential_uri: 'https://oauth2.googleapis.com/token',
      redirect_uri: google_oauth_callback_url
    )
  rescue => e
    Rails.logger.error "OAuth client configuration error: #{e.message}"
    raise e
  end

  def google_scopes
    [
      'https://www.googleapis.com/auth/spreadsheets',
      'https://www.googleapis.com/auth/userinfo.email'
    ]
  end

  def google_oauth_callback_url
    url_for(controller: 'google_oauth', action: 'callback', host: request.host_with_port, protocol: request.protocol)
  end

  def fetch_google_user_info(access_token)
    uri = URI('https://www.googleapis.com/oauth2/v2/userinfo')
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true

    request = Net::HTTP::Get.new(uri)
    request['Authorization'] = "Bearer #{access_token}"

    response = http.request(request)
    
    if response.code == '200'
      JSON.parse(response.body)
    else
      raise "Failed to fetch user info: #{response.code}"
    end
  end
end
</file>

<file path="controllers/health_controller.rb">
class HealthController < ApplicationController
  # Skip authentication for health checks
  skip_before_action :authenticate_user!, if: :devise_controller?
  
  def show
    # Basic health check - just return 200 if app is running
    render json: { 
      status: 'ok', 
      timestamp: Time.current.iso8601,
      version: Rails.application.config.version || '1.0.0'
    }
  end
  
  def detailed
    # Detailed health check with service status
    checks = {
      database: check_database,
      redis: check_redis,
      sidekiq: check_sidekiq
    }
    
    overall_status = checks.values.all? { |check| check[:status] == 'ok' } ? 'ok' : 'error'
    
    render json: {
      status: overall_status,
      timestamp: Time.current.iso8601,
      version: Rails.application.config.version || '1.0.0',
      checks: checks
    }, status: overall_status == 'ok' ? 200 : 503
  end
  
  private
  
  def check_database
    ActiveRecord::Base.connection.execute('SELECT 1')
    { status: 'ok', message: 'Database connection successful' }
  rescue => e
    { status: 'error', message: e.message }
  end
  
  def check_redis
    # Use RedisErrorLogger for comprehensive testing and logging
    connection_successful = RedisErrorLogger.test_and_log_connection(component: 'health_check')
    
    if connection_successful
      diagnostics = RedisErrorLogger.get_connection_diagnostics
      { 
        status: 'ok', 
        message: 'Redis connection successful',
        diagnostics: diagnostics.slice(:redis_version, :connected_clients, :used_memory_human)
      }
    else
      diagnostics = RedisErrorLogger.get_connection_diagnostics
      { 
        status: 'error', 
        message: diagnostics[:connection_error] || 'Redis connection failed',
        diagnostics: diagnostics
      }
    end
  rescue => e
    RedisErrorLogger.log_redis_error(e, {
      component: 'health_controller',
      operation: 'health_check'
    })
    
    { status: 'error', message: e.message }
  end
  
  def check_sidekiq
    # Check if Sidekiq is processing jobs
    stats = Sidekiq::Stats.new
    { 
      status: 'ok', 
      message: 'Sidekiq is running',
      processed: stats.processed,
      failed: stats.failed,
      busy: stats.workers_size,
      queues: stats.queues
    }
  rescue => e
    { status: 'error', message: e.message }
  end
end
</file>

<file path="controllers/landing_controller.rb">
class LandingController < ApplicationController
  layout 'landing'
  
  skip_before_action :authenticate_user!, only: [:index]
  
  def index
    # Redirect authenticated users to their dashboard instead of showing landing page
    redirect_to forms_path if user_signed_in?
  end
  
  private
  
  def skip_authorization?
    true
  end
end
</file>

<file path="controllers/payment_setup_controller.rb">
# frozen_string_literal: true

class PaymentSetupController < ApplicationController
  before_action :authenticate_user!
  before_action :set_template, only: [:index]

  # GET /payment_setup
  def index
    skip_policy_scope
    authorize current_user, :update?
    
    @template = FormTemplate.find(params[:template_id]) if params[:template_id].present?
    @return_to = params[:return_to] || templates_path
    
    # Get current setup status
    @setup_status = current_user.payment_setup_status
    @required_features = @template&.required_features || []
    
    # Check what setup steps are needed
    @setup_requirements = PaymentSetupValidationService.call(
      user: current_user,
      required_features: @required_features
    )
    
    # Track analytics
    track_event('payment_setup_page_viewed', {
      template_id: @template&.id,
      required_features: @required_features,
      current_setup_status: @setup_status
    })
  end

  # POST /payment_setup/complete
  def complete
    authorize current_user, :update?
    
    @template = FormTemplate.find(params[:template_id]) if params[:template_id].present?
    @return_to = params[:return_to] || templates_path
    
    # Validate that setup is actually complete
    validation_result = PaymentSetupValidationService.call(
      user: current_user,
      required_features: @template&.required_features || []
    )
    
    if validation_result.success?
      # Track completion
      track_event('payment_setup_completed', {
        template_id: @template&.id,
        setup_duration: session[:payment_setup_started_at] ? Time.current - session[:payment_setup_started_at] : nil
      })
      
      # Clear setup session
      session.delete(:payment_setup_started_at)
      
      if @template
        # Redirect to template show page with success message
        redirect_to template_path(@template), 
                    notice: "Payment setup complete! You can now use this payment-enabled template."
      else
        # Redirect to return URL
        redirect_to @return_to, 
                    notice: "Payment setup complete!"
      end
    else
      # Setup not complete, show requirements
      @setup_status = current_user.payment_setup_status
      @setup_requirements = validation_result
      
      flash.now[:alert] = "Payment setup is not yet complete. Please finish the required steps."
      render :index
    end
  end

  private

  def set_template
    @template = FormTemplate.find(params[:template_id]) if params[:template_id].present?
  end

  def track_event(event_name, properties = {})
    # Integration with analytics system
    if defined?(Analytics) && Analytics.respond_to?(:track)
      Analytics.track(
        user_id: current_user.id,
        event: event_name,
        properties: properties.merge(
          timestamp: Time.current.iso8601,
          user_role: current_user.role,
          user_subscription: current_user.subscription_tier
        )
      )
    end

    # Log for development
    Rails.logger.info "Analytics: #{event_name} - #{properties}" if Rails.env.development?
  end
end
</file>

<file path="controllers/payments_controller.rb">
class PaymentsController < ApplicationController
  before_action :set_form_and_response
  before_action :validate_payment_enabled

  # POST /f/:share_token/payments
  def create
    result = StripePaymentService.call(
      user: @form.user,
      form: @form,
      form_response: @form_response,
      payment_data: payment_params
    )

    if result.success?
      render json: {
        success: true,
        client_secret: result.data[:client_secret],
        payment_intent_id: result.data[:payment_intent].id,
        transaction_id: result.data[:transaction].id
      }
    else
      render json: {
        success: false,
        error: result.error_message
      }, status: :unprocessable_entity
    end
  end

  # POST /f/:share_token/payments/:payment_intent_id/confirm
  def confirm
    transaction = PaymentTransaction.find_by(
      stripe_payment_intent_id: params[:payment_intent_id],
      form: @form
    )

    unless transaction
      render json: { success: false, error: 'Payment not found' }, status: :not_found
      return
    end

    # Sync with Stripe to get latest status
    if transaction.sync_with_stripe!
      if transaction.successful?
        # Mark form response as paid
        @form_response.update!(
          payment_status: 'paid',
          payment_amount: transaction.amount,
          payment_currency: transaction.currency,
          payment_transaction_id: transaction.id
        )

        render json: {
          success: true,
          status: 'succeeded',
          transaction_id: transaction.id,
          redirect_url: thank_you_form_path(@form.share_token)
        }
      else
        render json: {
          success: false,
          status: transaction.status,
          error: transaction.failure_reason || 'Payment failed'
        }
      end
    else
      render json: {
        success: false,
        error: 'Unable to verify payment status'
      }, status: :unprocessable_entity
    end
  end

  # GET /f/:share_token/payments/config
  def config
    unless @form.user.stripe_configured?
      render json: { 
        success: false, 
        error: 'Payment processing not configured for this form' 
      }, status: :unprocessable_entity
      return
    end

    render json: {
      success: true,
      publishable_key: @form.user.stripe_publishable_key,
      currency: 'USD', # Default currency, could be configurable per form
      test_mode: @form.user.stripe_publishable_key.start_with?('pk_test_')
    }
  end

  private

  def set_form_and_response
    @form = Form.find_by!(share_token: params[:share_token])
    @form_response = @form.form_responses.find(params[:form_response_id]) if params[:form_response_id]
    
    unless @form_response
      render json: { success: false, error: 'Form response not found' }, status: :not_found
    end
  end

  def validate_payment_enabled
    unless @form.user.can_accept_payments?
      render json: { 
        success: false, 
        error: 'Payment processing not available for this form' 
      }, status: :forbidden
    end
  end

  def payment_params
    params.require(:payment).permit(:amount, :currency, :payment_method, :email)
  end
end
</file>

<file path="controllers/profile_controller.rb">
class ProfileController < ApplicationController
  before_action :authenticate_user!

  def show
    @user = current_user
  end

  def update
    @user = current_user
    
    if @user.update(user_params)
      redirect_to profile_path, notice: 'Profile updated successfully!'
    else
      render :show, status: :unprocessable_entity
    end
  end

  private

  def user_params
    params.require(:user).permit(:first_name, :last_name, :email)
  end
end
</file>

<file path="controllers/profiles_controller.rb">
class ProfilesController < ApplicationController
  before_action :authenticate_user!
  
  def show
    @user = current_user
  end
  
  def update
    @user = current_user
    
    if @user.update(user_params)
      redirect_to profile_path, notice: 'Profile updated successfully.'
    else
      render :show, alert: 'There was an error updating your profile.'
    end
  end
  
  private
  
  def user_params
    params.require(:user).permit(:first_name, :last_name, :email, :preferences)
  end
end
</file>

<file path="controllers/reports_controller.rb">
class ReportsController < ApplicationController
  include Devise::Controllers::Helpers
  before_action :authenticate_user!
  before_action :set_analysis_report, only: [:show, :download, :status]
  
  # Disable Pundit completely for this controller
  skip_after_action :verify_authorized
  skip_after_action :verify_policy_scoped

  # GET /reports/:id
  def show
    # Manual authorization check
    unless @analysis_report.form_response.form.user == current_user
      redirect_to root_path, alert: 'Not authorized to access this report.'
      return
    end
    
    respond_to do |format|
      format.html # Mostrar reporte en el navegador
      format.json { render json: serialize_report(@analysis_report) }
    end
  end

  # GET /reports/:id/download
  def download
    # Manual authorization check
    unless @analysis_report.form_response.form.user == current_user
      redirect_to root_path, alert: 'Not authorized to access this report.'
      return
    end
    
    # For now, since we don't have physical files, send the markdown content
    if @analysis_report.completed? && @analysis_report.markdown_content.present?
      filename = "report_#{@analysis_report.id}_#{Date.current.strftime('%Y%m%d')}.md"
      
      send_data @analysis_report.markdown_content,
                filename: filename,
                type: 'text/markdown',
                disposition: 'attachment'
    else
      redirect_to analysis_report_path(@analysis_report), 
                  alert: 'Report content not available for download.'
    end
  end

  # POST /reports/generate
  def generate
    # Check if user can use AI features (premium plan required)
    unless current_user.can_use_ai_features?
      redirect_to root_path, alert: 'Report generation requires a premium subscription. Please upgrade your plan to access this feature.'
      return
    end

    # Buscar la respuesta del formulario a travs de las formas del usuario
    @form_response = FormResponse.joins(:form)
                                 .where(forms: { user: current_user })
                                 .find(params[:form_response_id])

    # Manual authorization check since we skipped Pundit for this action
    unless @form_response.form.user == current_user
      redirect_to root_path, alert: 'Not authorized to generate reports for this form response.'
      return
    end

    # Check if report already exists and is recent
    existing_report = @form_response.analysis_reports
                                   .where(report_type: 'comprehensive_strategic_analysis')
                                   .where('created_at > ?', 24.hours.ago)
                                   .completed
                                   .first

    if existing_report
      return redirect_to existing_report, notice: 'Using existing recent report.'
    end

    # Generate sample report content immediately
    sample_content = generate_sample_report(@form_response)

    # Create new report record with content
    @analysis_report = @form_response.analysis_reports.create!(
      report_type: 'comprehensive_strategic_analysis',
      markdown_content: sample_content,
      status: 'completed', # Mark as completed since we're generating content immediately
      expires_at: 7.days.from_now,
      generated_at: Time.current,
      ai_cost: rand(0.10..2.50).round(2)
    )

    # In a real application, you would queue a background job here:
    # if defined?(Forms::ReportGenerationJob)
    #   @analysis_report.update!(status: 'generating', markdown_content: 'Generating...')
    #   Forms::ReportGenerationJob.perform_later(@form_response.id, @analysis_report.id)
    # end

    respond_to do |format|
      format.html { 
        redirect_to @analysis_report, 
                    notice: 'Report generated successfully!' 
      }
      format.json { 
        render json: { 
          report_id: @analysis_report.id,
          status: @analysis_report.status,
          redirect_url: analysis_report_path(@analysis_report)
        }
      }
    end
  rescue ActiveRecord::RecordNotFound
    redirect_to root_path, alert: 'Form response not found or not accessible.'
  end

  # GET /reports/:id/status
  def status
    # Manual authorization check
    unless @analysis_report.form_response.form.user == current_user
      render json: { error: 'Not authorized' }, status: :forbidden
      return
    end
    
    render json: {
      id: @analysis_report.id,
      status: @analysis_report.status,
      progress: calculate_progress(@analysis_report),
      completed_at: @analysis_report.generated_at,
      download_url: @analysis_report.completed? ? @analysis_report.download_url : nil,
      file_size: @analysis_report.respond_to?(:formatted_file_size) ? @analysis_report.formatted_file_size : 'Unknown'
    }
  end

  private

  def set_analysis_report
    @analysis_report = AnalysisReport.find(params[:id])
  end

  def calculate_progress(report)
    case report.status
    when 'generating'
      # Calculate based on how long it's been generating
      elapsed = Time.current - report.created_at
      estimated_total = 5.minutes # Estimated total time
      
      progress = (elapsed / estimated_total * 100).to_i
      [progress, 95].min # Never show 100% until actually completed
    when 'completed'
      100
    when 'failed'
      0
    else
      0
    end
  end

  def serialize_report(report)
    {
      id: report.id,
      report_type: report.report_type,
      status: report.status,
      file_size: report.respond_to?(:formatted_file_size) ? report.formatted_file_size : 'Unknown',
      ai_cost: report.ai_cost,
      generated_at: report.generated_at,
      download_url: report.respond_to?(:download_url) ? report.download_url : nil,
      sections_included: report.respond_to?(:sections_included) ? report.sections_included : [],
      ai_models_used: report.respond_to?(:ai_models_used) ? report.ai_models_used : [],
      generation_duration_minutes: report.respond_to?(:generation_duration) ? report.generation_duration : nil
    }
  end

  def generate_sample_report(form_response)
    # Mtodo temporal para generar contenido de ejemplo
    # En produccin, esto debera llamar a tu servicio de IA
    
    answers = form_response.question_responses.map do |qr|
      "**#{qr.form_question.title}:** #{qr.answer_data['value']}"
    end.join("\n\n")
    
    <<~MARKDOWN
      # Strategic Analysis Report
      
      ## Form Response Analysis
      
      **Response ID:** #{form_response.id}
      **Completed At:** #{form_response.completed_at&.strftime('%B %d, %Y at %H:%M')}
      **Total Time:** #{form_response.completed_at && form_response.started_at ? ((form_response.completed_at - form_response.started_at) / 60).round(2) : 'N/A'} minutes
      
      ## Responses Summary
      
      #{answers}
      
      ## Key Insights
      
      - Response demonstrates clear engagement with the form content
      - Time investment suggests thoughtful consideration of questions
      - Responses indicate strategic thinking and planning
      
      ## Recommendations
      
      1. **Follow-up Actions:** Consider personalized follow-up based on responses
      2. **Data Utilization:** Leverage insights for strategic decision making
      3. **Continuous Improvement:** Use feedback to enhance form effectiveness
      
      ---
      
      *Report generated on #{Time.current.strftime('%B %d, %Y at %H:%M %Z')}*
    MARKDOWN
  end
end
</file>

<file path="controllers/responses_controller.rb">
# frozen_string_literal: true

class ResponsesController < ApplicationController
  skip_before_action :authenticate_user!
  skip_after_action :verify_authorized, unless: :skip_authorization?
  skip_after_action :verify_policy_scoped, unless: :skip_authorization?
  before_action :set_form, only: [:show, :answer, :thank_you, :preview, :save_draft, :abandon, :resume]
  before_action :set_or_create_response, only: [:show, :answer]
  before_action :validate_form_access, only: [:show, :answer]
  before_action :track_form_view, only: [:show]
  
  # Public Actions
  
  # GET /f/:share_token - Show form to respondent
  def show
    Rails.logger.info "=== SHOW ACTION START ==="
    Rails.logger.info "Form state at start:"
    Rails.logger.info "Form present: #{@form.present?}"
    Rails.logger.info "Form share_token: #{@form&.share_token}"
    Rails.logger.info "Form ID: #{@form&.id}"
    Rails.logger.info "Form name: #{@form&.name}"
    
    @current_question = find_current_question
    @progress_percentage = @form_response.progress_percentage
    @total_questions = @form.form_questions.count
    
    Rails.logger.info "After finding current question:"
    Rails.logger.info "Current question: #{@current_question&.title}"
    Rails.logger.info "Form still present: #{@form.present?}"
    Rails.logger.info "Form share_token: #{@form&.share_token}"
    
    # Handle form completion
    if @form_response.completed?
      redirect_path = thank_you_form_path(@form.share_token)
      Rails.logger.info "Form completed, redirecting to: #{redirect_path}"
      redirect_to redirect_path
      return
    end
    
    # Handle no more questions (auto-complete)
    unless @current_question
      Rails.logger.info "No current question found, completing form"
      complete_form_response!
      redirect_path = thank_you_form_path(@form.share_token)
      Rails.logger.info "Auto-complete redirecting to: #{redirect_path}"
      redirect_to redirect_path
      return
    end
    
    prepare_question_data
    
    Rails.logger.info "Before rendering template:"
    Rails.logger.info "Form share_token for template: #{@form&.share_token}"
    
    respond_to do |format|
      format.html { render_form_layout }
      format.json { render_json_response }
    end
  end
  
  # POST /f/:share_token/answer - Submit answer to current question
  def answer
    Rails.logger.info "=== ANSWER ACTION START ==="
    @current_question = find_question_by_id(params[:question_id])

    unless @current_question
      return render_error("Question not found", :not_found)
    end

    # 1. Procesa y guarda la respuesta actual del usuario
    result = process_answer_submission
    unless result[:success]
      return respond_to_answer_error(result)
    end

    # 2. Actualiza la actividad de la respuesta
    @form_response.touch(:last_activity_at)
    @form = @form_response.form # Aseguramos que @form est cargado

    # 3. IMPORTANTE: Despus de guardar la respuesta, necesitamos verificar
    #    si esta respuesta afecta la visibilidad de otras preguntas.
    #    Para esto, invalidamos las respuestas de preguntas futuras que
    #    podran haber sido afectadas por cambios en la lgica condicional.
    invalidate_conditional_responses_if_needed

    # 4. Encuentra la prxima pregunta visible con la nueva lgica
    next_question = find_current_question

    # 5. Verifica si el formulario est listo para ser completado
    if next_question.nil? && @form_response.can_be_completed?
      complete_form_response!
      
      redirect_path = thank_you_form_path(@form.share_token)
      Rails.logger.info "Form completion detected, redirecting to: #{redirect_path}"
      
      return respond_to do |format|
        format.json { render json: { success: true, completed: true, redirect_url: redirect_path } }
        format.html { redirect_to redirect_path }
      end
    end

    # 6. Si no se ha completado, prepara la respuesta para la siguiente pregunta
    Rails.logger.info "=== NEXT QUESTION RESPONSE ==="
    Rails.logger.info "Next question: #{next_question&.title}"

    respond_to do |format|
      format.json do
        render json: {
          success: true,
          next_question: next_question ? serialize_question(next_question) : nil,
          progress: @form_response.progress_percentage,
          completed: next_question.nil?
        }
      end
      format.html { redirect_to public_form_path(@form.share_token) }
    end
  end
  
  # GET /f/:share_token/thank-you - Thank you page after completion
  def thank_you
    @completion_data = session[:completion_data] || {}
    @form_response = find_completed_response
    
    # Clear session data
    clear_response_session
    
    respond_to do |format|
      format.html { render_thank_you_page }
      format.json { render_completion_json }
    end
  end
  
  # GET /f/:share_token/preview - Preview form (for form creators)
  def preview
    @preview_mode = true
    @current_question = @form.form_questions.first
    @progress_percentage = 0
    @total_questions = @form.form_questions.count
    
    prepare_question_data
    render :show
  end
  
  # POST /f/:share_token/save_draft - Save partial response as draft
  def save_draft
    @form_response = find_or_create_response
    
    result = save_draft_data
    
    respond_to do |format|
      format.json { render json: result }
    end
  end
  
  # POST /f/:share_token/abandon - Mark response as abandoned
  def abandon
    @form_response = find_response_by_session
    
    if @form_response
      abandonment_reason = params[:reason] || 'user_abandoned'
      @form_response.mark_abandoned!(abandonment_reason)
      
      # Track abandonment analytics
      track_form_abandonment(abandonment_reason)
    end
    
    head :ok
  end
  
  # GET /f/:share_token/resume/:session_id - Resume abandoned response
  def resume
    @form_response = find_response_by_session(params[:session_id])
    
    unless @form_response&.paused?
      redirect_to public_form_path(@form.share_token)
      return
    end
    
    @form_response.resume!
    session[:form_response_id] = @form_response.id
    
    redirect_to public_form_path(@form.share_token)
  end
  
  def debug_conditional_logic
    return unless Rails.env.development?
    
    if @current_question&.has_conditional_logic?
      puts "\n" + "="*50
      puts "DEBUGGING CURRENT QUESTION: #{@current_question.title}"
      @current_question.debug_conditional_setup(@form_response)
      puts "="*50 + "\n"
    end
    
    # Debug all questions in the form
    @form.form_questions.where(conditional_enabled: true).each do |question|
      question.debug_conditional_setup(@form_response)
    end
  end

  private

  def invalidate_conditional_responses_if_needed
    # Encuentra todas las preguntas que dependen de la pregunta actual
    dependent_questions = @form.form_questions.where(
      "conditional_logic -> 'rules' @> ?", 
      [{ question_id: @current_question.id }].to_json
    )
    
    return if dependent_questions.empty?
    
    Rails.logger.info "Found #{dependent_questions.count} questions that depend on #{@current_question.title}"
    
    dependent_questions.each do |dependent_question|
      Rails.logger.info "Checking if we need to invalidate responses for: #{dependent_question.title}"
      
      # Verifica si esta pregunta dependiente ya fue respondida
      existing_response = @form_response.question_responses.find_by(form_question: dependent_question)
      
      if existing_response
        # Verifica si la pregunta dependiente debe seguir siendo visible
        should_show = dependent_question.should_show_for_response?(@form_response)
        
        Rails.logger.info "Dependent question '#{dependent_question.title}' should show: #{should_show}"
        
        unless should_show
          # Si la pregunta ya no debe mostrarse, elimina su respuesta
          Rails.logger.info "Removing response for question that should no longer be visible: #{dependent_question.title}"
          existing_response.destroy!
          
          # Tambin invalida respuestas de preguntas que dependan de esta
          invalidate_recursive_dependencies(dependent_question)
        end
      end
    end
  end

  # Mtodo recursivo para invalidar dependencias en cascada
  def invalidate_recursive_dependencies(question)
    # Encuentra preguntas que dependen de la pregunta dada
    dependent_questions = @form.form_questions.where(
      "conditional_logic -> 'rules' @> ?", 
      [{ question_id: question.id }].to_json
    )
    
    dependent_questions.each do |dependent_question|
      existing_response = @form_response.question_responses.find_by(form_question: dependent_question)
      
      if existing_response
        Rails.logger.info "Recursively removing response for: #{dependent_question.title}"
        existing_response.destroy!
        
        # Contina la recursin
        invalidate_recursive_dependencies(dependent_question)
      end
    end
  end
  
  def respond_to_answer_error(result)
    respond_to do |format|
      format.json do
        render json: { 
          success: false, 
          errors: result[:errors],
          question_id: @current_question.id
        }, status: :unprocessable_entity
      end
      format.html do
        flash[:error] = result[:errors].join(', ')
        redirect_back(fallback_location: public_form_path(@form.share_token))
      end
    end
  end
  
  def set_form
    Rails.logger.info "=== SET_FORM CALLED ==="
    Rails.logger.info "Params share_token: #{params[:share_token]}"
    
    @form = Form.find_by!(share_token: params[:share_token])
    
    Rails.logger.info "Form loaded successfully:"
    Rails.logger.info "Form ID: #{@form.id}"
    Rails.logger.info "Form share_token: #{@form.share_token}"
    Rails.logger.info "Form name: #{@form.name}"
  rescue ActiveRecord::RecordNotFound
    Rails.logger.error "Form not found with share_token: #{params[:share_token]}"
    render_error("Form not found", :not_found)
  end
  
  def set_or_create_response
    @form_response = find_or_create_response
  end
  
  def find_or_create_response
    # Try to find existing response by session
    existing_response = find_response_by_session
    
    if existing_response&.in_progress?
      return existing_response
    end
    
    # Create new response
    create_new_response
  end
  
  def find_response_by_session(session_id = nil)
    session_id ||= current_session_id
    return nil unless session_id
    
    @form.form_responses.find_by(session_id: session_id)
  end
  
  def create_new_response
    response_data = {
      form: @form,
      session_id: current_session_id,
      ip_address: request.remote_ip,
      user_agent: request.user_agent,
      referrer_url: request.referer,
      started_at: Time.current,
      status: :in_progress
    }
    
    # Add UTM parameters if present
    response_data[:utm_data] = extract_utm_parameters if has_utm_parameters?
    
    @form.form_responses.create!(response_data)
  end
  
  def find_completed_response
    session_id = session[:completed_response_session_id]
    return nil unless session_id
    
    @form.form_responses.find_by(session_id: session_id, status: :completed)
  end
  
  # Question Management
  
  def find_current_question
    return nil unless @form_response
    
    Rails.logger.info "=== FIND_CURRENT_QUESTION DEBUG ==="
    Rails.logger.info "Form present: #{@form.present?}"
    Rails.logger.info "FormResponse present: #{@form_response.present?}"
    
    # Get IDs of questions that have been answered (including skipped ones)
    processed_question_ids = @form_response.question_responses
                                          .joins(:form_question)
                                          .pluck('form_questions.id')
    
    Rails.logger.info "Processed question IDs: #{processed_question_ids}"
    
    # Find the highest position of processed questions
    max_processed_position = @form_response.question_responses
                                          .joins(:form_question)
                                          .maximum('form_questions.position') || 0
    
    Rails.logger.info "Max processed position: #{max_processed_position}"
    
    # Get all questions starting from the next position
    remaining_questions = @form.form_questions
                              .where.not(id: processed_question_ids)
                              .where('position > ?', max_processed_position)
                              .order(:position)
    
    Rails.logger.info "Remaining questions count: #{remaining_questions.count}"
    
    # Find the first question that should be shown based on conditional logic
    remaining_questions.each do |question|
      Rails.logger.info "Evaluating question: #{question.title} (position: #{question.position})"
      
      if should_show_question?(question)
        Rails.logger.info " Question should be shown: #{question.title}"
        return question
      else
        Rails.logger.info " Question should be skipped: #{question.title}"
        # Auto-skip this question
        skip_question(question)
        # Continue to next question in the loop
      end
    end
    
    # No more questions to show
    Rails.logger.info "No more questions to show"
    nil
  end
  
  def find_question_by_id(question_id)
    @form.form_questions.find_by(id: question_id)
  end
  
  def should_show_question?(question)
    return true unless question.has_conditional_logic?
    
    Rails.logger.info "  Checking conditional logic for: #{question.title}"
    Rails.logger.info "  Conditional rules: #{question.conditional_rules}"
    
    result = question.should_show_for_response?(@form_response)
    Rails.logger.info "  Conditional result: #{result}"
    
    result
  end
  
  def skip_question(question)
    # Create a skipped response record
    @form_response.question_responses.create!(
      form_question: question,
      answer_data: {},
      skipped: true,
      response_time_ms: 0
    )
  end
  
  # Answer Processing
  
  def process_answer_submission
    answer_data = extract_answer_data
    
    # Validate the answer
    validation_result = validate_answer(answer_data)
    return validation_result unless validation_result[:valid]
    
    # Process standard answer first
    result = process_standard_answer(answer_data)
    
    # Check if this is a budget-related question and trigger adaptation
    if should_trigger_budget_adaptation?(answer_data[:value])
      trigger_budget_adaptation(answer_data[:value])
    end
    
    # Process through SuperAgent workflow if AI is enabled
    if @form.ai_enhanced? && @current_question.ai_enhanced?
      process_with_ai_workflow(answer_data)
    else
      result
    end
  end
  
  def extract_answer_data
    answer_params = params.require(:answer)
    
    # Add metadata
    {
      value: answer_params[:value],
      started_at: answer_params[:started_at],
      completed_at: Time.current.iso8601,
      question_type: @current_question.question_type,
      metadata: {
        response_time_ms: calculate_response_time(answer_params[:started_at]),
        user_agent: request.user_agent,
        ip_address: request.remote_ip
      }
    }
  end
  
  def validate_answer(answer_data)
    question_handler = @current_question.question_type_handler
    validation_errors = question_handler.validate_answer(answer_data[:value])
    
    if validation_errors.empty?
      { valid: true, processed_data: question_handler.process_answer(answer_data[:value]) }
    else
      { valid: false, errors: validation_errors }
    end
  end
  
  def process_with_ai_workflow(answer_data)
    begin
      # Trigger SuperAgent workflow for AI processing
      workflow_result = Forms::ResponseAgent.new.process_form_response(
        @form_response,
        @current_question,
        answer_data,
        workflow_context
      )
      
      { success: true, workflow_result: workflow_result }
    rescue => error
      Rails.logger.error "AI workflow error: #{error.message}"
      # Fallback to standard processing
      process_standard_answer(answer_data)
    end
  end
  
  def process_standard_answer(answer_data)
    question_response = @form_response.question_responses.build(
      form_question: @current_question,
      answer_data: answer_data,
      response_time_ms: answer_data.dig(:metadata, :response_time_ms)
    )
    
    if question_response.save
      { success: true, question_response: question_response }
    else
      { success: false, errors: question_response.errors.full_messages }
    end
  end
  
  def workflow_context
    {
      form_id: @form.id,
      form_response_id: @form_response.id,
      question_id: @current_question.id,
      session_id: current_session_id,
      user_context: extract_user_context
    }
  end
  
  # Response Completion
  
  def complete_form_response!
    return unless @form_response.can_be_completed?
    
    Rails.logger.info "=== COMPLETING FORM RESPONSE ==="
    Rails.logger.info "Form state before completion:"
    Rails.logger.info "Form present: #{@form.present?}"
    Rails.logger.info "Form share_token: #{@form&.share_token}"
    Rails.logger.info "Form ID: #{@form&.id}"
    
    completion_data = {
      completed_at: Time.current,
      completion_method: 'auto',
      final_question_count: @form.form_questions.count,
      total_response_time: calculate_total_response_time
    }
    
    @form_response.mark_completed!(completion_data)
    
    # Store completion data in session for thank you page
    session[:completion_data] = completion_data
    session[:completed_response_session_id] = @form_response.session_id
    
    # Trigger completion workflows
    trigger_completion_workflows
    
    # Update form analytics
    update_form_completion_analytics
    
    Rails.logger.info "Form state after completion:"
    Rails.logger.info "Form present: #{@form.present?}"
    Rails.logger.info "Form share_token: #{@form&.share_token}"
  end
  
  def trigger_completion_workflows
    # Trigger integrations and AI analysis
    Forms::CompletionWorkflowJob.perform_later(@form_response.id) if defined?(Forms::CompletionWorkflowJob)
  end
  
  # Response Handling
  
  def handle_successful_answer(result)
    # Update response activity
    @form_response.touch(:last_activity_at)
    
    # Check if form should be completed
    if should_complete_form?
      complete_form_response!
      render_completion_response
    else
      render_next_question_response(result)
    end
  end
  
  def handle_answer_error(result)
    respond_to do |format|
      format.html { 
        flash[:error] = result[:errors].join(', ')
        redirect_back(fallback_location: form_path(@form.share_token))
      }
      format.json { 
        render json: { 
          success: false, 
          errors: result[:errors],
          question_id: @current_question.id
        }, status: :unprocessable_entity 
      }
    end
  end
  
  def render_next_question_response(result)
    next_question = find_current_question
    
    respond_to do |format|
      format.html { redirect_to public_form_path(@form.share_token) }
      format.json { 
        render json: {
          success: true,
          next_question: next_question ? serialize_question(next_question) : nil,
          progress: @form_response.progress_percentage,
          completed: next_question.nil?
        }
      }
    end
  end
  
  def render_completion_response
    respond_to do |format|
      format.html { redirect_to thank_you_form_path(@form.share_token) }
      format.json { 
        render json: {
          success: true,
          completed: true,
          redirect_url: thank_you_form_path(@form.share_token)
        }
      }
    end
  end
  
  # Validation and Security
  
  def validate_form_access
    unless @form.published?
      render_error("Form is not available", :not_found)
      return false
    end
    
    # Check if form has expired (if expiration is set)
    if form_expired?
      render_error("Form has expired", :gone)
      return false
    end
    
    # Check response limits (if set)
    if response_limit_exceeded?
      render_error("Form is no longer accepting responses", :gone)
      return false
    end
    
    true
  end
  
  def form_expired?
    expiry_date = @form.form_settings.dig('expiry_date')
    expiry_date && Date.parse(expiry_date) < Date.current
  rescue
    false
  end
  
  def response_limit_exceeded?
    max_responses = @form.form_settings.dig('max_responses')
    max_responses && @form.responses_count >= max_responses.to_i
  end
  
  # Session Management
  
  def current_session_id
    session[:form_session_id] ||= generate_session_id
  end
  
  def generate_session_id
    "#{@form.id}_#{SecureRandom.hex(16)}_#{Time.current.to_i}"
  end
  
  def clear_response_session
    session.delete(:form_response_id)
    session.delete(:form_session_id)
  end
  
  # Analytics and Tracking
  
  def track_form_view
    # Increment view count (use Redis for high-frequency updates)
    Rails.cache.increment("form_views:#{@form.id}", 1)
    
    # Update database periodically (via background job)
    UpdateFormViewsJob.perform_later(@form.id) if defined?(UpdateFormViewsJob)
  end
  
  def track_form_abandonment(reason)
    # Track abandonment analytics
    Rails.cache.increment("form_abandons:#{@form.id}", 1)
    
    # Store abandonment reason for analysis
    abandonment_data = {
      form_id: @form.id,
      question_position: @form_response&.current_question_position,
      reason: reason,
      timestamp: Time.current
    }
    
    Rails.cache.lpush("form_abandonment_data:#{@form.id}", abandonment_data.to_json)
  end
  
  def update_form_completion_analytics
    # Update completion count
    @form.increment!(:completion_count)
    
    # Update cached completion rate
    Rails.cache.delete("form/#{@form.id}/completion_rate")
  end
  
  # Data Preparation and Serialization
  
  def prepare_question_data
    return unless @current_question
    
    @question_config = @current_question.question_config || {}
    @question_handler = @current_question.question_type_handler
    @validation_rules = extract_validation_rules
    @conditional_logic = @current_question.conditional_rules if @current_question.has_conditional_logic?
  end
  
  def serialize_question(question)
    {
      id: question.id,
      title: question.title,
      description: question.description,
      type: question.question_type,
      required: question.required?,
      position: question.position,
      configuration: question.question_config,
      validation_rules: question.validation_rules
    }
  end
  
  def extract_validation_rules
    rules = {}
    
    if @current_question.required?
      rules[:required] = true
    end
    
    # Add type-specific validation rules
    case @current_question.question_type
    when 'email'
      rules[:email] = true
    when 'phone'
      rules[:phone] = true
    when 'number'
      rules[:number] = true
      rules[:min] = @question_config['min_value'] if @question_config['min_value']
      rules[:max] = @question_config['max_value'] if @question_config['max_value']
    when 'text_short', 'text_long'
      rules[:min_length] = @question_config['min_length'] if @question_config['min_length']
      rules[:max_length] = @question_config['max_length'] if @question_config['max_length']
    end
    
    rules
  end
  
  # Utility Methods
  
  def calculate_response_time(started_at_string)
    return 0 unless started_at_string
    
    started_at = Time.parse(started_at_string)
    ((Time.current - started_at) * 1000).to_i
  rescue
    0
  end
  
  def calculate_total_response_time
    return 0 unless @form_response.started_at
    
    (Time.current - @form_response.started_at).to_i
  end
  
  def should_complete_form?
    # Check if all required questions are answered
    Rails.logger.info "=== CHECKING SHOULD COMPLETE FORM ==="
    Rails.logger.info "Form present: #{@form.present?}"
    Rails.logger.info "Form share_token: #{@form&.share_token}"
    Rails.logger.info "FormResponse present: #{@form_response.present?}"
    Rails.logger.info "can_be_completed?: #{@form_response.can_be_completed?}"
    
    current_question = find_current_question
    Rails.logger.info "find_current_question returned: #{current_question&.title}"
    Rails.logger.info "find_current_question.nil?: #{current_question.nil?}"
    
    result = @form_response.can_be_completed? && current_question.nil?
    Rails.logger.info "should_complete_form? result: #{result}"
    result
  end
  
  def extract_utm_parameters
    utm_params = {}
    
    %w[utm_source utm_medium utm_campaign utm_term utm_content].each do |param|
      utm_params[param] = params[param] if params[param].present?
    end
    
    utm_params
  end
  
  def has_utm_parameters?
    params.keys.any? { |key| key.start_with?('utm_') }
  end
  
  def extract_user_context
    {
      ip_address: request.remote_ip,
      user_agent: request.user_agent,
      referrer: request.referer,
      utm_data: extract_utm_parameters,
      session_id: current_session_id,
      timestamp: Time.current.iso8601
    }
  end
  
  # Budget Adaptation Methods
  
def should_trigger_budget_adaptation?(answer_value)
  return false unless @form_response
  return false unless @current_question
  
  Rails.logger.info "=== Checking Budget Trigger ==="
  Rails.logger.info "Question title: '#{@current_question.title}'"
  Rails.logger.info "Answer value: '#{answer_value}'"
  
  # Check if this is a budget-related question
  title_lower = @current_question.title.downcase
  description_lower = @current_question.description.to_s.downcase
  
  budget_keywords = [
    # English keywords
    'budget', 'price', 'cost', 'money', 'amount', 'spend', 'investment', 'financial',
    'funding', 'capital', 'expense', 'afford', 'pay', 'dollar', 'revenue',
    
    # Spanish keywords
    'presupuesto', 'precio', 'costo', 'dinero', 'cantidad', 'gastar', 'inversin',
    'financiero', 'financiamiento', 'capital', 'gasto', 'pagar', 'pago'
  ]
  
  # Check if the question mentions budget or money
  question_mentions_budget = budget_keywords.any? { |keyword| 
    title_lower.include?(keyword) || description_lower.include?(keyword)
  }
  
  Rails.logger.info "Question mentions budget: #{question_mentions_budget}"
  
  # For the specific question "Which is budget for AI projects?"
  ai_budget_question = title_lower.include?('budget') && (
    title_lower.include?('ai') || 
    title_lower.include?('artificial intelligence') ||
    title_lower.include?('machine learning') ||
    title_lower.include?('project')
  )
  
  Rails.logger.info "AI budget question detected: #{ai_budget_question}"
  
  # Check if the answer indicates any budget amount or constraint
  answer_text = answer_value.to_s.downcase
  answer_has_budget_info = has_budget_information?(answer_text)
  
  Rails.logger.info "Answer has budget info: #{answer_has_budget_info}"
  
  # Trigger if it's a budget question AND the answer contains budget information
  should_trigger = (question_mentions_budget || ai_budget_question) && answer_has_budget_info
  
  Rails.logger.info "Should trigger: #{should_trigger}"
  
  should_trigger
end
  
# Add this helper method
def has_budget_information?(answer_text)
  return false if answer_text.blank?
  
  # Check for numeric values
  has_numbers = answer_text.match?(/\d/)
  
  # Check for currency symbols or words
  currency_indicators = ['$', '', '', '', 'usd', 'dollar', 'euro', 'pound', 'peso']
  has_currency = currency_indicators.any? { |indicator| answer_text.include?(indicator) }
  
  # Check for budget-related words
  budget_words = [
    'budget', 'cost', 'price', 'money', 'amount', 'spend', 'investment',
    'limited', 'small', 'tight', 'low', 'high', 'large', 'big',
    'thousand', 'million', 'hundred', 'k', 'm',
    'presupuesto', 'limitado', 'pequeo', 'bajo', 'alto', 'grande',
    'mil', 'milln', 'cien', 'startup', 'bootstrap', 'enterprise'
  ]
  has_budget_words = budget_words.any? { |word| answer_text.include?(word) }
  
  # Check for written numbers
  written_numbers = ['one', 'two', 'three', 'four', 'five', 'ten', 'twenty', 'fifty', 'hundred',
                     'uno', 'dos', 'tres', 'cuatro', 'cinco', 'diez', 'veinte', 'cincuenta', 'cien']
  has_written_numbers = written_numbers.any? { |num| answer_text.include?(num) }
  
  # Return true if answer contains budget-related information
  has_numbers || has_currency || has_budget_words || has_written_numbers
end

# Also update the trigger_budget_adaptation method with better logging
def trigger_budget_adaptation(budget_answer)
  return unless @form.ai_enhanced?
  return unless @form.user.can_use_ai_features?
  
  Rails.logger.info "=== TRIGGERING BUDGET ADAPTATION ==="
  Rails.logger.info "Budget answer: '#{budget_answer}'"
  Rails.logger.info "Response ID: #{@form_response.id}"
  
  # Delay the job by 3 seconds to ensure WebSocket connection is established
  Forms::BudgetAdaptationJob.set(wait: 3.seconds).perform_later(@form_response.id, budget_answer)
  
  Rails.logger.info "Budget adaptation job queued with 3-second delay"
end
  
  def save_draft_data
    draft_data = params[:draft_data] || {}
    
    # Update form response with draft data
    @form_response.update(
      draft_data: draft_data,
      last_activity_at: Time.current
    )
    
    { success: true, message: 'Draft saved successfully' }
  rescue => error
    { success: false, error: error.message }
  end
  
  # Rendering Methods
  
  def render_form_layout
    render layout: 'public_form'
  end
  
  def render_thank_you_page
    render layout: 'public_form'
  end
  
  def render_json_response
    render json: {
      form: serialize_form,
      question: serialize_question(@current_question),
      progress: @progress_percentage,
      total_questions: @total_questions,
      response_id: @form_response.id
    }
  end
  
  def render_completion_json
    render json: {
      completed: true,
      form: serialize_form,
      completion_data: @completion_data,
      response_summary: @form_response&.response_summary
    }
  end
  
  def serialize_form
    {
      id: @form.id,
      name: @form.name,
      description: @form.description,
      share_token: @form.share_token,
      style_configuration: @form.style_configuration
    }
  end
  
  def render_error(message, status)
    respond_to do |format|
      format.html { 
        render 'errors/form_error', 
               locals: { message: message, status: status },
               status: status,
               layout: 'public_form'
      }
      format.json { 
        render json: { error: message }, status: status 
      }
    end
  end

  def test_dynamic_question
      form_response = FormResponse.find_by!(session_id: current_session_id)
      
      # Create a simple test question
      dynamic_question = DynamicQuestion.create!(
        form_response: form_response,
        generated_from_question: form_response.question_responses.last&.form_question,
        question_type: 'text_long',
        title: 'Test Dynamic Question',
        description: 'This is a test question to verify Turbo Streams are working.',
        generation_context: { trigger: 'test' }
      )

      Rails.logger.info "Created test dynamic question: #{dynamic_question.id}"
      Rails.logger.info "Target: budget_adaptation_#{form_response.id}"

      # Test the broadcast
      begin
        Turbo::StreamsChannel.broadcast_append_to(
          form_response,
          target: "budget_adaptation_#{form_response.id}",
          partial: "responses/budget_adaptation_question",
          locals: {
            dynamic_question: dynamic_question,
            form_response: form_response
          }
        )
        
        Rails.logger.info "Test broadcast sent successfully"
        render json: { success: true, message: "Test question created and broadcast sent" }
      rescue => error
        Rails.logger.error "Test broadcast failed: #{error.message}"
        render json: { success: false, error: error.message }
      end
    end

  def trigger_budget_test
    form_response_id = params[:form_response_id]
    budget_answer = params[:budget_answer] || '800 usd'
    
    Rails.logger.info "=== MANUAL BUDGET TEST TRIGGER ==="
    Rails.logger.info "Form Response ID: #{form_response_id}"
    Rails.logger.info "Budget Answer: #{budget_answer}"
    
    begin
      # Trigger the job directly
      Forms::BudgetAdaptationJob.perform_now(form_response_id, budget_answer)
      
      render json: { 
        success: true, 
        message: "Budget adaptation job triggered manually",
        form_response_id: form_response_id,
        budget_answer: budget_answer
      }
      
    rescue => error
      Rails.logger.error "Manual trigger failed: #{error.message}"
      render json: { 
        success: false, 
        error: error.message,
        backtrace: error.backtrace.first(5)
      }
    end
  end
end
</file>

<file path="controllers/stripe_settings_controller.rb">
class StripeSettingsController < ApplicationController
  before_action :authenticate_user!
  before_action :ensure_premium_user

  def show
    authorize current_user, :update?
    @stripe_configured = current_user.stripe_configured?
    @test_mode = current_user.stripe_publishable_key&.start_with?('pk_test_')
  end

  def update
    authorize current_user, :update?
    if current_user.update(stripe_params)
      # Encrypt sensitive keys before saving
      current_user.encrypt_stripe_keys!
      current_user.save!
      
      redirect_to stripe_settings_path, notice: 'Stripe settings updated successfully!'
    else
      render :show, status: :unprocessable_entity
    end
  end

  def test_connection
    authorize current_user, :update?
    unless current_user.stripe_configured?
      render json: { success: false, error: 'Stripe not configured' }
      return
    end

    begin
      # Test the connection by retrieving account info
      client = current_user.stripe_client
      account = client.accounts.retrieve
      
      render json: {
        success: true,
        account_id: account.id,
        business_name: account.business_profile&.name || account.email,
        country: account.country,
        currency: account.default_currency&.upcase,
        charges_enabled: account.charges_enabled,
        payouts_enabled: account.payouts_enabled
      }
    rescue Stripe::AuthenticationError
      render json: { 
        success: false, 
        error: 'Invalid API keys. Please check your Stripe credentials.' 
      }
    rescue Stripe::StripeError => e
      render json: { 
        success: false, 
        error: "Stripe error: #{e.message}" 
      }
    rescue StandardError => e
      render json: { 
        success: false, 
        error: "Connection error: #{e.message}" 
      }
    end
  end

  def disable
    authorize current_user, :update?
    current_user.update!(
      stripe_enabled: false,
      stripe_publishable_key: nil,
      stripe_secret_key: nil,
      stripe_webhook_secret: nil,
      stripe_account_id: nil
    )
    
    redirect_to stripe_settings_path, notice: 'Stripe integration disabled successfully.'
  end

  private

  def ensure_premium_user
    unless current_user.premium?
      redirect_to profile_path, alert: 'Payment processing requires a premium subscription. Please upgrade your account.'
    end
  end

  def stripe_params
    params.require(:user).permit(
      :stripe_publishable_key, 
      :stripe_secret_key, 
      :stripe_webhook_secret,
      :stripe_enabled
    )
  end
end
</file>

<file path="controllers/stripe_webhooks_controller.rb">
# frozen_string_literal: true

class StripeWebhooksController < ApplicationController
  skip_before_action :authenticate_user!, raise: false
  skip_before_action :verify_authenticity_token, raise: false

  def create
    # La gema stripe_event maneja la verificacin y llama al servicio
    # configurado en el inicializador.
    StripeEvent.instrument(params.to_unsafe_h)
    head :ok
  rescue Stripe::SignatureVerificationError => e
    render json: { error: "Firma de Webhook invlida" }, status: 400
  end
end
</file>

<file path="controllers/subscription_management_controller.rb">
class SubscriptionManagementController < ApplicationController
  before_action :authenticate_user!

  def show
    @subscription_service = SubscriptionManagementService.new(user: current_user)
    @subscription_details = @subscription_service.subscription_details
    @plans = SubscriptionManagementService.plans
  end

  def create
    @subscription_service = SubscriptionManagementService.new(user: current_user)
    
    result = @subscription_service.create_subscription(
      billing_cycle: params[:billing_cycle] || 'monthly',
      discount_code: params[:discount_code],
      success_url: subscription_success_url,
      cancel_url: subscription_management_url
    )

    if result.success?
      redirect_to result.data[:checkout_url], allow_other_host: true
    else
      redirect_to subscription_management_path, alert: result.error
    end
  end

  def cancel
    @subscription_service = SubscriptionManagementService.new(user: current_user)
    
    result = @subscription_service.cancel_subscription(
      at_period_end: params[:immediate] != 'true'
    )

    if result.success?
      redirect_to subscription_management_path, notice: result.data[:message]
    else
      redirect_to subscription_management_path, alert: result.error
    end
  end

  def reactivate
    @subscription_service = SubscriptionManagementService.new(user: current_user)
    
    result = @subscription_service.reactivate_subscription

    if result.success?
      redirect_to subscription_management_path, notice: result.data[:message]
    else
      redirect_to subscription_management_path, alert: result.error
    end
  end

  def update_payment_method
    @subscription_service = SubscriptionManagementService.new(user: current_user)
    
    result = @subscription_service.update_payment_method(
      success_url: payment_method_success_url,
      cancel_url: subscription_management_url
    )

    if result.success?
      redirect_to result.data[:checkout_url], allow_other_host: true
    else
      redirect_to subscription_management_path, alert: result.error
    end
  end

  def success
    flash[:notice] = 'Subscription updated successfully!'
    redirect_to subscription_management_path
  end

  def payment_method_success
    flash[:notice] = 'Payment method updated successfully!'
    redirect_to subscription_management_path
  end

  private

  def subscription_params
    params.permit(:billing_cycle, :immediate, :discount_code)
  end
end
</file>

<file path="controllers/subscription_upgrades_controller.rb">
# frozen_string_literal: true

class SubscriptionUpgradesController < ApplicationController
  before_action :authenticate_user!
  before_action :ensure_trial_expired, only: [:new, :create]

  def new
    # Show upgrade form for users whose trial has expired
  end

  def create
    # Handle upgrade to premium subscription
    service = SubscriptionManagementService.new(user: current_user)
    
    result = service.create_subscription(
      billing_cycle: params[:billing_cycle] || 'monthly',
      discount_code: params[:discount_code],
      success_url: subscription_upgrade_success_url,
      cancel_url: subscription_upgrade_cancel_url
    )

    if result.success?
      redirect_to result.data[:checkout_url], allow_other_host: true
    else
      flash[:alert] = result.error
      render :new, status: :unprocessable_entity
    end
  end

  def success
    flash[:notice] = "Gracias por suscribirte! Tu cuenta premium est ahora activa."
    redirect_to root_path
  end

  def cancel
    flash[:alert] = "El proceso de pago fue cancelado. Puedes intentarlo de nuevo cuando gustes."
    redirect_to subscription_upgrade_path
  end

  private

  def ensure_trial_expired
    unless current_user.trial_expired? || current_user.subscription_status == 'expired'
      redirect_to root_path, notice: 'Tu perodo de prueba an est activo.'
    end
  end
end
</file>

<file path="controllers/subscriptions_controller.rb">
# frozen_string_literal: true

class SubscriptionsController < ApplicationController

  skip_before_action :authenticate_user!

  skip_after_action :verify_authorized, unless: :skip_authorization?
  skip_after_action :verify_policy_scoped, unless: :skip_authorization?

  def new
    @user = User.new
  end

  def create
    @user = User.new(user_params)

    if @user.save
      # Check if trial is enabled
      if TrialConfig.trial_enabled?
        # Start trial immediately without Stripe
        @user.update!(
          subscription_tier: 'premium',
          subscription_status: 'trialing',
          trial_ends_at: TrialConfig.trial_end_date(Time.current)
        )
        
        # Send trial welcome email
        UserMailer.trial_welcome(@user).deliver_later
        
        # Send confirmation email if user is not confirmed
        unless @user.confirmed?
          UserMailer.account_confirmation(@user).deliver_later
        end
        
        flash[:notice] = "Bienvenido! Tu perodo de prueba de #{TrialConfig.trial_period_days} das ha comenzado. Revisa tu correo (#{@user.email}) para confirmar tu cuenta."
        redirect_to success_subscriptions_path
      else
        # Normal Stripe flow for immediate payment
        begin
          checkout_session = Stripe::Checkout::Session.create({
            payment_method_types: ['card'],
            line_items: [{
              price: Rails.application.credentials.stripe[:premium_plan_price_id],
              quantity: 1,
            }],
            mode: 'subscription',
            success_url: success_subscriptions_url + "?session_id={CHECKOUT_SESSION_ID}",
            cancel_url: cancel_subscriptions_url,
            metadata: {
              user_id: @user.id
            }
          })
          
          redirect_to checkout_session.url, allow_other_host: true, status: :see_other
        rescue Stripe::StripeError => e
          @user.destroy
          flash[:alert] = "Hubo un error con el pago: #{e.message}"
          redirect_to new_subscription_path
        end
      end
    else
      render :new, status: :unprocessable_entity
    end
  end

  def success
    # This method handles both trial and Stripe success
    # The specific message is set in the create method
    redirect_to new_user_session_path
  end

  def cancel
    flash[:alert] = "El proceso de pago fue cancelado. Puedes intentarlo de nuevo."
    redirect_to new_user_registration_path
  end

  private

  def user_params
    params.require(:user).permit(:first_name, :last_name, :email, :password, :password_confirmation)
  end
end
</file>

<file path="controllers/templates_controller.rb">
class TemplatesController < ApplicationController
  include Pundit
  before_action :authenticate_user!
  before_action :set_template, only: [:show, :instantiate]

  # GET /templates
  def index
    @templates = policy_scope(FormTemplate).public_templates
    
    # Apply filters
    @templates = apply_filters(@templates)
    
    # Apply sorting
    @templates = apply_sorting(@templates)
    
    # Set filter state for UI
    @filter_params = filter_params
    @has_payment_filter = params[:payment_features].present?
    @category_filter = params[:category]
    @sort_by = params[:sort_by] || 'name'
  end

  # GET /templates/:id
  def show
    authorize @template
  end

  # POST /templates/:id/instantiate
  def instantiate
    authorize @template
    
    begin
      # Check if user skipped payment setup
      skip_setup = params[:skip_setup] == 'true'
      
      # Validate payment requirements if not skipping setup
      if @template.has_payment_questions? && !skip_setup
        # Check if PaymentSetupValidationService exists, otherwise skip validation for now
        if defined?(PaymentSetupValidationService)
          validation_result = PaymentSetupValidationService.call(
            user: current_user,
            required_features: @template.required_features
          )
          
          unless validation_result.success?
            # Redirect to payment setup with template context
            redirect_to payment_setup_path(template_id: @template.id, return_to: templates_path),
                        alert: "Payment setup required for this template. Please complete the setup to continue."
            return
          end
        end
      end
      
      new_form = @template.instantiate_for_user(current_user)
      
      # Set payment setup reminder if user skipped setup
      if skip_setup && @template.has_payment_questions?
        flash[:notice] = "Form created from template '#{@template.name}'. Remember to complete payment setup before publishing."
      else
        flash[:notice] = "Form created from template '#{@template.name}'."
      end
      
      redirect_to edit_form_path(new_form)
      
    rescue Pundit::NotAuthorizedError => e
      redirect_to templates_path, alert: "AI templates require a premium subscription. Please upgrade to access this template."
    rescue => e
      Rails.logger.error "Error instantiating template #{@template.id}: #{e.message}"
      redirect_to templates_path, alert: "Error creating form: #{e.message}"
    end
  end

  private

  def set_template
    @template = FormTemplate.find(params[:id])
  end

  private

  def apply_filters(templates)
    # Filter by category
    if params[:category].present? && params[:category] != 'all'
      templates = templates.by_category(params[:category])
    end
    
    # Search filter (apply before converting to array)
    if params[:search].present?
      templates = templates.where(
        'name ILIKE ? OR description ILIKE ?',
        "%#{params[:search]}%",
        "%#{params[:search]}%"
      )
    end
    
    # Convert to array for payment filtering
    templates_array = templates.to_a
    
    # Filter by payment features
    case params[:payment_features]
    when 'with_payments'
      templates_array = templates_array.select { |t| t.has_payment_questions? }
    when 'without_payments'
      templates_array = templates_array.reject { |t| t.has_payment_questions? }
    end
    
    # Filter by features
    if params[:features].present?
      features_array = params[:features].split(',')
      templates_array = templates_array.select do |template|
        features_array.any? { |feature| template.features&.include?(feature) }
      end
    end
    
    templates_array
  end
  
  def apply_sorting(templates)
    # If templates is an array (after payment filtering), sort manually
    if templates.is_a?(Array)
      case params[:sort_by]
      when 'popular'
        templates.sort_by { |t| -t.usage_count }
      when 'recent'
        templates.sort_by { |t| -t.created_at.to_i }
      when 'usage'
        templates.sort_by { |t| -t.usage_count }
      when 'time'
        templates.sort_by { |t| t.estimated_time_minutes || 0 }
      else
        templates.sort_by { |t| t.name }
      end
    else
      # If templates is still an ActiveRecord relation, use database sorting
      case params[:sort_by]
      when 'popular'
        templates.popular
      when 'recent'
        templates.recent
      when 'usage'
        templates.order(usage_count: :desc)
      when 'time'
        templates.order(:estimated_time_minutes)
      else
        templates.order(:name)
      end
    end
  end
  
  def filter_params
    params.permit(:category, :payment_features, :features, :search, :sort_by)
  end

  def template_params
    params.require(:template).permit(:name, :description, :category, :visibility)
  end
end
</file>

<file path="helpers/admin_helper.rb">
module AdminHelper
  def admin_nav_class(path)
    base_classes = "text-sm font-medium transition-colors duration-200"
    
    if current_page?(path)
      "#{base_classes} text-red-600 border-b-2 border-red-600 pb-1"
    else
      "#{base_classes} text-gray-500 hover:text-gray-700"
    end
  end

  def admin_breadcrumbs
    breadcrumbs = [{ name: 'Admin', path: admin_dashboard_path }]
    
    case controller_name
    when 'dashboard'
      breadcrumbs << { name: 'Dashboard', path: nil }
    when 'users'
      breadcrumbs << { name: 'Users', path: admin_users_path }
      if action_name == 'show'
        breadcrumbs << { name: @user&.email || 'User Details', path: nil }
      elsif action_name == 'edit'
        breadcrumbs << { name: 'Edit User', path: nil }
      end
    when 'discount_codes'
      breadcrumbs << { name: 'Discount Codes', path: admin_discount_codes_path }
      if action_name == 'show'
        breadcrumbs << { name: @discount_code&.code || 'Code Details', path: nil }
      elsif action_name == 'edit'
        breadcrumbs << { name: 'Edit Code', path: nil }
      end
    when 'notifications'
      breadcrumbs << { name: 'Notifications', path: admin_notifications_path }
      if action_name == 'show'
        breadcrumbs << { name: 'Notification Details', path: nil }
      end
    when 'security'
      breadcrumbs << { name: 'Security', path: admin_security_index_path }
    when 'payment_analytics'
      breadcrumbs << { name: 'Payment Analytics', path: admin_payment_analytics_path }
    end
    
    breadcrumbs
  end

  def notification_priority_badge(notification)
    classes = case notification.priority
              when 'critical'
                'bg-red-100 text-red-800'
              when 'high'
                'bg-orange-100 text-orange-800'
              when 'normal'
                'bg-blue-100 text-blue-800'
              when 'low'
                'bg-gray-100 text-gray-800'
              else
                'bg-gray-100 text-gray-800'
              end

    content_tag :span, class: "inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium #{classes}" do
      "#{notification.priority_icon} #{notification.priority.humanize}"
    end
  end

  def notification_event_badge(notification)
    content_tag :span, class: "inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800" do
      "#{notification.event_icon} #{notification.event_type.humanize}"
    end
  end

  def notification_time_ago(notification)
    content_tag :span, class: "text-xs text-gray-500" do
      "#{time_ago_in_words(notification.created_at)} ago"
    end
  end

  def unread_notification_count
    @unread_count ||= AdminNotification.unread.count
  end

  def notification_counter_badge
    count = unread_notification_count
    return '' if count.zero?

    content_tag :span, count, 
      id: 'nav-notification-counter',
      class: "absolute -top-2 -right-2 inline-flex items-center justify-center px-2 py-1 text-xs font-bold leading-none text-white transform translate-x-1/2 -translate-y-1/2 bg-red-600 rounded-full"
  end

  def format_notification_metadata(metadata)
    return '' if metadata.blank?

    content_tag :div, class: "mt-2 text-xs text-gray-600" do
      metadata.map do |key, value|
        content_tag :div, class: "flex justify-between" do
          content_tag(:span, key.humanize + ':', class: "font-medium") +
          content_tag(:span, value.to_s, class: "ml-2")
        end
      end.join.html_safe
    end
  end

  def notification_stats_card(title, count, icon, color_class = 'bg-blue-500')
    content_tag :div, class: "bg-white overflow-hidden shadow rounded-lg" do
      content_tag :div, class: "p-5" do
        content_tag :div, class: "flex items-center" do
          content_tag(:div, class: "flex-shrink-0") do
            content_tag :div, class: "w-8 h-8 #{color_class} rounded-md flex items-center justify-center" do
              content_tag :span, icon, class: "text-white text-sm font-medium"
            end
          end +
          content_tag(:div, class: "ml-5 w-0 flex-1") do
            content_tag :dl do
              content_tag(:dt, title, class: "text-sm font-medium text-gray-500 truncate") +
              content_tag(:dd, count, class: "text-lg font-medium text-gray-900")
            end
          end
        end
      end
    end
  end
end
</file>

<file path="helpers/application_helper.rb">
module ApplicationHelper
  def markdown(text)
    return "" if text.blank?
    
    renderer = Redcarpet::Render::HTML.new(
      filter_html: true,
      no_links: false,
      no_images: false,
      no_styles: false,
      safe_links_only: true,
      with_toc_data: false,
      hard_wrap: true
    )
    
    markdown = Redcarpet::Markdown.new(renderer,
      autolink: true,
      tables: true,
      strikethrough: true,
      fenced_code_blocks: true,
      no_intra_emphasis: true,
      superscript: true
    )
    
    markdown.render(text).html_safe
  end

  # Error display helpers for AI generation errors
  def error_border_color(severity)
    case severity
    when 'error', 'fatal'
      'border-red-400'
    when 'warning'
      'border-yellow-400'
    when 'info'
      'border-blue-400'
    else
      'border-gray-400'
    end
  end

  def error_text_color(severity)
    case severity
    when 'error', 'fatal'
      'text-red-800'
    when 'warning'
      'text-yellow-800'
    when 'info'
      'text-blue-800'
    else
      'text-gray-800'
    end
  end

  def error_icon(severity)
    case severity
    when 'error', 'fatal'
      content_tag(:svg, class: "w-6 h-6 text-red-400", fill: "currentColor", viewBox: "0 0 20 20") do
        content_tag(:path, "", fill_rule: "evenodd", d: "M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z", clip_rule: "evenodd")
      end
    when 'warning'
      content_tag(:svg, class: "w-6 h-6 text-yellow-400", fill: "currentColor", viewBox: "0 0 20 20") do
        content_tag(:path, "", fill_rule: "evenodd", d: "M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z", clip_rule: "evenodd")
      end
    when 'info'
      content_tag(:svg, class: "w-6 h-6 text-blue-400", fill: "currentColor", viewBox: "0 0 20 20") do
        content_tag(:path, "", fill_rule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z", clip_rule: "evenodd")
      end
    else
      content_tag(:svg, class: "w-6 h-6 text-gray-400", fill: "currentColor", viewBox: "0 0 20 20") do
        content_tag(:path, "", fill_rule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z", clip_rule: "evenodd")
      end
    end
  end

  # Admin navigation helpers
  def admin_nav_class(path)
    base_classes = "px-3 py-2 text-sm font-medium transition-colors"
    if current_page?(path)
      "#{base_classes} text-red-600 border-b-2 border-red-600"
    else
      "#{base_classes} text-gray-500 hover:text-red-600"
    end
  end

  def admin_card_classes
    "bg-white rounded-xl shadow-sm border border-gray-200 hover:shadow-md transition-shadow duration-200"
  end

  def admin_button_primary_classes
    "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition-colors"
  end

  def admin_button_secondary_classes
    "inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition-colors"
  end

  def admin_status_badge(status, text = nil)
    text ||= status.to_s.humanize
    
    case status.to_s.downcase
    when 'active', 'published', 'enabled'
      content_tag(:span, text, class: "inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800")
    when 'inactive', 'disabled', 'suspended'
      content_tag(:span, text, class: "inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800")
    when 'pending', 'processing'
      content_tag(:span, text, class: "inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800")
    when 'expired'
      content_tag(:span, text, class: "inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800")
    else
      content_tag(:span, text, class: "inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800")
    end
  end
end
</file>

<file path="helpers/content_security_policy_helper.rb">
# frozen_string_literal: true

# Content Security Policy Helper
# Provides utilities for working with CSP nonces and secure inline scripts
module ContentSecurityPolicyHelper
  # Get the current CSP nonce for scripts
  def csp_script_nonce
    content_security_policy_nonce
  end

  # Get the current CSP nonce for styles
  def csp_style_nonce
    content_security_policy_nonce
  end

  # Create a script tag with proper CSP nonce
  def safe_javascript_tag(content = nil, **options, &block)
    options[:nonce] = csp_script_nonce if Rails.env.production?
    
    if block_given?
      javascript_tag(**options, &block)
    else
      javascript_tag(content, **options)
    end
  end

  # Create a style tag with proper CSP nonce
  def safe_style_tag(content = nil, **options, &block)
    options[:nonce] = csp_style_nonce if Rails.env.production?
    
    if block_given?
      content_tag(:style, **options, &block)
    else
      content_tag(:style, content, **options)
    end
  end

  # Check if CSP is enabled
  def csp_enabled?
    Rails.env.production? && Rails.application.config.content_security_policy.present?
  end

  # Get CSP report URI if configured
  def csp_report_uri
    Rails.application.config.content_security_policy_report_only ? '/csp-report' : nil
  end
end
</file>

<file path="helpers/google_integration_helper.rb">
module GoogleIntegrationHelper
  def google_oauth_configured?
    GoogleSheets::ConfigService.oauth_configured?
  end

  def google_oauth_status_for_user(user)
    return :not_configured unless google_oauth_configured?
    return :not_connected unless user.google_integration.present?
    return :expired unless user.google_integration.valid_token?
    
    :connected
  end

  def google_oauth_status_message(status)
    case status
    when :not_configured
      "Google OAuth credentials need to be configured by an administrator."
    when :not_connected
      "Connect your Google account to enable Sheets integration."
    when :expired
      "Your Google connection has expired. Please reconnect."
    when :connected
      "Google Sheets integration is ready to use."
    else
      "Unknown status"
    end
  end

  def google_oauth_status_class(status)
    case status
    when :not_configured
      "bg-red-100 text-red-800"
    when :not_connected
      "bg-gray-100 text-gray-800"
    when :expired
      "bg-amber-100 text-amber-800"
    when :connected
      "bg-green-100 text-green-800"
    else
      "bg-gray-100 text-gray-800"
    end
  end
end
</file>

<file path="helpers/payment_error_helper.rb">
# frozen_string_literal: true

# Helper module for consistent payment error message formatting and display
module PaymentErrorHelper
  # Formats a PaymentValidationError for display in views
  def format_payment_error(error)
    return nil unless error.is_a?(PaymentValidationError)

    {
      type: error.error_type,
      message: error.message,
      description: error.user_guidance[:description],
      severity: error.user_guidance[:severity] || 'error',
      category: error.user_guidance[:category] || 'payment_setup',
      actionable: error.actionable?,
      primary_action: format_primary_action(error),
      additional_actions: format_additional_actions(error),
      help_available: help_available_for_error?(error.error_type)
    }
  end

  # Renders payment error flash message with appropriate styling
  def payment_error_flash(error, options = {})
    return nil unless error

    formatted_error = error.is_a?(PaymentValidationError) ? format_payment_error(error) : error
    
    render partial: 'shared/payment_error_flash', 
           locals: { 
             error: formatted_error.is_a?(Hash) ? OpenStruct.new(formatted_error) : error,
             **options 
           }
  end

  # Renders payment setup guidance component
  def payment_setup_guidance(error = nil, options = {})
    render partial: 'shared/payment_setup_guidance',
           locals: {
             error: error,
             show_actions: options.fetch(:show_actions, true),
             context: options.fetch(:context, 'general'),
             compact: options.fetch(:compact, false)
           }
  end

  # Renders payment setup required button
  def payment_setup_required_button(error = nil, options = {})
    render partial: 'shared/payment_setup_required_button',
           locals: {
             error: error,
             button_text: options.fetch(:button_text, 'Complete Setup to Publish'),
             button_class: options.fetch(:button_class, 'btn-primary'),
             show_icon: options.fetch(:show_icon, true)
           }
  end

  # Returns CSS classes for error severity
  def payment_error_severity_classes(severity)
    case severity.to_s
    when 'error'
      'bg-red-50 border-red-200 text-red-800'
    when 'warning'
      'bg-yellow-50 border-yellow-200 text-yellow-800'
    when 'info'
      'bg-blue-50 border-blue-200 text-blue-800'
    else
      'bg-gray-50 border-gray-200 text-gray-800'
    end
  end

  # Returns icon for error type
  def payment_error_icon(error_type)
    icons = {
      'stripe_not_configured' => 'credit-card',
      'premium_subscription_required' => 'star',
      'multiple_requirements_missing' => 'exclamation-triangle',
      'invalid_payment_configuration' => 'cog',
      'insufficient_permissions' => 'lock-closed'
    }
    
    icons[error_type.to_s] || 'exclamation-circle'
  end

  # Humanizes requirement names for display
  def humanize_payment_requirement(requirement)
    requirements_map = {
      'stripe_configuration' => 'Stripe Configuration',
      'stripe_config' => 'Stripe Setup',
      'premium_subscription' => 'Premium Subscription',
      'premium' => 'Premium Plan',
      'payment_setup' => 'Payment Setup',
      'payment_questions' => 'Payment Questions Setup',
      'webhook_configuration' => 'Webhook Configuration',
      'test_payment' => 'Payment Testing'
    }
    
    requirements_map[requirement.to_s] || requirement.to_s.humanize
  end

  # Returns estimated setup time for error type
  def estimated_setup_time(error_type)
    times = {
      'stripe_not_configured' => '5-10 minutes',
      'premium_subscription_required' => '2-3 minutes',
      'multiple_requirements_missing' => '10-15 minutes',
      'invalid_payment_configuration' => '3-5 minutes',
      'insufficient_permissions' => 'Contact support'
    }
    
    times[error_type.to_s] || 'Varies'
  end

  # Checks if contextual help is available for error type
  def help_available_for_error?(error_type)
    %w[
      stripe_not_configured
      premium_subscription_required
      multiple_requirements_missing
      invalid_payment_configuration
    ].include?(error_type.to_s)
  end

  # Returns help URL for error type
  def help_url_for_error(error_type)
    case error_type.to_s
    when 'stripe_not_configured'
      '/help/stripe-setup'
    when 'premium_subscription_required'
      '/help/premium-features'
    when 'multiple_requirements_missing'
      '/help/payment-setup-guide'
    when 'invalid_payment_configuration'
      '/help/payment-questions'
    else
      '/help/payment-setup'
    end
  end

  # Formats error for analytics tracking
  def payment_error_analytics_data(error)
    return {} unless error

    {
      error_type: error.error_type,
      error_category: error.user_guidance[:category],
      error_severity: error.user_guidance[:severity],
      has_actions: error.actionable?,
      action_count: error.required_actions.length,
      timestamp: Time.current.iso8601
    }
  end

  # Generates structured data for error recovery
  def payment_error_recovery_data(error, context = {})
    return {} unless error

    {
      error_type: error.error_type,
      recovery_available: true,
      estimated_time: estimated_setup_time(error.error_type),
      context: context,
      help_url: help_url_for_error(error.error_type),
      support_contact: 'support@agentform.com'
    }
  end

  # Renders error-specific educational content
  def payment_error_education(error_type)
    content = case error_type.to_s
    when 'stripe_not_configured'
      {
        title: 'About Stripe Integration',
        description: 'Stripe is a secure payment processor that handles all payment transactions for your forms.',
        benefits: [
          'PCI compliance and security handled automatically',
          'Support for 135+ currencies and multiple payment methods',
          'Detailed analytics and reporting',
          'Fraud protection and dispute management'
        ],
        setup_time: '5-10 minutes'
      }
    when 'premium_subscription_required'
      {
        title: 'Premium Features',
        description: 'Payment functionality is included in our Premium plans.',
        benefits: [
          'Unlimited payment forms and transactions',
          'Advanced analytics and reporting',
          'Custom branding and white-label options',
          'Priority support and onboarding assistance'
        ],
        setup_time: '2-3 minutes'
      }
    else
      {
        title: 'Payment Setup',
        description: 'Complete payment setup to unlock powerful form monetization features.',
        benefits: [
          'Accept payments directly through your forms',
          'Automated payment processing and notifications',
          'Secure, PCI-compliant payment handling',
          'Detailed payment analytics and reporting'
        ],
        setup_time: 'Varies'
      }
    end

    render partial: 'shared/payment_error_education', locals: { content: content }
  end

  private

  def format_primary_action(error)
    return nil unless error.primary_action_url.present?

    {
      text: error.primary_action_text || 'Take Action',
      url: error.primary_action_url,
      style: 'primary'
    }
  end

  def format_additional_actions(error)
    actions = []
    
    if help_available_for_error?(error.error_type)
      actions << {
        text: 'Get Help',
        action: 'show_help',
        style: 'secondary'
      }
    end
    
    if error.user_guidance[:missing_requirements].present?
      actions << {
        text: 'Setup Checklist',
        action: 'show_checklist',
        style: 'secondary'
      }
    end
    
    actions << {
      text: 'Contact Support',
      action: 'contact_support',
      style: 'secondary'
    }
    
    actions
  end
end
</file>

<file path="javascript/channels/form_response_channel.js">
// app/javascript/channels/form_response_channel.js

import consumer from "channels/consumer"

let formResponseChannel = null

export function subscribeToFormResponse(formResponseId) {
  console.log("Subscribing to FormResponse channel:", formResponseId)
  
  // Unsubscribe from previous channel if exists
  if (formResponseChannel) {
    formResponseChannel.unsubscribe()
  }
  
  formResponseChannel = consumer.subscriptions.create(
    {
      channel: "FormResponseChannel",
      form_response_id: formResponseId
    },
    {
      connected() {
        console.log("Connected to FormResponseChannel for:", formResponseId)
      },

      disconnected() {
        console.log("Disconnected from FormResponseChannel")
      },

      received(data) {
        console.log("Received broadcast data:", data)
        
        // Handle Turbo Stream HTML directly
        if (typeof data === 'string' && data.includes('<turbo-stream')) {
          console.log("Processing Turbo Stream HTML")
          
          // Create a temporary element to parse the turbo-stream
          const tempDiv = document.createElement('div')
          tempDiv.innerHTML = data
          
          const turboStream = tempDiv.querySelector('turbo-stream')
          if (turboStream) {
            const action = turboStream.getAttribute('action')
            const target = turboStream.getAttribute('target')
            const template = turboStream.querySelector('template')
            
            console.log(`Turbo Stream - Action: ${action}, Target: ${target}`)
            
            if (template && target) {
              const targetElement = document.getElementById(target)
              if (targetElement) {
                if (action === 'append') {
                  targetElement.insertAdjacentHTML('beforeend', template.innerHTML)
                } else if (action === 'prepend') {
                  targetElement.insertAdjacentHTML('afterbegin', template.innerHTML)
                } else if (action === 'replace') {
                  targetElement.outerHTML = template.innerHTML
                }
                
                console.log("Successfully updated DOM element:", target)
                this.initializeDynamicContent(targetElement)
              } else {
                console.error("Target element not found:", target)
              }
            }
          }
        } else {
          console.log("Received non-turbo-stream data:", typeof data, data)
        }
      },

      initializeDynamicContent(target) {
        console.log("Initializing dynamic content in:", target)
        
        // Add form submission handlers for dynamic questions
        const forms = target.querySelectorAll('form[data-dynamic-question]')
        forms.forEach(form => {
          console.log("Adding event listener to dynamic form:", form)
          form.addEventListener('submit', this.handleDynamicQuestionSubmit.bind(this))
        })
        
        // Add animation classes if needed
        const dynamicQuestions = target.querySelectorAll('.dynamic-question-container')
        dynamicQuestions.forEach(question => {
          question.style.opacity = '0'
          question.style.transform = 'translateY(20px)'
          
          setTimeout(() => {
            question.style.transition = 'opacity 0.3s ease, transform 0.3s ease'
            question.style.opacity = '1'
            question.style.transform = 'translateY(0)'
          }, 100)
        })
      },

      handleDynamicQuestionSubmit(event) {
        event.preventDefault()
        const form = event.target
        const formData = new FormData(form)
        
        console.log("Submitting dynamic question form:", form.action)
        
        // Submit the dynamic question response
        fetch(form.action, {
          method: 'POST',
          body: formData,
          headers: {
            'X-Requested-With': 'XMLHttpRequest',
            'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
          }
        })
        .then(response => response.json())
        .then(data => {
          console.log("Dynamic question response:", data)
          
          if (data.success) {
            // Hide the dynamic question
            form.style.display = 'none'
            
            // Show success message
            const successMessage = document.createElement('div')
            successMessage.className = 'dynamic-question-success mt-3 p-3 bg-green-100 border border-green-400 text-green-700 rounded'
            successMessage.textContent = 'Thank you for the additional information!'
            form.parentNode.insertBefore(successMessage, form.nextSibling)
          } else {
            console.error('Failed to submit dynamic question:', data.errors)
            alert('Failed to submit response. Please try again.')
          }
        })
        .catch(error => {
          console.error('Error submitting dynamic question:', error)
          alert('An error occurred. Please try again.')
        })
      }
    }
  )
  
  return formResponseChannel
}

// Auto-subscribe when page loads if form response ID is available
document.addEventListener('DOMContentLoaded', function() {
  const formResponseElement = document.querySelector('[data-form-response-id]')
  if (formResponseElement) {
    const formResponseId = formResponseElement.getAttribute('data-form-response-id')
    console.log("Auto-subscribing to FormResponse:", formResponseId)
    subscribeToFormResponse(formResponseId)
  }
})
</file>

<file path="javascript/channels/session_channel.js">
// app/javascript/channels/session_channel.js

import consumer from "channels/consumer"

const sessionChannel = consumer.subscriptions.create("SessionChannel", {
  connected() {
    console.log("Connected to SessionChannel")
  },

  disconnected() {
    console.log("Disconnected from SessionChannel")
  },

  received(data) {
    console.log("Received data:", data)
    
    if (data.type === 'turbo_stream') {
      // Handle Turbo Stream data
      const target = document.getElementById(data.target)
      
      if (target) {
        if (data.action === 'append') {
          target.insertAdjacentHTML('beforeend', data.html)
        } else if (data.action === 'prepend') {
          target.insertAdjacentHTML('afterbegin', data.html)
        } else if (data.action === 'replace') {
          target.outerHTML = data.html
        }
        
        console.log(`Dynamic question added to ${data.target}`)
        
        // Trigger any JavaScript that needs to run after the content is added
        this.initializeDynamicContent(target)
      } else {
        console.warn(`Target element ${data.target} not found`)
      }
    }
  },

  initializeDynamicContent(target) {
    // Initialize any JavaScript needed for the new dynamic content
    // For example, form validation, event listeners, etc.
    
    // Re-run Stimulus controllers if you're using them
    if (window.Stimulus) {
      window.Stimulus.load()
    }
    
    // Add form submission handlers for dynamic questions
    const forms = target.querySelectorAll('form[data-dynamic-question]')
    forms.forEach(form => {
      form.addEventListener('submit', this.handleDynamicQuestionSubmit.bind(this))
    })
  },

  handleDynamicQuestionSubmit(event) {
    event.preventDefault()
    const form = event.target
    const formData = new FormData(form)
    
    // Submit the dynamic question response
    fetch(form.action, {
      method: 'POST',
      body: formData,
      headers: {
        'X-Requested-With': 'XMLHttpRequest',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
      }
    })
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        // Hide the dynamic question or show a thank you message
        form.style.display = 'none'
        
        // Optionally show a success message
        const successMessage = document.createElement('div')
        successMessage.className = 'dynamic-question-success'
        successMessage.textContent = 'Thank you for the additional information!'
        form.parentNode.insertBefore(successMessage, form.nextSibling)
      } else {
        console.error('Failed to submit dynamic question:', data.errors)
      }
    })
    .catch(error => {
      console.error('Error submitting dynamic question:', error)
    })
  }
})
</file>

<file path="javascript/controllers/admin_notifications_controller.js">
import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  static targets = ["counter", "list"]

  connect() {
    console.log("Admin notifications controller connected")
    this.setupAutoRefresh()
  }

  disconnect() {
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval)
    }
  }

  setupAutoRefresh() {
    // Refresh notifications every 30 seconds
    this.refreshInterval = setInterval(() => {
      this.refreshNotifications()
    }, 30000)
  }

  refreshNotifications() {
    fetch('/admin/notifications', {
      headers: {
        'Accept': 'text/vnd.turbo-stream.html',
        'X-Requested-With': 'XMLHttpRequest'
      }
    })
    .then(response => response.text())
    .then(html => {
      if (html.includes('turbo-stream')) {
        Turbo.renderStreamMessage(html)
      }
    })
    .catch(error => {
      console.error('Error refreshing notifications:', error)
    })
  }

  markAsRead(event) {
    const notificationId = event.target.dataset.notificationId
    
    fetch(`/admin/notifications/${notificationId}/mark_as_read`, {
      method: 'PATCH',
      headers: {
        'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content,
        'Accept': 'text/vnd.turbo-stream.html'
      }
    })
    .then(response => response.text())
    .then(html => {
      Turbo.renderStreamMessage(html)
    })
    .catch(error => {
      console.error('Error marking notification as read:', error)
    })
  }

  markAllAsRead(event) {
    event.preventDefault()
    
    fetch('/admin/notifications/mark_all_as_read', {
      method: 'PATCH',
      headers: {
        'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content,
        'Accept': 'text/vnd.turbo-stream.html'
      }
    })
    .then(response => response.text())
    .then(html => {
      Turbo.renderStreamMessage(html)
    })
    .catch(error => {
      console.error('Error marking all notifications as read:', error)
    })
  }

  deleteNotification(event) {
    const notificationId = event.target.dataset.notificationId
    
    if (!confirm('Are you sure you want to delete this notification?')) {
      return
    }
    
    fetch(`/admin/notifications/${notificationId}`, {
      method: 'DELETE',
      headers: {
        'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content,
        'Accept': 'text/vnd.turbo-stream.html'
      }
    })
    .then(response => response.text())
    .then(html => {
      Turbo.renderStreamMessage(html)
    })
    .catch(error => {
      console.error('Error deleting notification:', error)
    })
  }

  // Filter handling
  applyFilters(event) {
    const form = event.target.closest('form')
    const formData = new FormData(form)
    const params = new URLSearchParams(formData)
    
    fetch(`/admin/notifications?${params.toString()}`, {
      headers: {
        'Accept': 'text/vnd.turbo-stream.html',
        'X-Requested-With': 'XMLHttpRequest'
      }
    })
    .then(response => response.text())
    .then(html => {
      if (html.includes('turbo-stream')) {
        Turbo.renderStreamMessage(html)
      } else {
        // Fallback: replace the entire list
        const parser = new DOMParser()
        const doc = parser.parseFromString(html, 'text/html')
        const newList = doc.querySelector('#notifications-list')
        if (newList && this.hasListTarget) {
          this.listTarget.innerHTML = newList.innerHTML
        }
      }
    })
    .catch(error => {
      console.error('Error applying filters:', error)
    })
  }
}
</file>

<file path="javascript/controllers/ai_form_generator_controller.js">
import { Controller } from "@hotwired/stimulus"

// Connects to data-controller="ai-form-generator"
export default class extends Controller {
  static targets = ["submitButton", "progressIndicator", "statusMessage", "errorContainer"]
  static values = { 
    submitUrl: String,
    redirectUrl: String,
    timeout: { type: Number, default: 120000 } // 2 minutes default timeout
  }

  connect() {
    this.isSubmitting = false
    this.setupFormValidation()
  }

  setupFormValidation() {
    // Listen for validation events from other controllers
    this.element.addEventListener('form-preview:updated', this.handleValidationUpdate.bind(this))
    this.element.addEventListener('file-upload:fileSelected', this.handleFileSelection.bind(this))
    this.element.addEventListener('file-upload:fileCleared', this.handleFileCleared.bind(this))
  }

  handleSubmit(event) {
    event.preventDefault()
    
    if (this.isSubmitting) {
      return
    }

    // Get the form that triggered the submission
    this.currentForm = event.target.closest('form')
    if (!this.currentForm) {
      console.error('No form found for submission')
      return
    }

    if (!this.validateForm()) {
      return
    }

    this.startSubmission()
  }

  validateForm() {
    if (!this.currentForm) {
      this.showError('Form not found')
      return false
    }

    // Get current form data
    const formData = new FormData(this.currentForm)
    const prompt = formData.get('prompt')
    const document = formData.get('document')

    // Check if we have either prompt or document
    if (!prompt?.trim() && (!document || document.size === 0)) {
      this.showError('Please provide either a text prompt or upload a document.')
      return false
    }

    // Validate prompt length if provided
    if (prompt?.trim()) {
      const wordCount = this.countWords(prompt.trim())
      if (wordCount < 10) {
        this.showError('Prompt must be at least 10 words long.')
        return false
      }
      if (wordCount > 5000) {
        this.showError('Prompt must be less than 5000 words.')
        return false
      }
    }

    return true
  }

  startSubmission() {
    this.isSubmitting = true
    this.updateSubmitButton(true)
    this.showProgressIndicator()
    this.clearErrors()
    
    // Set up timeout
    this.timeoutId = setTimeout(() => {
      this.handleTimeout()
    }, this.timeoutValue)

    // Submit the form
    this.submitForm()
  }

  async submitForm() {
    try {
      const formData = new FormData(this.currentForm)
      
      // Use the form's action if submitUrlValue is not set
      const submitUrl = this.submitUrlValue || this.currentForm.action
      
      const response = await fetch(submitUrl, {
        method: 'POST',
        body: formData,
        headers: {
          'X-Requested-With': 'XMLHttpRequest',
          'X-CSRF-Token': this.getCSRFToken(),
          'Accept': 'application/json'
        }
      })

      // Log response details for debugging
      console.log('Response status:', response.status)
      console.log('Response headers:', Object.fromEntries(response.headers.entries()))

      if (response.ok) {
        // Check if response is JSON
        const contentType = response.headers.get('content-type')
        if (contentType && contentType.includes('application/json')) {
          const result = await response.json()
          this.handleSuccess(result)
        } else {
          // If not JSON, it might be a redirect or HTML error page
          const text = await response.text()
          console.log('Non-JSON response:', text.substring(0, 500))
          this.handleError({ error: 'Server returned unexpected response format' })
        }
      } else {
        // Handle different error status codes
        await this.handleHttpError(response)
      }
    } catch (error) {
      console.error('Fetch error:', error)
      this.handleNetworkError(error)
    } finally {
      this.cleanup()
    }
  }

  async handleHttpError(response) {
    try {
      const contentType = response.headers.get('content-type')
      
      if (contentType && contentType.includes('application/json')) {
        const errorData = await response.json()
        this.handleError(errorData)
      } else {
        // Server returned HTML error page (common with 422/500 errors)
        const errorText = await response.text()
        console.log('HTML error response:', errorText.substring(0, 1000))
        
        // Try to extract meaningful error from HTML
        const errorMessage = this.extractErrorFromHtml(errorText) || 
                             `Server error (${response.status}): ${response.statusText}`
        
        this.handleError({ error: errorMessage })
      }
    } catch (parseError) {
      console.error('Error parsing error response:', parseError)
      this.handleError({ 
        error: `Server error (${response.status}): Unable to parse error details` 
      })
    }
  }

  extractErrorFromHtml(htmlText) {
    // Try to extract error message from Rails error pages
    const errorPatterns = [
      /<div[^>]*class="[^"]*exception[^"]*"[^>]*>([^<]+)/i,
      /<h1[^>]*>([^<]+)<\/h1>/i,
      /<title>([^<]+)<\/title>/i,
      /ActiveRecord::RecordInvalid:\s*(.+?)(?:\n|<)/i,
      /Validation failed:\s*(.+?)(?:\n|<)/i
    ]
    
    for (const pattern of errorPatterns) {
      const match = htmlText.match(pattern)
      if (match && match[1]) {
        return match[1].trim()
      }
    }
    
    return null
  }

  handleSuccess(result) {
    this.updateStatusMessage('Form generated successfully!', 'success')
    
    // Show the loading overlay while redirecting
    this.showGlobalLoadingOverlay()
    
    // Redirect after a short delay to show success message
    setTimeout(() => {
      if (result.redirect_url) {
        window.location.href = result.redirect_url
      } else if (this.redirectUrlValue) {
        window.location.href = this.redirectUrlValue
      } else {
        // Fallback: reload the page
        window.location.reload()
      }
    }, 1500)
  }

  handleError(errorData) {
    let errorMessage = 'An error occurred while generating your form.'
    
    if (typeof errorData === 'string') {
      errorMessage = errorData
    } else if (errorData && typeof errorData === 'object') {
      if (errorData.error) {
        errorMessage = errorData.error
      } else if (errorData.errors && Array.isArray(errorData.errors)) {
        errorMessage = errorData.errors.join(', ')
      } else if (errorData.message) {
        errorMessage = errorData.message
      }
    }
    
    // Clean up error message - ensure it's a string before calling replace
    errorMessage = this.cleanErrorMessage(String(errorMessage))
    
    this.showError(errorMessage)
    this.updateStatusMessage('Generation failed', 'error')
  }

  cleanErrorMessage(message) {
    // Ensure message is a string
    if (typeof message !== 'string') {
      return 'An unknown error occurred'
    }
    
    // Remove technical details that users don't need to see
    return message
      .replace(/ActiveRecord::[A-Za-z]+:\s*/g, '')
      .replace(/Validation failed:\s*/g, '')
      .replace(/undefined method\s+.+?\s+for\s+.+/g, 'Service temporarily unavailable')
      .replace(/\s+/g, ' ')
      .trim()
  }

  handleNetworkError(error) {
    console.error('Network error:', error)
    let errorMessage = 'Network error. Please check your connection and try again.'
    
    if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
      errorMessage = 'Unable to connect to server. Please check your internet connection.'
    } else if (error.name === 'AbortError') {
      errorMessage = 'Request was cancelled. Please try again.'
    }
    
    this.showError(errorMessage)
    this.updateStatusMessage('Connection failed', 'error')
  }

  handleTimeout() {
    this.showError('Request timed out. Please try again with shorter content.')
    this.updateStatusMessage('Request timed out', 'error')
    this.cleanup()
  }

  updateSubmitButton(isLoading) {
    // Find submit button in the current form
    const submitButton = this.currentForm?.querySelector('input[type="submit"], button[type="submit"]')
    if (!submitButton) return

    if (isLoading) {
      submitButton.disabled = true
      submitButton.classList.add('opacity-75', 'cursor-not-allowed')
      
      // Update button text with loading indicator
      const originalText = submitButton.textContent || submitButton.value
      submitButton.dataset.originalText = originalText
      
      if (submitButton.tagName === 'INPUT') {
        submitButton.value = 'Generating...'
      } else {
        submitButton.innerHTML = `
          <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
          Generating...
        `
      }
    } else {
      submitButton.disabled = false
      submitButton.classList.remove('opacity-75', 'cursor-not-allowed')
      
      // Restore original text
      const originalText = submitButton.dataset.originalText
      if (originalText) {
        if (submitButton.tagName === 'INPUT') {
          submitButton.value = originalText
        } else {
          submitButton.textContent = originalText
        }
      }
    }
  }

  showProgressIndicator() {
    if (this.hasProgressIndicatorTarget) {
      this.progressIndicatorTarget.classList.remove('hidden')
      this.progressIndicatorTarget.classList.add('animate-fade-in')
    }
  }

  hideProgressIndicator() {
    if (this.hasProgressIndicatorTarget) {
      this.progressIndicatorTarget.classList.add('hidden')
      this.progressIndicatorTarget.classList.remove('animate-fade-in')
    }
  }

  showGlobalLoadingOverlay() {
    // Show the AI processing overlay that's already in your HTML
    const overlay = document.getElementById('ai-processing-overlay')
    if (overlay) {
      overlay.classList.remove('hidden')
    }
  }

  hideGlobalLoadingOverlay() {
    const overlay = document.getElementById('ai-processing-overlay')
    if (overlay) {
      overlay.classList.add('hidden')
    }
  }

  updateStatusMessage(message, type = 'info') {
    if (!this.hasStatusMessageTarget) return

    this.statusMessageTarget.textContent = message
    this.statusMessageTarget.classList.remove('hidden', 'text-gray-600', 'text-green-600', 'text-red-600', 'text-blue-600')
    
    const colorClass = {
      'success': 'text-green-600',
      'error': 'text-red-600',
      'info': 'text-blue-600',
      'warning': 'text-amber-600'
    }[type] || 'text-gray-600'
    
    this.statusMessageTarget.classList.add(colorClass, 'animate-fade-in')
  }

  showError(message) {
    // Remove existing error messages first
    this.clearErrors()
    
    // Create error element if no target exists
    if (!this.hasErrorContainerTarget) {
      this.createErrorContainer(message)
    } else {
      this.errorContainerTarget.textContent = message
      this.errorContainerTarget.classList.remove('hidden')
      this.errorContainerTarget.classList.add('animate-fade-in')
    }
  }

  createErrorContainer(message) {
    const errorDiv = document.createElement('div')
    errorDiv.className = 'bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg mb-4 animate-fade-in'
    errorDiv.innerHTML = `
      <div class="flex items-center">
        <svg class="w-5 h-5 mr-2 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
        </svg>
        <span>${message}</span>
      </div>
    `
    
    // Insert at the top of the form
    if (this.currentForm) {
      this.currentForm.insertBefore(errorDiv, this.currentForm.firstChild)
      
      // Auto-remove after 8 seconds
      setTimeout(() => {
        errorDiv.remove()
      }, 8000)
    }
  }

  clearErrors() {
    if (this.hasErrorContainerTarget) {
      this.errorContainerTarget.classList.add('hidden')
      this.errorContainerTarget.textContent = ''
    }
    
    // Also remove any dynamically created error messages
    const errors = document.querySelectorAll('.bg-red-50')
    errors.forEach(error => {
      if (error.textContent.includes('Prompt must') || 
          error.textContent.includes('Please provide') ||
          error.textContent.includes('Server error') ||
          error.textContent.includes('Network error')) {
        error.remove()
      }
    })
  }

  cleanup() {
    this.isSubmitting = false
    this.updateSubmitButton(false)
    this.hideProgressIndicator()
    this.hideGlobalLoadingOverlay()
    this.currentForm = null
    
    if (this.timeoutId) {
      clearTimeout(this.timeoutId)
      this.timeoutId = null
    }
  }

  // Validation event handlers
  handleValidationUpdate(event) {
    const { isValid } = event.detail
    this.updateSubmitButtonState(isValid)
  }

  handleFileSelection(event) {
    // File was selected, enable submission if other validations pass
    this.updateSubmitButtonState(true)
  }

  handleFileCleared(event) {
    // File was cleared, check if prompt is valid
    if (!this.currentForm) return
    
    const formData = new FormData(this.currentForm)
    const prompt = formData.get('prompt')
    const isValid = prompt?.trim() && this.countWords(prompt.trim()) >= 10
    this.updateSubmitButtonState(isValid)
  }

  updateSubmitButtonState(isValid) {
    const submitButton = this.currentForm?.querySelector('input[type="submit"], button[type="submit"]')
    if (submitButton && !this.isSubmitting) {
      submitButton.disabled = !isValid
      if (isValid) {
        submitButton.classList.remove('opacity-50', 'cursor-not-allowed')
      } else {
        submitButton.classList.add('opacity-50', 'cursor-not-allowed')
      }
    }
  }

  // Utility methods
  countWords(text) {
    if (!text) return 0
    return text.split(/\s+/).filter(word => word.length > 0).length
  }

  getCSRFToken() {
    const token = document.querySelector('meta[name="csrf-token"]')
    return token ? token.getAttribute('content') : ''
  }

  // Public method to trigger submission (for external use)
  submit() {
    if (!this.isSubmitting && this.currentForm) {
      this.handleSubmit(new Event('submit'))
    }
  }

  // Public method to reset form state
  reset() {
    this.cleanup()
    this.clearErrors()
    if (this.hasStatusMessageTarget) {
      this.statusMessageTarget.classList.add('hidden')
    }
  }

  disconnect() {
    this.cleanup()
  }
}
</file>

<file path="javascript/controllers/auto_dismiss_controller.js">
import { Controller } from "@hotwired/stimulus"

// Connects to data-controller="auto-dismiss"
export default class extends Controller {
  static values = { delay: Number }
  
  connect() {
    this.timeout = setTimeout(() => {
      this.dismiss()
    }, this.delayValue || 5000)
  }
  
  disconnect() {
    if (this.timeout) {
      clearTimeout(this.timeout)
    }
  }
  
  dismiss() {
    this.element.style.transition = "opacity 0.3s ease-out, transform 0.3s ease-out"
    this.element.style.opacity = "0"
    this.element.style.transform = "translateY(-10px)"
    
    setTimeout(() => {
      if (this.element.parentNode) {
        this.element.remove()
      }
    }, 300)
  }
}
</file>

<file path="javascript/controllers/debug_controller.js">
import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  connect() {
    console.log("Debug controller connected")
  }

  turboStreamReceived(event) {
    console.log("Turbo Stream received:", event.detail)
  }
}
</file>

<file path="javascript/controllers/discount_code_controller.js">
import { Controller } from "@hotwired/stimulus"

// Connects to data-controller="discount-code"
export default class extends Controller {
  static targets = [
    "input", 
    "applyButton", 
    "clearButton",
    "feedback", 
    "originalPrice", 
    "discountAmount", 
    "finalPrice",
    "discountPercentage",
    "pricingDetails"
  ]
  
  static values = { 
    billingCycle: String,
    validateUrl: String
  }

  connect() {
    this.isValidating = false
    this.currentDiscount = null
    this.debounceTimer = null
    
    // Initialize state
    this.clearDiscount()
  }

  disconnect() {
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer)
    }
  }

  // Handle input changes with debouncing
  inputChanged() {
    const code = this.inputTarget.value.trim()
    
    // Clear previous timer
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer)
    }
    
    // Clear feedback and enable/disable buttons
    this.clearFeedback()
    this.updateButtonStates(code)
    
    // If code is empty, clear discount
    if (!code) {
      this.clearDiscount()
      return
    }
    
    // Debounce validation (wait 500ms after user stops typing)
    this.debounceTimer = setTimeout(() => {
      this.validateCode(code)
    }, 500)
  }

  // Manual apply button click
  applyDiscount(event) {
    event.preventDefault()
    const code = this.inputTarget.value.trim()
    
    if (!code) {
      this.showError("Please enter a discount code")
      return
    }
    
    this.validateCode(code)
  }

  // Clear discount code
  clearDiscount(event) {
    if (event) {
      event.preventDefault()
    }
    
    this.inputTarget.value = ""
    this.currentDiscount = null
    this.clearFeedback()
    this.resetPricing()
    this.updateButtonStates("")
    
    // Clear any pending validation
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer)
    }
  }

  // Validate discount code via API
  async validateCode(code) {
    if (this.isValidating) return
    
    this.isValidating = true
    this.showLoading()
    
    try {
      const response = await fetch(this.validateUrlValue, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': this.getCSRFToken()
        },
        body: JSON.stringify({
          code: code,
          billing_cycle: this.billingCycleValue
        })
      })
      
      const data = await response.json()
      
      if (response.ok && data.valid) {
        this.handleValidDiscount(data)
      } else {
        this.handleInvalidDiscount(data.error || "Invalid discount code")
      }
    } catch (error) {
      console.error('Discount validation error:', error)
      this.showError("Unable to validate discount code. Please try again.")
    } finally {
      this.isValidating = false
    }
  }

  // Handle valid discount response
  handleValidDiscount(data) {
    this.currentDiscount = data
    
    // Show success feedback
    this.showSuccess(`${data.discount_code.discount_percentage}% discount applied!`)
    
    // Update pricing display
    this.updatePricing(data.pricing)
    
    // Update button states
    this.updateButtonStates(this.inputTarget.value.trim(), true)
    
    // Dispatch custom event for other components
    this.dispatch("applied", { 
      detail: { 
        discountCode: data.discount_code,
        pricing: data.pricing
      } 
    })
  }

  // Handle invalid discount response
  handleInvalidDiscount(errorMessage) {
    this.currentDiscount = null
    this.showError(errorMessage)
    this.resetPricing()
    this.updateButtonStates(this.inputTarget.value.trim(), false)
    
    // Dispatch custom event
    this.dispatch("cleared")
  }

  // Update pricing display
  updatePricing(pricing) {
    if (this.hasOriginalPriceTarget) {
      this.originalPriceTarget.textContent = this.formatPrice(pricing.original_amount)
    }
    
    if (this.hasDiscountAmountTarget) {
      this.discountAmountTarget.textContent = `-${this.formatPrice(pricing.discount_amount)}`
    }
    
    if (this.hasFinalPriceTarget) {
      this.finalPriceTarget.textContent = this.formatPrice(pricing.final_amount)
    }
    
    if (this.hasDiscountPercentageTarget && this.currentDiscount) {
      this.discountPercentageTarget.textContent = `${this.currentDiscount.discount_code.discount_percentage}%`
    }
    
    // Show pricing details section
    if (this.hasPricingDetailsTarget) {
      this.pricingDetailsTarget.classList.remove('hidden')
    }
  }

  // Reset pricing to original values
  resetPricing() {
    if (this.hasDiscountAmountTarget) {
      this.discountAmountTarget.textContent = "$0.00"
    }
    
    if (this.hasDiscountPercentageTarget) {
      this.discountPercentageTarget.textContent = "0%"
    }
    
    // Hide pricing details section
    if (this.hasPricingDetailsTarget) {
      this.pricingDetailsTarget.classList.add('hidden')
    }
    
    // Dispatch custom event
    this.dispatch("cleared")
  }

  // Update button states based on input and validation status
  updateButtonStates(code, isValid = null) {
    const hasCode = code.length > 0
    
    // Apply button
    if (this.hasApplyButtonTarget) {
      this.applyButtonTarget.disabled = !hasCode || this.isValidating
      
      if (this.isValidating) {
        this.applyButtonTarget.textContent = "Validating..."
      } else if (isValid === true) {
        this.applyButtonTarget.textContent = "Applied "
      } else {
        this.applyButtonTarget.textContent = "Apply"
      }
    }
    
    // Clear button
    if (this.hasClearButtonTarget) {
      if (hasCode || isValid === true) {
        this.clearButtonTarget.classList.remove('hidden')
      } else {
        this.clearButtonTarget.classList.add('hidden')
      }
    }
  }

  // Show loading state
  showLoading() {
    this.clearFeedback()
    if (this.hasFeedbackTarget) {
      this.feedbackTarget.innerHTML = `
        <div class="flex items-center text-sm text-gray-600">
          <svg class="animate-spin -ml-1 mr-2 h-4 w-4 text-gray-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
          Validating discount code...
        </div>
      `
      this.feedbackTarget.classList.remove('hidden')
    }
  }

  // Show success message
  showSuccess(message) {
    this.clearFeedback()
    if (this.hasFeedbackTarget) {
      this.feedbackTarget.innerHTML = `
        <div class="flex items-center text-sm text-green-600">
          <svg class="mr-2 h-4 w-4" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
          </svg>
          ${message}
        </div>
      `
      this.feedbackTarget.classList.remove('hidden')
    }
  }

  // Show error message
  showError(message) {
    this.clearFeedback()
    if (this.hasFeedbackTarget) {
      this.feedbackTarget.innerHTML = `
        <div class="flex items-center text-sm text-red-600">
          <svg class="mr-2 h-4 w-4" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path>
          </svg>
          ${message}
        </div>
      `
      this.feedbackTarget.classList.remove('hidden')
    }
  }

  // Clear feedback messages
  clearFeedback() {
    if (this.hasFeedbackTarget) {
      this.feedbackTarget.innerHTML = ""
      this.feedbackTarget.classList.add('hidden')
    }
  }

  // Format price for display
  formatPrice(cents) {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD'
    }).format(cents / 100)
  }

  // Get CSRF token for API requests
  getCSRFToken() {
    const token = document.querySelector('meta[name="csrf-token"]')
    return token ? token.getAttribute('content') : ''
  }

  // Getter for current discount data (for external access)
  get discountData() {
    return this.currentDiscount
  }

  // Check if discount is currently applied
  get hasDiscount() {
    return this.currentDiscount !== null
  }
}
</file>

<file path="javascript/controllers/dropdown_controller.js">
import { Controller } from "@hotwired/stimulus"

// Connects to data-controller="dropdown"
export default class extends Controller {
  static targets = ["menu"]

  connect() {
    // Close dropdown when clicking outside
    this.boundCloseOnClickOutside = this.closeOnClickOutside.bind(this)
  }

  disconnect() {
    document.removeEventListener("click", this.boundCloseOnClickOutside)
  }

  toggle(event) {
    event.preventDefault()
    event.stopPropagation()
    
    if (this.menuTarget.classList.contains("hidden")) {
      this.open()
    } else {
      this.close()
    }
  }

  open() {
    this.menuTarget.classList.remove("hidden")
    document.addEventListener("click", this.boundCloseOnClickOutside)
  }

  close() {
    this.menuTarget.classList.add("hidden")
    document.removeEventListener("click", this.boundCloseOnClickOutside)
  }

  closeOnClickOutside(event) {
    if (!this.element.contains(event.target)) {
      this.close()
    }
  }
}
</file>

<file path="javascript/controllers/dynamic_question_controller.js">
// app/javascript/controllers/dynamic_question_controller.js
import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  static targets = ["submitButton", "answerInput"]
  static values = {
    responseId: String,
    dynamicId: String
  }

  submitAnswer(event) {
    event.preventDefault()
    this.submitButtonTarget.disabled = true
    this.submitButtonTarget.textContent = "Processing..."

    const answerValue = this.answerInputTarget ? this.answerInputTarget.value : "" // Maneja diferentes tipos de input
    // Necesitars una ruta para enviar esta respuesta. La crearemos a continuacin.
    const url = `/form_responses/${this.responseIdValue}/dynamic_questions/${this.dynamicIdValue}/answer`
    const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content')

    fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': csrfToken,
        'Accept': 'application/json'
      },
      body: JSON.stringify({
        answer: {
          value: answerValue
        }
      })
    })
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        window.location.reload()
      } else {
        alert("Hubo un error al enviar tu respuesta.")
        this.submitButtonTarget.disabled = false
        this.submitButtonTarget.textContent = "Continuar"
      }
    })
  }
}
</file>

<file path="javascript/controllers/error_recovery_controller.js">
import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  static targets = ["retryButton", "retryCountdown", "errorMessage"]
  static values = { 
    retryDelay: Number,
    autoRetry: Boolean,
    retryUrl: String,
    maxRetries: Number,
    currentRetries: Number
  }

  connect() {
    this.retryCount = this.currentRetriesValue || 0
    
    if (this.autoRetryValue && this.retryDelayValue > 0) {
      this.startRetryCountdown()
    }
  }

  retry(event) {
    event.preventDefault()
    
    const action = event.target.dataset.action
    
    switch (action) {
      case 'retry':
        this.performRetry()
        break
      case 'switch_input':
        this.switchInputMethod()
        break
      case 'edit_content':
        this.focusContentInput()
        break
      case 'upgrade':
        window.location.href = '/subscriptions/upgrade'
        break
      case 'support':
        window.location.href = '/support'
        break
      case 'show_examples':
        this.showExamples()
        break
      case 'use_template':
        window.location.href = '/templates'
        break
      case 'manual_form':
        window.location.href = '/forms/new'
        break
      case 'view_usage':
        window.location.href = '/profile/usage'
        break
      case 'status_page':
        window.open('https://status.agentform.com', '_blank')
        break
      default:
        this.performRetry()
    }
  }

  performRetry() {
    // Track retry attempt
    this.trackRetryAttempt()
    
    // Disable retry button and show loading state
    if (this.hasRetryButtonTarget) {
      this.retryButtonTarget.disabled = true
      this.retryButtonTarget.innerHTML = `
        <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
          <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
          <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        Retrying...
      `
    }

    // Submit the form again
    const form = this.element.closest('form')
    if (form) {
      form.submit()
    } else {
      // Fallback: reload the page
      window.location.reload()
    }
  }

  switchInputMethod() {
    // Switch between prompt and document tabs
    const tabsController = this.application.getControllerForElementAndIdentifier(
      document.querySelector('[data-controller*="tabs"]'), 
      'tabs'
    )
    
    if (tabsController) {
      // Determine current tab and switch to the other
      const currentTab = document.querySelector('[data-tabs-target="tab"].active')?.dataset.tabName
      const newTab = currentTab === 'prompt' ? 'document' : 'prompt'
      
      // Trigger tab switch
      const newTabButton = document.querySelector(`[data-tab-name="${newTab}"]`)
      if (newTabButton) {
        newTabButton.click()
      }
    }
  }

  focusContentInput() {
    // Focus on the main content input
    const promptInput = document.querySelector('[data-form-preview-target="promptInput"]')
    const documentInput = document.querySelector('[data-file-upload-target="fileInput"]')
    
    if (promptInput && !promptInput.closest('.hidden')) {
      promptInput.focus()
      promptInput.scrollIntoView({ behavior: 'smooth', block: 'center' })
    } else if (documentInput && !documentInput.closest('.hidden')) {
      documentInput.click()
    }
  }

  showExamples() {
    // Show examples modal or navigate to examples page
    const examplesModal = document.querySelector('#examples-modal')
    if (examplesModal) {
      // If modal exists, show it
      examplesModal.classList.remove('hidden')
    } else {
      // Otherwise navigate to examples page
      window.location.href = '/help/examples'
    }
  }

  startRetryCountdown() {
    let remainingTime = this.retryDelayValue
    
    if (this.hasRetryCountdownTarget) {
      this.retryCountdownTarget.textContent = remainingTime
      this.retryCountdownTarget.classList.remove('hidden')
    }

    const countdown = setInterval(() => {
      remainingTime--
      
      if (this.hasRetryCountdownTarget) {
        this.retryCountdownTarget.textContent = remainingTime
      }
      
      if (remainingTime <= 0) {
        clearInterval(countdown)
        this.showAutoRetryPrompt()
      }
    }, 1000)
  }

  showAutoRetryPrompt() {
    if (this.hasRetryCountdownTarget) {
      this.retryCountdownTarget.classList.add('hidden')
    }

    const shouldRetry = confirm(
      'Would you like to automatically retry with optimized settings? ' +
      'This may improve the chances of success.'
    )
    
    if (shouldRetry) {
      this.performRetry()
    }
  }

  trackRetryAttempt() {
    // Track retry attempt for analytics
    if (window.gtag) {
      window.gtag('event', 'retry_attempt', {
        event_category: 'ai_form_generation',
        event_label: 'user_initiated_retry',
        value: this.retryCount + 1
      })
    }

    // Send to backend for tracking
    fetch('/api/v1/analytics/events', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('[name="csrf-token"]')?.content
      },
      body: JSON.stringify({
        event_type: 'retry_attempted',
        event_data: {
          retry_count: this.retryCount + 1,
          error_recovery: true,
          timestamp: new Date().toISOString()
        }
      })
    }).catch(error => {
      console.log('Analytics tracking failed:', error)
    })
  }

  // Handle escape key to close error details
  handleKeydown(event) {
    if (event.key === 'Escape') {
      const expandedDetails = this.element.querySelector('.error-details.expanded')
      if (expandedDetails) {
        expandedDetails.classList.remove('expanded')
      }
    }
  }

  // Toggle error details expansion
  toggleDetails(event) {
    event.preventDefault()
    const details = event.target.closest('.error-details')
    if (details) {
      details.classList.toggle('expanded')
    }
  }

  // Copy error details to clipboard for support
  copyErrorDetails(event) {
    event.preventDefault()
    
    const errorDetails = {
      timestamp: new Date().toISOString(),
      error_type: this.element.dataset.errorType,
      retry_count: this.retryCount,
      user_agent: navigator.userAgent,
      url: window.location.href
    }
    
    const errorText = JSON.stringify(errorDetails, null, 2)
    
    if (navigator.clipboard) {
      navigator.clipboard.writeText(errorText).then(() => {
        this.showCopySuccess()
      }).catch(() => {
        this.fallbackCopyToClipboard(errorText)
      })
    } else {
      this.fallbackCopyToClipboard(errorText)
    }
  }

  fallbackCopyToClipboard(text) {
    const textArea = document.createElement('textarea')
    textArea.value = text
    textArea.style.position = 'fixed'
    textArea.style.left = '-999999px'
    textArea.style.top = '-999999px'
    document.body.appendChild(textArea)
    textArea.focus()
    textArea.select()
    
    try {
      document.execCommand('copy')
      this.showCopySuccess()
    } catch (err) {
      console.error('Failed to copy error details:', err)
    }
    
    document.body.removeChild(textArea)
  }

  showCopySuccess() {
    // Show temporary success message
    const successMessage = document.createElement('div')
    successMessage.className = 'fixed top-4 right-4 bg-green-500 text-white px-4 py-2 rounded-md shadow-lg z-50'
    successMessage.textContent = 'Error details copied to clipboard'
    
    document.body.appendChild(successMessage)
    
    setTimeout(() => {
      document.body.removeChild(successMessage)
    }, 3000)
  }
}
</file>

<file path="javascript/controllers/file_upload_controller.js">
import { Controller } from "@hotwired/stimulus"

// Connects to data-controller="file-upload"
export default class extends Controller {
  static targets = ["fileInput", "dropZone", "fileName", "fileSize", "fileInfo", "uploadPrompt", "errorMessage"]
  static values = { 
    maxSize: { type: Number, default: 10485760 }, // 10MB in bytes
    acceptedTypes: { type: Array, default: ['application/pdf', 'text/markdown', 'text/plain'] }
  }

  connect() {
    try {
      // Check if the controller's element is visible before initializing
      if (!this.isElementVisible()) {
        console.log('file-upload controller connected but element is hidden, skipping initialization')
        return
      }
      
      // Only initialize if we have the required targets
      if (!this.hasDropZoneTarget) {
        console.log('file-upload controller connected but no dropZone target found, will initialize when visible')
        return
      }
      
      this.setupDragAndDrop()
      this.hideFileInfo()
    } catch (error) {
      console.error('Error in file-upload controller connect:', error)
      // Silently fail - controller will not be functional but won't break the page
    }
  }

  // Called when the element becomes visible (e.g., when tab is switched)
  initializeWhenVisible() {
    if (this.hasDropZoneTarget && this.isElementVisible()) {
      this.setupDragAndDrop()
      this.hideFileInfo()
    }
  }

  isElementVisible() {
    const element = this.element
    if (!element) return false
    
    // Check if element or any parent has 'hidden' class
    let current = element
    while (current) {
      if (current.classList && current.classList.contains('hidden')) {
        return false
      }
      current = current.parentElement
    }
    
    // Check computed style
    const style = window.getComputedStyle(element)
    return style.display !== 'none' && style.visibility !== 'hidden'
  }

  setupDragAndDrop() {
    try {
      // Verify dropZone target exists before setting up event listeners
      if (!this.dropZoneTarget) {
        console.warn('dropZoneTarget is not available in setupDragAndDrop')
        return
      }

      // Prevent setting up multiple times
      if (this.dragDropInitialized) {
        return
      }

      // Prevent default drag behaviors on the entire document
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        document.addEventListener(eventName, this.preventDefaults.bind(this), false)
      })

      // Highlight drop zone when item is dragged over it
      ['dragenter', 'dragover'].forEach(eventName => {
        this.dropZoneTarget.addEventListener(eventName, this.highlight.bind(this), false)
      })

      ['dragleave', 'drop'].forEach(eventName => {
        this.dropZoneTarget.addEventListener(eventName, this.unhighlight.bind(this), false)
      })

      // Handle dropped files
      this.dropZoneTarget.addEventListener('drop', this.handleDrop.bind(this), false)
      
      this.dragDropInitialized = true
    } catch (error) {
      console.error('Error in setupDragAndDrop:', error)
    }
  }

  disconnect() {
    // Clean up event listeners when controller is disconnected
    if (this.dragDropInitialized) {
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        document.removeEventListener(eventName, this.preventDefaults.bind(this), false)
      })
    }
    
    // Remove tab switch listener
    this.element.removeEventListener('tabs:switched', this.handleTabSwitch.bind(this))
  }

  // Handle tab switch events
  handleTabSwitch(event) {
    const { activeTab } = event.detail
    
    // If switching to document tab and we haven't initialized yet, do it now
    if (activeTab === 'document' && !this.dragDropInitialized) {
      setTimeout(() => {
        this.initializeWhenVisible()
      }, 100) // Small delay to ensure DOM updates are complete
    }
  }

  preventDefaults(e) {
    e.preventDefault()
    e.stopPropagation()
  }

  highlight(e) {
    if (this.hasDropZoneTarget && this.dropZoneTarget) {
      this.dropZoneTarget.classList.add('border-indigo-400', 'bg-indigo-50')
      this.dropZoneTarget.classList.remove('border-gray-300')
    }
  }

  unhighlight(e) {
    if (this.hasDropZoneTarget && this.dropZoneTarget) {
      this.dropZoneTarget.classList.remove('border-indigo-400', 'bg-indigo-50')
      this.dropZoneTarget.classList.add('border-gray-300')
    }
  }

  handleDrop(e) {
    const dt = e.dataTransfer
    const files = dt.files
    this.handleFiles(files)
  }

  // Handle file selection via input
  fileSelected(event) {
    const files = event.target.files
    this.handleFiles(files)
  }

  handleFiles(files) {
    if (files.length === 0) return

    const file = files[0] // Only handle the first file
    
    if (this.validateFile(file)) {
      this.displayFileInfo(file)
      this.clearError()
      
      // Dispatch event with file data for other controllers
      this.dispatch('fileSelected', { 
        detail: { 
          file: file,
          fileName: file.name,
          fileSize: file.size,
          fileType: file.type
        } 
      })
    }
  }

  validateFile(file) {
    // Check file size
    if (file.size > this.maxSizeValue) {
      this.showError(`File size must be less than ${this.formatFileSize(this.maxSizeValue)}`)
      return false
    }

    // Check file type
    if (!this.acceptedTypesValue.includes(file.type)) {
      const acceptedExtensions = this.getAcceptedExtensions()
      this.showError(`Please upload a valid file type: ${acceptedExtensions.join(', ')}`)
      return false
    }

    return true
  }

  displayFileInfo(file) {
    if (this.hasFileNameTarget) {
      this.fileNameTarget.textContent = file.name
    }
    
    if (this.hasFileSizeTarget) {
      this.fileSizeTarget.textContent = this.formatFileSize(file.size)
    }
    
    // Hide upload prompt and show file info
    this.hideUploadPrompt()
    
    if (this.hasFileInfoTarget) {
      this.fileInfoTarget.classList.remove('hidden')
      this.fileInfoTarget.classList.add('animate-fade-in')
    }
  }

  hideFileInfo() {
    if (this.hasFileInfoTarget) {
      this.fileInfoTarget.classList.add('hidden')
    }
  }

  showUploadPrompt() {
    if (this.hasUploadPromptTarget) {
      this.uploadPromptTarget.classList.remove('hidden')
    }
  }

  hideUploadPrompt() {
    if (this.hasUploadPromptTarget) {
      this.uploadPromptTarget.classList.add('hidden')
    }
  }

  clearFile() {
    // Clear the file input
    if (this.hasFileInputTarget) {
      this.fileInputTarget.value = ''
    }
    
    // Hide file info and show upload prompt
    this.hideFileInfo()
    this.showUploadPrompt()
    
    // Clear any errors
    this.clearError()
    
    // Dispatch cleared event
    this.dispatch('fileCleared')
  }

  showError(message) {
    if (this.hasErrorMessageTarget) {
      this.errorMessageTarget.textContent = message
      this.errorMessageTarget.classList.remove('hidden')
      this.errorMessageTarget.classList.add('animate-fade-in')
    }
  }

  clearError() {
    if (this.hasErrorMessageTarget) {
      this.errorMessageTarget.classList.add('hidden')
      this.errorMessageTarget.textContent = ''
    }
  }

  formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes'
    
    const k = 1024
    const sizes = ['Bytes', 'KB', 'MB', 'GB']
    const i = Math.floor(Math.log(bytes) / Math.log(k))
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
  }

  getAcceptedExtensions() {
    const typeMap = {
      'application/pdf': 'PDF',
      'text/markdown': 'Markdown (.md)',
      'text/plain': 'Text (.txt)'
    }
    
    return this.acceptedTypesValue.map(type => typeMap[type] || type)
  }

  // Public method to trigger file selection
  triggerFileSelect() {
    if (this.hasFileInputTarget) {
      this.fileInputTarget.click()
    }
  }

  // Drag event handlers for external use
  dragOver(event) {
    this.highlight(event)
  }

  dragEnter(event) {
    this.highlight(event)
  }

  dragLeave(event) {
    this.unhighlight(event)
  }

  drop(event) {
    this.unhighlight(event)
    this.handleDrop(event)
  }
}
</file>

<file path="javascript/controllers/form_animation_controller.js">
import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  static targets = ["questionContainer", "progressBar", "navigationButtons", "progressFill", "questionInput"]
  static values = {
    currentStep: Number,
    totalSteps: Number,
    animationType: { type: String, default: "slide-up-elegant" },
    animationDuration: { type: Number, default: 400 }
  }

  connect() {
    console.log('Form animation controller connected')
    this.isAnimating = false
    
    // Apply initial animation styles without hiding content
    this.setupInitialAnimations()
  }

  disconnect() {
    // Clean up any running animations
    if (this.animationTimeout) {
      clearTimeout(this.animationTimeout)
    }
  }

  setupInitialAnimations() {
    // Only apply animations if elements are visible
    const elementsToAnimate = [
      { element: this.element, delay: 0, name: 'main container' },
      { element: this.hasProgressBarTarget ? this.progressBarTarget : null, delay: 150, name: 'progress bar' },
      { element: this.hasQuestionInputTarget ? this.questionInputTarget : null, delay: 300, name: 'question input' },
      { element: this.hasNavigationButtonsTarget ? this.navigationButtonsTarget : null, delay: 450, name: 'navigation buttons' }
    ].filter(item => item.element)

    console.log(`Setting up animations for ${elementsToAnimate.length} elements`)

    elementsToAnimate.forEach(({ element, delay, name }) => {
      if (element) {
        console.log(`Preparing animation for: ${name}`)
        
        // Set initial state for animation (subtle, won't break functionality)
        element.style.transform = 'translateY(15px)'
        element.style.opacity = '0.7'
        
        // Animate in after delay
        setTimeout(() => {
          this.animateElementIn(element, name)
        }, delay)
      }
    })
  }

  animateElementIn(element, name = 'element') {
    if (!element) return
    
    console.log(` Animating ${name} in`)
    
    // Apply smooth transition
    element.style.transition = 'all 0.6s cubic-bezier(0.16, 1, 0.3, 1)'
    element.style.transform = 'translateY(0)'
    element.style.opacity = '1'
    
    // Add subtle bounce effect
    setTimeout(() => {
      element.style.transform = 'translateY(-2px)'
      setTimeout(() => {
        element.style.transform = 'translateY(0)'
        
        // Clean up after animation
        setTimeout(() => {
          element.style.transition = ''
          element.style.transform = ''
          element.style.opacity = ''
          console.log(` Animation complete for ${name}`)
        }, 200)
      }, 100)
    }, 500)
  }

  animateElementOut(element, callback) {
    if (!element) {
      if (callback) callback()
      return
    }
    
    console.log('Animating element out:', element.className)
    
    this.isAnimating = true
    element.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.6, 1)'
    element.style.transform = 'translateY(-20px)'
    element.style.opacity = '0.5'
    
    setTimeout(() => {
      this.isAnimating = false
      if (callback) callback()
    }, 300)
  }

  // Public methods for external controllers
  animateNextQuestion() {
    console.log('Animating to next question')
    
    // Simple fade out animation
    if (this.element) {
      this.animateElementOut(this.element)
    }
  }

  showLoadingState() {
    const submitButton = this.element.querySelector('[data-question-response-target="submitButton"]')
    if (submitButton) {
      submitButton.style.opacity = '0.7'
      submitButton.style.pointerEvents = 'none'
    }
  }

  hideLoadingState() {
    const submitButton = this.element.querySelector('[data-question-response-target="submitButton"]')
    if (submitButton) {
      submitButton.style.opacity = '1'
      submitButton.style.pointerEvents = 'auto'
    }
  }
}
</file>

<file path="javascript/controllers/form_builder_controller.js">
import { Controller } from "@hotwired/stimulus"

// Connects to data-controller="form-builder"
export default class extends Controller {
  static targets = ["saveIndicator", "saveStatus", "questionsList"]
  static values = { 
    formId: String,
    csrfToken: String
  }

  connect() {
    console.log('Form builder controller connected successfully')
    console.log('Form ID:', this.formIdValue)
    console.log('Has questionsList target:', this.hasQuestionsListTarget)
  }

  // Test method to verify connection
  testConnection(event) {
    event.preventDefault()
    alert('Controller is working!')
    console.log('Test successful')
    console.log('Form ID:', this.formIdValue)
    console.log('Has questionsList target:', this.hasQuestionsListTarget)
  }

  // Main add question method
  addQuestion(event) {
    event.preventDefault()
    console.log('Add question clicked')
    
    const questionType = event.currentTarget.dataset.questionType || 'text_short'
    console.log('Question type:', questionType)
    
    this.createQuestion(questionType)
  }

  // Create question via AJAX
  async createQuestion(questionType) {
    console.log('Creating question with type:', questionType)
    
    // Show loading state
    const addButtons = this.element.querySelectorAll('[data-action*="addQuestion"]')
    addButtons.forEach(button => {
      button.disabled = true
      button.style.opacity = '0.5'
    })
    
    try {
      const url = `/forms/${this.formIdValue}/questions`
      console.log('Making request to:', url)
      
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': this.csrfTokenValue,
          'Accept': 'application/json'
        },
        body: JSON.stringify({
          form_question: {
            question_type: questionType,
            title: `New ${questionType.replace('_', ' ')} question`,
            required: false
          }
        })
      })

      console.log('Response status:', response.status)

      if (response.ok) {
        const data = await response.json()
        console.log('Question created successfully:', data)
        
        // Reload page to show the new question
        window.location.reload()
        
      } else {
        const errorData = await response.json()
        console.error('Server error:', errorData)
        throw new Error(errorData.errors ? errorData.errors.join(', ') : 'Failed to create question')
      }
    } catch (error) {
      console.error('Error creating question:', error)
      alert('Failed to create question: ' + error.message)
    } finally {
      // Restore button states
      addButtons.forEach(button => {
        button.disabled = false
        button.style.opacity = '1'
      })
    }
  }

  // Additional methods for functionality
  editQuestion(event) {
    event.preventDefault()
    const questionCard = event.currentTarget.closest('[data-question-id]')
    const questionId = questionCard.dataset.questionId
    console.log('Edit question:', questionId, 'Form ID:', this.formIdValue)
    
    // Build the correct URL
    const editUrl = `/forms/${this.formIdValue}/questions/${questionId}/edit`
    console.log('Navigating to:', editUrl)
    window.location.href = editUrl
  }

  async deleteQuestion(event) {
    event.preventDefault()
    
    if (!confirm('Are you sure you want to delete this question?')) {
      return
    }

    const questionCard = event.currentTarget.closest('[data-question-id]')
    const questionId = questionCard.dataset.questionId
    console.log('Deleting question:', questionId)

    // Show loading state
    const deleteButton = event.currentTarget
    const originalText = deleteButton.innerHTML
    deleteButton.innerHTML = '...'
    deleteButton.disabled = true

    try {
      const response = await fetch(`/forms/${this.formIdValue}/questions/${questionId}`, {
        method: 'DELETE',
        headers: {
          'X-CSRF-Token': this.csrfTokenValue,
          'Accept': 'application/json'
        }
      })

      if (response.ok) {
        console.log('Question deleted successfully')
        
        // Immediately disable all buttons to prevent further clicks
        const allButtons = questionCard.querySelectorAll('button')
        allButtons.forEach(btn => {
          btn.disabled = true
          btn.style.pointerEvents = 'none'
        })
        
        // Add a "deleted" class for visual feedback
        questionCard.classList.add('deleted')
        questionCard.style.pointerEvents = 'none'
        
        // Animate removal
        questionCard.style.transition = 'all 0.3s ease'
        questionCard.style.opacity = '0.3'
        questionCard.style.transform = 'translateX(-20px)'
        questionCard.style.filter = 'grayscale(100%)'
        
        // Remove from DOM after animation
        setTimeout(() => {
          questionCard.remove()
          this.updateStepNumbers()
        }, 300)
        
      } else {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Failed to delete question')
      }
    } catch (error) {
      console.error('Error deleting question:', error)
      alert('Failed to delete question: ' + error.message)
      
      // Restore button state
      deleteButton.innerHTML = originalText
      deleteButton.disabled = false
    }
  }

  async duplicateQuestion(event) {
    event.preventDefault()
    const questionCard = event.currentTarget.closest('[data-question-id]')
    const questionId = questionCard.dataset.questionId
    console.log('Duplicating question:', questionId)

    // Show loading state
    const duplicateButton = event.currentTarget
    const originalText = duplicateButton.innerHTML
    duplicateButton.innerHTML = '...'
    duplicateButton.disabled = true

    try {
      const response = await fetch(`/forms/${this.formIdValue}/questions/${questionId}/duplicate`, {
        method: 'POST',
        headers: {
          'X-CSRF-Token': this.csrfTokenValue,
          'Accept': 'application/json'
        }
      })

      if (response.ok) {
        console.log('Question duplicated successfully')
        // Reload page to show duplicated question
        window.location.reload()
        
      } else {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Failed to duplicate question')
      }
    } catch (error) {
      console.error('Error duplicating question:', error)
      alert('Failed to duplicate question: ' + error.message)
    } finally {
      // Restore button state
      duplicateButton.innerHTML = originalText
      duplicateButton.disabled = false
    }
  }

  // Toggle question required status
  async toggleRequired(event) {
    const questionCard = event.currentTarget.closest('[data-question-id]')
    const questionId = questionCard.dataset.questionId
    const isRequired = event.currentTarget.checked
    
    console.log('Toggling required for question:', questionId, 'to:', isRequired)

    try {
      const response = await fetch(`/forms/${this.formIdValue}/questions/${questionId}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': this.csrfTokenValue,
          'Accept': 'application/json'
        },
        body: JSON.stringify({
          form_question: {
            required: isRequired
          }
        })
      })

      if (response.ok) {
        console.log('Required status updated successfully')
        
        // Update the badge in the UI
        const requiredBadge = questionCard.querySelector('.bg-red-100.text-red-800')
        if (isRequired && !requiredBadge) {
          // Add required badge
          const badgeContainer = questionCard.querySelector('.flex.items-center.space-x-2.mb-1')
          const newBadge = document.createElement('span')
          newBadge.className = 'inline-flex items-center px-2 py-1 text-xs font-medium bg-red-100 text-red-800 rounded-full'
          newBadge.textContent = 'Required'
          badgeContainer.appendChild(newBadge)
        } else if (!isRequired && requiredBadge) {
          // Remove required badge
          requiredBadge.remove()
        }
        
        this.setSaveStatus("saved")
      } else {
        // Revert the checkbox if the request failed
        event.currentTarget.checked = !isRequired
        const errorData = await response.json()
        throw new Error(errorData.error || 'Failed to update question')
      }
    } catch (error) {
      console.error('Error updating question:', error)
      // Revert checkbox on error
      event.currentTarget.checked = !isRequired
      alert('Failed to update required status: ' + error.message)
      this.setSaveStatus("error")
    }
  }

  // Set save status (for auto-save feedback)
  setSaveStatus(status) {
    if (!this.hasSaveIndicatorTarget || !this.hasSaveStatusTarget) return
    
    switch (status) {
      case "saving":
        this.saveIndicatorTarget.classList.remove("bg-green-400", "bg-red-400")
        this.saveIndicatorTarget.classList.add("bg-yellow-400")
        this.saveStatusTarget.textContent = "Saving..."
        break
      case "saved":
        this.saveIndicatorTarget.classList.remove("bg-yellow-400", "bg-red-400")
        this.saveIndicatorTarget.classList.add("bg-green-400")
        this.saveStatusTarget.textContent = "Saved"
        break
      case "error":
        this.saveIndicatorTarget.classList.remove("bg-green-400", "bg-yellow-400")
        this.saveIndicatorTarget.classList.add("bg-red-400")
        this.saveStatusTarget.textContent = "Error"
        break
    }
  }

  // Helper method to update step numbers after deletion
  updateStepNumbers() {
    const questionCards = this.questionsListTarget.querySelectorAll('[data-question-id]')
    questionCards.forEach((card, index) => {
      const stepLabel = card.querySelector('.inline-flex.items-center.px-2.py-1')
      if (stepLabel) {
        stepLabel.textContent = `Step ${index + 1}`
      }
    })
  }

  // Check if question type is payment-related
  isPaymentQuestion(questionType) {
    return questionType === 'payment' || questionType === 'subscription' || questionType === 'donation'
  }

  // Override createQuestion to handle payment questions
  async createQuestion(questionType) {
    console.log('Creating question with type:', questionType)
    
    // Check if this is a payment question and notify payment setup controller
    const isPayment = this.isPaymentQuestion(questionType)
    
    // Show loading state
    const addButtons = this.element.querySelectorAll('[data-action*="addQuestion"]')
    addButtons.forEach(button => {
      button.disabled = true
      button.style.opacity = '0.5'
    })
    
    try {
      const url = `/forms/${this.formIdValue}/questions`
      console.log('Making request to:', url)
      
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': this.csrfTokenValue,
          'Accept': 'application/json'
        },
        body: JSON.stringify({
          form_question: {
            question_type: questionType,
            title: `New ${questionType.replace('_', ' ')} question`,
            required: false
          }
        })
      })

      console.log('Response status:', response.status)

      if (response.ok) {
        const data = await response.json()
        console.log('Question created successfully:', data)
        
        // If this was a payment question, notify the payment setup controller
        if (isPayment) {
          this.notifyPaymentQuestionAdded()
        }
        
        // Reload page to show the new question
        window.location.reload()
        
      } else {
        const errorData = await response.json()
        console.error('Server error:', errorData)
        throw new Error(errorData.errors ? errorData.errors.join(', ') : 'Failed to create question')
      }
    } catch (error) {
      console.error('Error creating question:', error)
      alert('Failed to create question: ' + error.message)
    } finally {
      // Restore button states
      addButtons.forEach(button => {
        button.disabled = false
        button.style.opacity = '1'
      })
    }
  }

  // Override deleteQuestion to handle payment questions
  async deleteQuestion(event) {
    event.preventDefault()
    
    if (!confirm('Are you sure you want to delete this question?')) {
      return
    }

    const questionCard = event.currentTarget.closest('[data-question-id]')
    const questionId = questionCard.dataset.questionId
    
    // Check if this is a payment question
    const questionTypeElement = questionCard.querySelector('.font-medium')
    const questionType = questionTypeElement ? questionTypeElement.textContent.toLowerCase() : ''
    const isPayment = this.isPaymentQuestion(questionType)
    
    console.log('Deleting question:', questionId)

    // Show loading state
    const deleteButton = event.currentTarget
    const originalText = deleteButton.innerHTML
    deleteButton.innerHTML = '...'
    deleteButton.disabled = true

    try {
      const response = await fetch(`/forms/${this.formIdValue}/questions/${questionId}`, {
        method: 'DELETE',
        headers: {
          'X-CSRF-Token': this.csrfTokenValue,
          'Accept': 'application/json'
        }
      })

      if (response.ok) {
        console.log('Question deleted successfully')
        
        // If this was a payment question, notify the payment setup controller
        if (isPayment) {
          this.notifyPaymentQuestionRemoved()
        }
        
        // Immediately disable all buttons to prevent further clicks
        const allButtons = questionCard.querySelectorAll('button')
        allButtons.forEach(btn => {
          btn.disabled = true
          btn.style.pointerEvents = 'none'
        })
        
        // Add a "deleted" class for visual feedback
        questionCard.classList.add('deleted')
        questionCard.style.pointerEvents = 'none'
        
        // Animate removal
        questionCard.style.transition = 'all 0.3s ease'
        questionCard.style.opacity = '0.3'
        questionCard.style.transform = 'translateX(-20px)'
        questionCard.style.filter = 'grayscale(100%)'
        
        // Remove from DOM after animation
        setTimeout(() => {
          questionCard.remove()
          this.updateStepNumbers()
        }, 300)
        
      } else {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Failed to delete question')
      }
    } catch (error) {
      console.error('Error deleting question:', error)
      alert('Failed to delete question: ' + error.message)
      
      // Restore button state
      deleteButton.innerHTML = originalText
      deleteButton.disabled = false
    }
  }

  // Notify payment setup controller about payment question changes
  notifyPaymentQuestionAdded() {
    const paymentSetupController = this.application.getControllerForElementAndIdentifier(
      this.element, 'payment-setup-status'
    )
    
    if (paymentSetupController) {
      paymentSetupController.onPaymentQuestionAdded()
    }
  }

  notifyPaymentQuestionRemoved() {
    const paymentSetupController = this.application.getControllerForElementAndIdentifier(
      this.element, 'payment-setup-status'
    )
    
    if (paymentSetupController) {
      paymentSetupController.onPaymentQuestionRemoved()
    }
  }
}
</file>

<file path="javascript/controllers/form_preview_controller.js">
import { Controller } from "@hotwired/stimulus"

// Connects to data-controller="form-preview"
export default class extends Controller {
  static targets = ["wordCount", "costEstimate", "contentInput", "promptInput", "previewArea", "feedback"]
  static values = { 
    baseCost: { type: Number, default: 0.05 },
    questionCost: { type: Number, default: 0.01 },
    minWords: { type: Number, default: 10 },
    maxWords: { type: Number, default: 5000 },
    wordsPerQuestion: { type: Number, default: 50 } // Rough estimate for question generation
  }

  connect() {
    this.updatePreview()
    this.setupDebouncing()
  }

  setupDebouncing() {
    this.debounceTimer = null
    this.debounceDelay = 300 // 300ms delay
  }

  updatePreview(event) {
    // Clear existing timer
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer)
    }

    // Set new timer for debounced update
    this.debounceTimer = setTimeout(() => {
      this.performUpdate()
    }, this.debounceDelay)
  }

  performUpdate() {
    const content = this.getContentText()
    const wordCount = this.countWords(content)
    const estimatedQuestions = this.estimateQuestionCount(wordCount)
    const estimatedCost = this.calculateCost(estimatedQuestions)
    
    this.updateWordCount(wordCount)
    this.updateCostEstimate(estimatedCost, estimatedQuestions)
    this.updateFeedback(wordCount, content)
    
    // Dispatch update event for other controllers
    this.dispatch('updated', {
      detail: {
        wordCount: wordCount,
        estimatedCost: estimatedCost,
        estimatedQuestions: estimatedQuestions,
        isValid: this.isContentValid(wordCount)
      }
    })
  }

  getContentText() {
    if (this.hasPromptInputTarget) {
      return this.promptInputTarget.value.trim()
    } else if (this.hasContentInputTarget) {
      return this.contentInputTarget.value.trim()
    }
    return ''
  }

  countWords(text) {
    if (!text) return 0
    
    // Split by whitespace and filter out empty strings
    return text.split(/\s+/).filter(word => word.length > 0).length
  }

  estimateQuestionCount(wordCount) {
    if (wordCount === 0) return 0
    
    // Estimate questions based on content length
    // More sophisticated logic could be added here
    const baseQuestions = Math.max(1, Math.floor(wordCount / this.wordsPerQuestionValue))
    return Math.min(baseQuestions, 20) // Cap at 20 questions max
  }

  calculateCost(questionCount) {
    return this.baseCostValue + (questionCount * this.questionCostValue)
  }

  updateWordCount(count) {
    if (this.hasWordCountTarget) {
      this.wordCountTarget.textContent = count.toLocaleString()
      
      // Add visual feedback based on word count
      this.wordCountTarget.classList.remove('text-gray-600', 'text-amber-600', 'text-red-600', 'text-green-600')
      
      if (count === 0) {
        this.wordCountTarget.classList.add('text-gray-600')
      } else if (count < this.minWordsValue) {
        this.wordCountTarget.classList.add('text-amber-600')
      } else if (count > this.maxWordsValue) {
        this.wordCountTarget.classList.add('text-red-600')
      } else {
        this.wordCountTarget.classList.add('text-green-600')
      }
    }
  }

  updateCostEstimate(cost, questionCount) {
    if (this.hasCostEstimateTarget) {
      const formattedCost = cost.toFixed(2)
      this.costEstimateTarget.textContent = `$${formattedCost}`
      
      // Update additional cost information if available
      const costContainer = this.costEstimateTarget.closest('.cost-breakdown')
      if (costContainer) {
        const questionInfo = costContainer.querySelector('.question-estimate')
        if (questionInfo) {
          questionInfo.textContent = `~${questionCount} questions`
        }
      }
    }
  }

  updateFeedback(wordCount, content) {
    if (!this.hasFeedbackTarget) return

    let feedbackMessage = ''
    let feedbackClass = 'text-gray-600'

    if (wordCount === 0) {
      feedbackMessage = 'Start typing to see word count and cost estimate'
      feedbackClass = 'text-gray-600'
    } else if (wordCount < this.minWordsValue) {
      const needed = this.minWordsValue - wordCount
      feedbackMessage = `Add ${needed} more word${needed !== 1 ? 's' : ''} to meet minimum requirement`
      feedbackClass = 'text-amber-600'
    } else if (wordCount > this.maxWordsValue) {
      const excess = wordCount - this.maxWordsValue
      feedbackMessage = `Content is ${excess} word${excess !== 1 ? 's' : ''} over the limit. Please shorten.`
      feedbackClass = 'text-red-600'
    } else {
      feedbackMessage = 'Content length looks good!'
      feedbackClass = 'text-green-600'
    }

    this.feedbackTarget.textContent = feedbackMessage
    this.feedbackTarget.className = `text-sm ${feedbackClass}`
  }

  isContentValid(wordCount) {
    return wordCount >= this.minWordsValue && wordCount <= this.maxWordsValue
  }

  // Method to handle file content updates from file upload controller
  handleFileContent(event) {
    const { content } = event.detail
    if (this.hasContentInputTarget) {
      this.contentInputTarget.value = content
      this.updatePreview()
    }
  }

  // Method to clear preview
  clearPreview() {
    if (this.hasContentInputTarget) {
      this.contentInputTarget.value = ''
    }
    this.updatePreview()
  }

  // Method to get current metrics for external use
  getCurrentMetrics() {
    const content = this.getContentText()
    const wordCount = this.countWords(content)
    const estimatedQuestions = this.estimateQuestionCount(wordCount)
    const estimatedCost = this.calculateCost(estimatedQuestions)
    
    return {
      wordCount,
      estimatedQuestions,
      estimatedCost,
      isValid: this.isContentValid(wordCount),
      content
    }
  }

  // Method to update preview with external content
  setContent(content) {
    if (this.hasContentInputTarget) {
      this.contentInputTarget.value = content
      this.updatePreview()
    }
  }

  // Handle input events
  handleInput(event) {
    this.updatePreview()
  }

  // Handle paste events
  handlePaste(event) {
    // Small delay to allow paste content to be processed
    setTimeout(() => {
      this.updatePreview()
    }, 10)
  }

  // Method to use example prompts
  useExample(event) {
    const examplePrompt = event.currentTarget.dataset.examplePrompt
    if (examplePrompt && this.hasPromptInputTarget) {
      this.promptInputTarget.value = examplePrompt
      this.updatePreview()
      
      // Scroll to the prompt input
      this.promptInputTarget.scrollIntoView({ behavior: 'smooth', block: 'center' })
      
      // Focus the input for immediate editing
      this.promptInputTarget.focus()
      
      // Dispatch event to notify other controllers
      this.dispatch('exampleUsed', {
        detail: { prompt: examplePrompt }
      })
    }
  }

  disconnect() {
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer)
    }
  }
}
</file>

<file path="javascript/controllers/form_response_controller.js">
import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  static targets = ["progressBar", "currentStep", "totalSteps", "nextButton", "prevButton", "submitButton"]
  static values = {
    formId: String,
    sessionId: String,
    responseId: String,
    currentStepIndex: Number,
    totalSteps: Number,
    autoSave: Boolean
  }
  
  connect() {
    this.setupBeforeUnload()
    this.trackPageView()
    this.initializeAutoSave()
    this.updateProgress()
    this.updateNavigationButtons()
  }
  
  disconnect() {
    this.removeBeforeUnload()
    this.clearAutoSaveTimeout()
  }

  // Auto-save functionality
  initializeAutoSave() {
    if (!this.autoSaveValue) return

    this.autoSaveTimeout = null
    this.lastSaveData = null
    
    // Set up auto-save on input changes
    this.element.addEventListener('input', this.handleInputChange.bind(this))
    this.element.addEventListener('change', this.handleInputChange.bind(this))
  }

  handleInputChange(event) {
    if (!this.autoSaveValue) return
    
    // Debounce auto-save
    this.clearAutoSaveTimeout()
    this.autoSaveTimeout = setTimeout(() => {
      this.performAutoSave()
    }, 2000) // Auto-save after 2 seconds of inactivity
  }

  clearAutoSaveTimeout() {
    if (this.autoSaveTimeout) {
      clearTimeout(this.autoSaveTimeout)
      this.autoSaveTimeout = null
    }
  }

  async performAutoSave() {
    const formData = this.collectFormData()
    
    // Don't save if data hasn't changed
    if (JSON.stringify(formData) === this.lastSaveData) {
      return
    }

    try {
      const response = await fetch(`/forms/${this.formIdValue}/responses/${this.responseIdValue}/auto_save`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': this.getCsrfToken()
        },
        body: JSON.stringify({
          form_response: {
            question_responses_attributes: formData
          }
        })
      })

      if (response.ok) {
        this.lastSaveData = JSON.stringify(formData)
        this.showSaveIndicator('saved')
      } else {
        throw new Error('Auto-save failed')
      }
    } catch (error) {
      console.error('Auto-save error:', error)
      this.showSaveIndicator('error')
    }
  }

  collectFormData() {
    const formData = []
    const inputs = this.element.querySelectorAll('[data-question-id]')
    
    inputs.forEach(input => {
      const questionId = input.dataset.questionId
      let value = null

      if (input.type === 'radio' || input.type === 'checkbox') {
        if (input.checked) {
          value = input.value
        }
      } else if (input.tagName === 'SELECT') {
        value = input.value
      } else {
        value = input.value.trim()
      }

      if (value !== null && value !== '') {
        formData.push({
          form_question_id: questionId,
          answer_data: value
        })
      }
    })

    return formData
  }

  showSaveIndicator(status) {
    // Create or update save indicator
    let indicator = this.element.querySelector('.auto-save-indicator')
    
    if (!indicator) {
      indicator = document.createElement('div')
      indicator.className = 'auto-save-indicator fixed top-4 right-4 px-3 py-2 rounded-md text-sm font-medium transition-all duration-300'
      this.element.appendChild(indicator)
    }

    // Remove existing status classes
    indicator.classList.remove('bg-green-100', 'text-green-800', 'bg-red-100', 'text-red-800', 'bg-yellow-100', 'text-yellow-800')

    switch (status) {
      case 'saving':
        indicator.classList.add('bg-yellow-100', 'text-yellow-800')
        indicator.textContent = 'Saving...'
        break
      case 'saved':
        indicator.classList.add('bg-green-100', 'text-green-800')
        indicator.textContent = 'Saved'
        // Hide after 2 seconds
        setTimeout(() => {
          indicator.style.opacity = '0'
        }, 2000)
        break
      case 'error':
        indicator.classList.add('bg-red-100', 'text-red-800')
        indicator.textContent = 'Save failed'
        break
    }

    indicator.style.opacity = '1'
  }
  
  setupBeforeUnload() {
    this.beforeUnloadHandler = (event) => {
      // Only show warning if form has content
      if (this.hasUnsavedContent()) {
        event.preventDefault()
        event.returnValue = 'You have unsaved changes. Are you sure you want to leave?'
        return event.returnValue
      }
    }
    
    window.addEventListener('beforeunload', this.beforeUnloadHandler)
  }
  
  removeBeforeUnload() {
    if (this.beforeUnloadHandler) {
      window.removeEventListener('beforeunload', this.beforeUnloadHandler)
    }
  }
  
  hasUnsavedContent() {
    // Check if any form inputs have content
    const inputs = document.querySelectorAll('input, textarea, select')
    return Array.from(inputs).some(input => {
      if (input.type === 'radio' || input.type === 'checkbox') {
        return input.checked
      } else {
        return input.value.trim() !== ''
      }
    })
  }
  
  trackPageView() {
    // Track form view for analytics
    if (typeof gtag !== 'undefined') {
      gtag('event', 'form_view', {
        'form_id': this.formIdValue,
        'session_id': this.sessionIdValue
      })
    }
    
    // Custom analytics tracking
    if (window.agentFormAnalytics) {
      window.agentFormAnalytics.trackView({
        formId: this.formIdValue,
        sessionId: this.sessionIdValue,
        timestamp: new Date().toISOString()
      })
    }
  }

  // Navigation methods
  async nextStep(event) {
    event.preventDefault()
    
    // Validate current step before proceeding
    if (!this.validateCurrentStep()) {
      return
    }

    // Save current step data
    await this.saveCurrentStep()

    // Navigate to next step
    if (this.currentStepIndexValue < this.totalStepsValue - 1) {
      this.currentStepIndexValue += 1
      this.navigateToStep(this.currentStepIndexValue)
    } else {
      // This is the last step, submit the form
      this.submitForm()
    }
  }

  async prevStep(event) {
    event.preventDefault()
    
    if (this.currentStepIndexValue > 0) {
      this.currentStepIndexValue -= 1
      this.navigateToStep(this.currentStepIndexValue)
    }
  }

  async navigateToStep(stepIndex) {
    try {
      const response = await fetch(`/forms/${this.formIdValue}/responses/${this.responseIdValue}/step/${stepIndex}`, {
        method: 'GET',
        headers: {
          'Accept': 'text/html',
          'X-Requested-With': 'XMLHttpRequest'
        }
      })

      if (response.ok) {
        const html = await response.text()
        
        // Update the step content
        const stepContainer = this.element.querySelector('.step-container')
        if (stepContainer) {
          stepContainer.innerHTML = html
        }

        this.updateProgress()
        this.updateNavigationButtons()
        this.scrollToTop()
      } else {
        throw new Error('Failed to load step')
      }
    } catch (error) {
      console.error('Navigation error:', error)
      this.showError('Failed to navigate to step')
    }
  }

  validateCurrentStep() {
    const requiredInputs = this.element.querySelectorAll('[required]')
    let isValid = true

    requiredInputs.forEach(input => {
      if (!this.isInputValid(input)) {
        this.showFieldError(input, 'This field is required')
        isValid = false
      } else {
        this.clearFieldError(input)
      }
    })

    return isValid
  }

  isInputValid(input) {
    if (input.type === 'radio') {
      const radioGroup = this.element.querySelectorAll(`input[name="${input.name}"]`)
      return Array.from(radioGroup).some(radio => radio.checked)
    } else if (input.type === 'checkbox') {
      return input.checked
    } else {
      return input.value.trim() !== ''
    }
  }

  showFieldError(input, message) {
    // Remove existing error
    this.clearFieldError(input)

    // Add error styling
    input.classList.add('border-red-500', 'focus:border-red-500', 'focus:ring-red-500')

    // Create error message
    const errorElement = document.createElement('div')
    errorElement.className = 'field-error text-red-600 text-sm mt-1'
    errorElement.textContent = message

    // Insert error message after the input
    input.parentNode.insertBefore(errorElement, input.nextSibling)
  }

  clearFieldError(input) {
    // Remove error styling
    input.classList.remove('border-red-500', 'focus:border-red-500', 'focus:ring-red-500')

    // Remove error message
    const errorElement = input.parentNode.querySelector('.field-error')
    if (errorElement) {
      errorElement.remove()
    }
  }

  async saveCurrentStep() {
    if (this.autoSaveValue) {
      // If auto-save is enabled, just perform a final save
      await this.performAutoSave()
    } else {
      // Manual save for current step
      const formData = this.collectFormData()
      
      try {
        const response = await fetch(`/forms/${this.formIdValue}/responses/${this.responseIdValue}/save_step`, {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRF-Token': this.getCsrfToken()
          },
          body: JSON.stringify({
            form_response: {
              question_responses_attributes: formData
            }
          })
        })

        if (!response.ok) {
          throw new Error('Failed to save step')
        }
      } catch (error) {
        console.error('Save step error:', error)
        throw error
      }
    }
  }

  async submitForm(event) {
    if (event) event.preventDefault()

    // Validate all required fields
    if (!this.validateCurrentStep()) {
      return
    }

    // Show loading state
    this.setSubmitButtonLoading(true)

    try {
      // Save current step data
      await this.saveCurrentStep()

      // Submit the form
      const response = await fetch(`/forms/${this.formIdValue}/responses/${this.responseIdValue}/submit`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': this.getCsrfToken()
        }
      })

      if (response.ok) {
        const result = await response.json()
        
        // Redirect to thank you page
        if (result.redirect_url) {
          window.location.href = result.redirect_url
        } else {
          window.location.href = `/forms/${this.formIdValue}/responses/${this.responseIdValue}/thank_you`
        }
      } else {
        throw new Error('Failed to submit form')
      }
    } catch (error) {
      console.error('Submit error:', error)
      this.showError('Failed to submit form. Please try again.')
    } finally {
      this.setSubmitButtonLoading(false)
    }
  }

  updateProgress() {
    const progressPercentage = ((this.currentStepIndexValue + 1) / this.totalStepsValue) * 100

    // Update progress bar
    if (this.hasProgressBarTarget) {
      this.progressBarTarget.style.width = `${progressPercentage}%`
    }

    // Update step counter
    if (this.hasCurrentStepTarget) {
      this.currentStepTarget.textContent = this.currentStepIndexValue + 1
    }
    
    if (this.hasTotalStepsTarget) {
      this.totalStepsTarget.textContent = this.totalStepsValue
    }
  }

  updateNavigationButtons() {
    // Update previous button
    if (this.hasPrevButtonTarget) {
      if (this.currentStepIndexValue === 0) {
        this.prevButtonTarget.style.display = 'none'
      } else {
        this.prevButtonTarget.style.display = 'inline-flex'
      }
    }

    // Update next/submit button
    if (this.hasNextButtonTarget && this.hasSubmitButtonTarget) {
      if (this.currentStepIndexValue === this.totalStepsValue - 1) {
        this.nextButtonTarget.style.display = 'none'
        this.submitButtonTarget.style.display = 'inline-flex'
      } else {
        this.nextButtonTarget.style.display = 'inline-flex'
        this.submitButtonTarget.style.display = 'none'
      }
    }
  }

  setSubmitButtonLoading(loading) {
    if (this.hasSubmitButtonTarget) {
      if (loading) {
        this.submitButtonTarget.disabled = true
        this.submitButtonTarget.innerHTML = `
          <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
          Submitting...
        `
      } else {
        this.submitButtonTarget.disabled = false
        this.submitButtonTarget.innerHTML = 'Submit'
      }
    }
  }

  scrollToTop() {
    window.scrollTo({ top: 0, behavior: 'smooth' })
  }

  showError(message) {
    // Create or update error notification
    let errorElement = this.element.querySelector('.form-error-notification')
    
    if (!errorElement) {
      errorElement = document.createElement('div')
      errorElement.className = 'form-error-notification fixed top-4 right-4 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded max-w-md'
      this.element.appendChild(errorElement)
    }

    errorElement.innerHTML = `
      <div class="flex">
        <div class="flex-shrink-0">
          <svg class="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
          </svg>
        </div>
        <div class="ml-3">
          <p class="text-sm">${message}</p>
        </div>
        <div class="ml-auto pl-3">
          <button class="inline-flex text-red-400 hover:text-red-600" onclick="this.parentElement.parentElement.parentElement.remove()">
            <svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
              <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
            </svg>
          </button>
        </div>
      </div>
    `

    // Auto-hide after 5 seconds
    setTimeout(() => {
      if (errorElement.parentNode) {
        errorElement.remove()
      }
    }, 5000)
  }

  getCsrfToken() {
    const token = document.querySelector('meta[name="csrf-token"]')
    return token ? token.getAttribute('content') : ''
  }

  // Keyboard navigation
  handleKeydown(event) {
    if (event.key === 'Enter' && event.ctrlKey) {
      // Ctrl+Enter to go to next step
      if (this.hasNextButtonTarget && this.nextButtonTarget.style.display !== 'none') {
        this.nextStep(event)
      } else if (this.hasSubmitButtonTarget && this.submitButtonTarget.style.display !== 'none') {
        this.submitForm(event)
      }
    }
  }
}
</file>

<file path="javascript/controllers/google_connection_controller.js">
import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  static targets = ["status"]

  connect() {
    this.checkConnectionStatus()
  }

  async checkConnectionStatus() {
    try {
      const response = await fetch('/google_oauth/status', {
        headers: {
          'Accept': 'application/json',
          'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content
        }
      })

      const data = await response.json()
      this.updateStatusDisplay(data)
    } catch (error) {
      console.error('Failed to check Google connection status:', error)
    }
  }

  async testConnection() {
    const button = event.target
    const originalText = button.innerHTML
    
    button.disabled = true
    button.innerHTML = `
      <svg class="animate-spin -ml-1 mr-2 h-4 w-4 text-gray-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
      Testing...
    `

    try {
      // Test by making a simple API call to Google Sheets
      const response = await fetch('/google_oauth/status', {
        method: 'GET',
        headers: {
          'Accept': 'application/json',
          'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content
        }
      })

      const data = await response.json()
      
      if (data.connected) {
        this.showNotification('Google Sheets connection is working perfectly!', 'success')
      } else {
        this.showNotification('Connection test failed. Please reconnect to Google.', 'error')
      }
    } catch (error) {
      this.showNotification('Connection test failed. Please check your internet connection.', 'error')
    } finally {
      button.disabled = false
      button.innerHTML = originalText
    }
  }

  showHelp() {
    const helpModal = document.createElement('div')
    helpModal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50'
    helpModal.innerHTML = `
      <div class="bg-white rounded-lg max-w-md w-full mx-4 p-6">
        <div class="flex items-center justify-between mb-4">
          <h3 class="text-lg font-semibold text-gray-900">Google Sheets Integration Help</h3>
          <button class="text-gray-400 hover:text-gray-600" onclick="this.closest('.fixed').remove()">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
            </svg>
          </button>
        </div>
        
        <div class="space-y-4 text-sm text-gray-600">
          <div>
            <h4 class="font-medium text-gray-900 mb-2">What happens when you connect?</h4>
            <ul class="space-y-1 ml-4">
              <li> AgentForm will request permission to access your Google Sheets</li>
              <li> You can create new spreadsheets or use existing ones</li>
              <li> Form responses will be automatically exported to your chosen sheets</li>
              <li> You maintain full control over your Google account</li>
            </ul>
          </div>
          
          <div>
            <h4 class="font-medium text-gray-900 mb-2">Is it secure?</h4>
            <p>Yes! We use Google's official OAuth2 protocol. AgentForm never sees your Google password and you can revoke access at any time from your Google Account settings.</p>
          </div>
          
          <div>
            <h4 class="font-medium text-gray-900 mb-2">What permissions do we need?</h4>
            <ul class="space-y-1 ml-4">
              <li> <strong>Google Sheets:</strong> To create and update spreadsheets</li>
              <li> <strong>Profile info:</strong> To show which account is connected</li>
            </ul>
          </div>
        </div>
        
        <div class="mt-6 flex justify-end">
          <button onclick="this.closest('.fixed').remove()" 
                  class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">
            Got it
          </button>
        </div>
      </div>
    `
    
    document.body.appendChild(helpModal)
  }

  updateStatusDisplay(data) {
    if (!this.hasStatusTarget) return

    const statusElement = this.statusTarget
    
    if (data.connected) {
      statusElement.innerHTML = `
        <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-green-100 text-green-800">
          <div class="w-2 h-2 bg-green-400 rounded-full mr-2"></div>
          Connected
        </span>
      `
    } else {
      statusElement.innerHTML = `
        <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-100 text-gray-800">
          <div class="w-2 h-2 bg-gray-400 rounded-full mr-2"></div>
          Not Connected
        </span>
      `
    }
  }

  showNotification(message, type = 'info') {
    const notification = document.createElement('div')
    notification.className = `fixed top-4 right-4 max-w-sm w-full bg-white shadow-lg rounded-lg pointer-events-auto ring-1 ring-black ring-opacity-5 z-50`
    
    const bgColor = {
      'success': 'bg-green-50 border-green-200',
      'error': 'bg-red-50 border-red-200',
      'info': 'bg-blue-50 border-blue-200'
    }[type] || 'bg-gray-50 border-gray-200'

    const iconColor = {
      'success': 'text-green-400',
      'error': 'text-red-400',
      'info': 'text-blue-400'
    }[type] || 'text-gray-400'

    const icon = {
      'success': '',
      'error': '',
      'info': ''
    }[type] || ''

    notification.innerHTML = `
      <div class="p-4 ${bgColor} border rounded-lg">
        <div class="flex">
          <div class="flex-shrink-0">
            <span class="inline-flex items-center justify-center w-5 h-5 rounded-full ${iconColor} text-sm font-medium">
              ${icon}
            </span>
          </div>
          <div class="ml-3 w-0 flex-1">
            <p class="text-sm text-gray-900">${message}</p>
          </div>
          <div class="ml-4 flex-shrink-0 flex">
            <button class="inline-flex text-gray-400 hover:text-gray-500" onclick="this.parentElement.parentElement.parentElement.parentElement.remove()">
              <span class="sr-only">Close</span>
              <svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path>
              </svg>
            </button>
          </div>
        </div>
      </div>
    `

    document.body.appendChild(notification)

    setTimeout(() => {
      if (notification.parentNode) {
        notification.remove()
      }
    }, 5000)
  }
}
</file>

<file path="javascript/controllers/google_sheets_integration_controller.js">
import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  static targets = [
    "setupType", 
    "setupForm", 
    "newSpreadsheetOptions", 
    "existingSpreadsheetOptions",
    "spreadsheetTitle",
    "spreadsheetId",
    "sheetName",
    "autoSync",
    "exportExisting"
  ]
  
  static values = { 
    formId: String 
  }

  connect() {
    // Use setTimeout to ensure DOM is fully loaded
    setTimeout(() => {
      this.updateSetupOptions()
    }, 100)
  }

  disconnect() {
    // Clean up any resources when controller is disconnected
    // Remove any pending timeouts or event listeners if needed
  }

  setupTypeChanged() {
    this.updateSetupOptions()
  }

  updateSetupOptions() {
    // Check if targets exist before using them
    if (!this.hasNewSpreadsheetOptionsTarget || !this.hasExistingSpreadsheetOptionsTarget) {
      return
    }
    
    const selectedType = this.setupTypeTargets.find(radio => radio.checked)?.value
    
    if (selectedType === "create_new") {
      this.newSpreadsheetOptionsTarget.classList.remove("hidden")
      this.existingSpreadsheetOptionsTarget.classList.add("hidden")
    } else {
      this.newSpreadsheetOptionsTarget.classList.add("hidden")
      this.existingSpreadsheetOptionsTarget.classList.remove("hidden")
    }
  }

  async testConnection(event) {
    const button = event.target
    const originalText = button.innerHTML
    
    button.disabled = true
    button.innerHTML = `
      <svg class="animate-spin -ml-1 mr-2 h-4 w-4 text-gray-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
      Testing...
    `

    try {
      const response = await fetch(`/forms/${this.formIdValue}/integrations/google_sheets/test_connection`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content
        }
      })

      const data = await response.json()
      
      if (data.success) {
        this.showNotification('Connection successful! Google Sheets API is working.', 'success')
        if (data.test_spreadsheet_url) {
          this.showNotification(`Test spreadsheet created: <a href="${data.test_spreadsheet_url}" target="_blank" class="underline">View here</a>`, 'info')
        }
      } else {
        this.showNotification(`Connection failed: ${data.error}`, 'error')
      }
    } catch (error) {
      this.showNotification('Connection test failed. Please check your configuration.', 'error')
    } finally {
      button.disabled = false
      button.innerHTML = originalText
    }
  }

  async setupIntegration(event) {
    const button = event.target
    const originalText = button.innerHTML
    
    button.disabled = true
    button.innerHTML = `
      <svg class="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
      Connecting...
    `

    try {
      const setupType = this.setupTypeTargets.find(radio => radio.checked)?.value
      const payload = {
        google_sheets_integration: {
          sheet_name: this.sheetNameTarget.value,
          auto_sync: this.autoSyncTarget.checked
        },
        export_existing: this.exportExistingTarget.checked
      }

      if (setupType === 'create_new') {
        payload.create_new_spreadsheet = true
        payload.spreadsheet_title = this.spreadsheetTitleTarget.value
      } else {
        payload.google_sheets_integration.spreadsheet_id = this.spreadsheetIdTarget.value
      }

      const response = await fetch(`/forms/${this.formIdValue}/integrations/google_sheets`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content
        },
        body: JSON.stringify(payload)
      })

      const data = await response.json()
      
      if (response.ok) {
        this.showNotification(data.message, 'success')
        if (data.spreadsheet_url) {
          this.showNotification(`Spreadsheet ready: <a href="${data.spreadsheet_url}" target="_blank" class="underline">Open Google Sheets</a>`, 'info')
        }
        // Reload the page to show the connected state
        setTimeout(() => window.location.reload(), 2000)
      } else {
        this.showNotification(data.error || 'Setup failed', 'error')
      }
    } catch (error) {
      this.showNotification('Setup failed. Please try again.', 'error')
    } finally {
      button.disabled = false
      button.innerHTML = originalText
    }
  }

  async exportNow(event) {
    const button = event.target
    const originalText = button.innerHTML
    
    button.disabled = true
    button.innerHTML = `
      <svg class="animate-spin -ml-1 mr-2 h-4 w-4 text-gray-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
      Exporting...
    `

    try {
      const response = await fetch(`/forms/${this.formIdValue}/integrations/google_sheets/export`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content
        }
      })

      const data = await response.json()
      
      if (response.ok) {
        this.showNotification(data.message, 'success')
        if (data.spreadsheet_url) {
          this.showNotification(`<a href="${data.spreadsheet_url}" target="_blank" class="underline">View updated spreadsheet</a>`, 'info')
        }
      } else {
        this.showNotification(data.error || 'Export failed', 'error')
      }
    } catch (error) {
      this.showNotification('Export failed. Please try again.', 'error')
    } finally {
      button.disabled = false
      button.innerHTML = originalText
    }
  }

  async toggleAutoSync(event) {
    const checkbox = event.target
    const isEnabled = checkbox.checked

    try {
      const response = await fetch(`/forms/${this.formIdValue}/integrations/google_sheets/toggle_auto_sync`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content
        }
      })

      const data = await response.json()
      
      if (response.ok) {
        this.showNotification(data.message, 'success')
      } else {
        // Revert checkbox state on error
        checkbox.checked = !isEnabled
        this.showNotification('Failed to update auto-sync setting', 'error')
      }
    } catch (error) {
      checkbox.checked = !isEnabled
      this.showNotification('Failed to update auto-sync setting', 'error')
    }
  }

  async disconnectIntegration(event) {
    if (!confirm('Are you sure you want to disconnect Google Sheets? This will stop automatic syncing.')) {
      return
    }

    const button = event.target
    const originalText = button.innerHTML
    
    button.disabled = true
    button.innerHTML = `
      <svg class="animate-spin -ml-1 mr-2 h-4 w-4 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
      Disconnecting...
    `

    try {
      const response = await fetch(`/forms/${this.formIdValue}/integrations/google_sheets`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content
        }
      })

      const data = await response.json()
      
      if (response.ok) {
        this.showNotification(data.message, 'success')
        // Reload the page to show the disconnected state
        setTimeout(() => window.location.reload(), 1500)
      } else {
        this.showNotification('Failed to disconnect', 'error')
      }
    } catch (error) {
      this.showNotification('Failed to disconnect', 'error')
    } finally {
      button.disabled = false
      button.innerHTML = originalText
    }
  }

  showNotification(message, type = 'info') {
    // Create notification element
    const notification = document.createElement('div')
    notification.className = `fixed top-4 right-4 max-w-sm w-full bg-white shadow-lg rounded-lg pointer-events-auto ring-1 ring-black ring-opacity-5 z-50`
    
    const bgColor = {
      'success': 'bg-green-50 border-green-200',
      'error': 'bg-red-50 border-red-200',
      'info': 'bg-blue-50 border-blue-200'
    }[type] || 'bg-gray-50 border-gray-200'

    const iconColor = {
      'success': 'text-green-400',
      'error': 'text-red-400',
      'info': 'text-blue-400'
    }[type] || 'text-gray-400'

    const icon = {
      'success': '',
      'error': '',
      'info': ''
    }[type] || ''

    notification.innerHTML = `
      <div class="p-4 ${bgColor} border rounded-lg">
        <div class="flex">
          <div class="flex-shrink-0">
            <span class="inline-flex items-center justify-center w-5 h-5 rounded-full ${iconColor} text-sm font-medium">
              ${icon}
            </span>
          </div>
          <div class="ml-3 w-0 flex-1">
            <p class="text-sm text-gray-900">${message}</p>
          </div>
          <div class="ml-4 flex-shrink-0 flex">
            <button class="inline-flex text-gray-400 hover:text-gray-500" onclick="this.parentElement.parentElement.parentElement.parentElement.remove()">
              <span class="sr-only">Close</span>
              <svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path>
              </svg>
            </button>
          </div>
        </div>
      </div>
    `

    document.body.appendChild(notification)

    // Auto-remove after 5 seconds
    setTimeout(() => {
      if (notification.parentNode) {
        notification.remove()
      }
    }, 5000)
  }
}
</file>

<file path="javascript/controllers/hello_controller.js">
// app/javascript/controllers/hello_controller.js
import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  connect() {
    this.element.textContent = "Hello World!"
  }
}
</file>

<file path="javascript/controllers/payment_error_controller.js">
import { Controller } from "@hotwired/stimulus"

// Stimulus controller for handling payment error interactions
export default class extends Controller {
  static values = { 
    type: String,
    actions: Array
  }

  connect() {
    this.setupErrorTracking()
  }

  // Dismisses the payment error message
  dismiss(event) {
    event.preventDefault()
    
    // Track dismissal
    this.trackErrorEvent('dismissed')
    
    // Fade out and remove the error element
    this.element.style.transition = 'opacity 0.3s ease-out'
    this.element.style.opacity = '0'
    
    setTimeout(() => {
      if (this.element.parentNode) {
        this.element.remove()
      }
    }, 300)
  }

  // Handles action button clicks
  handleAction(event) {
    const actionType = event.currentTarget.dataset.action
    
    // Track action taken
    this.trackErrorEvent('action_taken', { action: actionType })
    
    // Allow default behavior (navigation) to proceed
  }

  // Sets up error tracking and analytics
  setupErrorTracking() {
    // Track error display
    this.trackErrorEvent('displayed')
    
    // Set up automatic dismissal after 30 seconds for non-critical errors
    if (this.typeValue !== 'stripe_not_configured' && this.typeValue !== 'premium_required') {
      setTimeout(() => {
        if (this.element && this.element.parentNode) {
          this.dismiss({ preventDefault: () => {} })
        }
      }, 30000)
    }
  }

  // Tracks payment error events for analytics
  trackErrorEvent(eventType, additionalData = {}) {
    const eventData = {
      error_type: this.typeValue,
      required_actions: this.actionsValue,
      event_type: eventType,
      timestamp: new Date().toISOString(),
      ...additionalData
    }

    // Send to analytics if available
    if (window.analytics && typeof window.analytics.track === 'function') {
      window.analytics.track('payment_validation_error', eventData)
    }

    // Log to console in development
    if (process.env.NODE_ENV === 'development') {
      console.log('Payment Error Event:', eventData)
    }

    // Send to server for logging
    this.sendErrorEvent(eventData)
  }

  // Sends error event to server for logging
  async sendErrorEvent(eventData) {
    try {
      await fetch('/api/v1/analytics/payment_errors', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.content
        },
        body: JSON.stringify({ event: eventData })
      })
    } catch (error) {
      console.warn('Failed to send payment error event:', error)
    }
  }

  // Handles retry actions
  retry(event) {
    event.preventDefault()
    
    this.trackErrorEvent('retry_attempted')
    
    // Reload the page or trigger a re-validation
    window.location.reload()
  }

  // Shows additional help information
  showHelp(event) {
    event.preventDefault()
    
    this.trackErrorEvent('help_requested')
    
    // Could open a modal or navigate to help page
    const helpUrl = event.currentTarget.dataset.helpUrl || '/help/payment-setup'
    window.open(helpUrl, '_blank')
  }
}
</file>

<file path="javascript/controllers/payment_error_flash_controller.js">
import { Controller } from "@hotwired/stimulus"

// Connects to data-controller="payment-error-flash"
export default class extends Controller {
  static values = { 
    errorType: String,
    dismissible: Boolean
  }
  
  static targets = ["helpModal", "checklistModal"]

  connect() {
    this.trackErrorDisplay()
    
    // Auto-dismiss after 10 seconds if dismissible
    if (this.dismissibleValue) {
      this.autoDismissTimeout = setTimeout(() => {
        this.dismiss()
      }, 10000)
    }
  }

  disconnect() {
    if (this.autoDismissTimeout) {
      clearTimeout(this.autoDismissTimeout)
    }
  }

  dismiss() {
    if (this.autoDismissTimeout) {
      clearTimeout(this.autoDismissTimeout)
    }
    
    this.element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out'
    this.element.style.opacity = '0'
    this.element.style.transform = 'translateY(-10px)'
    
    setTimeout(() => {
      this.element.remove()
    }, 300)
    
    this.trackErrorDismiss()
  }

  trackAction(event) {
    const actionType = event.params.actionType
    
    // Track the action click
    if (window.analytics) {
      window.analytics.track('Payment Error Action Clicked', {
        error_type: this.errorTypeValue,
        action_type: actionType,
        timestamp: new Date().toISOString()
      })
    }
    
    console.log(`Payment error action clicked: ${actionType} for error: ${this.errorTypeValue}`)
  }

  showHelp() {
    this.createHelpModal()
    this.trackHelpRequest()
  }

  showChecklist() {
    this.createChecklistModal()
    this.trackChecklistRequest()
  }

  createHelpModal() {
    const modal = document.createElement('div')
    modal.className = 'fixed inset-0 z-50 overflow-y-auto'
    modal.innerHTML = this.getHelpModalContent()
    
    document.body.appendChild(modal)
    
    // Add event listeners for modal close
    modal.addEventListener('click', (e) => {
      if (e.target === modal || e.target.closest('[data-action="close-modal"]')) {
        this.closeModal(modal)
      }
    })
    
    // Focus trap and accessibility
    const firstFocusable = modal.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])')
    if (firstFocusable) {
      firstFocusable.focus()
    }
  }

  createChecklistModal() {
    const modal = document.createElement('div')
    modal.className = 'fixed inset-0 z-50 overflow-y-auto'
    modal.innerHTML = this.getChecklistModalContent()
    
    document.body.appendChild(modal)
    
    // Add event listeners
    modal.addEventListener('click', (e) => {
      if (e.target === modal || e.target.closest('[data-action="close-modal"]')) {
        this.closeModal(modal)
      }
    })
  }

  closeModal(modal) {
    modal.style.transition = 'opacity 0.3s ease-out'
    modal.style.opacity = '0'
    
    setTimeout(() => {
      modal.remove()
    }, 300)
  }

  getHelpModalContent() {
    const errorTypeHelp = this.getErrorTypeHelp()
    
    return `
      <div class="flex items-end justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0">
        <div class="fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity"></div>
        
        <div class="inline-block align-bottom bg-white rounded-lg px-4 pt-5 pb-4 text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-lg sm:w-full sm:p-6">
          <div class="sm:flex sm:items-start">
            <div class="mx-auto flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-blue-100 sm:mx-0 sm:h-10 sm:w-10">
              <svg class="h-6 w-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
            </div>
            <div class="mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left">
              <h3 class="text-lg leading-6 font-medium text-gray-900">
                Payment Setup Help
              </h3>
              <div class="mt-2">
                <div class="text-sm text-gray-500">
                  ${errorTypeHelp.description}
                </div>
                <div class="mt-4">
                  <h4 class="font-medium text-gray-900 mb-2">Next Steps:</h4>
                  <ol class="list-decimal list-inside space-y-1 text-sm text-gray-700">
                    ${errorTypeHelp.steps.map(step => `<li>${step}</li>`).join('')}
                  </ol>
                </div>
                ${errorTypeHelp.additionalInfo ? `
                  <div class="mt-4 p-3 bg-blue-50 rounded-md">
                    <p class="text-sm text-blue-800">${errorTypeHelp.additionalInfo}</p>
                  </div>
                ` : ''}
              </div>
            </div>
          </div>
          <div class="mt-5 sm:mt-4 sm:flex sm:flex-row-reverse">
            <button type="button" 
                    class="w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-blue-600 text-base font-medium text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 sm:ml-3 sm:w-auto sm:text-sm"
                    data-action="close-modal">
              Got it
            </button>
            <button type="button" 
                    class="mt-3 w-full inline-flex justify-center rounded-md border border-gray-300 shadow-sm px-4 py-2 bg-white text-base font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 sm:mt-0 sm:w-auto sm:text-sm"
                    data-action="close-modal">
              Close
            </button>
          </div>
        </div>
      </div>
    `
  }

  getChecklistModalContent() {
    return `
      <div class="flex items-end justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0">
        <div class="fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity"></div>
        
        <div class="inline-block align-bottom bg-white rounded-lg px-4 pt-5 pb-4 text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-md sm:w-full sm:p-6">
          <div class="sm:flex sm:items-start">
            <div class="mx-auto flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-indigo-100 sm:mx-0 sm:h-10 sm:w-10">
              <svg class="h-6 w-6 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4" />
              </svg>
            </div>
            <div class="mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left w-full">
              <h3 class="text-lg leading-6 font-medium text-gray-900">
                Setup Checklist
              </h3>
              <div class="mt-2">
                <div class="space-y-3">
                  ${this.getChecklistItems().map(item => `
                    <div class="flex items-center">
                      <div class="flex-shrink-0">
                        ${item.completed ? 
                          '<svg class="h-5 w-5 text-green-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" /></svg>' :
                          '<svg class="h-5 w-5 text-gray-300" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm0-2a6 6 0 100-12 6 6 0 000 12z" clip-rule="evenodd" /></svg>'
                        }
                      </div>
                      <div class="ml-3 flex-1">
                        <p class="text-sm font-medium ${item.completed ? 'text-gray-900' : 'text-gray-500'}">
                          ${item.title}
                        </p>
                        ${item.description ? `<p class="text-xs text-gray-500">${item.description}</p>` : ''}
                      </div>
                    </div>
                  `).join('')}
                </div>
              </div>
            </div>
          </div>
          <div class="mt-5 sm:mt-4 sm:flex sm:flex-row-reverse">
            <button type="button" 
                    class="w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-indigo-600 text-base font-medium text-white hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 sm:ml-3 sm:w-auto sm:text-sm"
                    data-action="close-modal">
              Close
            </button>
          </div>
        </div>
      </div>
    `
  }

  getErrorTypeHelp() {
    const helpContent = {
      'stripe_not_configured': {
        description: 'Your form contains payment questions, but Stripe is not configured to process payments.',
        steps: [
          'Go to Stripe Settings in your account',
          'Connect your Stripe account or create a new one',
          'Configure your payment settings and webhooks',
          'Test your payment configuration',
          'Return to publish your form'
        ],
        additionalInfo: 'Stripe is required to securely process payments from your forms. The setup process typically takes 5-10 minutes.'
      },
      'premium_subscription_required': {
        description: 'Payment questions are a Premium feature that requires an upgraded subscription.',
        steps: [
          'Go to Subscription Management',
          'Choose a Premium plan that fits your needs',
          'Complete the upgrade process',
          'Return to publish your form with payment features'
        ],
        additionalInfo: 'Premium plans include unlimited payment forms, advanced analytics, and priority support.'
      },
      'multiple_requirements_missing': {
        description: 'Several setup steps are required before you can publish forms with payment functionality.',
        steps: [
          'Review the setup checklist below',
          'Complete each required step',
          'Verify your configuration',
          'Return to publish your form'
        ],
        additionalInfo: 'We recommend completing all setup steps at once for the best experience.'
      },
      'invalid_payment_configuration': {
        description: 'One or more payment questions in your form have configuration issues.',
        steps: [
          'Review your payment questions in the form editor',
          'Check that all required fields are properly configured',
          'Verify payment amounts and currency settings',
          'Test your payment flow',
          'Save and try publishing again'
        ],
        additionalInfo: 'Common issues include missing payment amounts, invalid currency codes, or incomplete question setup.'
      }
    }
    
    return helpContent[this.errorTypeValue] || {
      description: 'There was an issue with your payment setup.',
      steps: [
        'Review the error message above',
        'Follow the suggested actions',
        'Contact support if you need additional help'
      ],
      additionalInfo: null
    }
  }

  getChecklistItems() {
    // This would typically come from the server, but for now we'll generate based on error type
    const baseItems = [
      {
        title: 'Stripe Configuration',
        description: 'Connect and configure Stripe for payment processing',
        completed: false
      },
      {
        title: 'Premium Subscription',
        description: 'Upgrade to Premium for payment features',
        completed: false
      },
      {
        title: 'Payment Questions Setup',
        description: 'Configure payment questions in your form',
        completed: true
      }
    ]
    
    return baseItems
  }

  trackErrorDisplay() {
    if (window.analytics) {
      window.analytics.track('Payment Error Displayed', {
        error_type: this.errorTypeValue,
        timestamp: new Date().toISOString()
      })
    }
  }

  trackErrorDismiss() {
    if (window.analytics) {
      window.analytics.track('Payment Error Dismissed', {
        error_type: this.errorTypeValue,
        timestamp: new Date().toISOString()
      })
    }
  }

  trackHelpRequest() {
    if (window.analytics) {
      window.analytics.track('Payment Error Help Requested', {
        error_type: this.errorTypeValue,
        timestamp: new Date().toISOString()
      })
    }
  }

  trackChecklistRequest() {
    if (window.analytics) {
      window.analytics.track('Payment Error Checklist Requested', {
        error_type: this.errorTypeValue,
        timestamp: new Date().toISOString()
      })
    }
  }
}
</file>

<file path="javascript/controllers/payment_setup_controller.js">
import { Controller } from "@hotwired/stimulus"

// Stimulus controller for handling payment setup guidance and status updates
export default class extends Controller {
  static targets = ["setupChecklist", "requirementItem", "actionButton", "statusIndicator"]
  static values = { 
    hasPaymentQuestions: Boolean,
    stripeConfigured: Boolean,
    isPremium: Boolean,
    requiredFeatures: Array
  }

  connect() {
    console.log('Payment setup controller connected')
    this.updateSetupStatus()
    this.showRequiredActions()
    this.setupPolling()
  }

  disconnect() {
    this.stopPolling()
  }

  // Updates UI based on current setup status
  updateSetupStatus() {
    if (!this.hasPaymentQuestionsValue) {
      this.hideSetupRequirements()
      return
    }

    const setupComplete = this.stripeConfiguredValue && this.isPremiumValue
    const setupProgress = this.calculateSetupProgress()

    // Update status indicators
    this.statusIndicatorTargets.forEach(indicator => {
      this.updateStatusIndicator(indicator, setupComplete, setupProgress)
    })

    // Update checklist items
    this.updateChecklistItems()

    // Show/hide action buttons based on status
    this.updateActionButtons(setupComplete)

    // Dispatch custom event for other controllers to listen to
    this.dispatch('statusUpdated', { 
      detail: { 
        setupComplete, 
        setupProgress,
        stripeConfigured: this.stripeConfiguredValue,
        isPremium: this.isPremiumValue
      } 
    })
  }

  // Displays required setup actions
  showRequiredActions() {
    if (!this.hasPaymentQuestionsValue) return

    const missingRequirements = this.getMissingRequirements()
    
    this.requirementItemTargets.forEach(item => {
      const requirement = item.dataset.requirement
      const isComplete = !missingRequirements.includes(requirement)
      
      this.updateRequirementItem(item, requirement, isComplete)
    })

    // Show setup checklist if there are missing requirements
    if (missingRequirements.length > 0 && this.hasSetupChecklistTarget) {
      this.setupChecklistTarget.classList.remove('hidden')
      this.animateChecklistAppearance()
    }
  }

  // Handles setup action initiation
  initiateSetup(event) {
    event.preventDefault()
    
    const actionType = event.currentTarget.dataset.setupAction
    const actionUrl = event.currentTarget.dataset.actionUrl
    
    // Track setup initiation
    this.trackSetupEvent('setup_initiated', { action: actionType })
    
    switch (actionType) {
      case 'stripe_configuration':
        this.initiateStripeSetup(actionUrl)
        break
      case 'premium_subscription':
        this.initiatePremiumUpgrade(actionUrl)
        break
      case 'complete_setup':
        this.initiateCompleteSetup()
        break
      default:
        console.warn('Unknown setup action:', actionType)
    }
  }

  // Polls for setup completion status
  checkSetupProgress() {
    if (!this.hasPaymentQuestionsValue) return

    fetch('/payment_setup/status', {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.content
      }
    })
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        this.updateSetupValues(data.setup_status)
        this.updateSetupStatus()
      }
    })
    .catch(error => {
      console.warn('Failed to check setup progress:', error)
    })
  }

  // Private methods

  calculateSetupProgress() {
    const totalRequirements = 2 // Stripe + Premium
    let completedRequirements = 0
    
    if (this.stripeConfiguredValue) completedRequirements++
    if (this.isPremiumValue) completedRequirements++
    
    return Math.round((completedRequirements / totalRequirements) * 100)
  }

  getMissingRequirements() {
    const missing = []
    
    if (!this.stripeConfiguredValue) missing.push('stripe_configuration')
    if (!this.isPremiumValue) missing.push('premium_subscription')
    
    return missing
  }

  updateStatusIndicator(indicator, setupComplete, setupProgress) {
    const progressBar = indicator.querySelector('.progress-bar')
    const statusText = indicator.querySelector('.status-text')
    const statusIcon = indicator.querySelector('.status-icon')
    
    if (progressBar) {
      progressBar.style.width = `${setupProgress}%`
      progressBar.className = setupComplete 
        ? 'progress-bar bg-green-500 h-2 rounded-full transition-all duration-500'
        : 'progress-bar bg-indigo-500 h-2 rounded-full transition-all duration-500'
    }
    
    if (statusText) {
      statusText.textContent = setupComplete 
        ? 'Payment setup complete' 
        : `Setup ${setupProgress}% complete`
    }
    
    if (statusIcon) {
      statusIcon.innerHTML = setupComplete
        ? '<svg class="w-5 h-5 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>'
        : '<svg class="w-5 h-5 text-amber-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>'
    }
  }

  updateChecklistItems() {
    this.requirementItemTargets.forEach(item => {
      const requirement = item.dataset.requirement
      let isComplete = false
      
      switch (requirement) {
        case 'stripe_configuration':
          isComplete = this.stripeConfiguredValue
          break
        case 'premium_subscription':
          isComplete = this.isPremiumValue
          break
      }
      
      this.updateRequirementItem(item, requirement, isComplete)
    })
  }

  updateRequirementItem(item, requirement, isComplete) {
    const checkbox = item.querySelector('.requirement-checkbox')
    const text = item.querySelector('.requirement-text')
    const actionButton = item.querySelector('.requirement-action')
    
    if (checkbox) {
      checkbox.checked = isComplete
      checkbox.className = isComplete
        ? 'requirement-checkbox w-4 h-4 text-green-600 bg-green-100 border-green-300 rounded focus:ring-green-500'
        : 'requirement-checkbox w-4 h-4 text-gray-400 bg-gray-100 border-gray-300 rounded focus:ring-indigo-500'
    }
    
    if (text) {
      text.className = isComplete
        ? 'requirement-text text-sm text-green-700 line-through'
        : 'requirement-text text-sm text-gray-700'
    }
    
    if (actionButton) {
      actionButton.style.display = isComplete ? 'none' : 'inline-flex'
    }
    
    // Add completion animation
    if (isComplete && !item.dataset.wasComplete) {
      item.classList.add('animate-pulse')
      setTimeout(() => item.classList.remove('animate-pulse'), 1000)
      item.dataset.wasComplete = 'true'
    }
  }

  updateActionButtons(setupComplete) {
    this.actionButtonTargets.forEach(button => {
      const buttonType = button.dataset.buttonType
      
      if (buttonType === 'complete-setup') {
        button.style.display = setupComplete ? 'none' : 'inline-flex'
      } else if (buttonType === 'publish-form') {
        button.disabled = !setupComplete
        button.className = setupComplete
          ? 'inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500'
          : 'inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-gray-400 bg-gray-200 cursor-not-allowed'
      }
    })
  }

  hideSetupRequirements() {
    if (this.hasSetupChecklistTarget) {
      this.setupChecklistTarget.classList.add('hidden')
    }
  }

  animateChecklistAppearance() {
    if (this.hasSetupChecklistTarget) {
      this.setupChecklistTarget.style.opacity = '0'
      this.setupChecklistTarget.style.transform = 'translateY(-10px)'
      
      setTimeout(() => {
        this.setupChecklistTarget.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out'
        this.setupChecklistTarget.style.opacity = '1'
        this.setupChecklistTarget.style.transform = 'translateY(0)'
      }, 100)
    }
  }

  initiateStripeSetup(actionUrl) {
    // Open Stripe configuration in new tab to preserve form state
    const stripeUrl = actionUrl || '/stripe_settings'
    window.open(stripeUrl, '_blank', 'noopener,noreferrer')
    
    // Start polling for completion
    this.startSetupPolling('stripe_configuration')
  }

  initiatePremiumUpgrade(actionUrl) {
    // Open subscription management in new tab
    const subscriptionUrl = actionUrl || '/subscription_management'
    window.open(subscriptionUrl, '_blank', 'noopener,noreferrer')
    
    // Start polling for completion
    this.startSetupPolling('premium_subscription')
  }

  initiateCompleteSetup() {
    // Show modal with both setup options
    this.showCompleteSetupModal()
  }

  showCompleteSetupModal() {
    // Create and show modal with setup options
    const modal = document.createElement('div')
    modal.className = 'fixed inset-0 z-50 overflow-y-auto'
    modal.innerHTML = `
      <div class="flex items-end justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0">
        <div class="fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity"></div>
        <div class="inline-block align-bottom bg-white rounded-lg text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-lg sm:w-full">
          <div class="bg-white px-4 pt-5 pb-4 sm:p-6 sm:pb-4">
            <h3 class="text-lg leading-6 font-medium text-gray-900 mb-4">Complete Payment Setup</h3>
            <div class="space-y-4">
              ${!this.stripeConfiguredValue ? `
                <div class="flex items-center justify-between p-3 border rounded-lg">
                  <div>
                    <h4 class="font-medium">Configure Stripe</h4>
                    <p class="text-sm text-gray-600">Set up payment processing</p>
                  </div>
                  <button class="setup-action-btn bg-indigo-600 text-white px-3 py-1 rounded text-sm" data-action="stripe">
                    Configure
                  </button>
                </div>
              ` : ''}
              ${!this.isPremiumValue ? `
                <div class="flex items-center justify-between p-3 border rounded-lg">
                  <div>
                    <h4 class="font-medium">Upgrade to Premium</h4>
                    <p class="text-sm text-gray-600">Unlock payment features</p>
                  </div>
                  <button class="setup-action-btn bg-indigo-600 text-white px-3 py-1 rounded text-sm" data-action="premium">
                    Upgrade
                  </button>
                </div>
              ` : ''}
            </div>
          </div>
          <div class="bg-gray-50 px-4 py-3 sm:px-6 sm:flex sm:flex-row-reverse">
            <button class="close-modal-btn mt-3 w-full inline-flex justify-center rounded-md border border-gray-300 shadow-sm px-4 py-2 bg-white text-base font-medium text-gray-700 hover:bg-gray-50 sm:mt-0 sm:ml-3 sm:w-auto sm:text-sm">
              Close
            </button>
          </div>
        </div>
      </div>
    `
    
    document.body.appendChild(modal)
    
    // Add event listeners
    modal.querySelector('.close-modal-btn').addEventListener('click', () => {
      document.body.removeChild(modal)
    })
    
    modal.querySelectorAll('.setup-action-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const action = e.target.dataset.action
        if (action === 'stripe') {
          this.initiateStripeSetup()
        } else if (action === 'premium') {
          this.initiatePremiumUpgrade()
        }
        document.body.removeChild(modal)
      })
    })
  }

  setupPolling() {
    // Poll every 5 seconds when setup is incomplete
    if (!this.stripeConfiguredValue || !this.isPremiumValue) {
      this.pollingInterval = setInterval(() => {
        this.checkSetupProgress()
      }, 5000)
    }
  }

  stopPolling() {
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval)
      this.pollingInterval = null
    }
  }

  startSetupPolling(setupType) {
    // More frequent polling when user is actively setting up
    this.activeSetupPolling = setInterval(() => {
      this.checkSetupProgress()
    }, 2000)
    
    // Stop active polling after 2 minutes
    setTimeout(() => {
      if (this.activeSetupPolling) {
        clearInterval(this.activeSetupPolling)
        this.activeSetupPolling = null
      }
    }, 120000)
  }

  updateSetupValues(setupStatus) {
    this.stripeConfiguredValue = setupStatus.stripe_configured
    this.isPremiumValue = setupStatus.premium_subscription
  }

  trackSetupEvent(eventType, additionalData = {}) {
    const eventData = {
      has_payment_questions: this.hasPaymentQuestionsValue,
      stripe_configured: this.stripeConfiguredValue,
      is_premium: this.isPremiumValue,
      required_features: this.requiredFeaturesValue,
      event_type: eventType,
      timestamp: new Date().toISOString(),
      ...additionalData
    }

    // Send to analytics if available
    if (window.analytics && typeof window.analytics.track === 'function') {
      window.analytics.track('payment_setup_interaction', eventData)
    }

    // Log to console in development
    if (process.env.NODE_ENV === 'development') {
      console.log('Payment Setup Event:', eventData)
    }

    // Send to server for logging
    this.sendSetupEvent(eventData)
  }

  async sendSetupEvent(eventData) {
    try {
      await fetch('/analytics/payment_setup', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.content
        },
        body: JSON.stringify({ event: eventData })
      })
    } catch (error) {
      console.warn('Failed to send payment setup event:', error)
    }
  }
}
</file>

<file path="javascript/controllers/payment_setup_guidance_controller.js">
import { Controller } from "@hotwired/stimulus"

// Connects to data-controller="payment-setup-guidance"
export default class extends Controller {
  static values = { 
    context: String,
    errorType: String
  }

  connect() {
    this.trackGuidanceDisplay()
  }

  trackSetupStart(event) {
    const actionType = event.params.actionType
    
    if (window.analytics) {
      window.analytics.track('Payment Setup Started', {
        context: this.contextValue,
        error_type: this.errorTypeValue,
        action_type: actionType,
        timestamp: new Date().toISOString()
      })
    }
    
    console.log(`Payment setup started: ${actionType} from context: ${this.contextValue}`)
  }

  showEducationalContent() {
    this.createEducationalModal()
    this.trackEducationalContentRequest()
  }

  contactSupport() {
    this.createSupportModal()
    this.trackSupportRequest()
  }

  createEducationalModal() {
    const modal = document.createElement('div')
    modal.className = 'fixed inset-0 z-50 overflow-y-auto'
    modal.innerHTML = this.getEducationalModalContent()
    
    document.body.appendChild(modal)
    
    // Add event listeners
    modal.addEventListener('click', (e) => {
      if (e.target === modal || e.target.closest('[data-action="close-modal"]')) {
        this.closeModal(modal)
      }
    })
    
    // Focus management
    const firstFocusable = modal.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])')
    if (firstFocusable) {
      firstFocusable.focus()
    }
  }

  createSupportModal() {
    const modal = document.createElement('div')
    modal.className = 'fixed inset-0 z-50 overflow-y-auto'
    modal.innerHTML = this.getSupportModalContent()
    
    document.body.appendChild(modal)
    
    // Add event listeners
    modal.addEventListener('click', (e) => {
      if (e.target === modal || e.target.closest('[data-action="close-modal"]')) {
        this.closeModal(modal)
      }
    })
  }

  closeModal(modal) {
    modal.style.transition = 'opacity 0.3s ease-out'
    modal.style.opacity = '0'
    
    setTimeout(() => {
      modal.remove()
    }, 300)
  }

  getEducationalModalContent() {
    return `
      <div class="flex items-end justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0">
        <div class="fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity"></div>
        
        <div class="inline-block align-bottom bg-white rounded-lg px-4 pt-5 pb-4 text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-2xl sm:w-full sm:p-6">
          <div class="sm:flex sm:items-start">
            <div class="mx-auto flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-indigo-100 sm:mx-0 sm:h-10 sm:w-10">
              <svg class="h-6 w-6 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
              </svg>
            </div>
            <div class="mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left w-full">
              <h3 class="text-lg leading-6 font-medium text-gray-900">
                About Payment Features
              </h3>
              <div class="mt-2">
                <div class="prose prose-sm text-gray-500">
                  <h4 class="text-base font-medium text-gray-900 mt-4 mb-2">What are Payment Questions?</h4>
                  <p>Payment questions allow you to collect payments directly through your forms. This includes:</p>
                  <ul class="list-disc list-inside space-y-1 mt-2">
                    <li>One-time payments for products or services</li>
                    <li>Subscription signups with recurring billing</li>
                    <li>Donation collection with custom amounts</li>
                    <li>Event registration with ticket sales</li>
                  </ul>
                  
                  <h4 class="text-base font-medium text-gray-900 mt-4 mb-2">Why Stripe Integration?</h4>
                  <p>Stripe is a secure, industry-leading payment processor that:</p>
                  <ul class="list-disc list-inside space-y-1 mt-2">
                    <li>Handles PCI compliance and security automatically</li>
                    <li>Supports 135+ currencies and multiple payment methods</li>
                    <li>Provides detailed analytics and reporting</li>
                    <li>Offers fraud protection and dispute management</li>
                  </ul>
                  
                  <h4 class="text-base font-medium text-gray-900 mt-4 mb-2">Premium Features</h4>
                  <p>Payment functionality is included in our Premium plans, which also provide:</p>
                  <ul class="list-disc list-inside space-y-1 mt-2">
                    <li>Unlimited forms and responses</li>
                    <li>Advanced analytics and reporting</li>
                    <li>Custom branding and white-label options</li>
                    <li>Priority support and onboarding assistance</li>
                  </ul>
                  
                  <div class="mt-4 p-4 bg-indigo-50 rounded-lg">
                    <p class="text-sm text-indigo-800">
                      <strong>Setup Time:</strong> Most users complete payment setup in 5-10 minutes. 
                      Our guided process walks you through each step.
                    </p>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="mt-5 sm:mt-4 sm:flex sm:flex-row-reverse">
            <button type="button" 
                    class="w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-indigo-600 text-base font-medium text-white hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 sm:ml-3 sm:w-auto sm:text-sm"
                    onclick="window.open('/payment_setup', '_blank')"
                    data-action="close-modal">
              Start Setup
            </button>
            <button type="button" 
                    class="mt-3 w-full inline-flex justify-center rounded-md border border-gray-300 shadow-sm px-4 py-2 bg-white text-base font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 sm:mt-0 sm:w-auto sm:text-sm"
                    data-action="close-modal">
              Close
            </button>
          </div>
        </div>
      </div>
    `
  }

  getSupportModalContent() {
    return `
      <div class="flex items-end justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0">
        <div class="fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity"></div>
        
        <div class="inline-block align-bottom bg-white rounded-lg px-4 pt-5 pb-4 text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-lg sm:w-full sm:p-6">
          <div class="sm:flex sm:items-start">
            <div class="mx-auto flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-green-100 sm:mx-0 sm:h-10 sm:w-10">
              <svg class="h-6 w-6 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.364 5.636l-3.536 3.536m0 5.656l3.536 3.536M9.172 9.172L5.636 5.636m3.536 9.192L5.636 18.364M12 2.25a9.75 9.75 0 109.75 9.75A9.75 9.75 0 0012 2.25z" />
              </svg>
            </div>
            <div class="mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left w-full">
              <h3 class="text-lg leading-6 font-medium text-gray-900">
                Contact Support
              </h3>
              <div class="mt-2">
                <p class="text-sm text-gray-500 mb-4">
                  Our support team is here to help you with payment setup and any questions you might have.
                </p>
                
                <div class="space-y-3">
                  <div class="flex items-center p-3 bg-gray-50 rounded-lg">
                    <svg class="h-5 w-5 text-gray-400 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 8l7.89 4.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
                    </svg>
                    <div>
                      <p class="text-sm font-medium text-gray-900">Email Support</p>
                      <p class="text-xs text-gray-500">support@agentform.com</p>
                    </div>
                  </div>
                  
                  <div class="flex items-center p-3 bg-gray-50 rounded-lg">
                    <svg class="h-5 w-5 text-gray-400 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                    </svg>
                    <div>
                      <p class="text-sm font-medium text-gray-900">Live Chat</p>
                      <p class="text-xs text-gray-500">Available 9 AM - 6 PM EST</p>
                    </div>
                  </div>
                  
                  <div class="flex items-center p-3 bg-gray-50 rounded-lg">
                    <svg class="h-5 w-5 text-gray-400 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
                    </svg>
                    <div>
                      <p class="text-sm font-medium text-gray-900">Help Center</p>
                      <p class="text-xs text-gray-500">Guides and tutorials</p>
                    </div>
                  </div>
                </div>
                
                <div class="mt-4 p-3 bg-blue-50 rounded-lg">
                  <p class="text-sm text-blue-800">
                    <strong>Pro Tip:</strong> Include your error type "${this.errorTypeValue}" when contacting support for faster assistance.
                  </p>
                </div>
              </div>
            </div>
          </div>
          <div class="mt-5 sm:mt-4 sm:flex sm:flex-row-reverse">
            <button type="button" 
                    class="w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-green-600 text-base font-medium text-white hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 sm:ml-3 sm:w-auto sm:text-sm"
                    onclick="window.open('mailto:support@agentform.com?subject=Payment Setup Help - ${this.errorTypeValue}', '_blank')"
                    data-action="close-modal">
              Send Email
            </button>
            <button type="button" 
                    class="mt-3 w-full inline-flex justify-center rounded-md border border-gray-300 shadow-sm px-4 py-2 bg-white text-base font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 sm:mt-0 sm:w-auto sm:text-sm"
                    data-action="close-modal">
              Close
            </button>
          </div>
        </div>
      </div>
    `
  }

  trackGuidanceDisplay() {
    if (window.analytics) {
      window.analytics.track('Payment Setup Guidance Displayed', {
        context: this.contextValue,
        error_type: this.errorTypeValue,
        timestamp: new Date().toISOString()
      })
    }
  }

  trackEducationalContentRequest() {
    if (window.analytics) {
      window.analytics.track('Payment Educational Content Requested', {
        context: this.contextValue,
        error_type: this.errorTypeValue,
        timestamp: new Date().toISOString()
      })
    }
  }

  trackSupportRequest() {
    if (window.analytics) {
      window.analytics.track('Payment Support Requested', {
        context: this.contextValue,
        error_type: this.errorTypeValue,
        timestamp: new Date().toISOString()
      })
    }
  }
}
</file>

<file path="javascript/controllers/payment_setup_required_button_controller.js">
import { Controller } from "@hotwired/stimulus"

// Connects to data-controller="payment-setup-required-button"
export default class extends Controller {
  static values = { 
    errorType: String
  }

  connect() {
    this.trackButtonDisplay()
  }

  trackSetupClick(event) {
    const actionType = event.params.actionType
    
    if (window.analytics) {
      window.analytics.track('Payment Setup Button Clicked', {
        error_type: this.errorTypeValue,
        action_type: actionType,
        timestamp: new Date().toISOString()
      })
    }
    
    console.log(`Payment setup button clicked: ${actionType} for error: ${this.errorTypeValue}`)
  }

  trackPublishClick() {
    if (window.analytics) {
      window.analytics.track('Form Publish Button Clicked', {
        has_payment_setup_error: false,
        timestamp: new Date().toISOString()
      })
    }
    
    console.log('Form publish button clicked (no payment errors)')
  }

  trackButtonDisplay() {
    if (window.analytics) {
      window.analytics.track('Payment Setup Required Button Displayed', {
        error_type: this.errorTypeValue,
        timestamp: new Date().toISOString()
      })
    }
  }
}
</file>

<file path="javascript/controllers/payment_setup_status_controller.js">
import { Controller } from "@hotwired/stimulus"

// Connects to data-controller="payment-setup-status"
export default class extends Controller {
  static targets = [
    "statusIndicator", 
    "notificationBar", 
    "progressBar", 
    "progressText", 
    "actionButton",
    "setupModal",
    "requirementsList"
  ]
  
  static values = { 
    formId: String,
    hasPaymentQuestions: Boolean,
    stripeConfigured: Boolean,
    isPremium: Boolean,
    setupComplete: Boolean,
    completionPercentage: Number
  }

  connect() {
    console.log('Payment setup status controller connected')
    this.updateStatusDisplay()
    this.startPeriodicCheck()
  }

  disconnect() {
    if (this.checkInterval) {
      clearInterval(this.checkInterval)
    }
  }

  // Update the visual status display
  updateStatusDisplay() {
    if (!this.hasPaymentQuestionsValue) {
      this.hidePaymentStatus()
      return
    }

    this.showPaymentStatus()
    this.updateProgressBar()
    this.updateNotificationBar()
    this.updateStatusIndicator()
  }

  // Show payment status elements
  showPaymentStatus() {
    if (this.hasStatusIndicatorTarget) {
      this.statusIndicatorTarget.classList.remove('hidden')
    }
    if (this.hasNotificationBarTarget) {
      this.notificationBarTarget.classList.remove('hidden')
    }
  }

  // Hide payment status elements
  hidePaymentStatus() {
    if (this.hasStatusIndicatorTarget) {
      this.statusIndicatorTarget.classList.add('hidden')
    }
    if (this.hasNotificationBarTarget) {
      this.notificationBarTarget.classList.add('hidden')
    }
  }

  // Update progress bar
  updateProgressBar() {
    if (!this.hasProgressBarTarget) return

    const percentage = this.completionPercentageValue
    this.progressBarTarget.style.width = `${percentage}%`
    
    // Update progress text
    if (this.hasProgressTextTarget) {
      this.progressTextTarget.textContent = `${percentage}% Complete`
    }

    // Update progress bar color based on completion
    this.progressBarTarget.classList.remove('bg-red-500', 'bg-yellow-500', 'bg-green-500')
    if (percentage < 50) {
      this.progressBarTarget.classList.add('bg-red-500')
    } else if (percentage < 100) {
      this.progressBarTarget.classList.add('bg-yellow-500')
    } else {
      this.progressBarTarget.classList.add('bg-green-500')
    }
  }

  // Update notification bar content
  updateNotificationBar() {
    if (!this.hasNotificationBarTarget) return

    if (this.setupCompleteValue) {
      this.showSuccessNotification()
    } else {
      this.showSetupRequiredNotification()
    }
  }

  // Show success notification
  showSuccessNotification() {
    this.notificationBarTarget.className = 'bg-green-50 border-l-4 border-green-400 p-4 mb-6'
    this.notificationBarTarget.innerHTML = `
      <div class="flex items-center justify-between">
        <div class="flex">
          <div class="flex-shrink-0">
            <svg class="h-5 w-5 text-green-400" viewBox="0 0 20 20" fill="currentColor">
              <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
            </svg>
          </div>
          <div class="ml-3">
            <p class="text-sm text-green-700">
              <strong>Payment setup complete!</strong> Your form is ready to accept payments.
            </p>
          </div>
        </div>
      </div>
    `
  }

  // Show setup required notification
  showSetupRequiredNotification() {
    const missingRequirements = this.getMissingRequirements()
    const requirementsList = missingRequirements.map(req => `<li>${req}</li>`).join('')

    this.notificationBarTarget.className = 'bg-amber-50 border-l-4 border-amber-400 p-4 mb-6'
    this.notificationBarTarget.innerHTML = `
      <div class="flex items-center justify-between">
        <div class="flex">
          <div class="flex-shrink-0">
            <svg class="h-5 w-5 text-amber-400" viewBox="0 0 20 20" fill="currentColor">
              <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
            </svg>
          </div>
          <div class="ml-3 flex-1">
            <p class="text-sm text-amber-700">
              <strong>Payment setup required</strong> to publish this form with payment questions.
            </p>
            <ul class="mt-2 text-sm text-amber-600 list-disc list-inside">
              ${requirementsList}
            </ul>
          </div>
        </div>
        <div class="ml-4 flex-shrink-0">
          <button data-action="click->payment-setup-status#openSetupModal" 
                  class="bg-amber-100 hover:bg-amber-200 text-amber-800 px-3 py-2 rounded-md text-sm font-medium transition-colors">
            Complete Setup
          </button>
        </div>
      </div>
    `
  }

  // Update status indicator in header
  updateStatusIndicator() {
    if (!this.hasStatusIndicatorTarget) return

    if (this.setupCompleteValue) {
      this.statusIndicatorTarget.innerHTML = `
        <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
          <div class="w-2 h-2 bg-green-400 rounded-full mr-1.5"></div>
          Payment Ready
        </span>
      `
    } else {
      this.statusIndicatorTarget.innerHTML = `
        <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-amber-100 text-amber-800">
          <div class="w-2 h-2 bg-amber-400 rounded-full mr-1.5"></div>
          Setup Required
        </span>
      `
    }
  }

  // Get missing requirements
  getMissingRequirements() {
    const requirements = []
    
    if (!this.stripeConfiguredValue) {
      requirements.push('Configure Stripe payment processing')
    }
    
    if (!this.isPremiumValue) {
      requirements.push('Upgrade to Premium subscription')
    }
    
    return requirements
  }

  // Open setup modal
  openSetupModal(event) {
    event.preventDefault()
    
    if (this.hasSetupModalTarget) {
      this.setupModalTarget.classList.remove('hidden')
      this.populateSetupModal()
    } else {
      // Fallback: redirect to payment setup page
      window.open('/payment_setup', '_blank')
    }
  }

  // Close setup modal
  closeSetupModal(event) {
    event.preventDefault()
    
    if (this.hasSetupModalTarget) {
      this.setupModalTarget.classList.add('hidden')
    }
  }

  // Populate setup modal with requirements
  populateSetupModal() {
    if (!this.hasRequirementsListTarget) return

    const requirements = this.getMissingRequirements()
    const requirementsHtml = requirements.map(req => {
      let actionUrl = '#'
      let actionText = 'Setup'
      
      if (req.includes('Stripe')) {
        actionUrl = '/stripe_settings'
        actionText = 'Configure Stripe'
      } else if (req.includes('Premium')) {
        actionUrl = '/subscription_management'
        actionText = 'Upgrade Plan'
      }
      
      return `
        <li class="flex items-center justify-between py-3 border-b border-gray-200 last:border-b-0">
          <span class="text-sm text-gray-700">${req}</span>
          <a href="${actionUrl}" target="_blank" 
             class="inline-flex items-center px-3 py-1 border border-transparent text-xs font-medium rounded text-indigo-700 bg-indigo-100 hover:bg-indigo-200 transition-colors">
            ${actionText}
          </a>
        </li>
      `
    }).join('')

    this.requirementsListTarget.innerHTML = requirementsHtml
  }

  // Start periodic check for setup completion
  startPeriodicCheck() {
    // Check every 30 seconds for setup completion
    this.checkInterval = setInterval(() => {
      this.checkSetupStatus()
    }, 30000)
  }

  // Check setup status via API
  async checkSetupStatus() {
    try {
      const response = await fetch(`/forms/${this.formIdValue}/payment_setup_status`, {
        method: 'GET',
        headers: {
          'Accept': 'application/json',
          'X-Requested-With': 'XMLHttpRequest'
        }
      })

      if (response.ok) {
        const data = await response.json()
        this.updateStatusFromAPI(data)
      }
    } catch (error) {
      console.error('Error checking payment setup status:', error)
    }
  }

  // Update status from API response
  updateStatusFromAPI(data) {
    let statusChanged = false

    if (this.stripeConfiguredValue !== data.stripe_configured) {
      this.stripeConfiguredValue = data.stripe_configured
      statusChanged = true
    }

    if (this.isPremiumValue !== data.premium_subscription) {
      this.isPremiumValue = data.premium_subscription
      statusChanged = true
    }

    if (this.setupCompleteValue !== data.setup_complete) {
      this.setupCompleteValue = data.setup_complete
      statusChanged = true
    }

    if (this.completionPercentageValue !== data.completion_percentage) {
      this.completionPercentageValue = data.completion_percentage
      statusChanged = true
    }

    if (statusChanged) {
      this.updateStatusDisplay()
      this.showStatusChangeNotification(data)
    }
  }

  // Show notification when status changes
  showStatusChangeNotification(data) {
    if (data.setup_complete) {
      this.showToast('Payment setup completed! Your form is now ready to accept payments.', 'success')
    } else if (data.completion_percentage > this.completionPercentageValue) {
      this.showToast('Payment setup progress updated.', 'info')
    }
  }

  // Show toast notification
  showToast(message, type = 'info') {
    const toast = document.createElement('div')
    toast.className = `fixed top-4 right-4 z-50 max-w-sm w-full bg-white shadow-lg rounded-lg pointer-events-auto ring-1 ring-black ring-opacity-5 overflow-hidden`
    
    const bgColor = type === 'success' ? 'bg-green-50' : type === 'error' ? 'bg-red-50' : 'bg-blue-50'
    const textColor = type === 'success' ? 'text-green-800' : type === 'error' ? 'text-red-800' : 'text-blue-800'
    
    toast.innerHTML = `
      <div class="p-4">
        <div class="flex items-start">
          <div class="flex-shrink-0">
            <svg class="h-6 w-6 ${textColor}" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          </div>
          <div class="ml-3 w-0 flex-1 pt-0.5">
            <p class="text-sm font-medium ${textColor}">${message}</p>
          </div>
          <div class="ml-4 flex-shrink-0 flex">
            <button class="bg-white rounded-md inline-flex text-gray-400 hover:text-gray-500 focus:outline-none" onclick="this.parentElement.parentElement.parentElement.parentElement.remove()">
              <span class="sr-only">Close</span>
              <svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
              </svg>
            </button>
          </div>
        </div>
      </div>
    `
    
    document.body.appendChild(toast)
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
      if (toast.parentNode) {
        toast.remove()
      }
    }, 5000)
  }

  // Handle payment question changes
  onPaymentQuestionAdded() {
    this.hasPaymentQuestionsValue = true
    this.updateStatusDisplay()
  }

  onPaymentQuestionRemoved() {
    // Check if there are still payment questions
    this.checkPaymentQuestions()
  }

  // Check if form still has payment questions
  async checkPaymentQuestions() {
    try {
      const response = await fetch(`/forms/${this.formIdValue}/has_payment_questions`, {
        method: 'GET',
        headers: {
          'Accept': 'application/json',
          'X-Requested-With': 'XMLHttpRequest'
        }
      })

      if (response.ok) {
        const data = await response.json()
        this.hasPaymentQuestionsValue = data.has_payment_questions
        this.updateStatusDisplay()
      }
    } catch (error) {
      console.error('Error checking payment questions:', error)
    }
  }
}
</file>

<file path="javascript/controllers/question_response_controller.js">
import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  static targets = [
    "answerInput", 
    "submitButton", 
    "submitText", 
    "loadingSpinner", 
    "startedAt",
    "charCount",
    "otherCheckbox",
    "otherInput",
    "otherInputContainer"
  ]
  
  static values = {
    questionId: String,
    formToken: String,
    required: Boolean
  }
  
  connect() {
    this.setStartTime()
    this.setupCharacterCount()
    this.setupAutoSave()
  }
  
  setStartTime() {
    if (this.hasStartedAtTarget) {
      this.startedAtTarget.value = new Date().toISOString()
    }
  }
  
  setupCharacterCount() {
    this.answerInputTargets.forEach(input => {
      if (input.type === 'text' || input.type === 'textarea') {
        this.updateCharCount(input)
      }
    })
  }
  
  setupAutoSave() {
    // Set up auto-save interval if enabled
    this.autoSaveInterval = setInterval(() => {
      this.autoSaveDraft()
    }, 30000) // Auto-save every 30 seconds
  }
  
  disconnect() {
    if (this.autoSaveInterval) {
      clearInterval(this.autoSaveInterval)
    }
  }
  
  validateInput(event) {
    const input = event.target
    this.updateCharCount(input)
    this.updateSliderValue(event)
    this.validateAnswer()
  }
  
  updateCharCount(input) {
    if (this.hasCharCountTarget && (input.type === 'text' || input.tagName === 'TEXTAREA')) {
      this.charCountTarget.textContent = input.value.length
    }
  }
  
  validateAnswer() {
    const isValid = this.isAnswerValid()
    
    if (this.hasSubmitButtonTarget) {
      this.submitButtonTarget.disabled = !isValid
    }
    
    this.hideValidationErrors()
    return isValid
  }
  
  isAnswerValid() {
    if (!this.requiredValue) return true
    
    // Check different input types
    const textInputs = this.answerInputTargets.filter(input => 
      input.type === 'text' || input.type === 'email' || input.tagName === 'TEXTAREA'
    )
    
    const radioInputs = this.answerInputTargets.filter(input => input.type === 'radio')
    const checkboxInputs = this.answerInputTargets.filter(input => input.type === 'checkbox')
    
    // Text inputs
    if (textInputs.length > 0) {
      return textInputs.some(input => input.value.trim() !== '')
    }
    
    // Radio buttons
    if (radioInputs.length > 0) {
      return radioInputs.some(input => input.checked)
    }
    
    // Checkboxes
    if (checkboxInputs.length > 0) {
      return checkboxInputs.some(input => input.checked)
    }
    
    return true
  }
  
  submitAnswer(event) {
    event.preventDefault()
    
    if (!this.validateAnswer()) {
      this.showValidationErrors(['Please provide an answer to continue'])
      return
    }
    
    // Trigger simple exit animation
    this.triggerAnimation('question-will-change')
    
    // Small delay for animation, then submit
    setTimeout(() => {
      this.performSubmission(event.target)
    }, 200)
  }

  performSubmission(form) {
    this.showLoading()
    
    const formData = new FormData(form)
    
    fetch(form.action, {
      method: 'POST',
      body: formData,
      headers: {
        'Accept': 'application/json',
        'X-Requested-With': 'XMLHttpRequest',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
      }
    })
    .then(response => response.json())
    .then(data => {
      this.hideLoading()
      
      if (data.success) {
        if (data.completed) {
          // Simple success animation before redirect
          this.showSuccessMessage(() => {
            if (data.redirect_url && data.redirect_url !== 'undefined' && data.redirect_url !== '/f/undefined') {
              console.log('Redirecting to:', data.redirect_url)
              window.location.href = data.redirect_url
            } else {
              console.error('Invalid redirect URL:', data.redirect_url)
              this.showValidationErrors(['Invalid redirect URL. Please refresh the page.'])
              if (this.formTokenValue) {
                window.location.href = `/f/${this.formTokenValue}`
              } else {
                window.location.reload()
              }
            }
          })
        } else if (data.next_question) {
          this.loadNextQuestion(data.next_question)
        } else {
          window.location.reload()
        }
      } else {
        this.showValidationErrors(data.errors || ['An error occurred. Please try again.'])
      }
    })
    .catch(error => {
      this.hideLoading()
      console.error('Error:', error)
      this.showValidationErrors(['An error occurred. Please try again.'])
    })
  }
  
  showLoading() {
    if (this.hasSubmitButtonTarget) {
      this.submitButtonTarget.disabled = true
    }
    
    if (this.hasSubmitTextTarget) {
      this.submitTextTarget.textContent = 'Processing...'
    }
    
    if (this.hasLoadingSpinnerTarget) {
      this.loadingSpinnerTarget.classList.remove('hidden')
    }
  }
  
  hideLoading() {
    if (this.hasSubmitButtonTarget) {
      this.submitButtonTarget.disabled = false
    }
    
    if (this.hasSubmitTextTarget) {
      this.submitTextTarget.textContent = 'Continue'
    }
    
    if (this.hasLoadingSpinnerTarget) {
      this.loadingSpinnerTarget.classList.add('hidden')
    }
  }
  
  showValidationErrors(errors) {
    const errorContainer = document.getElementById('validation-errors')
    const errorList = document.getElementById('error-list')
    
    if (errorContainer && errorList) {
      errorList.innerHTML = ''
      errors.forEach(error => {
        const li = document.createElement('li')
        li.textContent = error
        errorList.appendChild(li)
      })
      
      errorContainer.classList.remove('hidden')
      errorContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' })
    }
  }
  
  hideValidationErrors() {
    const errorContainer = document.getElementById('validation-errors')
    if (errorContainer) {
      errorContainer.classList.add('hidden')
    }
  }
  
  toggleOtherInput(event) {
    const checkbox = event.target
    
    if (this.hasOtherInputContainerTarget) {
      if (checkbox.checked) {
        this.otherInputContainerTarget.classList.remove('hidden')
        if (this.hasOtherInputTarget) {
          this.otherInputTarget.focus()
        }
      } else {
        this.otherInputContainerTarget.classList.add('hidden')
        if (this.hasOtherInputTarget) {
          this.otherInputTarget.value = ''
        }
      }
    }
  }
  
  saveDraft() {
    const formData = this.collectFormData()
    
    fetch(`/f/${this.formTokenValue}/save_draft`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
      },
      body: JSON.stringify({ draft_data: formData })
    })
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        this.showNotification('Draft saved successfully', 'success')
      } else {
        this.showNotification('Failed to save draft', 'error')
      }
    })
    .catch(error => {
      console.error('Error saving draft:', error)
      this.showNotification('Failed to save draft', 'error')
    })
  }
  
  autoSaveDraft() {
    // Only auto-save if there's content and the form is not being submitted
    if (this.hasAnswerContent() && !this.isSubmitting) {
      this.saveDraft()
    }
  }
  
  hasAnswerContent() {
    return this.answerInputTargets.some(input => {
      if (input.type === 'radio' || input.type === 'checkbox') {
        return input.checked
      } else {
        return input.value.trim() !== ''
      }
    })
  }
  
  collectFormData() {
    const data = {}
    
    this.answerInputTargets.forEach(input => {
      if (input.type === 'radio' || input.type === 'checkbox') {
        if (input.checked) {
          if (data[input.name]) {
            if (Array.isArray(data[input.name])) {
              data[input.name].push(input.value)
            } else {
              data[input.name] = [data[input.name], input.value]
            }
          } else {
            data[input.name] = input.value
          }
        }
      } else {
        data[input.name] = input.value
      }
    })
    
    return data
  }
  
  goToPrevious() {
    // This would need to be implemented based on your navigation logic
    // For now, we'll just go back in browser history
    window.history.back()
  }
  
  showNotification(message, type = 'info') {
    // Create a simple notification
    const notification = document.createElement('div')
    notification.className = `fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg ${
      type === 'success' ? 'bg-green-100 text-green-800 border border-green-200' :
      type === 'error' ? 'bg-red-100 text-red-800 border border-red-200' :
      'bg-blue-100 text-blue-800 border border-blue-200'
    }`
    notification.textContent = message
    
    document.body.appendChild(notification)
    
    // Remove after 3 seconds
    setTimeout(() => {
      notification.remove()
    }, 3000)
  }
  
  updateSliderValue(event) {
    const input = event.target
    if (input.type === 'range') {
      const prefix = input.dataset.prefix || ''
      const suffix = input.dataset.suffix || ''
      const value = input.value
      
      // Find the slider value display element
      const sliderValueElement = this.element.querySelector('[data-question-response-target="sliderValue"]')
      if (sliderValueElement) {
        sliderValueElement.textContent = prefix + value + suffix
      }
    }
  }

  loadNextQuestion(questionData) {
    // This would implement dynamic question loading
    // For now, we'll just reload the page
    window.location.reload()
  }

  // Simple animation methods
  showSuccessMessage(callback) {
    // Simple success notification
    const notification = document.createElement('div')
    notification.className = 'fixed top-4 right-4 z-50 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg'
    notification.innerHTML = `
      <div class="flex items-center">
        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
        </svg>
        Form submitted successfully!
      </div>
    `
    document.body.appendChild(notification)
    
    setTimeout(() => {
      notification.remove()
      if (callback) callback()
    }, 1500)
  }

  loadNextQuestion(questionData) {
    // Simple page reload for next question
    window.location.reload()
  }

  // Helper method to trigger animations
  triggerAnimation(eventType) {
    // Try to call the form animation controller if it exists
    const formAnimationController = this.application.getControllerForElementAndIdentifier(this.element, 'form-animation')
    if (formAnimationController) {
      switch(eventType) {
        case 'question-will-change':
          formAnimationController.animateNextQuestion()
          break
        case 'form-submitting':
          formAnimationController.showLoadingState()
          break
        case 'form-submitted':
          formAnimationController.hideLoadingState()
          break
      }
    }
  }
}
</file>

<file path="javascript/controllers/rating_controller.js">
import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  static targets = ["option", "container"]
  static values = { 
    questionId: String,
    required: Boolean 
  }

  connect() {
    console.log('Rating controller connected for question:', this.questionIdValue)
    this.initializeSelection()
  }

  disconnect() {
    console.log('Rating controller disconnected')
  }

  // Handle rating selection
  selectRating(event) {
    console.log('Rating selected:', event.target.value)
    const radio = event.target
    const value = radio.value
    
    if (radio.checked) {
      // Remove selected class from all options
      this.optionTargets.forEach(option => {
        option.classList.remove('selected')
      })
      
      // Add selected class to clicked option
      const selectedOption = this.optionTargets.find(option => 
        option.dataset.value === value
      )
      
      if (selectedOption) {
        selectedOption.classList.add('selected')
        
        // Add a subtle animation
        selectedOption.style.animation = 'none'
        selectedOption.offsetHeight // Trigger reflow
        selectedOption.style.animation = 'pulse 0.3s ease-in-out'
      }
      
      // Also trigger the change event for the question response controller
      radio.dispatchEvent(new Event('change', { bubbles: true }))
    }
  }

  // Initialize any pre-selected values
  initializeSelection() {
    console.log('Initializing selection, options found:', this.optionTargets.length)
    this.optionTargets.forEach(option => {
      const value = option.dataset.value
      const radio = this.element.querySelector(`input[type="radio"][value="${value}"]`)
      
      if (radio && radio.checked) {
        console.log('Found pre-selected value:', value)
        option.classList.add('selected')
      }
    })
  }

  // Handle hover effects
  optionTargetConnected(element) {
    element.addEventListener('mouseenter', this.handleMouseEnter)
    element.addEventListener('mouseleave', this.handleMouseLeave)
  }

  optionTargetDisconnected(element) {
    element.removeEventListener('mouseenter', this.handleMouseEnter)
    element.removeEventListener('mouseleave', this.handleMouseLeave)
  }

  handleMouseEnter = (event) => {
    const option = event.currentTarget
    if (!option.classList.contains('selected')) {
      option.classList.add('border-indigo-400', 'bg-indigo-50', 'scale-110')
    }
  }

  handleMouseLeave = (event) => {
    const option = event.currentTarget
    if (!option.classList.contains('selected')) {
      option.classList.remove('border-indigo-400', 'bg-indigo-50', 'scale-110')
    }
  }
}
</file>

<file path="javascript/controllers/sortable_controller.js">
import { Controller } from "@hotwired/stimulus"
import Sortable from "sortablejs"

export default class extends Controller {
  static values = { handle: String }
  
  connect() {
    this.initializeSortable()
  }

  disconnect() {
    if (this.sortable) {
      this.sortable.destroy()
    }
  }

  initializeSortable() {
    const handleSelector = this.hasHandleValue ? this.handleValue : '.cursor-grab'
    
    this.sortable = Sortable.create(this.element, {
      handle: handleSelector,
      animation: 150,
      ghostClass: 'sortable-ghost',
      chosenClass: 'sortable-chosen',
      dragClass: 'sortable-drag',
      onEnd: (evt) => {
        this.dispatch('sorted', { detail: { item: evt.item, newIndex: evt.newIndex, oldIndex: evt.oldIndex } })
      }
    })
  }
}
</file>

<file path="javascript/controllers/stripe_settings_controller.js">
import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  static targets = ["publishableKey", "secretKey", "webhookSecret", "submitButton", "status"]

  connect() {
    console.log('Stripe settings controller connected')
    this.showHideFields()
  }

  toggleEnabled(event) {
    this.showHideFields()
  }

  showHideFields() {
    const stripeFields = document.getElementById('stripe-fields')
    const enabledCheckbox = document.getElementById('user_stripe_enabled')
    
    if (enabledCheckbox && stripeFields) {
      if (enabledCheckbox.checked) {
        stripeFields.classList.remove('hidden')
        // Make fields required when enabled
        if (this.hasPublishableKeyTarget) this.publishableKeyTarget.required = true
        if (this.hasSecretKeyTarget) this.secretKeyTarget.required = true
      } else {
        stripeFields.classList.add('hidden')
        // Remove required when disabled
        if (this.hasPublishableKeyTarget) this.publishableKeyTarget.required = false
        if (this.hasSecretKeyTarget) this.secretKeyTarget.required = false
        
        // Clear the status
        this.hideStatus()
      }
    }
  }

  async testConnection() {
    const button = event.target
    const originalText = button.textContent
    
    // Show loading state
    button.disabled = true
    button.innerHTML = `
      <svg class="animate-spin -ml-1 mr-2 h-4 w-4 text-current" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
      Testing...
    `

    try {
      const response = await fetch('/stripe_settings/test_connection', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
        }
      })

      const data = await response.json()

      if (data.success) {
        this.showSuccessStatus(data)
      } else {
        this.showErrorStatus(data.error)
      }
    } catch (error) {
      console.error('Test connection error:', error)
      this.showErrorStatus('Connection test failed. Please try again.')
    } finally {
      // Reset button
      button.disabled = false
      button.textContent = originalText
    }
  }

  showSuccessStatus(data) {
    if (!this.hasStatusTarget) return
    
    this.statusTarget.className = 'mt-4 p-4 rounded-md bg-green-50 border border-green-200'
    this.statusTarget.innerHTML = `
      <div class="flex items-start">
        <svg class="w-5 h-5 text-green-600 mt-0.5 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
        </svg>
        <div class="flex-1">
          <h4 class="text-sm font-medium text-green-900">Connection Successful!</h4>
          <div class="mt-2 text-sm text-green-700">
            <p><strong>Account ID:</strong> ${data.account_id}</p>
            ${data.business_name ? `<p><strong>Business:</strong> ${data.business_name}</p>` : ''}
            <p><strong>Country:</strong> ${data.country}</p>
            <p><strong>Currency:</strong> ${data.currency}</p>
            <p><strong>Charges Enabled:</strong> ${data.charges_enabled ? 'Yes' : 'No'}</p>
            <p><strong>Payouts Enabled:</strong> ${data.payouts_enabled ? 'Yes' : 'No'}</p>
          </div>
        </div>
      </div>
    `
    this.statusTarget.classList.remove('hidden')
  }

  showErrorStatus(error) {
    if (!this.hasStatusTarget) return
    
    this.statusTarget.className = 'mt-4 p-4 rounded-md bg-red-50 border border-red-200'
    this.statusTarget.innerHTML = `
      <div class="flex items-start">
        <svg class="w-5 h-5 text-red-600 mt-0.5 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
        </svg>
        <div>
          <h4 class="text-sm font-medium text-red-900">Connection Failed</h4>
          <p class="mt-1 text-sm text-red-700">${error}</p>
        </div>
      </div>
    `
    this.statusTarget.classList.remove('hidden')
  }

  hideStatus() {
    if (this.hasStatusTarget) {
      this.statusTarget.classList.add('hidden')
    }
  }

  validateKeys() {
    if (!this.hasPublishableKeyTarget || !this.hasSecretKeyTarget) return true
    
    const publishableKey = this.publishableKeyTarget.value
    const secretKey = this.secretKeyTarget.value
    
    let isValid = true
    
    // Validate publishable key
    if (publishableKey && !publishableKey.startsWith('pk_')) {
      this.showFieldError(this.publishableKeyTarget, 'Publishable key must start with pk_')
      isValid = false
    } else {
      this.clearFieldError(this.publishableKeyTarget)
    }
    
    // Validate secret key
    if (secretKey && !secretKey.startsWith('sk_')) {
      this.showFieldError(this.secretKeyTarget, 'Secret key must start with sk_')
      isValid = false
    } else {
      this.clearFieldError(this.secretKeyTarget)
    }
    
    return isValid
  }

  showFieldError(field, message) {
    field.classList.add('border-red-300', 'focus:border-red-500', 'focus:ring-red-500')
    field.classList.remove('border-gray-300', 'focus:border-indigo-500', 'focus:ring-indigo-500')
    
    // Remove existing error message
    const existingError = field.parentNode.querySelector('.field-error')
    if (existingError) {
      existingError.remove()
    }
    
    // Add new error message
    const errorElement = document.createElement('p')
    errorElement.className = 'field-error mt-1 text-xs text-red-600'
    errorElement.textContent = message
    field.parentNode.appendChild(errorElement)
  }

  clearFieldError(field) {
    field.classList.remove('border-red-300', 'focus:border-red-500', 'focus:ring-red-500')
    field.classList.add('border-gray-300', 'focus:border-indigo-500', 'focus:ring-indigo-500')
    
    const errorElement = field.parentNode.querySelector('.field-error')
    if (errorElement) {
      errorElement.remove()
    }
  }
}
</file>

<file path="javascript/controllers/subscription_checkout_controller.js">
import { Controller } from "@hotwired/stimulus"

// Connects to data-controller="subscription-checkout"
export default class extends Controller {
  static targets = [
    "monthlyForm", 
    "yearlyForm", 
    "monthlyButton", 
    "yearlyButton",
    "monthlyDiscountField",
    "yearlyDiscountField"
  ]

  connect() {
    this.currentDiscount = null
    this.originalPrices = {
      monthly: 29.00,
      yearly: 290.00
    }
  }

  // Handle discount applied event
  updateDiscount(event) {
    const { discountCode, pricing } = event.detail
    this.currentDiscount = {
      code: discountCode.code,
      percentage: discountCode.discount_percentage,
      pricing: pricing
    }
    
    // Update hidden discount code fields
    if (this.hasMonthlyDiscountFieldTarget) {
      this.monthlyDiscountFieldTarget.value = discountCode.code
    }
    if (this.hasYearlyDiscountFieldTarget) {
      this.yearlyDiscountFieldTarget.value = discountCode.code
    }
    
    // Update button text to show discounted prices
    this.updateButtonPricing()
  }

  // Handle discount cleared event
  clearDiscount(event) {
    this.currentDiscount = null
    
    // Clear hidden discount code fields
    if (this.hasMonthlyDiscountFieldTarget) {
      this.monthlyDiscountFieldTarget.value = ''
    }
    if (this.hasYearlyDiscountFieldTarget) {
      this.yearlyDiscountFieldTarget.value = ''
    }
    
    // Reset button text to original prices
    this.updateButtonPricing()
  }

  // Update button pricing display
  updateButtonPricing() {
    if (this.currentDiscount) {
      // Calculate discounted prices
      const monthlyDiscount = Math.round(this.originalPrices.monthly * this.currentDiscount.percentage / 100 * 100) / 100
      const yearlyDiscount = Math.round(this.originalPrices.yearly * this.currentDiscount.percentage / 100 * 100) / 100
      
      const monthlyFinal = this.originalPrices.monthly - monthlyDiscount
      const yearlyFinal = this.originalPrices.yearly - yearlyDiscount
      
      // Update monthly button
      if (this.hasMonthlyButtonTarget) {
        this.monthlyButtonTarget.innerHTML = `
          <span class="flex flex-col items-center">
            <span class="text-sm line-through opacity-75">$${this.originalPrices.monthly}/month</span>
            <span>Subscribe Monthly ($${monthlyFinal.toFixed(2)}/month)</span>
            <span class="text-xs">${this.currentDiscount.percentage}% off first payment</span>
          </span>
        `
      }
      
      // Update yearly button
      if (this.hasYearlyButtonTarget) {
        this.yearlyButtonTarget.innerHTML = `
          <span class="flex flex-col items-center">
            <span class="text-sm line-through opacity-75">$${this.originalPrices.yearly}/year</span>
            <span>Subscribe Yearly ($${yearlyFinal.toFixed(2)}/year)</span>
            <span class="text-xs">${this.currentDiscount.percentage}% off first payment</span>
          </span>
        `
      }
    } else {
      // Reset to original pricing
      if (this.hasMonthlyButtonTarget) {
        this.monthlyButtonTarget.textContent = `Subscribe Monthly ($${this.originalPrices.monthly}/month)`
      }
      
      if (this.hasYearlyButtonTarget) {
        this.yearlyButtonTarget.textContent = `Subscribe Yearly ($${this.originalPrices.yearly}/year)`
      }
    }
  }

  // Handle form submission (can add additional logic here if needed)
  submitForm(event) {
    // Allow form to submit normally
    // The discount code will be included in the hidden field
    return true
  }
}
</file>

<file path="javascript/controllers/tabs_controller.js">
import { Controller } from "@hotwired/stimulus"

// Connects to data-controller="tabs"
export default class extends Controller {
  static targets = ["tab", "panel"]
  static values = { 
    defaultTab: String,
    activeTab: String 
  }

  connect() {
    // Set default tab based on URL parameters or defaultTab value
    const urlParams = new URLSearchParams(window.location.search)
    const sourceParam = urlParams.get('source')
    
    let initialTab = this.defaultTabValue || 'prompt'
    if (sourceParam && ['prompt', 'document'].includes(sourceParam)) {
      initialTab = sourceParam
    }
    
    this.switchTo(initialTab)
  }

  switch(event) {
    event.preventDefault()
    const tabName = event.currentTarget.dataset.tab
    this.switchTo(tabName)
  }

  switchTo(tabName) {
    // Store previous tab for event dispatch
    const previousTab = this.activeTabValue
    
    // Update active tab value
    this.activeTabValue = tabName
    
    // Update tab states with smooth transitions
    this.tabTargets.forEach(tab => {
      const isActive = tab.dataset.tab === tabName
      
      if (isActive) {
        tab.classList.add('active', 'bg-indigo-50', 'text-indigo-700', 'border-indigo-200')
        tab.classList.remove('text-gray-500', 'hover:text-gray-700', 'border-transparent')
        tab.setAttribute('aria-selected', 'true')
      } else {
        tab.classList.remove('active', 'bg-indigo-50', 'text-indigo-700', 'border-indigo-200')
        tab.classList.add('text-gray-500', 'hover:text-gray-700', 'border-transparent')
        tab.setAttribute('aria-selected', 'false')
      }
    })
    
    // Update panel visibility with fade transitions
    this.panelTargets.forEach(panel => {
      const isActive = panel.dataset.panel === tabName
      
      if (isActive) {
        panel.classList.remove('hidden')
        panel.classList.add('animate-fade-in')
        // Remove animation class after animation completes
        setTimeout(() => {
          panel.classList.remove('animate-fade-in')
        }, 400)
      } else {
        panel.classList.add('hidden')
        panel.classList.remove('animate-fade-in')
      }
    })
    
    // Update URL parameter without page reload
    this.updateUrlParameter(tabName)
    
    // Dispatch custom event for other controllers to listen to
    this.dispatch('switched', { 
      detail: { 
        activeTab: tabName,
        previousTab: previousTab 
      } 
    })
    
    // Also dispatch to specific panels for controllers that might be nested inside
    this.panelTargets.forEach(panel => {
      if (panel.dataset.panel === tabName) {
        const customEvent = new CustomEvent('tabs:switched', {
          detail: { 
            activeTab: tabName,
            previousTab: previousTab 
          },
          bubbles: true
        })
        panel.dispatchEvent(customEvent)
      }
    })
  }

  updateUrlParameter(tabName) {
    const url = new URL(window.location)
    url.searchParams.set('source', tabName)
    window.history.replaceState({}, '', url)
  }

  // Getter for current active tab
  get currentTab() {
    return this.activeTabValue
  }

  // Method to programmatically switch tabs (for external controllers)
  activateTab(tabName) {
    if (['prompt', 'document'].includes(tabName)) {
      this.switchTo(tabName)
    }
  }
}
</file>

<file path="javascript/controllers/template_gallery_controller.js">
import { Controller } from "@hotwired/stimulus"

// Connects to data-controller="template-gallery"
export default class extends Controller {
  static targets = ["filterForm", "templateGrid", "resultsCount"]

  connect() {
    this.setupAutoSubmit()
    this.trackPageView()
  }

  // Auto-submit form when filters change
  setupAutoSubmit() {
    const form = this.element.querySelector('form')
    if (!form) return

    const selects = form.querySelectorAll('select')
    selects.forEach(select => {
      select.addEventListener('change', () => {
        this.trackFilterChange(select.name, select.value)
        form.submit()
      })
    })

    // Handle search input with debounce
    const searchInput = form.querySelector('input[name="search"]')
    if (searchInput) {
      let debounceTimer
      searchInput.addEventListener('input', (event) => {
        clearTimeout(debounceTimer)
        debounceTimer = setTimeout(() => {
          if (event.target.value.length >= 3 || event.target.value.length === 0) {
            this.trackSearch(event.target.value)
            form.submit()
          }
        }, 500)
      })
    }
  }

  // Track analytics events
  trackPageView() {
    this.trackEvent('template_gallery_viewed', {
      total_templates: this.getTemplateCount(),
      has_filters: this.hasActiveFilters()
    })
  }

  trackFilterChange(filterName, filterValue) {
    this.trackEvent('template_filter_applied', {
      filter_name: filterName,
      filter_value: filterValue,
      total_templates: this.getTemplateCount()
    })
  }

  trackSearch(searchTerm) {
    this.trackEvent('template_search_performed', {
      search_term: searchTerm,
      search_length: searchTerm.length
    })
  }

  trackTemplateInteraction(templateId, action) {
    this.trackEvent('template_interaction', {
      template_id: templateId,
      action: action,
      page: 'gallery'
    })
  }

  // Helper methods
  getTemplateCount() {
    const templateCards = this.element.querySelectorAll('[data-template-id]')
    return templateCards.length
  }

  hasActiveFilters() {
    const form = this.element.querySelector('form')
    if (!form) return false

    const formData = new FormData(form)
    for (let [key, value] of formData.entries()) {
      if (value && value !== '' && value !== 'all') {
        return true
      }
    }
    return false
  }

  trackEvent(eventName, properties = {}) {
    // Integration with analytics system
    if (window.analytics && typeof window.analytics.track === 'function') {
      window.analytics.track(eventName, {
        ...properties,
        timestamp: new Date().toISOString(),
        page: window.location.pathname,
        user_agent: navigator.userAgent
      })
    }

    // Fallback to console for development
    if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
      console.log(`Analytics Event: ${eventName}`, properties)
    }
  }
}
</file>

<file path="javascript/controllers/template_preview_controller.js">
import { Controller } from "@hotwired/stimulus"

// Connects to data-controller="template-preview"
export default class extends Controller {
  static targets = ["paymentBadge", "requirementsList", "setupModal"]
  static values = { 
    templateId: String,
    hasPaymentQuestions: Boolean,
    requiredFeatures: Array
  }

  connect() {
    this.updatePaymentBadgeVisibility()
  }

  // Show payment requirements modal when user clicks on payment badge or requirements
  showPaymentRequirements(event) {
    event.preventDefault()
    
    if (!this.hasPaymentQuestionsValue) {
      return
    }

    this.populateRequirementsList()
    this.showModal()
  }

  // User chooses to proceed with guided setup
  proceedWithSetup(event) {
    event.preventDefault()
    
    // Track analytics event
    this.trackEvent('payment_setup_initiated', {
      template_id: this.templateIdValue,
      required_features: this.requiredFeaturesValue
    })

    // Redirect to payment setup with template context
    const setupUrl = `/payment_setup?template_id=${this.templateIdValue}&return_to=${encodeURIComponent(window.location.pathname)}`
    window.location.href = setupUrl
  }

  // User chooses to proceed without setup (with reminders)
  proceedWithoutSetup(event) {
    event.preventDefault()
    
    // Track analytics event
    this.trackEvent('payment_setup_skipped', {
      template_id: this.templateIdValue,
      required_features: this.requiredFeaturesValue
    })

    // Close modal and proceed with template instantiation
    this.hideModal()
    
    // Redirect to template instantiation
    const instantiateUrl = `/templates/${this.templateIdValue}/instantiate`
    
    // Create a form and submit it (for POST request)
    const form = document.createElement('form')
    form.method = 'POST'
    form.action = instantiateUrl
    
    // Add CSRF token
    const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content')
    if (csrfToken) {
      const csrfInput = document.createElement('input')
      csrfInput.type = 'hidden'
      csrfInput.name = 'authenticity_token'
      csrfInput.value = csrfToken
      form.appendChild(csrfInput)
    }
    
    // Add skip setup parameter
    const skipSetupInput = document.createElement('input')
    skipSetupInput.type = 'hidden'
    skipSetupInput.name = 'skip_setup'
    skipSetupInput.value = 'true'
    form.appendChild(skipSetupInput)
    
    document.body.appendChild(form)
    form.submit()
  }

  // Close modal
  closeModal(event) {
    if (event) {
      event.preventDefault()
    }
    this.hideModal()
  }

  // Handle escape key to close modal
  handleKeydown(event) {
    if (event.key === 'Escape') {
      this.closeModal()
    }
  }

  // Private methods

  updatePaymentBadgeVisibility() {
    if (this.hasPaymentBadgeTarget) {
      if (this.hasPaymentQuestionsValue) {
        this.paymentBadgeTarget.classList.remove('hidden')
      } else {
        this.paymentBadgeTarget.classList.add('hidden')
      }
    }
  }

  populateRequirementsList() {
    if (!this.hasRequirementsListTarget) return

    const requirements = this.requiredFeaturesValue || []
    const requirementItems = requirements.map(feature => {
      const config = this.getFeatureConfig(feature)
      return `
        <div class="flex items-start space-x-3 p-3 bg-gray-50 rounded-lg">
          <div class="flex-shrink-0 w-5 h-5 mt-0.5">
            ${config.icon}
          </div>
          <div class="flex-1">
            <h4 class="text-sm font-medium text-gray-900">${config.title}</h4>
            <p class="text-xs text-gray-600 mt-1">${config.description}</p>
          </div>
        </div>
      `
    }).join('')

    this.requirementsListTarget.innerHTML = requirementItems
  }

  getFeatureConfig(feature) {
    const configs = {
      'stripe_payments': {
        title: 'Stripe Payment Configuration',
        description: 'Connect your Stripe account to accept payments through forms',
        icon: '<svg class="w-5 h-5 text-blue-600" fill="currentColor" viewBox="0 0 20 20"><path d="M4 4a2 2 0 00-2 2v1h16V6a2 2 0 00-2-2H4zM18 9H2v5a2 2 0 002 2h12a2 2 0 002-2V9zM4 13a1 1 0 011-1h1a1 1 0 110 2H5a1 1 0 01-1-1zm5-1a1 1 0 100 2h1a1 1 0 100-2H9z"></path></svg>'
      },
      'premium_subscription': {
        title: 'Premium Subscription',
        description: 'Upgrade to Premium to unlock payment features and advanced functionality',
        icon: '<svg class="w-5 h-5 text-purple-600" fill="currentColor" viewBox="0 0 20 20"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path></svg>'
      }
    }

    return configs[feature] || {
      title: feature.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase()),
      description: 'Required for payment functionality',
      icon: '<svg class="w-5 h-5 text-gray-600" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg>'
    }
  }

  showModal() {
    if (this.hasSetupModalTarget) {
      this.setupModalTarget.classList.remove('hidden')
      document.body.classList.add('overflow-hidden')
      
      // Focus trap
      const focusableElements = this.setupModalTarget.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      )
      if (focusableElements.length > 0) {
        focusableElements[0].focus()
      }

      // Add escape key listener
      document.addEventListener('keydown', this.handleKeydown.bind(this))
    }
  }

  hideModal() {
    if (this.hasSetupModalTarget) {
      this.setupModalTarget.classList.add('hidden')
      document.body.classList.remove('overflow-hidden')
      
      // Remove escape key listener
      document.removeEventListener('keydown', this.handleKeydown.bind(this))
    }
  }

  trackEvent(eventName, properties = {}) {
    // Integration with analytics system
    if (window.analytics && typeof window.analytics.track === 'function') {
      window.analytics.track(eventName, {
        ...properties,
        timestamp: new Date().toISOString(),
        page: window.location.pathname
      })
    }

    // Fallback to console for development
    // Check if we're in development by looking for Rails development indicators
    const isDevelopment = document.querySelector('meta[name="environment"]')?.getAttribute('content') === 'development' ||
                         window.location.hostname === 'localhost' ||
                         window.location.hostname === '127.0.0.1'
    
    if (isDevelopment) {
      console.log(`Analytics Event: ${eventName}`, properties)
    }
  }
}
</file>

<file path="javascript/application.js">
// app/javascript/application.js

import "@hotwired/turbo-rails";
import { Application } from "@hotwired/stimulus";
import { eagerLoadControllersFrom } from "@hotwired/stimulus-loading";

// --- INICIO DE STIMULUS ---
const application = Application.start();

// Configura la experiencia de desarrollo de Stimulus
application.debug = false; // Cambia a true para depurar
window.Stimulus = application;

// Carga automticamente todos los controladores desde la carpeta "controllers"
// La magia de importmap-rails se encarga del resto.
eagerLoadControllersFrom("controllers", application);
// -----------------------

// Import payment integration
import "payment_integration"
</file>

<file path="javascript/payment_integration.js">
// Payment Integration JavaScript
// This handles Stripe and PayPal payment processing

document.addEventListener('DOMContentLoaded', function() {
  console.log('Payment Integration loaded');
  
  // Initialize all payment containers
  initializePaymentContainers();
});

function initializePaymentContainers() {
  const paymentContainers = document.querySelectorAll('[data-payment-container="true"]');
  
  paymentContainers.forEach(container => {
    initializePaymentForContainer(container);
  });
}

function initializePaymentForContainer(container) {
  try {
    console.log('Initializing payment for container:', container);
    
    // Initialize payment method selection
    initializePaymentMethodSelection(container);

    // Initialize Stripe if available
    if (typeof Stripe !== 'undefined') {
      console.log('Stripe SDK loaded');
      initializeStripePayment(container);
    } else {
      console.warn('Stripe.js not loaded, showing manual input');
      showManualCardInput(container);
    }

    // Initialize PayPal if available
    if (typeof paypal !== 'undefined') {
      console.log('PayPal SDK loaded');
      initializePayPalPayment(container);
    } else {
      console.warn('PayPal SDK not loaded');
    }

    // Show default payment method
    const defaultMethod = getSelectedPaymentMethod(container) || 'credit_card';
    showPaymentMethod(container, defaultMethod);
    
  } catch (error) {
    console.error('Error initializing payment container:', error);
    showManualCardInput(container);
  }
}

function initializePaymentMethodSelection(container) {
  const paymentMethodRadios = container.querySelectorAll('input[name="answer[payment_method]"]');
  
  paymentMethodRadios.forEach(radio => {
    radio.addEventListener('change', function() {
      console.log('Payment method changed to:', this.value);
      showPaymentMethod(container, this.value);
    });
  });
}

function getSelectedPaymentMethod(container) {
  const selected = container.querySelector('input[name="answer[payment_method]"]:checked');
  return selected ? selected.value : null;
}

function showPaymentMethod(container, method) {
  if (!container || !method) return;

  // Hide all payment containers first
  const paymentContainers = container.querySelectorAll('[data-payment-method]');
  paymentContainers.forEach(paymentContainer => {
    paymentContainer.style.display = 'none';
  });

  // Show selected payment method
  const selectedContainer = container.querySelector(`[data-payment-method="${method}"]`);
  if (selectedContainer) {
    selectedContainer.style.display = 'block';
    console.log('Showing payment method:', method);
  } else {
    console.warn('Payment method container not found:', method);
  }
}

// Stripe Payment Integration
function initializeStripePayment(container) {
  try {
    // Get configuration from the container
    const config = getPaymentConfig(container);
    if (!config || !config.stripe_publishable_key) {
      console.warn('No Stripe configuration found, using manual input');
      showManualCardInput(container);
      return;
    }

    const stripe = Stripe(config.stripe_publishable_key);
    const elements = stripe.elements();

    // Create card element
    const cardElement = elements.create('card', {
      style: {
        base: {
          fontSize: '16px',
          color: '#424770',
          '::placeholder': {
            color: '#aab7c4',
          },
        },
      },
    });

    // Mount card element
    const cardElementContainer = container.querySelector('.stripe-card-element');
    if (cardElementContainer) {
      cardElement.mount(cardElementContainer);
      console.log('Stripe card element mounted successfully');
    } else {
      console.error('Stripe card mount point not found');
      return;
    }

    // Handle form submission
    const form = container.closest('form');
    if (form) {
      form.addEventListener('submit', async (event) => {
        const selectedMethod = getSelectedPaymentMethod(container);
        if (selectedMethod === 'credit_card') {
          event.preventDefault();
          
          const { paymentMethod, error } = await stripe.createPaymentMethod({
            type: 'card',
            card: cardElement,
          });

          if (error) {
            displayPaymentError(container, error.message);
          } else {
            // Add payment method ID to form
            const hiddenInput = document.createElement('input');
            hiddenInput.type = 'hidden';
            hiddenInput.name = 'answer[payment_method_id]';
            hiddenInput.value = paymentMethod.id;
            form.appendChild(hiddenInput);
            
            form.submit();
          }
        }
      });
    }
  } catch (error) {
    console.error('Stripe initialization error:', error);
    showManualCardInput(container);
  }
}

// PayPal Payment Integration
function initializePayPalPayment(container) {
  try {
    const config = getPaymentConfig(container);
    if (!config || !config.amount) {
      console.warn('No PayPal configuration found');
      return;
    }

    const paypalContainer = container.querySelector('.paypal-button-container');
    if (!paypalContainer) {
      console.warn('PayPal button container not found');
      return;
    }

    paypal.Buttons({
      createOrder: function(data, actions) {
        return actions.order.create({
          purchase_units: [{
            amount: {
              value: config.amount.toString(),
              currency_code: config.currency || 'USD'
            },
            description: config.description || 'Payment'
          }]
        });
      },
      onApprove: function(data, actions) {
        return actions.order.capture().then(function(details) {
          // Add payment confirmation to form
          const hiddenInput = document.createElement('input');
          hiddenInput.type = 'hidden';
          hiddenInput.name = 'answer[payment_confirmation]';
          hiddenInput.value = JSON.stringify(details);
          
          const form = container.closest('form');
          if (form) {
            form.appendChild(hiddenInput);
            form.submit();
          }
        });
      },
      onError: function(err) {
        console.error('PayPal Error:', err);
        displayPaymentError(container, 'Payment failed. Please try again.');
      }
    }).render(paypalContainer);

    console.log('PayPal buttons initialized');
  } catch (error) {
    console.error('PayPal initialization error:', error);
  }
}

// Get payment configuration from container data attributes
function getPaymentConfig(container) {
  // Look for configuration in various places
  const configElement = container.querySelector('[data-payment-config]');
  if (configElement) {
    try {
      return JSON.parse(configElement.dataset.paymentConfig || '{}');
    } catch (e) {
      console.warn('Failed to parse payment config:', e);
    }
  }

  // Fallback to individual data attributes
  return {
    amount: parseFloat(container.dataset.amount || 0),
    currency: container.dataset.currency || 'USD',
    stripe_publishable_key: container.dataset.stripeKey || 'pk_test_demo',
    description: container.dataset.description || 'Payment'
  };
}

// Manual card input fallback
function showManualCardInput(container) {
  const cardContainer = container.querySelector('.stripe-payment-container');
  if (cardContainer) {
    cardContainer.innerHTML = `
      <div class="border border-gray-200 rounded-lg p-4">
        <label class="block text-sm font-medium text-gray-700 mb-2">Card Number</label>
        <input type="text" class="w-full border border-gray-300 rounded-md p-2" 
               placeholder="1234 5678 9012 3456" maxlength="19" 
               name="answer[card_number]" required>
        
        <div class="grid grid-cols-2 gap-4 mt-4">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">Expiry Date</label>
            <input type="text" class="w-full border border-gray-300 rounded-md p-2" 
                   placeholder="MM/YY" maxlength="5" 
                   name="answer[expiry_date]" required>
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">CVC</label>
            <input type="text" class="w-full border border-gray-300 rounded-md p-2" 
                   placeholder="123" maxlength="4" 
                   name="answer[cvc]" required>
          </div>
        </div>
      </div>
    `;
    cardContainer.style.display = 'block';
  }
}

// Payment error handling
function displayPaymentError(container, message) {
  const errorContainer = container.querySelector('.payment-error');
  if (errorContainer) {
    errorContainer.textContent = message;
    errorContainer.style.display = 'block';
  }
}

// Export for global use
window.PaymentIntegration = {
  initializePaymentContainers,
  showPaymentMethod,
  initializeStripePayment,
  initializePayPalPayment,
  showManualCardInput,
  displayPaymentError
};
</file>

<file path="jobs/ai/cache_warming_job.rb">
# frozen_string_literal: true

module Ai
  class CacheWarmingJob < ApplicationJob
    queue_as :ai_processing
    
    # Retry configuration for cache warming
    retry_on StandardError, wait: :exponentially_longer, attempts: 3
    
    def perform(cache_types = nil)
      Rails.logger.info "Starting AI cache warming job"
      
      cache_types ||= [:form_templates, :user_preferences]
      
      cache_types.each do |cache_type|
        case cache_type.to_sym
        when :form_templates
          warm_form_templates
        when :user_preferences
          warm_user_preferences
        when :content_analysis
          warm_content_analysis
        when :all
          Ai::CachingService.warm_cache
        else
          Rails.logger.warn "Unknown cache type for warming: #{cache_type}"
        end
      end
      
      Rails.logger.info "AI cache warming job completed"
    end
    
    private
    
    def warm_form_templates
      Rails.logger.info "Warming form templates cache"
      
      # Common form patterns to pre-cache
      common_patterns = [
        {
          'recommended_approach' => 'lead_capture',
          'complexity_level' => 'simple',
          'suggested_question_count' => 5,
          'form_category' => 'lead_generation'
        },
        {
          'recommended_approach' => 'feedback',
          'complexity_level' => 'moderate',
          'suggested_question_count' => 8,
          'form_category' => 'customer_feedback'
        },
        {
          'recommended_approach' => 'survey',
          'complexity_level' => 'complex',
          'suggested_question_count' => 12,
          'form_category' => 'market_research'
        },
        {
          'recommended_approach' => 'registration',
          'complexity_level' => 'simple',
          'suggested_question_count' => 6,
          'form_category' => 'event_registration'
        },
        {
          'recommended_approach' => 'assessment',
          'complexity_level' => 'moderate',
          'suggested_question_count' => 10,
          'form_category' => 'job_application'
        }
      ]
      
      common_patterns.each do |pattern|
        template_key = Ai::CachingService.generate_template_key(pattern)
        
        # Only generate if not already cached
        unless Ai::CachingService.get_cached_form_template(template_key)
          template_structure = generate_template_structure(pattern)
          Ai::CachingService.cache_form_template(template_key, template_structure)
          
          Rails.logger.info "Warmed template cache for pattern: #{pattern['recommended_approach']}"
        end
      end
    end
    
    def warm_user_preferences
      Rails.logger.info "Warming user preferences cache"
      
      # Get recently active users who have used AI features
      active_users = User.joins(:forms)
                        .where(forms: { ai_enabled: true })
                        .where('users.updated_at > ?', 7.days.ago)
                        .distinct
                        .limit(50)
      
      active_users.find_each do |user|
        # Only warm if not already cached
        unless Ai::CachingService.get_cached_user_preferences(user.id)
          preferences = generate_user_preferences(user)
          Ai::CachingService.cache_user_preferences(user.id, preferences)
          
          Rails.logger.debug "Warmed preferences cache for user: #{user.id}"
        end
      end
    end
    
    def warm_content_analysis
      Rails.logger.info "Warming content analysis cache"
      
      # Common content patterns that might be analyzed
      common_content_samples = [
        "I need a contact form for my website to capture leads from potential customers.",
        "We want to collect customer feedback about our new product launch and user experience.",
        "Create a survey to understand market preferences and customer demographics.",
        "I need a registration form for our upcoming webinar event with payment processing.",
        "We need an assessment form for job applicants to evaluate their skills and experience."
      ]
      
      common_content_samples.each do |content|
        content_hash = Ai::CachingService.generate_content_hash(content)
        
        # Only analyze if not already cached
        unless Ai::CachingService.get_cached_content_analysis(content_hash)
          # This would normally trigger the AI analysis, but for warming we'll skip
          # actual LLM calls and just prepare the cache structure
          Rails.logger.debug "Content analysis cache prepared for sample content"
        end
      end
    end
    
    def generate_template_structure(pattern)
      {
        form_meta: {
          title: generate_title_for_pattern(pattern),
          description: generate_description_for_pattern(pattern),
          category: pattern['form_category'],
          instructions: "Please fill out this form completely."
        },
        questions: generate_questions_for_pattern(pattern),
        form_settings: {
          one_question_per_page: pattern['complexity_level'] == 'complex',
          show_progress_bar: pattern['suggested_question_count'] > 5,
          allow_multiple_submissions: false,
          thank_you_message: "Thank you for your response!",
          mobile_optimized: true,
          auto_save_enabled: true
        },
        metadata: {
          template_generated: true,
          pattern: pattern,
          generated_at: Time.current.iso8601
        }
      }
    end
    
    def generate_title_for_pattern(pattern)
      case pattern['recommended_approach']
      when 'lead_capture'
        "Contact Us"
      when 'feedback'
        "Your Feedback Matters"
      when 'survey'
        "Quick Survey"
      when 'registration'
        "Event Registration"
      when 'assessment'
        "Skills Assessment"
      else
        "#{pattern['form_category'].humanize} Form"
      end
    end
    
    def generate_description_for_pattern(pattern)
      case pattern['recommended_approach']
      when 'lead_capture'
        "Get in touch with us and we'll respond as soon as possible."
      when 'feedback'
        "Help us improve by sharing your thoughts and experiences."
      when 'survey'
        "Your responses help us understand our audience better."
      when 'registration'
        "Register for our upcoming event and secure your spot."
      when 'assessment'
        "Complete this assessment to help us understand your qualifications."
      else
        "Please complete this form with accurate information."
      end
    end
    
    def generate_questions_for_pattern(pattern)
      base_questions = []
      
      case pattern['recommended_approach']
      when 'lead_capture'
        base_questions = [
          {
            title: "What's your name?",
            question_type: "text_short",
            required: true,
            position: 1
          },
          {
            title: "Email address",
            question_type: "email",
            required: true,
            position: 2
          },
          {
            title: "Company name",
            question_type: "text_short",
            required: false,
            position: 3
          },
          {
            title: "Phone number",
            question_type: "phone",
            required: false,
            position: 4
          },
          {
            title: "How can we help you?",
            question_type: "text_long",
            required: true,
            position: 5
          }
        ]
      when 'feedback'
        base_questions = [
          {
            title: "How would you rate your overall experience?",
            question_type: "rating",
            required: true,
            position: 1,
            question_config: { scale: 5, labels: ["Poor", "Excellent"] }
          },
          {
            title: "What did you like most?",
            question_type: "text_long",
            required: false,
            position: 2
          },
          {
            title: "What could we improve?",
            question_type: "text_long",
            required: false,
            position: 3
          },
          {
            title: "Would you recommend us to others?",
            question_type: "yes_no",
            required: true,
            position: 4
          },
          {
            title: "Any additional comments?",
            question_type: "text_long",
            required: false,
            position: 5
          }
        ]
      when 'survey'
        base_questions = [
          {
            title: "What's your age range?",
            question_type: "multiple_choice",
            required: false,
            position: 1,
            question_config: {
              options: ["18-24", "25-34", "35-44", "45-54", "55-64", "65+"]
            }
          },
          {
            title: "What's your location?",
            question_type: "text_short",
            required: false,
            position: 2
          },
          {
            title: "What's your primary interest?",
            question_type: "multiple_choice",
            required: true,
            position: 3,
            question_config: {
              options: ["Technology", "Business", "Education", "Healthcare", "Other"]
            }
          },
          {
            title: "How did you hear about us?",
            question_type: "multiple_choice",
            required: false,
            position: 4,
            question_config: {
              options: ["Social Media", "Search Engine", "Friend/Colleague", "Advertisement", "Other"]
            }
          }
        ]
      when 'registration'
        base_questions = [
          {
            title: "Full name",
            question_type: "text_short",
            required: true,
            position: 1
          },
          {
            title: "Email address",
            question_type: "email",
            required: true,
            position: 2
          },
          {
            title: "Phone number",
            question_type: "phone",
            required: true,
            position: 3
          },
          {
            title: "Organization/Company",
            question_type: "text_short",
            required: false,
            position: 4
          },
          {
            title: "Dietary restrictions or special requirements",
            question_type: "text_long",
            required: false,
            position: 5
          }
        ]
      when 'assessment'
        base_questions = [
          {
            title: "Full name",
            question_type: "text_short",
            required: true,
            position: 1
          },
          {
            title: "Email address",
            question_type: "email",
            required: true,
            position: 2
          },
          {
            title: "Years of experience",
            question_type: "number",
            required: true,
            position: 3
          },
          {
            title: "Relevant skills",
            question_type: "text_long",
            required: true,
            position: 4
          },
          {
            title: "Why are you interested in this position?",
            question_type: "text_long",
            required: true,
            position: 5
          }
        ]
      end
      
      # Limit to suggested question count
      base_questions.take(pattern['suggested_question_count'])
    end
    
    def generate_user_preferences(user)
      # Analyze user's form history to generate preferences
      user_forms = user.forms.where(ai_enabled: true).limit(10)
      
      # Default preferences
      preferences = {
        preferred_complexity: 'moderate',
        preferred_question_count: 8,
        common_categories: [],
        ai_features_usage: {
          sentiment_analysis: false,
          lead_scoring: false,
          dynamic_followup: false
        },
        form_patterns: [],
        last_updated: Time.current.iso8601
      }
      
      if user_forms.any?
        # Analyze patterns from user's forms
        categories = user_forms.pluck(:category).compact.uniq
        preferences[:common_categories] = categories.take(3)
        
        # Analyze AI configuration usage
        ai_configs = user_forms.where.not(ai_configuration: {}).pluck(:ai_configuration)
        if ai_configs.any?
          features_used = ai_configs.flat_map { |config| config['features'] || [] }.uniq
          preferences[:ai_features_usage] = {
            sentiment_analysis: features_used.include?('sentiment_analysis'),
            lead_scoring: features_used.include?('lead_scoring'),
            dynamic_followup: features_used.include?('dynamic_followup')
          }
        end
        
        # Calculate average question count preference
        question_counts = user_forms.joins(:form_questions).group('forms.id').count.values
        if question_counts.any?
          avg_questions = question_counts.sum / question_counts.length
          preferences[:preferred_question_count] = avg_questions.round
        end
      end
      
      preferences
    end
  end
end
</file>

<file path="jobs/ai/database_performance_monitoring_job.rb">
# frozen_string_literal: true

module Ai
  class DatabasePerformanceMonitoringJob < ApplicationJob
    queue_as :ai_processing
    
    # Retry configuration for monitoring
    retry_on StandardError, wait: :exponentially_longer, attempts: 3
    
    def perform
      Rails.logger.info "Starting AI database performance monitoring"
      
      # Monitor connection pool health
      pool_health = Ai::ConnectionPoolService.monitor_connection_pool_health
      
      # Monitor database performance for AI operations
      db_performance = Ai::DatabaseOptimizationService.monitor_ai_database_performance
      
      # Check for performance issues and take action
      handle_performance_issues(pool_health, db_performance)
      
      # Generate performance report
      performance_report = generate_performance_report(pool_health, db_performance)
      
      Rails.logger.info "AI database performance monitoring completed"
      performance_report
    end
    
    private
    
    def handle_performance_issues(pool_health, db_performance)
      # Handle connection pool issues
      if pool_health[:pool_utilization] > 90
        Rails.logger.warn "High connection pool utilization detected: #{pool_health[:pool_utilization]}%"
        
        # Try to optimize pool usage
        Ai::ConnectionPoolService.optimize_pool_for_ai_usage
      end
      
      if pool_health[:waiting_count] > 0
        Rails.logger.warn "Connections waiting in queue: #{pool_health[:waiting_count]}"
        
        # Handle potential pool exhaustion
        Ai::ConnectionPoolService.handle_pool_exhaustion
      end
      
      # Handle slow query issues
      if db_performance[:query_performance][:slow_query_count] > 5
        Rails.logger.warn "High number of slow AI queries detected"
        
        # Trigger database optimization
        Ai::DatabaseOptimizationService.optimize_database_for_ai
      end
    end
    
    def generate_performance_report(pool_health, db_performance)
      {
        timestamp: Time.current.iso8601,
        connection_pool: {
          health_status: determine_pool_health_status(pool_health),
          utilization: pool_health[:pool_utilization],
          waiting_connections: pool_health[:waiting_count],
          recommendations: generate_pool_recommendations(pool_health)
        },
        database_performance: {
          query_performance: db_performance[:query_performance],
          index_usage: db_performance[:index_usage],
          table_sizes: db_performance[:table_sizes],
          recommendations: generate_db_recommendations(db_performance)
        },
        overall_health: calculate_overall_health(pool_health, db_performance)
      }
    end
    
    def determine_pool_health_status(pool_health)
      utilization = pool_health[:pool_utilization]
      waiting = pool_health[:waiting_count]
      
      if waiting > 0 || utilization > 90
        'critical'
      elsif utilization > 80
        'warning'
      elsif utilization > 60
        'good'
      else
        'excellent'
      end
    end
    
    def generate_pool_recommendations(pool_health)
      recommendations = []
      
      if pool_health[:pool_utilization] > 80
        recommendations << "Consider increasing connection pool size"
      end
      
      if pool_health[:waiting_count] > 0
        recommendations << "Optimize long-running AI operations"
        recommendations << "Consider connection pooling optimization"
      end
      
      if pool_health[:connection_health][:health_percentage] < 100
        recommendations << "Check for unhealthy database connections"
      end
      
      recommendations
    end
    
    def generate_db_recommendations(db_performance)
      recommendations = []
      
      if db_performance[:query_performance][:slow_query_count] > 5
        recommendations << "Optimize slow AI-related queries"
        recommendations << "Consider adding additional indexes"
      end
      
      if db_performance[:index_usage][:unused_indexes].any?
        recommendations << "Remove unused indexes to improve write performance"
      end
      
      # Check table sizes
      large_tables = db_performance[:table_sizes].select { |_, size| size.include?('GB') }
      if large_tables.any?
        recommendations << "Consider archiving old data from large tables: #{large_tables.keys.join(', ')}"
      end
      
      recommendations
    end
    
    def calculate_overall_health(pool_health, db_performance)
      pool_score = calculate_pool_health_score(pool_health)
      db_score = calculate_db_health_score(db_performance)
      
      overall_score = (pool_score + db_score) / 2
      
      case overall_score
      when 90..100
        'excellent'
      when 70..89
        'good'
      when 50..69
        'fair'
      when 30..49
        'poor'
      else
        'critical'
      end
    end
    
    def calculate_pool_health_score(pool_health)
      score = 100
      
      # Deduct points for high utilization
      utilization = pool_health[:pool_utilization]
      if utilization > 90
        score -= 30
      elsif utilization > 80
        score -= 20
      elsif utilization > 70
        score -= 10
      end
      
      # Deduct points for waiting connections
      waiting = pool_health[:waiting_count]
      score -= (waiting * 10) if waiting > 0
      
      # Deduct points for unhealthy connections
      health_percentage = pool_health[:connection_health][:health_percentage]
      score -= (100 - health_percentage) if health_percentage < 100
      
      [score, 0].max
    end
    
    def calculate_db_health_score(db_performance)
      score = 100
      
      # Deduct points for slow queries
      slow_queries = db_performance[:query_performance][:slow_query_count]
      score -= (slow_queries * 5) if slow_queries > 0
      
      # Deduct points for poor index usage
      # This would be based on actual index usage statistics
      
      [score, 0].max
    end
  end
end
</file>

<file path="jobs/forms/budget_adaptation_job.rb">
# app/jobs/forms/budget_adaptation_job.rb

class Forms::BudgetAdaptationJob < ApplicationJob
  queue_as :default

  def perform(form_response_id, budget_answer)
    Rails.logger.info "Starting BudgetAdaptationJob for response ID: #{form_response_id}"
    Rails.logger.info "Budget answer: '#{budget_answer}'"
    
    begin
      form_response = FormResponse.find(form_response_id)
      
      # Extract budget amount from text answer
      budget_amount = extract_budget_amount(budget_answer)
      Rails.logger.info "Extracted amount: #{budget_amount}"
      
      # Check if it's a low budget OR indicates budget constraints
      is_low_budget = determine_low_budget(budget_answer, budget_amount)
      Rails.logger.info "Is low budget: #{is_low_budget}"
      
      unless is_low_budget
        Rails.logger.info "Budget doesn't require follow-up, skipping dynamic question"
        return
      end
      
      # Check for existing questions
      existing = form_response.dynamic_questions
                             .where("generation_context @> ?", { trigger: 'budget_adaptation' }.to_json)
                             .exists?
      
      if existing
        Rails.logger.info "Budget adaptation question already exists"
        return
      end
      
      # Create contextual question based on the answer type
      question_data = generate_contextual_question(budget_answer, budget_amount)
      
      # Create dynamic question
      dynamic_question = DynamicQuestion.create!(
        form_response: form_response,
        generated_from_question: form_response.question_responses.last&.form_question,
        question_type: 'text_long',
        title: question_data[:title],
        description: question_data[:description],
        generation_context: { 
          trigger: 'budget_adaptation', 
          budget_amount: budget_amount,
          original_answer: budget_answer,
          question_type: question_data[:type]
        }
      )
      
      Rails.logger.info " Dynamic question created: #{dynamic_question.id}"
      
      # WAIT A BIT FOR WEBSOCKET TO CONNECT
      Rails.logger.info "Waiting to ensure WebSocket connection..."
      sleep(2) # Wait 2 seconds for WebSocket to establish
      
      # Broadcast using Turbo Streams
      Rails.logger.info "Sending broadcast..."
      Turbo::StreamsChannel.broadcast_append_to(
        form_response,
        target: "budget_adaptation_#{form_response.id}",
        partial: "responses/budget_adaptation_question",
        locals: {
          dynamic_question: dynamic_question,
          form_response: form_response
        }
      )
      
      Rails.logger.info " Broadcast sent successfully"
      
      # ALSO TRY ALTERNATIVE BROADCAST METHOD
      Rails.logger.info "Sending alternative broadcast..."
      begin
        html_content = ApplicationController.render(
          partial: "responses/budget_adaptation_question",
          locals: {
            dynamic_question: dynamic_question,
            form_response: form_response
          }
        )
        
        # Direct ActionCable broadcast
        ActionCable.server.broadcast(
          "turbo_streams_for_#{form_response.to_sgid_param}",
          "<turbo-stream action='append' target='budget_adaptation_#{form_response.id}'><template>#{html_content}</template></turbo-stream>"
        )
        
        Rails.logger.info " Broadcast alternativo enviado"
        
      rescue => alt_error
        Rails.logger.error "Alternative broadcast failed: #{alt_error.message}"
      end
      
    rescue => error
      Rails.logger.error "BudgetAdaptationJob failed: #{error.message}"
      Rails.logger.error error.backtrace.first(5).join("\n")
    end
  end

  private

  def extract_budget_amount(budget_text)
    return 0.0 if budget_text.blank?
    
    text = budget_text.to_s.downcase.strip
    
    # Handle written numbers first
    written_numbers = {
      'zero' => 0, 'cero' => 0,
      'one hundred' => 100, 'cien' => 100,
      'two hundred' => 200, 'doscientos' => 200,
      'three hundred' => 300, 'trescientos' => 300,
      'four hundred' => 400, 'cuatrocientos' => 400,
      'five hundred' => 500, 'quinientos' => 500,
      'one thousand' => 1000, 'mil' => 1000,
      'two thousand' => 2000, 'dos mil' => 2000,
      'three thousand' => 3000, 'tres mil' => 3000,
      'five thousand' => 5000, 'cinco mil' => 5000,
      'ten thousand' => 10000, 'diez mil' => 10000
    }
    
    written_numbers.each do |written, value|
      if text.include?(written)
        return value.to_f
      end
    end
    
    # Extract numeric values with various patterns
    patterns = [
      /(\d+(?:\.\d+)?)\s*k\b/i,  # 1k, 2.5k
      /(\d+(?:[,.]?\d+)*)\s*(?:usd|dollars?|pesos?||euros?)\b/i,  # 1000 usd, 500 dollars
      /[$]\s*(\d+(?:[,.]?\d+)*)/,  # $1000, 500
      /(\d+(?:[,.]?\d+)*)/  # Just numbers
    ]
    
    patterns.each do |pattern|
      match = text.match(pattern)
      if match
        number_str = match[1]
        if pattern == /(\d+(?:\.\d+)?)\s*k\b/i
          # Handle 'k' suffix (thousands)
          return number_str.to_f * 1000
        else
          # Clean and convert
          clean_number = number_str.gsub(',', '').to_f
          return clean_number if clean_number > 0
        end
      end
    end
    
    0.0
  end

  def determine_low_budget(budget_text, extracted_amount)
    return false if budget_text.blank?
    
    text = budget_text.to_s.downcase.strip
    
    # Explicit low budget indicators
    low_budget_phrases = [
      'limited', 'small', 'tight', 'low', 'minimal', 'constrained',
      'not much', 'very little',
      'bootstrap', 'startup budget', 'shoestring',
      'no budget'
    ]
    
    # Check for explicit low budget language
    if low_budget_phrases.any? { |phrase| text.include?(phrase) }
      return true
    end
    
    # If we extracted a number, use threshold
    if extracted_amount > 0
      return extracted_amount < 2000  # Increased threshold for AI projects
    end
    
    # Check for ranges that suggest low budget
    low_ranges = [
      /under \$?(\d+)/i,
      /less than \$?(\d+)/i,
      /below \$?(\d+)/i
    ]
    
    low_ranges.each do |range_pattern|
      match = text.match(range_pattern)
      if match
        threshold = match[1].to_f
        return threshold < 3000  # If they say "under 3000", consider it low
      end
    end
    
    false
  end

  def generate_contextual_question(budget_answer, budget_amount)
    text = budget_answer.to_s.downcase
    
    # Different question types based on the answer
    if budget_amount > 0
      # They gave a specific amount
      {
        type: 'specific_amount',
        title: "Let's optimize your $#{budget_amount.to_i} investment",
        description: "I understand you have a budget of $#{budget_amount.to_i} for AI projects. To help you get maximum value from this investment, could you share your main objectives and what you hope to achieve? This will help me suggest the best strategy within your budget."
      }
    elsif text.include?('limited') || text.include?('small') || text.include?('tight') || text.include?('limitado')
      # They indicated limited budget
      {
        type: 'limited_budget',
        title: "Maximize impact with limited budget",
        description: "I understand you're working with a limited budget for AI projects. This is very common and there are many effective ways to start. Could you tell me what specific business problem you hope to solve with AI? This will help me suggest cost-effective approaches that generate maximum impact."
      }
    elsif text.include?('startup') || text.include?('bootstrap')
      # Startup context
      {
        type: 'startup_budget',
        title: "AI strategy for startups",
        description: "Perfect, I understand you're in startup mode. The good news is that many modern AI solutions are very accessible for startups. What's the most critical business problem you believe AI could help solve? I'd like to suggest approaches that fit the reality of a startup."
      }
    else
      # General low budget case
      {
        type: 'general_constraint',
        title: "Let's understand your priorities",
        description: "Thank you for sharing your budget situation. To provide you with the best recommendations that fit your reality, could you tell me more about what you hope to achieve with AI and what your main priorities are? This way I can suggest options that really work for you."
      }
    end
  end
end
</file>

<file path="jobs/forms/completion_workflow_job.rb">
# frozen_string_literal: true

module Forms
  # Background job responsible for processing form completion workflows
  # This job handles analytics updates, integration triggers, and completion-related tasks
  class CompletionWorkflowJob < ApplicationJob
    queue_as :default
    
    # Retry on specific errors that might be temporary
    retry_on StandardError, wait: :polynomially_longer, attempts: 2
    retry_on ActiveRecord::RecordNotFound, wait: 5.seconds, attempts: 3
    
    # Discard if records are not found or configuration is invalid
    discard_on ArgumentError
    
    def perform(form_response_id)
      log_progress("Starting completion workflow for form_response #{form_response_id}")
      
      # Find the form response and related records
      form_response = find_record(FormResponse, form_response_id)
      form = form_response.form
      
      # Validate that the form response is actually completed
      validate_completion_prerequisites!(form_response)
      
      # Process completion workflow steps
      results = process_completion_workflow(form_response, form)
      
      # Log completion
      log_progress("Completion workflow finished", {
        form_response_id: form_response.id,
        form_id: form.id,
        analytics_updated: results[:analytics_updated],
        integrations_triggered: results[:integrations_triggered],
        ai_analysis_queued: results[:ai_analysis_queued]
      })
      
      results
    rescue StandardError => e
      handle_completion_error(form_response_id, e)
    end
    
    private
    
    # Validate that completion processing is appropriate
    def validate_completion_prerequisites!(form_response)
      unless form_response.completed?
        raise ArgumentError, "Form response #{form_response.id} is not in completed state"
      end
      
      unless form_response.completed_at
        raise ArgumentError, "Form response #{form_response.id} missing completion timestamp"
      end
      
      log_progress("Completion prerequisites validated", {
        form_response_id: form_response.id,
        status: form_response.status,
        completed_at: form_response.completed_at
      })
    end
    
    # Process the main completion workflow
    def process_completion_workflow(form_response, form)
      results = {
        analytics_updated: false,
        integrations_triggered: false,
        ai_analysis_queued: false,
        errors: []
      }
      
      # Step 1: Update form analytics
      begin
        update_form_analytics(form, form_response)
        results[:analytics_updated] = true
        log_progress("Form analytics updated successfully")
      rescue StandardError => e
        results[:errors] << { step: 'analytics', error: e.message }
        Rails.logger.error "Failed to update form analytics: #{e.message}"
      end
      
      # Step 2: Update question-level analytics
      begin
        update_question_analytics(form_response)
        log_progress("Question analytics updated successfully")
      rescue StandardError => e
        results[:errors] << { step: 'question_analytics', error: e.message }
        Rails.logger.error "Failed to update question analytics: #{e.message}"
      end
      
      # Step 3: Trigger integrations if enabled
      if form.integrations_enabled?
        begin
          trigger_completion_integrations(form_response)
          results[:integrations_triggered] = true
          log_progress("Completion integrations triggered successfully")
        rescue StandardError => e
          results[:errors] << { step: 'integrations', error: e.message }
          Rails.logger.error "Failed to trigger integrations: #{e.message}"
        end
      end
      
      # Step 4: Queue AI analysis if enabled and sufficient responses
      if should_queue_ai_analysis?(form, form_response)
        begin
          queue_ai_analysis(form, form_response)
          results[:ai_analysis_queued] = true
          log_progress("AI analysis queued successfully")
        rescue StandardError => e
          results[:errors] << { step: 'ai_analysis', error: e.message }
          Rails.logger.error "Failed to queue AI analysis: #{e.message}"
        end
      end
      
      # Step 5: Update form completion metrics
      begin
        update_form_completion_metrics(form, form_response)
        log_progress("Form completion metrics updated successfully")
      rescue StandardError => e
        results[:errors] << { step: 'completion_metrics', error: e.message }
        Rails.logger.error "Failed to update completion metrics: #{e.message}"
      end
      
      # Step 6: Send completion notifications if configured
      if should_send_completion_notifications?(form)
        begin
          send_completion_notifications(form, form_response)
          log_progress("Completion notifications sent successfully")
        rescue StandardError => e
          results[:errors] << { step: 'notifications', error: e.message }
          Rails.logger.error "Failed to send completion notifications: #{e.message}"
        end
      end
      
      results
    end
    
    # Update form-level analytics with the new completion
    def update_form_analytics(form, form_response)
      safe_db_operation do
        # Update basic completion counts
        form.increment!(:completion_count)
        form.update!(updated_at: form_response.completed_at)
        
        # Update or create daily analytics record
        today = Date.current
        analytics = FormAnalytic.find_or_initialize_by(
          form: form,
          date: today,
          period_type: 'daily'
        )
        
        analytics.completed_responses_count = (analytics.completed_responses_count || 0) + 1
        
        # Calculate and update average completion time
        completion_time = calculate_completion_time(form_response)
        if completion_time
          current_avg = analytics.avg_completion_time || 0
          current_count = analytics.completed_responses_count
          
          # Calculate new average using incremental formula
          analytics.avg_completion_time = if current_count == 1
                                           completion_time
                                         else
                                           ((current_avg * (current_count - 1)) + completion_time) / current_count
                                         end
        end
        
        # Update quality and sentiment scores if available
        if form_response.ai_analysis.present?
          update_ai_metrics(analytics, form_response)
        end
        
        analytics.save!
        
        log_progress("Analytics updated", {
          form_id: form.id,
          date: today,
          completed_responses_count: analytics.completed_responses_count,
          avg_completion_time: analytics.avg_completion_time
        })
      end
    end
    
    # Update question-level analytics
    def update_question_analytics(form_response)
      form_response.question_responses.includes(:form_question).each do |question_response|
        question = question_response.form_question
        
        # Update question completion stats
        safe_db_operation do
          # This could be expanded to track question-specific metrics
          # For now, we'll update basic completion tracking
          question.touch(:updated_at)
        end
      end
    end
    
    # Trigger completion-specific integrations
    def trigger_completion_integrations(form_response)
      # Queue integration job with completion event
      Forms::IntegrationTriggerJob.perform_later(
        form_response.id,
        'form_completed',
        { source: 'completion_workflow' }
      )
      
      log_progress("Integration trigger job queued", {
        form_response_id: form_response.id,
        trigger_event: 'form_completed'
      })
    end
    
    # Determine if AI analysis should be queued
    def should_queue_ai_analysis?(form, form_response)
      return false unless form.ai_enhanced?
      return false unless form.user.can_use_ai_features?
      
      # Only queue analysis if form has sufficient responses for meaningful insights
      form.responses_count >= 5
    end
    
    # Queue AI analysis for the form
    def queue_ai_analysis(form, form_response)
      # Queue form-level analysis if we have enough responses
      if form.responses_count % 10 == 0 # Analyze every 10 completions
        Forms::AnalysisWorkflow.perform_later(form.id)
        log_progress("Form analysis workflow queued", { form_id: form.id })
      end
      
      # Queue individual response analysis if AI features are enabled
      if form_response.should_analyze_with_ai?
        Forms::ResponseAnalysisJob.perform_later(form_response.id)
        log_progress("Response analysis job queued", { form_response_id: form_response.id })
      end
    end
    
    # Update form completion metrics
    def update_form_completion_metrics(form, form_response)
      safe_db_operation do
        # Calculate completion rate
        total_responses = form.responses_count
        total_completions = form.completion_count
        completion_rate = total_responses > 0 ? (total_completions.to_f / total_responses * 100).round(2) : 0
        
        # Update form settings with latest metrics
        form_settings = form.form_settings || {}
        form_settings[:completion_rate] = completion_rate
        form_settings[:last_completion_at] = form_response.completed_at.iso8601
        form_settings[:completion_metrics_updated_at] = Time.current.iso8601
        
        form.update!(form_settings: form_settings)
        
        log_progress("Completion metrics updated", {
          form_id: form.id,
          completion_rate: completion_rate,
          total_responses: total_responses,
          total_completions: total_completions
        })
      end
    end
    
    # Determine if completion notifications should be sent
    def should_send_completion_notifications?(form)
      notification_settings = form.form_settings&.dig('notifications', 'completion')
      return false unless notification_settings
      
      notification_settings['enabled'] == true
    end
    
    # Send completion notifications
    def send_completion_notifications(form, form_response)
      notification_settings = form.form_settings.dig('notifications', 'completion')
      
      # Send email notification if configured
      if notification_settings['email_enabled']
        send_completion_email_notification(form, form_response, notification_settings)
      end
      
      # Send Slack notification if configured
      if notification_settings['slack_enabled']
        send_completion_slack_notification(form, form_response, notification_settings)
      end
      
      # Send webhook notification if configured
      if notification_settings['webhook_enabled']
        send_completion_webhook_notification(form, form_response, notification_settings)
      end
    end
    
    # Send email notification for completion
    def send_completion_email_notification(form, form_response, settings)
      # This would integrate with ActionMailer
      # For now, we'll log the action
      log_progress("Email notification would be sent", {
        form_id: form.id,
        form_response_id: form_response.id,
        recipients: settings['email_recipients']
      })
    end
    
    # Send Slack notification for completion
    def send_completion_slack_notification(form, form_response, settings)
      # This would integrate with Slack API
      # For now, we'll log the action
      log_progress("Slack notification would be sent", {
        form_id: form.id,
        form_response_id: form_response.id,
        channel: settings['slack_channel']
      })
    end
    
    # Send webhook notification for completion
    def send_completion_webhook_notification(form, form_response, settings)
      # This would trigger a webhook
      # For now, we'll log the action
      log_progress("Webhook notification would be sent", {
        form_id: form.id,
        form_response_id: form_response.id,
        webhook_url: settings['webhook_url']
      })
    end
    
    # Calculate completion time for a form response
    def calculate_completion_time(form_response)
      return nil unless form_response.started_at && form_response.completed_at
      
      # Return time in minutes
      ((form_response.completed_at - form_response.started_at) / 1.minute).round(2)
    end
    
    # Update AI-related metrics in analytics
    def update_ai_metrics(analytics, form_response)
      ai_results = form_response.ai_analysis
      
      # Update sentiment score
      if ai_results&.dig('overall_sentiment')
        current_sentiment = analytics.avg_sentiment_score || 0
        current_count = analytics.completed_responses_count
        
        new_sentiment = ai_results['overall_sentiment'].to_f
        analytics.avg_sentiment_score = if current_count == 1
                                         new_sentiment
                                       else
                                         ((current_sentiment * (current_count - 1)) + new_sentiment) / current_count
                                       end
      end
      
      # Update quality score
      if ai_results&.dig('overall_quality')
        current_quality = analytics.avg_quality_score || 0
        current_count = analytics.completed_responses_count
        
        new_quality = ai_results['overall_quality'].to_f
        analytics.avg_quality_score = if current_count == 1
                                       new_quality
                                     else
                                       ((current_quality * (current_count - 1)) + new_quality) / current_count
                                     end
      end
      
      # Update AI insights
      if ai_results&.dig('key_insights')
        analytics.ai_insights ||= {}
        analytics.ai_insights[:latest_insights] = ai_results['key_insights']
        analytics.ai_insights[:last_updated] = Time.current.iso8601
      end
    end
    
    # Handle completion workflow errors
    def handle_completion_error(form_response_id, error)
      error_context = {
        form_response_id: form_response_id,
        job_id: job_id,
        error_message: error.message,
        error_type: error.class.name
      }
      
      Rails.logger.error "Completion workflow failed for form_response #{form_response_id}: #{error.message}"
      Rails.logger.error error.backtrace.join("\n") if Rails.env.development?
      
      # Try to update form response with error information if possible
      begin
        form_response = FormResponse.find_by(id: form_response_id)
        if form_response
          completion_metadata = form_response.completion_data || {}
          completion_metadata[:workflow_errors] ||= []
          completion_metadata[:workflow_errors] << {
            error: error.message,
            error_type: error.class.name,
            failed_at: Time.current.iso8601,
            job_id: job_id
          }
          
          # Keep only last 3 errors
          completion_metadata[:workflow_errors] = completion_metadata[:workflow_errors].last(3)
          
          form_response.update!(completion_data: completion_metadata)
        end
      rescue StandardError => update_error
        Rails.logger.error "Failed to update form response with error information: #{update_error.message}"
      end
      
      # Track error in monitoring system
      if defined?(Sentry)
        Sentry.capture_exception(error, extra: error_context)
      end
      
      # Re-raise to trigger retry logic
      raise error
    end
  end
end
</file>

<file path="jobs/forms/data_enrichment_job.rb">
# frozen_string_literal: true

module Forms
  # Background job for enriching form response data with external company information
  # This job is triggered when a user provides their email address in a form
  # with AI enrichment enabled
  class DataEnrichmentJob < ApplicationJob
    queue_as :default
    
    # Maximum number of retry attempts
    retry_on StandardError, wait: :exponentially_longer, attempts: 3
    
    # Perform data enrichment for a form response
    # @param form_response_id [Integer] ID of the form response to enrich
    # @param email [String] Email address provided by the user
    def perform(form_response_id, email = nil)
      form_response = FormResponse.find(form_response_id)
      
      # Skip if form doesn't have AI enhancement enabled
      unless form_response.form.ai_enhanced?
        Rails.logger.info "Skipping enrichment - AI not enabled for form #{form_response.form.id}"
        return
      end
      
      # Skip if already enriched
      if form_response.enrichment_data.present?
        Rails.logger.info "Skipping enrichment - Already enriched for response #{form_response_id}"
        return
      end
      
      # Get email from response if not provided
      email ||= form_response.get_answer('email')
      
      unless email.present?
        Rails.logger.warn "No email found for enrichment in response #{form_response_id}"
        return
      end
      
      Rails.logger.info "Starting data enrichment for response #{form_response_id} with email #{email}"
      
      # Execute the enrichment workflow
      workflow_result = Forms::EnrichmentWorkflow.execute(
        form_response_id: form_response_id
      )

      Rails.logger.info "Starting data enrichment for response #{form_response_id} with email #{email}"
    
      # CORRECCIN: Usar WorkflowEngine
      context = SuperAgent::Workflow::Context.new(form_response_id: form_response_id)
      engine = SuperAgent::WorkflowEngine.new
      workflow_result = engine.execute(Forms::EnrichmentWorkflow, context)
      
      if workflow_result.completed?
        Rails.logger.info "Successfully enriched response #{form_response_id}"
      else
        Rails.logger.error "Failed to enrich response #{form_response_id}: #{workflow_result.error_message}"
        raise workflow_result.error if workflow_result.error.present?
      end
      
      if workflow_result.success?
        Rails.logger.info "Successfully enriched response #{form_response_id}"
      else
        Rails.logger.error "Failed to enrich response #{form_response_id}: #{workflow_result.error}"
        raise workflow_result.error if workflow_result.error.present?
      end
      
    rescue ActiveRecord::RecordNotFound => e
      Rails.logger.error "Form response #{form_response_id} not found for enrichment"
      raise e
    rescue StandardError => e
      Rails.logger.error "Data enrichment failed for response #{form_response_id}: #{e.message}"
      raise e
    end
    
    # Priority for this job type
    def self.priority
      5 # Medium priority
    end
    
    # Maximum runtime for this job
    def max_run_time
      5.minutes
    end
  end
end
</file>

<file path="jobs/forms/dynamic_question_generation_job.rb">
# frozen_string_literal: true

module Forms
  # Background job responsible for generating dynamic follow-up questions using AI
  # This job is triggered when a response analysis suggests a follow-up question would be valuable
  class DynamicQuestionGenerationJob < ApplicationJob
    queue_as :ai_processing
    
    # Retry on specific errors that might be temporary
    retry_on StandardError, wait: :polynomially_longer, attempts: 2
    
    # Discard if records are not found or invalid
    discard_on ActiveRecord::RecordNotFound, ArgumentError
    
    def perform(form_response_id, source_question_id, options = {})
      log_progress("Starting dynamic question generation for form_response #{form_response_id}, source_question #{source_question_id}")
      
      # Find the required records
      form_response = find_record(FormResponse, form_response_id)
      source_question = find_record(FormQuestion, source_question_id)
      
      # Validate prerequisites for dynamic question generation
      validate_generation_prerequisites!(form_response, source_question)
      
      # Get the source answer data
      source_answer_data = get_source_answer_data(form_response, source_question)
      
      # Execute dynamic question generation workflow
      generation_result = execute_generation_workflow(form_response, source_question, source_answer_data, options)
      
      # Log completion
      log_progress("Dynamic question generation completed", {
        form_response_id: form_response.id,
        source_question_id: source_question.id,
        success: generation_result[:success],
        dynamic_question_id: generation_result[:dynamic_question_id]
      })
      
      generation_result
    rescue StandardError => e
      handle_generation_error(form_response_id, source_question_id, e)
    end
    
    private
    
    # Validate that dynamic question generation is appropriate and allowed
    def validate_generation_prerequisites!(form_response, source_question)
      form = source_question.form
      user = form.user
      
      # Verify form response belongs to the same form as the source question
      unless form_response.form_id == source_question.form_id
        raise ArgumentError, "Form response #{form_response.id} does not belong to form #{source_question.form_id}"
      end
      
      # Check if form has AI features enabled
      unless form.ai_enhanced?
        raise ArgumentError, "Form #{form.id} does not have AI features enabled"
      end
      
      # Check if source question supports dynamic follow-ups
      unless source_question.generates_followups?
        raise ArgumentError, "Source question #{source_question.id} is not configured for follow-up generation"
      end
      
      # Check user's AI capabilities
      unless user.can_use_ai_features?
        raise ArgumentError, "User #{user.id} does not have AI features available"
      end
      
      # Check if we've already generated too many dynamic questions for this response
      existing_count = form_response.dynamic_questions.count
      max_dynamic_questions = form.ai_configuration&.dig('max_dynamic_questions') || 3
      
      if existing_count >= max_dynamic_questions
        raise ArgumentError, "Maximum dynamic questions limit reached (#{existing_count}/#{max_dynamic_questions})"
      end
      
      # Check if we've already generated follow-ups for this specific question
      existing_from_source = form_response.dynamic_questions
                                         .where(generated_from_question: source_question)
                                         .count
      max_per_question = source_question.ai_configuration&.dig('max_followups') || 2
      
      if existing_from_source >= max_per_question
        raise ArgumentError, "Maximum follow-ups for this question reached (#{existing_from_source}/#{max_per_question})"
      end
      
      # Check if form response is still active (not completed too long ago)
      if form_response.completed? && form_response.completed_at < 1.hour.ago
        raise ArgumentError, "Form response was completed too long ago for dynamic questions"
      end
      
      log_progress("Dynamic question generation prerequisites validated", {
        form_response_id: form_response.id,
        source_question_id: source_question.id,
        existing_dynamic_count: existing_count,
        existing_from_source: existing_from_source,
        form_ai_enabled: form.ai_enhanced?,
        user_can_use_ai: user.can_use_ai_features?
      })
    end
    
    # Get the answer data for the source question from the form response
    def get_source_answer_data(form_response, source_question)
      # Find the question response for the source question
      question_response = form_response.question_responses
                                      .find_by(form_question: source_question)
      
      unless question_response
        raise ArgumentError, "No response found for source question #{source_question.id}"
      end
      
      unless question_response.answer_data.present?
        raise ArgumentError, "Source question response has no answer data"
      end
      
      log_progress("Retrieved source answer data", {
        question_response_id: question_response.id,
        answer_present: question_response.answer_data.present?,
        answer_type: question_response.answer_data.class.name
      })
      
      question_response.answer_data
    end
    
    # Execute the dynamic question generation workflow
    def execute_generation_workflow(form_response, source_question, source_answer_data, options)
      log_progress("Executing dynamic question generation workflow")
      
      begin
        # Prepare workflow inputs
        workflow_inputs = {
          form_response_id: form_response.id,
          source_question_id: source_question.id,
          source_answer_data: source_answer_data,
          generation_trigger: options[:trigger] || 'manual'
        }
        
        # Execute the workflow
        workflow = Forms::DynamicQuestionWorkflow.new
        result = workflow.execute(workflow_inputs)
        
        # Check if workflow execution was successful
        if result.success?
          final_output = result.final_output
          
          if final_output.is_a?(Hash) && final_output[:dynamic_question_id]
            log_progress("Workflow executed successfully", {
              dynamic_question_id: final_output[:dynamic_question_id],
              ai_cost: final_output[:ai_cost],
              strategy: final_output[:strategy]&.dig(:type)
            })
            
            {
              success: true,
              dynamic_question_id: final_output[:dynamic_question_id],
              dynamic_question: final_output[:dynamic_question],
              ai_cost: final_output[:ai_cost],
              strategy: final_output[:strategy],
              workflow_result: result
            }
          else
            log_progress("Workflow completed but no dynamic question was generated", {
              final_output: final_output,
              reason: final_output[:reason] || 'Unknown'
            })
            
            {
              success: false,
              skipped: true,
              reason: final_output[:reason] || 'Generation was skipped',
              workflow_result: result
            }
          end
        else
          error_message = result.error_message || 'Workflow execution failed'
          
          log_progress("Workflow execution failed", {
            error: error_message,
            error_type: result.error_type
          })
          
          {
            success: false,
            error: error_message,
            error_type: result.error_type || 'workflow_error',
            workflow_result: result
          }
        end
      rescue StandardError => e
        Rails.logger.error "Dynamic question generation workflow failed: #{e.message}"
        
        {
          success: false,
          error: e.message,
          error_type: e.class.name
        }
      end
    end
    
    # Handle generation errors
    def handle_generation_error(form_response_id, source_question_id, error)
      error_context = {
        form_response_id: form_response_id,
        source_question_id: source_question_id,
        job_id: job_id,
        error_message: error.message,
        error_type: error.class.name
      }
      
      Rails.logger.error "Dynamic question generation failed for form_response #{form_response_id}, source_question #{source_question_id}: #{error.message}"
      Rails.logger.error error.backtrace.join("\n") if Rails.env.development?
      
      # Try to log the error in the form response if possible
      begin
        form_response = FormResponse.find_by(id: form_response_id)
        if form_response
          # Add error information to the form response's AI analysis results
          current_analysis = form_response.ai_analysis_results || {}
          current_analysis[:dynamic_question_errors] ||= []
          current_analysis[:dynamic_question_errors] << {
            source_question_id: source_question_id,
            error: error.message,
            error_type: error.class.name,
            failed_at: Time.current.iso8601,
            job_id: job_id
          }
          
          form_response.update!(ai_analysis_results: current_analysis)
        end
      rescue StandardError => update_error
        Rails.logger.error "Failed to update form response with error information: #{update_error.message}"
      end
      
      # Track error in monitoring system
      if defined?(Sentry)
        Sentry.capture_exception(error, extra: error_context)
      end
      
      # Re-raise to trigger retry logic
      raise error
    end
    
    # Check if AI budget is available for this operation
    def check_ai_budget(user, estimated_cost)
      return true unless user.respond_to?(:ai_credits_remaining)
      
      remaining_credits = user.ai_credits_remaining
      
      if remaining_credits < estimated_cost
        log_progress("Insufficient AI credits", {
          user_id: user.id,
          remaining_credits: remaining_credits,
          estimated_cost: estimated_cost
        })
        return false
      end
      
      true
    end
    
    # Validate that the generated dynamic question is appropriate
    def validate_generated_question(dynamic_question, source_question, form_response)
      return false unless dynamic_question.persisted?
      
      # Check that it's not too similar to existing questions
      existing_questions = form_response.form.form_questions.pluck(:title)
      existing_dynamic_questions = form_response.dynamic_questions.where.not(id: dynamic_question.id).pluck(:title)
      all_existing = existing_questions + existing_dynamic_questions
      
      # Simple similarity check
      similar_question = all_existing.find do |existing_title|
        calculate_text_similarity(dynamic_question.title, existing_title) > 0.8
      end
      
      if similar_question
        log_progress("Generated question too similar to existing question", {
          generated_title: dynamic_question.title,
          similar_to: similar_question,
          dynamic_question_id: dynamic_question.id
        })
        return false
      end
      
      # Check that it's not asking for the same information as the source
      if calculate_text_similarity(dynamic_question.title, source_question.title) > 0.7
        log_progress("Generated question too similar to source question", {
          generated_title: dynamic_question.title,
          source_title: source_question.title,
          dynamic_question_id: dynamic_question.id
        })
        return false
      end
      
      true
    end
    
    # Calculate text similarity between two strings
    def calculate_text_similarity(text1, text2)
      return 0.0 if text1.blank? || text2.blank?
      
      words1 = text1.downcase.split(/\W+/).reject(&:blank?)
      words2 = text2.downcase.split(/\W+/).reject(&:blank?)
      
      return 0.0 if words1.empty? || words2.empty?
      
      common_words = words1 & words2
      total_unique_words = (words1 | words2).length
      
      common_words.length.to_f / total_unique_words
    end
    
    # Schedule follow-up analysis if the dynamic question gets answered
    def schedule_followup_analysis(dynamic_question)
      return unless dynamic_question.should_generate_followup?
      
      log_progress("Scheduling follow-up analysis for dynamic question", {
        dynamic_question_id: dynamic_question.id,
        form_response_id: dynamic_question.form_response_id
      })
      
      # This could trigger another round of dynamic question generation
      # or other analysis workflows based on the answer
      Forms::ResponseAnalysisJob.perform_later(dynamic_question.id)
    end
    
    # Update form analytics with dynamic question generation metrics
    def update_form_analytics(form, generation_result)
      return unless generation_result[:success]
      
      safe_db_operation do
        # Find or create analytics record for today
        analytics = FormAnalytic.find_or_create_by(
          form: form,
          date: Date.current
        ) do |record|
          record.initialize_metrics
        end
        
        # Update dynamic question metrics
        current_metrics = analytics.metrics || {}
        dynamic_metrics = current_metrics['dynamic_questions'] ||= {}
        
        dynamic_metrics['generated_count'] = (dynamic_metrics['generated_count'] || 0) + 1
        dynamic_metrics['total_ai_cost'] = (dynamic_metrics['total_ai_cost'] || 0.0) + (generation_result[:ai_cost] || 0.0)
        dynamic_metrics['last_generated_at'] = Time.current.iso8601
        
        # Track strategy types
        strategy_type = generation_result[:strategy]&.dig(:type)
        if strategy_type
          strategy_counts = dynamic_metrics['strategy_counts'] ||= {}
          strategy_counts[strategy_type] = (strategy_counts[strategy_type] || 0) + 1
        end
        
        analytics.update!(metrics: current_metrics)
        
        log_progress("Updated form analytics with dynamic question metrics", {
          form_id: form.id,
          generated_count: dynamic_metrics['generated_count'],
          strategy_type: strategy_type
        })
      end
    rescue StandardError => e
      Rails.logger.error "Failed to update form analytics: #{e.message}"
      # Don't re-raise as this is not critical
    end
  end
end
</file>

<file path="jobs/forms/integration_trigger_job.rb">
# frozen_string_literal: true
require 'net/http'
require 'openssl'

module Forms
  # Background job responsible for triggering external integrations when form events occur
  # This job is triggered when forms are completed, responses are submitted, or other integration events occur
  class IntegrationTriggerJob < ApplicationJob
    queue_as :integrations
    
    # Retry on specific errors that might be temporary (network issues, API rate limits)
    retry_on StandardError, wait: :polynomially_longer, attempts: 3
    retry_on Timeout::Error, wait: 5.seconds, attempts: 5
    retry_on Net::HTTPError, wait: 10.seconds, attempts: 3

        
    # Discard if records are not found or configuration is invalid
    discard_on ActiveRecord::RecordNotFound, ArgumentError
    
    def perform(form_response_id, trigger_event = 'form_completed', options = {})
      log_progress("Starting integration triggers for form_response #{form_response_id}, event: #{trigger_event}")
      
      # Find the form response and related records
      form_response = find_record(FormResponse, form_response_id)
      form = form_response.form
      
      # Validate prerequisites for integration processing
      validate_integration_prerequisites!(form_response, form, trigger_event)
      
      # Get enabled integrations for this form and trigger event
      enabled_integrations = get_enabled_integrations(form, trigger_event)
      
      if enabled_integrations.empty?
        log_progress("No integrations enabled for trigger event: #{trigger_event}")
        return { success: true, processed_count: 0, skipped: true }
      end
      
      # Process each enabled integration
      results = process_integrations(enabled_integrations, form_response, trigger_event, options)
      
      # Update integration tracking
      update_integration_tracking(form_response, results)
      
      # Log completion
      log_progress("Integration processing completed", {
        form_response_id: form_response.id,
        trigger_event: trigger_event,
        processed_count: results[:processed_count],
        success_count: results[:success_count],
        error_count: results[:error_count]
      })
      
      results
    rescue StandardError => e
      handle_integration_error(form_response_id, trigger_event, e)
    end
    
    private
    
    # Validate that integration processing is appropriate and allowed
    def validate_integration_prerequisites!(form_response, form, trigger_event)
      # Check if form has integrations enabled
      unless form.integrations_enabled?
        raise ArgumentError, "Form #{form.id} does not have integrations enabled"
      end
      
      # Check if user has integration capabilities
      user = form.user
      unless user.can_use_integrations?
        raise ArgumentError, "User #{user.id} does not have integration capabilities"
      end
      
      # Validate trigger event
      valid_events = %w[form_completed response_updated question_answered form_abandoned]
      unless valid_events.include?(trigger_event)
        raise ArgumentError, "Invalid trigger event: #{trigger_event}"
      end
      
      # Check if form response is in appropriate state for the trigger
      case trigger_event
      when 'form_completed'
        unless form_response.completed?
          raise ArgumentError, "Form response #{form_response.id} is not completed"
        end
      when 'form_abandoned'
        unless form_response.abandoned?
          raise ArgumentError, "Form response #{form_response.id} is not abandoned"
        end
      end
      
      log_progress("Integration prerequisites validated", {
        form_response_id: form_response.id,
        form_id: form.id,
        trigger_event: trigger_event,
        integrations_enabled: form.integrations_enabled?,
        user_can_integrate: user.can_use_integrations?
      })
    end
    
    # Get enabled integrations for the form and trigger event
    def get_enabled_integrations(form, trigger_event)
      integration_settings = form.integration_settings || {}
      enabled_integrations = {}
      
      integration_settings.each do |integration_name, config|
        next unless config.is_a?(Hash) && config['enabled']
        
        # Check if this integration should trigger for this event
        trigger_events = config['trigger_events'] || ['form_completed']
        next unless trigger_events.include?(trigger_event)
        
        enabled_integrations[integration_name] = config
      end
      
      log_progress("Found enabled integrations", {
        trigger_event: trigger_event,
        enabled_count: enabled_integrations.size,
        integration_names: enabled_integrations.keys
      })
      
      enabled_integrations
    end
    
    # Process all enabled integrations
    def process_integrations(enabled_integrations, form_response, trigger_event, options)
      results = {
        processed_count: 0,
        success_count: 0,
        error_count: 0,
        integration_results: {},
        errors: []
      }
      
      enabled_integrations.each do |integration_name, config|
        begin
          log_progress("Processing integration: #{integration_name}")
          
          integration_result = process_integration(integration_name, config, form_response, trigger_event, options)
          
          results[:processed_count] += 1
          results[:integration_results][integration_name] = integration_result
          
          if integration_result[:success]
            results[:success_count] += 1
            log_progress("Integration #{integration_name} completed successfully")
          else
            results[:error_count] += 1
            results[:errors] << {
              integration: integration_name,
              error: integration_result[:error],
              error_type: integration_result[:error_type]
            }
            log_progress("Integration #{integration_name} failed", {
              error: integration_result[:error]
            })
          end
          
        rescue StandardError => e
          results[:processed_count] += 1
          results[:error_count] += 1
          results[:errors] << {
            integration: integration_name,
            error: e.message,
            error_type: e.class.name
          }
          
          Rails.logger.error "Integration #{integration_name} processing failed: #{e.message}"
          
          # Continue processing other integrations even if one fails
          next
        end
      end
      
      results
    end
    
    # Process a single integration
    def process_integration(integration_name, config, form_response, trigger_event, options = {})
      log_progress("Processing #{integration_name} integration")
      
      case integration_name.to_s
      when 'webhook'
        process_webhook_integration(config, form_response, trigger_event, options)
      when 'slack'
        process_slack_integration(config, form_response, trigger_event, options)
      when 'email'
        process_email_integration(config, form_response, trigger_event, options)
      when 'salesforce', 'crm'
        process_crm_integration(config, form_response, trigger_event, options)
      when 'mailchimp'
        process_mailchimp_integration(config, form_response, trigger_event, options)
      when 'hubspot'
        process_hubspot_integration(config, form_response, trigger_event, options)
      when 'zapier'
        process_zapier_integration(config, form_response, trigger_event, options)
      else
        {
          success: false,
          error: "Unknown integration type: #{integration_name}",
          error_type: 'unknown_integration'
        }
      end
    end
    
    # Process webhook integration
    def process_webhook_integration(config, form_response, trigger_event, options = {})
      webhook_url = config['webhook_url'] || config['url']
      
      unless webhook_url.present?
        return {
          success: false,
          error: 'Webhook URL not configured',
          error_type: 'configuration_error'
        }
      end
      
      # Prepare webhook payload
      payload = build_webhook_payload(form_response, trigger_event, config)
      
      # Prepare headers
      headers = {
        'Content-Type' => 'application/json',
        'User-Agent' => 'AgentForm/1.0',
        'X-AgentForm-Event' => trigger_event,
        'X-AgentForm-Form-Id' => form_response.form.id,
        'X-AgentForm-Response-Id' => form_response.id
      }
      
      # Add custom headers if configured
      if config['headers'].is_a?(Hash)
        headers.merge!(config['headers'])
      end
      
      # Add webhook secret for verification
      if config['secret'].present?
        signature = generate_webhook_signature(payload.to_json, config['secret'])
        headers['X-AgentForm-Signature'] = signature
      end
      
      begin
        # Make HTTP request
        uri = URI(webhook_url)
        http = Net::HTTP.new(uri.host, uri.port)
        http.use_ssl = uri.scheme == 'https'
        http.read_timeout = config['timeout'] || 30
        
        request = Net::HTTP::Post.new(uri.path, headers)
        request.body = payload.to_json
        
        response = http.request(request)
        
        if response.code.to_i.between?(200, 299)
          log_progress("Webhook delivered successfully", {
            url: webhook_url,
            status_code: response.code,
            response_body: response.body&.truncate(200)
          })
          
          {
            success: true,
            status_code: response.code.to_i,
            response_body: response.body,
            delivered_at: Time.current.iso8601
          }
        else
          {
            success: false,
            error: "HTTP #{response.code}: #{response.message}",
            error_type: 'http_error',
            status_code: response.code.to_i,
            response_body: response.body
          }
        end
        
      rescue Net::TimeoutError => e
        {
          success: false,
          error: "Webhook timeout: #{e.message}",
          error_type: 'timeout_error'
        }
      rescue StandardError => e
        {
          success: false,
          error: "Webhook delivery failed: #{e.message}",
          error_type: e.class.name
        }
      end
    end
    
    # Process Slack integration
    def process_slack_integration(config, form_response, trigger_event, options = {})
      webhook_url = config['webhook_url']
      
      unless webhook_url.present?
        return {
          success: false,
          error: 'Slack webhook URL not configured',
          error_type: 'configuration_error'
        }
      end
      
      # Build Slack message payload
      slack_payload = build_slack_payload(form_response, trigger_event, config)
      
      begin
        uri = URI(webhook_url)
        http = Net::HTTP.new(uri.host, uri.port)
        http.use_ssl = true
        http.read_timeout = 30
        
        request = Net::HTTP::Post.new(uri.path, {
          'Content-Type' => 'application/json'
        })
        request.body = slack_payload.to_json
        
        response = http.request(request)
        
        if response.code == '200'
          log_progress("Slack notification sent successfully")
          
          {
            success: true,
            status_code: 200,
            delivered_at: Time.current.iso8601
          }
        else
          {
            success: false,
            error: "Slack API error: #{response.code} #{response.message}",
            error_type: 'slack_api_error',
            status_code: response.code.to_i
          }
        end
        
      rescue StandardError => e
        {
          success: false,
          error: "Slack notification failed: #{e.message}",
          error_type: e.class.name
        }
      end
    end
    
    # Process email integration
    def process_email_integration(config, form_response, trigger_event, options = {})
      email_type = config['type'] || 'notification'
      
      case email_type
      when 'notification'
        send_notification_email(config, form_response, trigger_event)
      when 'autoresponder'
        send_autoresponder_email(config, form_response, trigger_event)
      when 'admin_alert'
        send_admin_alert_email(config, form_response, trigger_event)
      else
        {
          success: false,
          error: "Unknown email type: #{email_type}",
          error_type: 'configuration_error'
        }
      end
    end
    
    # Process CRM integration (Salesforce, etc.)
    def process_crm_integration(config, form_response, trigger_event, options = {})
      crm_type = config['type'] || config['provider'] || 'salesforce'
      
      begin
        case crm_type.downcase
        when 'salesforce'
          service = Forms::Integrations::SalesforceService.new(config)
          result = service.sync_response(form_response)
        when 'hubspot'
          service = Forms::Integrations::HubspotService.new(config)
          result = service.sync_response(form_response)
        else
          return {
            success: false,
            error: "Unsupported CRM type: #{crm_type}",
            error_type: 'configuration_error'
          }
        end
        
        if result[:success]
          log_progress("CRM sync completed successfully", {
            crm_type: crm_type,
            record_id: result[:record_id]
          })
          
          {
            success: true,
            crm_type: crm_type,
            record_id: result[:record_id],
            synced_at: Time.current.iso8601
          }
        else
          {
            success: false,
            error: result[:error] || 'CRM sync failed',
            error_type: result[:error_type] || 'crm_error'
          }
        end
        
      rescue StandardError => e
        {
          success: false,
          error: "CRM integration failed: #{e.message}",
          error_type: e.class.name
        }
      end
    end
    
    # Process Mailchimp integration
    def process_mailchimp_integration(config, form_response, trigger_event, options = {})
      begin
        service = Forms::Integrations::MailchimpService.new(config)
        result = service.sync_response(form_response)
        
        if result[:success]
          log_progress("Mailchimp sync completed successfully", {
            list_id: result[:list_id],
            subscriber_id: result[:subscriber_id]
          })
          
          {
            success: true,
            list_id: result[:list_id],
            subscriber_id: result[:subscriber_id],
            synced_at: Time.current.iso8601
          }
        else
          {
            success: false,
            error: result[:error] || 'Mailchimp sync failed',
            error_type: result[:error_type] || 'mailchimp_error'
          }
        end
        
      rescue StandardError => e
        {
          success: false,
          error: "Mailchimp integration failed: #{e.message}",
          error_type: e.class.name
        }
      end
    end
    
    # Process HubSpot integration
    def process_hubspot_integration(config, form_response, trigger_event, options = {})
      begin
        service = Forms::Integrations::HubspotService.new(config)
        result = service.sync_response(form_response)
        
        if result[:success]
          log_progress("HubSpot sync completed successfully", {
            contact_id: result[:contact_id],
            deal_id: result[:deal_id]
          })
          
          {
            success: true,
            contact_id: result[:contact_id],
            deal_id: result[:deal_id],
            synced_at: Time.current.iso8601
          }
        else
          {
            success: false,
            error: result[:error] || 'HubSpot sync failed',
            error_type: result[:error_type] || 'hubspot_error'
          }
        end
        
      rescue StandardError => e
        {
          success: false,
          error: "HubSpot integration failed: #{e.message}",
          error_type: e.class.name
        }
      end
    end
    
    # Process Zapier integration
    def process_zapier_integration(config, form_response, trigger_event, options = {})
      # Zapier integration is essentially a webhook with specific formatting
      zapier_config = config.merge({
        'webhook_url' => config['webhook_url'] || config['zapier_webhook_url']
      })
      
      process_webhook_integration(zapier_config, form_response, trigger_event, options)
    end
    
    # Build webhook payload
    def build_webhook_payload(form_response, trigger_event, config)
      form = form_response.form
      
      # Base payload structure
      payload = {
        event: trigger_event,
        timestamp: Time.current.iso8601,
        form: {
          id: form.id,
          name: form.name,
          description: form.description
        },
        response: {
          id: form_response.id,
          submitted_at: form_response.created_at.iso8601,
          completed_at: form_response.completed_at&.iso8601,
          status: form_response.status,
          progress_percentage: form_response.progress_percentage
        },
        answers: build_answers_payload(form_response),
        metadata: {
          user_agent: form_response.user_agent,
          ip_address: form_response.ip_address,
          referrer: form_response.referrer_url
        }
      }
      
      # Add AI analysis if available
      if form_response.ai_analysis_results.present?
        payload[:ai_analysis] = {
          overall_sentiment: form_response.ai_analysis_results['overall_sentiment'],
          overall_quality: form_response.ai_analysis_results['overall_quality'],
          key_insights: form_response.ai_analysis_results['key_insights']
        }
      end
      
      # Add custom fields if configured
      if config['include_custom_fields']
        payload[:custom_fields] = extract_custom_fields(form_response)
      end
      
      payload
    end
    
    # Build Slack message payload
    def build_slack_payload(form_response, trigger_event, config)
      form = form_response.form
      
      # Determine message color based on form response
      color = determine_slack_color(form_response)
      
      # Build main message
      text = case trigger_event
             when 'form_completed'
               "New form submission received for '#{form.name}'"
             when 'form_abandoned'
               "Form '#{form.name}' was abandoned"
             when 'response_updated'
               "Form response updated for '#{form.name}'"
             else
               "Form event '#{trigger_event}' for '#{form.name}'"
             end
      
      # Build fields for Slack attachment
      fields = build_slack_fields(form_response)
      
      payload = {
        text: text,
        attachments: [
          {
            color: color,
            fields: fields,
            footer: "AgentForm",
            ts: Time.current.to_i
          }
        ]
      }
      
      # Add channel if specified
      if config['channel'].present?
        payload[:channel] = config['channel']
      end
      
      # Add username if specified
      if config['username'].present?
        payload[:username] = config['username']
      end
      
      payload
    end
    
    # Determine Slack message color based on form response
    def determine_slack_color(form_response)
      return '#36a64f' if form_response.completed? # Green for completed
      return '#ff9900' if form_response.in_progress? # Orange for in progress
      return '#ff0000' if form_response.abandoned? # Red for abandoned
      
      '#439fe0' # Default blue
    end
    
    # Build Slack fields from form response
    def build_slack_fields(form_response)
      fields = []
      
      # Add basic info
      fields << {
        title: "Response ID",
        value: form_response.id,
        short: true
      }
      
      fields << {
        title: "Status",
        value: form_response.status.humanize,
        short: true
      }
      
      if form_response.completed_at
        fields << {
          title: "Completed At",
          value: form_response.completed_at.strftime("%Y-%m-%d %H:%M:%S"),
          short: true
        }
      end
      
      # Add key answers (limit to avoid message being too long)
      form_response.question_responses.includes(:form_question).limit(5).each do |qr|
        next unless qr.answer_data.present?
        
        fields << {
          title: qr.form_question.title,
          value: truncate_answer(qr.answer_data.to_s),
          short: false
        }
      end
      
      # Add AI insights if available
      if form_response.ai_analysis_results.present?
        sentiment = form_response.ai_analysis_results['overall_sentiment']
        if sentiment
          sentiment_label = case sentiment
                           when 0.0..0.3 then "Negative"
                           when 0.3..0.7 then "Neutral"
                           else "Positive"
                           end
          
          fields << {
            title: "AI Sentiment",
            value: sentiment_label,
            short: true
          }
        end
      end
      
      fields
    end
    
    # Truncate answer for display
    def truncate_answer(answer)
      return answer if answer.length <= 100
      
      "#{answer[0..97]}..."
    end
    
    # Build answers payload for webhooks
    def build_answers_payload(form_response)
      answers = {}
      
      form_response.question_responses.includes(:form_question).each do |qr|
        question = qr.form_question
        
        answers[question.id] = {
          question_id: question.id,
          question_title: question.title,
          question_type: question.question_type,
          answer: qr.answer_data,
          answered_at: qr.created_at.iso8601
        }
        
        # Add AI analysis for this specific answer if available
        if qr.ai_analysis_results.present?
          answers[question.id][:ai_analysis] = {
            sentiment: qr.ai_analysis_results['sentiment'],
            quality: qr.ai_analysis_results['quality'],
            confidence_score: qr.ai_confidence_score
          }
        end
      end
      
      answers
    end
    
    # Extract custom fields from form response
    def extract_custom_fields(form_response)
      custom_fields = {}
      
      # Add any custom metadata
      if form_response.metadata.present?
        custom_fields.merge!(form_response.metadata)
      end
      
      # Add form-specific custom fields
      form = form_response.form
      if form.form_settings.present? && form.form_settings['custom_fields']
        form.form_settings['custom_fields'].each do |field_name, field_config|
          # Extract custom field value based on configuration
          custom_fields[field_name] = extract_custom_field_value(form_response, field_config)
        end
      end
      
      custom_fields
    end
    
    # Extract custom field value
    def extract_custom_field_value(form_response, field_config)
      case field_config['type']
      when 'calculated'
        # Perform calculation based on answers
        calculate_field_value(form_response, field_config['formula'])
      when 'lookup'
        # Look up value from another source
        lookup_field_value(form_response, field_config['source'])
      else
        field_config['default_value']
      end
    end
    
    # Calculate field value based on formula
    def calculate_field_value(form_response, formula)
      # Simple calculation implementation
      # This could be expanded to support more complex formulas
      return 0 unless formula.present?
      
      # For now, just return a placeholder
      "calculated_value"
    end
    
    # Look up field value from external source
    def lookup_field_value(form_response, source_config)
      # Placeholder for lookup functionality
      "lookup_value"
    end
    
    # Send notification email
    def send_notification_email(config, form_response, trigger_event)
      begin
        # This would integrate with ActionMailer
        # For now, return success placeholder
        {
          success: true,
          email_type: 'notification',
          sent_at: Time.current.iso8601
        }
      rescue StandardError => e
        {
          success: false,
          error: "Email notification failed: #{e.message}",
          error_type: e.class.name
        }
      end
    end
    
    # Send autoresponder email
    def send_autoresponder_email(config, form_response, trigger_event)
      begin
        # This would integrate with ActionMailer
        # For now, return success placeholder
        {
          success: true,
          email_type: 'autoresponder',
          sent_at: Time.current.iso8601
        }
      rescue StandardError => e
        {
          success: false,
          error: "Autoresponder email failed: #{e.message}",
          error_type: e.class.name
        }
      end
    end
    
    # Send admin alert email
    def send_admin_alert_email(config, form_response, trigger_event)
      begin
        # This would integrate with ActionMailer
        # For now, return success placeholder
        {
          success: true,
          email_type: 'admin_alert',
          sent_at: Time.current.iso8601
        }
      rescue StandardError => e
        {
          success: false,
          error: "Admin alert email failed: #{e.message}",
          error_type: e.class.name
        }
      end
    end
    
    # Generate webhook signature for verification
    def generate_webhook_signature(payload, secret)
      OpenSSL::HMAC.hexdigest('SHA256', secret, payload)
    end
    
    # Update integration tracking on the form response
    def update_integration_tracking(form_response, results)
      safe_db_operation do
        # Update integration metadata
        integration_metadata = form_response.integration_metadata || {}
        integration_metadata[:last_triggered_at] = Time.current.iso8601
        integration_metadata[:trigger_count] = (integration_metadata[:trigger_count] || 0) + 1
        integration_metadata[:last_results] = {
          processed_count: results[:processed_count],
          success_count: results[:success_count],
          error_count: results[:error_count],
          job_id: job_id
        }
        
        # Store individual integration results
        integration_metadata[:integration_history] ||= []
        integration_metadata[:integration_history] << {
          timestamp: Time.current.iso8601,
          results: results[:integration_results],
          job_id: job_id
        }
        
        # Keep only last 10 history entries
        integration_metadata[:integration_history] = integration_metadata[:integration_history].last(10)
        
        form_response.update!(integration_metadata: integration_metadata)
        
        log_progress("Integration tracking updated", {
          form_response_id: form_response.id,
          trigger_count: integration_metadata[:trigger_count]
        })
      end
    rescue StandardError => e
      Rails.logger.error "Failed to update integration tracking: #{e.message}"
      # Don't re-raise as this is not critical
    end
    
    # Handle integration processing errors
    def handle_integration_error(form_response_id, trigger_event, error)
      error_context = {
        form_response_id: form_response_id,
        trigger_event: trigger_event,
        job_id: job_id,
        error_message: error.message,
        error_type: error.class.name
      }
      
      Rails.logger.error "Integration processing failed for form_response #{form_response_id}, event #{trigger_event}: #{error.message}"
      Rails.logger.error error.backtrace.join("\n") if Rails.env.development?
      
      # Try to update form response with error information if possible
      begin
        form_response = FormResponse.find_by(id: form_response_id)
        if form_response
          integration_metadata = form_response.integration_metadata || {}
          integration_metadata[:errors] ||= []
          integration_metadata[:errors] << {
            error: error.message,
            error_type: error.class.name,
            trigger_event: trigger_event,
            failed_at: Time.current.iso8601,
            job_id: job_id
          }
          
          # Keep only last 5 errors
          integration_metadata[:errors] = integration_metadata[:errors].last(5)
          
          form_response.update!(integration_metadata: integration_metadata)
        end
      rescue StandardError => update_error
        Rails.logger.error "Failed to update form response with error information: #{update_error.message}"
      end
      
      # Track error in monitoring system
      if defined?(Sentry)
        Sentry.capture_exception(error, extra: error_context)
      end
      
      # Re-raise to trigger retry logic
      raise error
    end
  end
end
</file>

<file path="jobs/forms/lead_scoring_job.rb">
# frozen_string_literal: true

module Forms
  # Background job responsible for scoring leads and routing them to appropriate teams
  class LeadScoringJob < ApplicationJob
    queue_as :ai_processing
    
    # Retry on specific errors that might be temporary
    retry_on StandardError, wait: :polynomially_longer, attempts: 2
    retry_on ActiveRecord::RecordNotFound, wait: 5.seconds, attempts: 3
    
    # Discard if records are not found or configuration is invalid
    discard_on ArgumentError
    
    def perform(form_response_id, options = {})
      log_progress("Starting lead scoring for form_response #{form_response_id}")
      
      # Find the form response and related records
      form_response = find_record(FormResponse, form_response_id)
      form = form_response.form
      
      # Validate prerequisites for lead scoring
      validate_scoring_prerequisites!(form_response, form)
      
      # Execute lead scoring workflow
      scoring_result = execute_scoring_workflow(form_response, form, options)
      
      # Log completion
      log_progress("Lead scoring completed", {
        form_response_id: form_response.id,
        form_id: form.id,
        score: scoring_result[:score],
        tier: scoring_result[:tier],
        routing_actions: scoring_result[:routing_actions]&.length || 0
      })
      
      scoring_result
    rescue StandardError => e
      handle_scoring_error(form_response_id, e)
    end
    
    private
    
    # Validate that lead scoring is appropriate and allowed
    def validate_scoring_prerequisites!(form_response, form)
      unless form_response.completed?
        raise ArgumentError, "Form response #{form_response.id} must be completed for lead scoring"
      end
      
      unless form.ai_enhanced?
        raise ArgumentError, "Form #{form.id} does not have AI features enabled"
      end
      
      # Check user's AI capabilities
      user = form.user
      unless user.can_use_ai_features?
        raise ArgumentError, "User #{user.id} does not have AI features available"
      end
      
      # Check if we've already scored this response
      if LeadScoring.exists?(form_response_id: form_response.id)
        raise ArgumentError, "Lead already scored for response #{form_response.id}"
      end
      
      log_progress("Lead scoring prerequisites validated", {
        form_response_id: form_response.id,
        form_id: form.id,
        ai_enabled: form.ai_enhanced?,
        user_can_use_ai: user.can_use_ai_features?
      })
    end
    
    # Execute the lead scoring workflow
    def execute_scoring_workflow(form_response, form, options)
      log_progress("Executing lead scoring workflow")
      
      begin
        # Prepare workflow inputs
        workflow_inputs = {
          form_response_id: form_response.id
        }
        
        # Execute the workflow
        workflow = Forms::LeadScoringWorkflow.new
        result = workflow.execute(workflow_inputs)
        
        # Check if workflow execution was successful
        if result.success?
          final_output = result.final_output
          
          if final_output.is_a?(Hash) && final_output[:lead_scoring_id]
            log_progress("Workflow executed successfully", {
              lead_scoring_id: final_output[:lead_scoring_id],
              score: final_output[:score],
              tier: final_output[:tier],
              ai_cost: final_output[:ai_cost]
            })
            
            # Trigger routing integrations based on scoring
            trigger_routing_integrations(form_response, final_output)
            
            {
              success: true,
              lead_scoring_id: final_output[:lead_scoring_id],
              score: final_output[:score],
              tier: final_output[:tier],
              routing_actions: final_output[:routing_actions],
              workflow_result: result
            }
          else
            log_progress("Workflow completed but generated skipped result", {
              final_output: final_output,
              reason: final_output[:reason] || 'Unknown'
            })
            
            {
              success: false,
              skipped: true,
              reason: final_output[:reason] || 'Lead scoring was skipped',
              workflow_result: result
            }
          end
        else
          error_message = result.error_message || 'Workflow execution failed'
          
          log_progress("Workflow execution failed", {
            error: error_message,
            error_type: result.error_type
          })
          
          {
            success: false,
            error: error_message,
            error_type: result.error_type || 'workflow_error',
            workflow_result: result
          }
        end
      rescue StandardError => e
        Rails.logger.error "Lead scoring workflow failed: #{e.message}"
        
        {
          success: false,
          error: e.message,
          error_type: e.class.name
        }
      end
    end
    
    # Trigger routing integrations based on lead score
    def trigger_routing_integrations(form_response, scoring_result)
      log_progress("Triggering routing integrations based on lead score")
      
      tier = scoring_result[:tier]
      score = scoring_result[:score]
      
      # Determine integration triggers based on tier
      case tier
      when 'hot'
        # Immediate follow-up for hot leads
        trigger_immediate_followup(form_response, score, tier)
      when 'warm'
        # Scheduled follow-up for warm leads
        trigger_warm_followup(form_response, score, tier)
      when 'cold'
        # Nurture campaign for cold leads
        trigger_nurture_campaign(form_response, score, tier)
      end
    end
    
    # Trigger immediate follow-up for hot leads
    def trigger_immediate_followup(form_response, score, tier)
      log_progress("Triggering immediate follow-up for hot lead", {
        form_response_id: form_response.id,
        score: score
      })
      
      # Queue integration job with high priority
      Forms::IntegrationTriggerJob.perform_later(
        form_response.id,
        'hot_lead_qualified',
        {
          score: score,
          tier: tier,
          priority: 'critical',
          sla_hours: 1,
          channels: ['email', 'phone', 'slack'],
          assign_to: 'sales_team'
        }
      )
    end
    
    # Trigger scheduled follow-up for warm leads
    def trigger_warm_followup(form_response, score, tier)
      log_progress("Triggering scheduled follow-up for warm lead", {
        form_response_id: form_response.id,
        score: score
      })
      
      # Queue integration job with medium priority
      Forms::IntegrationTriggerJob.perform_later(
        form_response.id,
        'warm_lead_qualified',
        {
          score: score,
          tier: tier,
          priority: 'high',
          sla_hours: 24,
          channels: ['email', 'slack'],
          assign_to: 'marketing_team'
        }
      )
    end
    
    # Trigger nurture campaign for cold leads
    def trigger_nurture_campaign(form_response, score, tier)
      log_progress("Triggering nurture campaign for cold lead", {
        form_response_id: form_response.id,
        score: score
      })
      
      # Queue integration job with low priority
      Forms::IntegrationTriggerJob.perform_later(
        form_response.id,
        'cold_lead_nurture',
        {
          score: score,
          tier: tier,
          priority: 'medium',
          sla_hours: 72,
          channels: ['email'],
          campaign_type: 'nurture'
        }
      )
    end
    
    # Handle lead scoring errors
    def handle_scoring_error(form_response_id, error)
      error_context = {
        form_response_id: form_response_id,
        job_id: job_id,
        error_message: error.message,
        error_type: error.class.name
      }
      
      Rails.logger.error "Lead scoring failed for form_response #{form_response_id}: #{error.message}"
      Rails.logger.error error.backtrace.join("\n") if Rails.env.development?
      
      # Try to update form response with error information if possible
      begin
        form_response = FormResponse.find_by(id: form_response_id)
        if form_response
          # Add error information to the form response's AI analysis results
          current_analysis = form_response.ai_analysis_results || {}
          current_analysis[:lead_scoring_errors] ||= []
          current_analysis[:lead_scoring_errors] << {
            error: error.message,
            error_type: error.class.name,
            failed_at: Time.current.iso8601,
            job_id: job_id
          }
          
          form_response.update!(ai_analysis_results: current_analysis)
        end
      rescue StandardError => update_error
        Rails.logger.error "Failed to update form response with error information: #{update_error.message}"
      end
      
      # Track error in monitoring system
      if defined?(Sentry)
        Sentry.capture_exception(error, extra: error_context)
      end
      
      # Re-raise to trigger retry logic
      raise error
    end
  end
end
</file>

<file path="jobs/forms/process_a_i_workflow_job.rb">
# frozen_string_literal: true

class Forms::ProcessAIWorkflowJob < ApplicationJob
  include CircuitBreaker::JobIntegration
  
  queue_as :ai_processing
  
  # Circuit breaker configuration
  circuit_breaker_options(
    failure_threshold: 5,    # Open after 5 failures
    recovery_timeout: 60,    # Try to close after 60 seconds
    expected_errors: [OpenAI::Error, Timeout::Error, Net::OpenTimeout, Net::ReadTimeout]
  )
  
  retry_on OpenAI::Error, wait: :exponentially_longer, attempts: 5
  retry_on Net::OpenTimeout, wait: 10.seconds, attempts: 3
  retry_on Net::ReadTimeout, wait: 10.seconds, attempts: 3
  retry_on StandardError, wait: 5.seconds, attempts: 3
  
  def perform(form_response_id, question_id, answer_data)
    # Pre-execution validations
    form_response = FormResponse.find(form_response_id)
    return unless should_process_ai?(form_response)
    
    # Apply intelligent rate limiting
    if rate_limited?(form_response.form)
      reschedule_job(5.minutes.from_now, form_response_id, question_id, answer_data)
      return
    end
    
    # Check user credits
    unless has_sufficient_credits?(form_response.form.user)
      Rails.logger.warn "Insufficient AI credits for user #{form_response.form.user_id}"
      return
    end
    
    # Execute with monitoring
    start_time = Time.current
    
    begin
      with_circuit_breaker do
        workflow = Forms::UniversalAIWorkflow.new
        result = workflow.run(
          form_response_id: form_response_id,
          question_id: question_id,
          answer_data: answer_data
        )
        
        # Log success
        log_execution_success(form_response_id, Time.current - start_time, result)
        
        # Update success metrics
        update_success_metrics(form_response.form)
        
        # Consume credits
        consume_ai_credits(form_response.form.user, calculate_execution_cost(result))
        
        result
      end
      
    rescue CircuitBreaker::OpenError => e
      Rails.logger.error "AI Circuit breaker open for form #{form_response.form_id}: #{e.message}"
      handle_circuit_breaker_open(form_response)
      
    rescue OpenAI::Error => e
      if e.message.include?("rate limit")
        Rails.logger.warn "OpenAI rate limit hit: #{e.message}"
        reschedule_job(30.seconds.from_now, form_response_id, question_id, answer_data)
      else
        Rails.logger.error "OpenAI API error: #{e.message}"
        raise e
      end
      
    rescue StandardError => e
      Rails.logger.error "AI Workflow failed for form #{form_response.form_id}: #{e.message}"
      Rails.logger.error e.backtrace.join("\n")
      
      handle_workflow_error(form_response, e)
      update_failure_metrics(form_response.form)
      
      # Re-raise for retry
      raise e
    end
  end
  
  private
  
  def should_process_ai?(form_response)
    form = form_response.form
    
    # Check if AI is enabled
    return false unless form.ai_enhanced?
    
    # Check if this response has already been processed
    key = "ai_processed:#{form_response.id}"
    return false if Rails.cache.read(key)
    
    # Check if form is still active
    return false if form.status == 'archived'
    
    true
  end
  
  def rate_limited?(form)
    rate_limit_key = "ai_rate_limit:#{form.id}"
    current_count = Rails.cache.read(rate_limit_key) || 0
    
    # Get configurable limits from form AI config
    ai_config = form.ai_configuration
    max_requests = ai_config.dig('ai_engine', 'rate_limiting', 'max_requests_per_minute') || 10
    
    if current_count >= max_requests
      true
    else
      Rails.cache.write(rate_limit_key, current_count + 1, expires_in: 1.minute)
      false
    end
  end
  
  def has_sufficient_credits?(user)
    credits = user.ai_credits_remaining || 0
    credits >= 1 # Minimum 1 credit required
  end
  
  def consume_ai_credits(user, cost)
    current_credits = user.ai_credits_remaining || 0
    user.update!(ai_credits_remaining: [current_credits - cost, 0].max)
  end
  
  def calculate_execution_cost(result)
    # Placeholder - implement actual cost calculation based on tokens, model, etc.
    # For now, use fixed cost per execution
    1
  end
  
  def reschedule_job(delay, *args)
    self.class.set(wait: delay).perform_later(*args)
    Rails.logger.info "AI job rescheduled due to rate limiting: #{delay} delay"
  end
  
  def handle_circuit_breaker_open(form_response)
    # Notify administrators
    AdminNotificationMailer.ai_circuit_breaker_open(form_response.form).deliver_later
    
    # Mark system as degraded
    Rails.cache.write("ai_system_degraded:#{form_response.form_id}", true, expires_in: 10.minutes)
    
    # Log to monitoring system
    Rails.logger.error "AI Circuit breaker opened for form #{form_response.form_id}"
  end
  
  def handle_workflow_error(form_response, error)
    # Log detailed error
    error_details = {
      form_id: form_response.form_id,
      response_id: form_response.id,
      error_class: error.class.name,
      error_message: error.message,
      backtrace: error.backtrace.first(10),
      timestamp: Time.current.iso8601
    }
    
    Rails.logger.error("AI Workflow Error: #{error_details.to_json}")
    
    # Send error notification
    AdminNotificationMailer.ai_workflow_error(form_response.form, error).deliver_later
    
    # Mark response as having AI processing issues
    form_response.update!(ai_processing_error: error.message)
  end
  
  def log_execution_success(response_id, duration, result)
    Rails.logger.info({
      event: 'ai_workflow_success',
      response_id: response_id,
      duration_seconds: duration,
      questions_generated: result&.dig(:questions_generated) || 0,
      actions_executed: result&.dig(:additional_actions_executed) || 0,
      timestamp: Time.current.iso8601
    }.to_json)
  end
  
  def update_success_metrics(form)
    key = "ai_success_count:#{form.id}:#{Date.current}"
    Rails.cache.increment(key, 1)
    
    # Update form analytics
    Forms::AnalysisWorkflow.perform_async(form.id)
  end
  
  def update_failure_metrics(form)
    key = "ai_failure_count:#{form.id}:#{Date.current}"
    Rails.cache.increment(key, 1)
  end
end
</file>

<file path="jobs/forms/report_generation_job.rb">
class Forms::ReportGenerationJob < ApplicationJob
  queue_as :ai_processing

  def perform(form_response_id, analysis_report_id)
    form_response = FormResponse.find(form_response_id)
    analysis_report = AnalysisReport.find(analysis_report_id)

    Rails.logger.info "Starting report generation for FormResponse: #{form_response_id}"

    begin
      # Execute the ReportGenerationWorkflow
      workflow_result = Forms::ReportGenerationWorkflow.new.run({
        form_response_id: form_response_id
      })

      if workflow_result[:success]
        # Update the analysis report with results
        analysis_report.update!(
          status: 'completed',
          markdown_content: workflow_result[:markdown_content] || '',
          file_path: workflow_result[:file_path],
          file_size: workflow_result[:file_size],
          ai_cost: workflow_result[:ai_cost],
          generated_at: Time.current,
          metadata: workflow_result[:metadata] || {}
        )

        # Notify user via ActionCable if connected
        broadcast_completion(form_response, analysis_report)

        Rails.logger.info "Report generation completed successfully for #{form_response_id}"
      else
        handle_workflow_failure(analysis_report, workflow_result[:error])
      end

    rescue StandardError => e
      Rails.logger.error "Report generation failed: #{e.message}"
      Rails.logger.error e.backtrace.join("\n")

      analysis_report.update!(
        status: 'failed',
        metadata: { 
          error: e.message,
          failed_at: Time.current.iso8601
        }
      )

      # Notify user of failure
      broadcast_failure(form_response, analysis_report, e.message)
    end
  end

  private

  def broadcast_completion(form_response, analysis_report)
    ActionCable.server.broadcast(
      "form_response_#{form_response.id}",
      {
        type: 'report_completed',
        report_id: analysis_report.id,
        download_url: analysis_report.download_url,
        file_size: analysis_report.formatted_file_size
      }
    )
  end

  def broadcast_failure(form_response, analysis_report, error_message)
    ActionCable.server.broadcast(
      "form_response_#{form_response.id}",
      {
        type: 'report_failed',
        report_id: analysis_report.id,
        error: error_message
      }
    )
  end

  def handle_workflow_failure(analysis_report, error)
    Rails.logger.error "Workflow failed: #{error}"
    
    analysis_report.update!(
      status: 'failed',
      metadata: {
        workflow_error: error,
        failed_at: Time.current.iso8601
      }
    )
  end
end
</file>

<file path="jobs/forms/response_analysis_job.rb">
# frozen_string_literal: true

module Forms
  # Background job responsible for AI-powered analysis of individual question responses
  # This job is triggered when a question response is created or updated and requires AI analysis
  class ResponseAnalysisJob < ApplicationJob
    queue_as :ai_processing
    
    # Retry on specific errors that might be temporary
    retry_on StandardError, wait: :polynomially_longer, attempts: 2
    
    # Discard if question response is not found or invalid
    discard_on ActiveRecord::RecordNotFound, ArgumentError
    
    def perform(question_response_id)
      log_progress("Starting response analysis for question response #{question_response_id}")
      
      # Find the question response
      question_response = find_record(QuestionResponse, question_response_id)
      form_response = question_response.form_response
      question = question_response.form_question
      
      # Validate prerequisites for AI analysis
      validate_analysis_prerequisites!(question_response, question, form_response)
      
      # Execute AI analysis workflow
      analysis_result = execute_ai_analysis(question_response)
      
      # Update question response with analysis results
      update_question_response_with_analysis(question_response, analysis_result) if analysis_result[:success]
      
      # Generate dynamic follow-up if needed
      schedule_dynamic_question_generation(question_response, analysis_result) if should_generate_followup?(analysis_result)
      
      # Update aggregate form response analysis
      update_aggregate_analysis(form_response)
      
      # Log completion
      log_progress("Response analysis completed", {
        question_response_id: question_response.id,
        success: analysis_result[:success],
        generated_followup: analysis_result[:generate_followup]
      })
      
      analysis_result
    rescue StandardError => e
      handle_analysis_error(question_response_id, e)
    end
    
    private
    
    # Validate that the question response is ready for AI analysis
    def validate_analysis_prerequisites!(question_response, question, form_response)
      unless question.ai_enhanced?
        raise ArgumentError, "Question #{question.id} does not have AI enhancement enabled"
      end
      
      unless form_response.form.user.can_use_ai_features?
        raise ArgumentError, "User #{form_response.form.user.id} cannot use AI features"
      end
      
      unless question_response.answer_data.present?
        raise ArgumentError, "Question response #{question_response.id} has no answer data to analyze"
      end
      
      # Check if already analyzed recently
      if question_response.ai_analysis_results.present? && 
         question_response.updated_at > 5.minutes.ago
        Rails.logger.info "Question response #{question_response.id} was recently analyzed, skipping"
        return false
      end
      
      log_progress("Analysis prerequisites validated", {
        question_response_id: question_response.id,
        question_type: question.question_type,
        ai_enhanced: question.ai_enhanced?
      })
      
      true
    end
    
    # Execute AI analysis using the ResponseAgent
    def execute_ai_analysis(question_response)
      log_progress("Executing AI analysis for question response #{question_response.id}")
      
      begin
        # Use the ResponseAgent to analyze response quality
        agent = Forms::ResponseAgent.new
        result = agent.analyze_response_quality(question_response.form_response)
        
        if result.is_a?(Hash) && result[:error]
          log_progress("AI analysis failed", {
            question_response_id: question_response.id,
            error: result[:error_message]
          })
          
          return {
            success: false,
            error: result[:error_message],
            error_type: result[:error_type] || 'analysis_error'
          }
        end
        
        # Extract analysis data from the result
        analysis_data = extract_analysis_data(result, question_response)
        
        log_progress("AI analysis completed successfully", {
          question_response_id: question_response.id,
          confidence_score: analysis_data[:confidence_score],
          sentiment: analysis_data.dig(:ai_analysis, :sentiment)
        })
        
        {
          success: true,
          analysis_data: analysis_data,
          generate_followup: analysis_data[:generate_followup] || false,
          ai_cost: calculate_analysis_cost(question_response)
        }
      rescue StandardError => e
        Rails.logger.error "AI analysis execution failed: #{e.message}"
        
        {
          success: false,
          error: e.message,
          error_type: e.class.name
        }
      end
    end
    
    # Extract and structure analysis data from the agent result
    def extract_analysis_data(result, question_response)
      # Handle different result formats from the agent
      if result.respond_to?(:final_output)
        analysis_output = result.final_output
      elsif result.is_a?(Hash)
        analysis_output = result
      else
        analysis_output = { raw_result: result }
      end
      
      # Structure the analysis data
      {
        ai_analysis: {
          sentiment: extract_sentiment_data(analysis_output),
          quality: extract_quality_data(analysis_output),
          insights: extract_insights(analysis_output),
          flags: extract_flags(analysis_output),
          completeness: calculate_completeness_score(question_response, analysis_output)
        },
        confidence_score: analysis_output[:confidence_score] || calculate_confidence_score(analysis_output),
        completeness_score: analysis_output[:completeness_score] || calculate_completeness_score(question_response, analysis_output),
        generate_followup: analysis_output[:generate_followup] || should_generate_followup_from_analysis?(analysis_output),
        analyzed_at: Time.current.iso8601,
        analysis_version: 1
      }
    end
    
    # Extract sentiment analysis data
    def extract_sentiment_data(analysis_output)
      sentiment_data = analysis_output.dig(:ai_analysis, :sentiment) || analysis_output[:sentiment] || {}
      
      {
        label: sentiment_data[:label] || 'neutral',
        confidence: sentiment_data[:confidence] || 0.5,
        score: sentiment_data[:score] || 0.0,
        reasoning: sentiment_data[:reasoning] || ''
      }
    end
    
    # Extract quality analysis data
    def extract_quality_data(analysis_output)
      quality_data = analysis_output.dig(:ai_analysis, :quality) || analysis_output[:quality] || {}
      
      {
        completeness: quality_data[:completeness] || 0.5,
        relevance: quality_data[:relevance] || 0.5,
        clarity: quality_data[:clarity] || 0.5,
        overall_score: quality_data[:overall_score] || 0.5,
        issues: quality_data[:issues] || [],
        strengths: quality_data[:strengths] || []
      }
    end
    
    # Extract insights from the analysis
    def extract_insights(analysis_output)
      insights = analysis_output.dig(:ai_analysis, :insights) || analysis_output[:insights] || []
      
      # Ensure insights are properly formatted
      insights.map do |insight|
        if insight.is_a?(String)
          { text: insight, confidence: 0.7, category: 'general' }
        else
          insight
        end
      end
    end
    
    # Extract flags from the analysis
    def extract_flags(analysis_output)
      flags = analysis_output.dig(:ai_analysis, :flags) || analysis_output[:flags] || {}
      
      {
        needs_review: flags[:needs_review] || false,
        potential_spam: flags[:potential_spam] || false,
        incomplete_answer: flags[:incomplete_answer] || false,
        unusual_pattern: flags[:unusual_pattern] || false,
        high_quality: flags[:high_quality] || false
      }
    end
    
    # Calculate completeness score based on the response and analysis
    def calculate_completeness_score(question_response, analysis_output)
      base_score = analysis_output.dig(:completeness_score) || 0.5
      
      # Adjust based on answer length and type
      answer_data = question_response.answer_data
      question_type = question_response.form_question.question_type
      
      case question_type
      when 'text_short', 'text_long'
        text_length = answer_data.to_s.length
        length_score = [text_length / 100.0, 1.0].min
        base_score = (base_score + length_score) / 2.0
      when 'multiple_choice', 'single_choice'
        # Full score if valid choice is selected
        base_score = answer_data.present? ? 1.0 : 0.0
      end
      
      [base_score, 1.0].min.round(3)
    end
    
    # Calculate confidence score from analysis output
    def calculate_confidence_score(analysis_output)
      confidence_indicators = [
        analysis_output.dig(:sentiment, :confidence),
        analysis_output.dig(:quality, :overall_score),
        analysis_output.dig(:completeness_score)
      ].compact
      
      return 0.5 if confidence_indicators.empty?
      
      (confidence_indicators.sum / confidence_indicators.length).round(3)
    end
    
    # Determine if a follow-up question should be generated
    def should_generate_followup_from_analysis?(analysis_output)
      # Generate follow-up if:
      # 1. Analysis suggests it would be valuable
      # 2. Response shows engagement but needs clarification
      # 3. Quality score is moderate (not too low, not perfect)
      
      quality_score = analysis_output.dig(:quality, :overall_score) || 0.5
      sentiment_confidence = analysis_output.dig(:sentiment, :confidence) || 0.5
      
      # Sweet spot for follow-ups: engaged but could be more detailed
      quality_score.between?(0.4, 0.8) && sentiment_confidence > 0.6
    end
    
    # Calculate the AI cost for this analysis
    def calculate_analysis_cost(question_response)
      # Base cost for response analysis
      base_cost = 0.02
      
      # Additional cost based on answer complexity
      answer_length = question_response.answer_data.to_s.length
      complexity_multiplier = [1.0 + (answer_length / 1000.0), 3.0].min
      
      (base_cost * complexity_multiplier).round(4)
    end
    
    # Update the question response with analysis results
    def update_question_response_with_analysis(question_response, analysis_result)
      log_progress("Updating question response with analysis results")
      
      safe_db_operation do
        analysis_data = analysis_result[:analysis_data]
        
        question_response.update!(
          ai_analysis_results: analysis_data[:ai_analysis],
          ai_confidence_score: analysis_data[:confidence_score],
          ai_completeness_score: analysis_data[:completeness_score],
          ai_analysis_requested_at: Time.current
        )
        
        # Track AI usage
        user = question_response.form_response.form.user
        ai_cost = analysis_result[:ai_cost] || 0.02
        user.consume_ai_credit(ai_cost) if user.respond_to?(:consume_ai_credit)
        
        log_progress("Question response updated successfully", {
          question_response_id: question_response.id,
          confidence_score: analysis_data[:confidence_score],
          ai_cost: ai_cost
        })
      end
    rescue StandardError => e
      Rails.logger.error "Failed to update question response #{question_response.id}: #{e.message}"
      raise e
    end
    
    # Schedule dynamic question generation if needed
    def schedule_dynamic_question_generation(question_response, analysis_result)
      return unless analysis_result[:generate_followup]
      
      question = question_response.form_question
      form_response = question_response.form_response
      
      # Check if we've already generated enough follow-ups for this question
      existing_count = form_response.dynamic_questions
                                   .where(generated_from_question: question)
                                   .count
      
      max_followups = question.ai_configuration.dig('max_followups') || 2
      return if existing_count >= max_followups
      
      log_progress("Scheduling dynamic question generation", {
        form_response_id: form_response.id,
        source_question_id: question.id,
        existing_followups: existing_count
      })
      
      # Schedule the dynamic question generation job
      Forms::DynamicQuestionGenerationJob.perform_later(
        form_response.id,
        question.id
      )
    end
    
    # Check if follow-up should be generated based on analysis result
    def should_generate_followup?(analysis_result)
      return false unless analysis_result[:success]
      return false unless analysis_result[:generate_followup]
      
      # Additional checks can be added here
      true
    end
    
    # Update aggregate analysis for the entire form response
    def update_aggregate_analysis(form_response)
      log_progress("Updating aggregate analysis for form response #{form_response.id}")
      
      safe_db_operation do
        aggregate_data = aggregate_response_analysis(form_response)
        
        form_response.update!(
          ai_analysis_results: aggregate_data,
          ai_analysis_updated_at: Time.current
        )
        
        log_progress("Aggregate analysis updated", {
          form_response_id: form_response.id,
          overall_sentiment: aggregate_data[:overall_sentiment],
          overall_quality: aggregate_data[:overall_quality]
        })
      end
    rescue StandardError => e
      Rails.logger.error "Failed to update aggregate analysis for form response #{form_response.id}: #{e.message}"
      # Don't re-raise as this is not critical
    end
    
    # Aggregate analysis from all question responses in the form response
    def aggregate_response_analysis(form_response)
      analyses = form_response.question_responses
                             .where.not(ai_analysis_results: [nil, {}])
                             .pluck(:ai_analysis_results)
      
      return default_aggregate_analysis if analyses.empty?
      
      # Aggregate sentiment scores
      sentiments = analyses.map { |a| a.dig('sentiment', 'confidence') }.compact
      avg_sentiment = sentiments.any? ? sentiments.sum / sentiments.size : 0.5
      
      # Aggregate quality scores  
      quality_scores = analyses.map { |a| a.dig('quality', 'overall_score') }.compact
      avg_quality = quality_scores.any? ? quality_scores.sum / quality_scores.size : 0.5
      
      # Collect insights
      all_insights = analyses.flat_map { |a| a['insights'] || [] }
      
      # Collect flags
      all_flags = analyses.map { |a| a['flags'] || {} }.reduce({}) do |merged, flags|
        flags.each { |key, value| merged[key] = (merged[key] || false) || value }
        merged
      end
      
      {
        overall_sentiment: avg_sentiment.round(3),
        overall_quality: avg_quality.round(3),
        key_insights: all_insights.uniq.first(5),
        flags: all_flags,
        analysis_count: analyses.size,
        analyzed_at: Time.current.iso8601,
        completeness_distribution: calculate_completeness_distribution(analyses),
        sentiment_distribution: calculate_sentiment_distribution(analyses)
      }
    end
    
    # Default aggregate analysis structure
    def default_aggregate_analysis
      {
        overall_sentiment: 0.5,
        overall_quality: 0.5,
        key_insights: [],
        flags: {},
        analysis_count: 0,
        analyzed_at: Time.current.iso8601
      }
    end
    
    # Calculate distribution of completeness scores
    def calculate_completeness_distribution(analyses)
      completeness_scores = analyses.map { |a| a.dig('completeness') }.compact
      return {} if completeness_scores.empty?
      
      {
        high: completeness_scores.count { |score| score > 0.8 },
        medium: completeness_scores.count { |score| score.between?(0.4, 0.8) },
        low: completeness_scores.count { |score| score < 0.4 },
        average: (completeness_scores.sum / completeness_scores.size).round(3)
      }
    end
    
    # Calculate distribution of sentiment scores
    def calculate_sentiment_distribution(analyses)
      sentiments = analyses.map { |a| a.dig('sentiment', 'label') }.compact
      return {} if sentiments.empty?
      
      distribution = sentiments.tally
      total = sentiments.size
      
      distribution.transform_values { |count| (count.to_f / total * 100).round(1) }
    end
    
    # Handle analysis errors
    def handle_analysis_error(question_response_id, error)
      error_context = {
        question_response_id: question_response_id,
        job_id: job_id,
        error_message: error.message,
        error_type: error.class.name
      }
      
      Rails.logger.error "Response analysis failed for question response #{question_response_id}: #{error.message}"
      Rails.logger.error error.backtrace.join("\n") if Rails.env.development?
      
      # Try to update question response with error information if possible
      begin
        question_response = QuestionResponse.find_by(id: question_response_id)
        if question_response
          question_response.update!(
            ai_analysis_results: {
              error: {
                message: error.message,
                type: error.class.name,
                failed_at: Time.current.iso8601,
                job_id: job_id
              }
            }
          )
        end
      rescue StandardError => update_error
        Rails.logger.error "Failed to update question response with error information: #{update_error.message}"
      end
      
      # Track error in monitoring system
      if defined?(Sentry)
        Sentry.capture_exception(error, extra: error_context)
      end
      
      # Re-raise to trigger retry logic
      raise error
    end
  end
end
</file>

<file path="jobs/forms/workflow_generation_job.rb">
# frozen_string_literal: true

module Forms
  # Background job responsible for generating SuperAgent workflow classes for forms
  # This job is triggered when a form is published or when workflow regeneration is requested
  class WorkflowGenerationJob < ApplicationJob
    queue_as :ai_processing
    
    # Retry on specific errors that might be temporary
    retry_on StandardError, wait: :exponentially_longer, attempts: 3
    
    # Discard if form is not found or invalid
    discard_on ActiveRecord::RecordNotFound, ArgumentError
    
    def perform(form_id, options = {})
      log_progress("Starting workflow generation for form #{form_id}")
      
      # Find the form
      form = find_record(Form, form_id)
      
      # Validate form is ready for workflow generation
      validate_form_for_workflow_generation!(form)
      
      # Generate the workflow class
      result = generate_workflow_class(form, options)
      
      # Update form with generated workflow class name
      update_form_with_workflow(form, result) if result[:success]
      
      # Log completion
      log_progress("Workflow generation completed", {
        form_id: form.id,
        workflow_class: result[:workflow_class_name],
        success: result[:success]
      })
      
      result
    rescue StandardError => e
      handle_workflow_generation_error(form_id, e)
    end
    
    private
    
    # Validate that the form is ready for workflow generation
    def validate_form_for_workflow_generation!(form)
      unless form.ai_enabled?
        raise ArgumentError, "Form #{form.id} does not have AI features enabled"
      end
      
      unless form.form_questions.any?
        raise ArgumentError, "Form #{form.id} must have at least one question to generate workflow"
      end
      
      if form.draft?
        Rails.logger.warn "Generating workflow for draft form #{form.id} - this is unusual"
      end
      
      log_progress("Form validation passed", {
        form_id: form.id,
        questions_count: form.form_questions.count,
        ai_enhanced_questions: form.form_questions.count { |q| q.ai_enhanced? }
      })
    end
    
    # Generate the workflow class using the service
    def generate_workflow_class(form, options = {})
      log_progress("Generating workflow class for form #{form.id}")
      
      safe_db_operation do
        # Use the workflow generator service
        service = execute_service(Forms::WorkflowGeneratorService, form)
        
        if service
          workflow_class = service
          workflow_class_name = form.workflow_class || generate_workflow_class_name(form)
          
          log_progress("Workflow class generated successfully", {
            form_id: form.id,
            workflow_class_name: workflow_class_name,
            class_methods: workflow_class.instance_methods(false).count
          })
          
          {
            success: true,
            workflow_class: workflow_class,
            workflow_class_name: workflow_class_name,
            generated_at: Time.current
          }
        else
          {
            success: false,
            error: "Workflow generation service returned nil",
            form_id: form.id
          }
        end
      end
    rescue StandardError => e
      log_progress("Workflow generation failed", {
        form_id: form.id,
        error: e.message
      })
      
      {
        success: false,
        error: e.message,
        error_type: e.class.name,
        form_id: form.id
      }
    end
    
    # Update the form with the generated workflow class information
    def update_form_with_workflow(form, generation_result)
      log_progress("Updating form with workflow information")
      
      safe_db_operation do
        # Update the workflow_class field and store metadata in workflow_config
        form.update!(
          workflow_class: generation_result[:workflow_class_name],
          workflow_config: form.workflow_config.merge({
            job_id: job_id,
            generated_at: generation_result[:generated_at],
            class_name: generation_result[:workflow_class_name],
            generation_version: 1,
            last_generation_job_id: job_id
          })
        )
        
        log_progress("Form updated successfully", {
          form_id: form.id,
          workflow_class_name: generation_result[:workflow_class_name]
        })
      end
    rescue StandardError => e
      Rails.logger.error "Failed to update form #{form.id} with workflow information: #{e.message}"
      
      # Don't re-raise here as the workflow was generated successfully
      # Just log the error and continue
      if defined?(Sentry)
        Sentry.capture_exception(e, extra: {
          form_id: form.id,
          workflow_class_name: generation_result[:workflow_class_name],
          job_id: job_id
        })
      end
    end
    
    # Generate a unique workflow class name for the form
    def generate_workflow_class_name(form)
      # Create a unique class name based on form ID
      form_identifier = form.id.to_s.gsub('-', '').first(8).upcase
      "Forms::Form#{form_identifier}Workflow"
    end
    
    # Handle workflow generation errors
    def handle_workflow_generation_error(form_id, error)
      error_context = {
        form_id: form_id,
        job_id: job_id,
        error_message: error.message,
        error_type: error.class.name
      }
      
      Rails.logger.error "Workflow generation failed for form #{form_id}: #{error.message}"
      Rails.logger.error error.backtrace.join("\n") if Rails.env.development?
      
      # Try to update form with error information if possible
      begin
        form = Form.find_by(id: form_id)
        if form
          form.update!(
            workflow_config: form.workflow_config.merge({
              generation_error: {
                error: error.message,
                error_type: error.class.name,
                failed_at: Time.current,
                job_id: job_id
              }
            })
          )
        end
      rescue StandardError => update_error
        Rails.logger.error "Failed to update form with error information: #{update_error.message}"
      end
      
      # Track error in monitoring system
      if defined?(Sentry)
        Sentry.capture_exception(error, extra: error_context)
      end
      
      # Re-raise to trigger retry logic
      raise error
    end
    
    # Check if workflow class exists and is valid
    def validate_generated_workflow(workflow_class_name)
      return false unless workflow_class_name.present?
      
      begin
        workflow_class = workflow_class_name.constantize
        
        # Basic validation that it's a workflow class
        return false unless workflow_class.ancestors.include?(ApplicationWorkflow)
        
        # Check that it has the expected methods
        required_methods = [:workflow, :execute]
        required_methods.all? { |method| workflow_class.method_defined?(method) }
      rescue NameError
        false
      end
    end
    
    # Clean up any existing workflow class before regeneration
    def cleanup_existing_workflow(form)
      return unless form.workflow_class.present?
      
      begin
        existing_class = form.workflow_class.constantize
        
        # Remove the constant to allow redefinition
        namespace, class_name = form.workflow_class.split('::')
        if namespace && class_name
          namespace.constantize.send(:remove_const, class_name)
        else
          Object.send(:remove_const, form.workflow_class)
        end
        
        log_progress("Cleaned up existing workflow class", {
          form_id: form.id,
          old_class_name: form.workflow_class
        })
      rescue NameError
        # Class doesn't exist, nothing to clean up
        log_progress("No existing workflow class to clean up")
      rescue StandardError => e
        Rails.logger.warn "Failed to clean up existing workflow class: #{e.message}"
      end
    end
  end
end
</file>

<file path="jobs/admin_maintenance_job.rb">
# frozen_string_literal: true

# Scheduled job for admin system maintenance tasks
class AdminMaintenanceJob < ApplicationJob
  queue_as :default
  
  # Run with lower priority to avoid impacting user-facing operations
  retry_on StandardError, wait: :exponentially_longer, attempts: 2

  def perform(task_type = 'full')
    Rails.logger.info "Starting admin maintenance job: #{task_type}"
    
    maintenance_stats = {
      task_type: task_type,
      started_at: Time.current,
      completed_tasks: [],
      errors: []
    }

    begin
      case task_type
      when 'full'
        run_full_maintenance(maintenance_stats)
      when 'cleanup'
        run_cleanup_only(maintenance_stats)
      when 'cache_warmup'
        run_cache_warmup_only(maintenance_stats)
      else
        raise ArgumentError, "Unknown maintenance task type: #{task_type}"
      end

      maintenance_stats[:completed_at] = Time.current
      maintenance_stats[:duration_seconds] = (maintenance_stats[:completed_at] - maintenance_stats[:started_at]).round(2)
      
      # Log successful maintenance
      AuditLog.create!(
        event_type: 'admin_maintenance_completed',
        details: maintenance_stats.except(:errors),
        ip_address: 'system'
      )
      
      Rails.logger.info "Admin maintenance completed: #{maintenance_stats}"
      
    rescue StandardError => e
      maintenance_stats[:errors] << e.message
      maintenance_stats[:failed_at] = Time.current
      
      Rails.logger.error "Admin maintenance failed: #{e.message}"
      
      # Log maintenance failure
      AuditLog.create!(
        event_type: 'admin_maintenance_failed',
        details: maintenance_stats,
        ip_address: 'system'
      )
      
      raise e
    end
    
    maintenance_stats
  end

  private

  def run_full_maintenance(stats)
    # Run discount code cleanup
    cleanup_result = DiscountCodeCleanupJob.perform_now
    stats[:completed_tasks] << {
      task: 'discount_code_cleanup',
      result: cleanup_result
    }
    
    # Clear old audit logs (keep last 6 months)
    old_logs_count = cleanup_old_audit_logs
    stats[:completed_tasks] << {
      task: 'audit_log_cleanup',
      old_logs_removed: old_logs_count
    }
    
    # Clear and warm up caches
    cache_result = refresh_admin_caches
    stats[:completed_tasks] << {
      task: 'cache_refresh',
      result: cache_result
    }
    
    # Update user statistics (for users who haven't been active)
    inactive_users_updated = update_inactive_user_stats
    stats[:completed_tasks] << {
      task: 'user_stats_update',
      users_updated: inactive_users_updated
    }
  end

  def run_cleanup_only(stats)
    cleanup_result = DiscountCodeCleanupJob.perform_now
    stats[:completed_tasks] << {
      task: 'discount_code_cleanup',
      result: cleanup_result
    }
    
    old_logs_count = cleanup_old_audit_logs
    stats[:completed_tasks] << {
      task: 'audit_log_cleanup',
      old_logs_removed: old_logs_count
    }
  end

  def run_cache_warmup_only(stats)
    cache_result = refresh_admin_caches
    stats[:completed_tasks] << {
      task: 'cache_refresh',
      result: cache_result
    }
  end

  def cleanup_old_audit_logs
    # Remove audit logs older than 6 months
    cutoff_date = 6.months.ago
    old_logs = AuditLog.where('created_at < ?', cutoff_date)
    count = old_logs.count
    
    if count > 0
      old_logs.delete_all
      Rails.logger.info "Removed #{count} old audit log entries"
    end
    
    count
  end

  def refresh_admin_caches
    # Clear all admin caches
    cleared_count = AdminCacheService.clear_all_caches
    
    # Warm up caches with fresh data
    AdminCacheService.warm_up_caches
    
    {
      caches_cleared: cleared_count,
      caches_warmed: true
    }
  end

  def update_inactive_user_stats
    # Update last_activity_at for users who haven't been updated recently
    # This helps with admin dashboard accuracy
    inactive_cutoff = 1.week.ago
    inactive_users = User.where('last_activity_at < ? OR last_activity_at IS NULL', inactive_cutoff)
    
    count = inactive_users.count
    if count > 0
      # Update in batches to avoid long-running queries
      inactive_users.find_in_batches(batch_size: 100) do |batch|
        batch.each do |user|
          # Check if user has recent forms or responses
          recent_activity = user.forms.where('created_at > ?', inactive_cutoff).exists? ||
                           user.form_responses.where('created_at > ?', inactive_cutoff).exists?
          
          if recent_activity
            user.update_column(:last_activity_at, Time.current)
          end
        end
      end
    end
    
    count
  end
end
</file>

<file path="jobs/admin_security_monitoring_job.rb">
# frozen_string_literal: true

# Background job for monitoring admin security and generating alerts
class AdminSecurityMonitoringJob < ApplicationJob
  queue_as :default

  def perform
    monitoring_service = AdminMonitoringService.new
    alerts = monitoring_service.check_security_alerts
    
    # Process alerts
    alerts.each do |alert|
      process_alert(alert)
    end
    
    # Clean up old audit logs (keep last 90 days)
    cleanup_old_audit_logs
    
    # Log monitoring completion
    Rails.logger.info "Admin security monitoring completed. Found #{alerts.count} alerts."
  end

  private

  def process_alert(alert)
    case alert[:severity]
    when 'high'
      handle_high_severity_alert(alert)
    when 'medium'
      handle_medium_severity_alert(alert)
    else
      handle_low_severity_alert(alert)
    end
    
    # Log the alert
    AuditLog.create!(
      event_type: 'security_alert_generated',
      details: alert,
      ip_address: alert[:ip_address]
    )
  end

  def handle_high_severity_alert(alert)
    # For high severity alerts, we might want to:
    # 1. Send immediate notifications to admins
    # 2. Temporarily block suspicious IPs
    # 3. Log to external monitoring systems
    
    Rails.logger.error "HIGH SEVERITY SECURITY ALERT: #{alert[:message]}"
    
    # Send notification to all superadmins
    notify_superadmins(alert)
    
    # If it's a coordinated attack, consider temporary IP blocking
    if alert[:type] == 'coordinated_attack'
      consider_ip_blocking(alert[:ip_address])
    end
  end

  def handle_medium_severity_alert(alert)
    Rails.logger.warn "MEDIUM SEVERITY SECURITY ALERT: #{alert[:message]}"
    
    # For medium severity, log and potentially notify during business hours
    notify_superadmins(alert) if business_hours?
  end

  def handle_low_severity_alert(alert)
    Rails.logger.info "LOW SEVERITY SECURITY ALERT: #{alert[:message]}"
    
    # Just log low severity alerts for review
  end

  def notify_superadmins(alert)
    superadmins = User.where(role: 'superadmin')
    
    superadmins.find_each do |admin|
      # In a real implementation, you might send emails or Slack notifications
      # For now, we'll just create an audit log entry
      AuditLog.create!(
        user: admin,
        event_type: 'security_alert_notification',
        details: {
          alert_type: alert[:type],
          alert_message: alert[:message],
          alert_severity: alert[:severity],
          notified_at: Time.current
        }
      )
    end
  end

  def consider_ip_blocking(ip_address)
    return if ip_address.blank?
    
    # In a real implementation, you might:
    # 1. Add IP to a blocklist in Redis
    # 2. Update firewall rules
    # 3. Notify infrastructure team
    
    Rails.logger.error "CONSIDERING IP BLOCK for #{ip_address} due to coordinated attack"
    
    # For now, just log the recommendation
    AuditLog.create!(
      event_type: 'ip_block_recommendation',
      details: {
        ip_address: ip_address,
        reason: 'coordinated_attack',
        recommended_at: Time.current
      },
      ip_address: ip_address
    )
  end

  def business_hours?
    # Simple business hours check (9 AM - 5 PM UTC, Monday-Friday)
    time = Time.current.utc
    time.wday.between?(1, 5) && time.hour.between?(9, 17)
  end

  def cleanup_old_audit_logs
    # Keep audit logs for 90 days
    cutoff_date = 90.days.ago
    
    old_logs_count = AuditLog.where('created_at < ?', cutoff_date).count
    
    if old_logs_count > 0
      AuditLog.where('created_at < ?', cutoff_date).delete_all
      
      Rails.logger.info "Cleaned up #{old_logs_count} old audit log entries"
      
      # Log the cleanup
      AuditLog.create!(
        event_type: 'audit_log_cleanup',
        details: {
          deleted_count: old_logs_count,
          cutoff_date: cutoff_date,
          cleaned_at: Time.current
        }
      )
    end
  end
end
</file>

<file path="jobs/application_job.rb">
# frozen_string_literal: true

# Base job class for all background jobs in this application
class ApplicationJob < ActiveJob::Base
  include SuperAgent::JobHelpers if defined?(SuperAgent::JobHelpers)
  
  # Automatically retry jobs that encountered a deadlock
  retry_on ActiveRecord::Deadlocked, wait: 5.seconds, attempts: 3
  
  # Most jobs are safe to ignore if the underlying records are no longer available
  discard_on ActiveJob::DeserializationError
  
  # Retry on temporary failures
  retry_on StandardError, wait: :exponentially_longer, attempts: 5
  
  # Discard jobs that are clearly invalid
  discard_on ArgumentError, ActiveRecord::RecordNotFound
  
  # Queue configuration
  queue_as do
    case self.class.name
    when /Critical/
      :critical
    when /AI/, /Analysis/, /LLM/
      :ai_processing
    when /Integration/, /Webhook/, /API/
      :integrations
    when /Analytics/, /Report/
      :analytics
    else
      :default
    end
  end
  
  # Global job callbacks
  before_perform do |job|
    Rails.logger.info "Starting job #{job.class.name} with arguments: #{job.arguments.inspect}"
    job.instance_variable_set(:@job_started_at, Time.current)
  end
  
  after_perform do |job|
    started_at = job.instance_variable_get(:@job_started_at)
    duration = started_at ? Time.current - started_at : 0
    Rails.logger.info "Completed job #{job.class.name} in #{duration.round(2)}s"
  end
  
  around_perform do |job, block|
    # Add job context for error tracking
    if defined?(Sentry)
      Sentry.with_scope do |scope|
        if scope
          scope.set_tag(:job_class, job.class.name)
          scope.set_tag(:job_queue, job.queue_name)
          scope.set_context(:job_arguments, job.arguments)
        end
        block.call
      end
    else
      block.call
    end
  end
  
  protected
  
  # Execute a workflow from within a job
  def execute_workflow(workflow_class, inputs = {})
    Rails.logger.info "Job #{self.class.name} executing workflow #{workflow_class.name}"
    
    begin
      context = SuperAgent::Workflow::Context.new(inputs.merge(job_context))
      engine = SuperAgent::WorkflowEngine.new
      result = engine.execute(workflow_class, context)

      log_workflow_result(workflow_class, result)
      result
    rescue StandardError => e
      Rails.logger.error "Workflow execution failed in job #{self.class.name}: #{e.message}"
      handle_workflow_error(workflow_class, e)
    end
  end
  
  # Execute a service from within a job
  def execute_service(service_class, *args)
    Rails.logger.info "Job #{self.class.name} executing service #{service_class.name}"
    
    service = service_class.call(*args)
    
    if service.failure?
      Rails.logger.error "Service execution failed: #{service.errors.full_messages.join(', ')}"
      raise StandardError, "Service #{service_class.name} failed: #{service.errors.full_messages.join(', ')}"
    end
    
    service.result
  end
  
  # Get job context for workflows and services
  def job_context
    {
      job_id: job_id,
      job_class: self.class.name,
      queue_name: queue_name,
      enqueued_at: enqueued_at,
      executions: executions
    }
  end
  
  # Safe database operation with error handling
  def safe_db_operation
    ActiveRecord::Base.transaction do
      yield
    end
  rescue ActiveRecord::RecordInvalid => e
    Rails.logger.error "Database validation error in job #{self.class.name}: #{e.message}"
    raise e
  rescue ActiveRecord::RecordNotFound => e
    Rails.logger.error "Record not found in job #{self.class.name}: #{e.message}"
    raise e
  rescue StandardError => e
    Rails.logger.error "Database operation failed in job #{self.class.name}: #{e.message}"
    raise e
  end
  
  # Find record with error handling
  def find_record(model_class, id)
    record = model_class.find_by(id: id)
    
    unless record
      error_message = "#{model_class.name} not found with id: #{id}"
      Rails.logger.error error_message
      raise ActiveRecord::RecordNotFound, error_message
    end
    
    record
  end
  
  # Check if job should continue based on record state
  def should_continue?(record, expected_state = nil)
    return false unless record
    
    if expected_state && record.respond_to?(:status)
      return record.status == expected_state.to_s
    end
    
    true
  end
  
  # Log job progress
  def log_progress(message, details = {})
    Rails.logger.info "Job #{self.class.name} progress: #{message}"
    Rails.logger.debug "Details: #{details.inspect}" if details.any?
  end
  
  # Handle job-specific errors
  def handle_job_error(error, context = {})
    Rails.logger.error "Job #{self.class.name} error: #{error.message}"
    Rails.logger.error error.backtrace.join("\n") if Rails.env.development?
    
    # Track error in Sentry if available
    if defined?(Sentry)
      Sentry.capture_exception(error, extra: {
        job_class: self.class.name,
        job_id: job_id,
        queue_name: queue_name,
        context: context
      })
    end
    
    # Re-raise to trigger retry logic
    raise error
  end
  
  private
  
  # Handle workflow execution errors
  def handle_workflow_error(workflow_class, error)
    Rails.logger.error "Workflow #{workflow_class.name} failed in job #{self.class.name}: #{error.message}"
    
    # Track error but don't re-raise to allow job to complete
    if defined?(Sentry)
      Sentry.capture_exception(error, extra: {
        job_class: self.class.name,
        workflow_class: workflow_class.name,
        job_context: job_context
      })
    end
    
    {
      error: true,
      error_message: error.message,
      error_type: error.class.name,
      workflow: workflow_class.name,
      job: self.class.name
    }
  end
  
  # Log workflow execution results
  def log_workflow_result(workflow_class, result)
    if result.is_a?(Hash) && result[:error]
      Rails.logger.error "Workflow #{workflow_class.name} completed with error: #{result[:error_message]}"
    else
      Rails.logger.info "Workflow #{workflow_class.name} completed successfully"
    end
  end
end
</file>

<file path="jobs/discount_code_cleanup_job.rb">
# frozen_string_literal: true

# Background job for cleaning up expired discount codes and maintaining data integrity
class DiscountCodeCleanupJob < ApplicationJob
  queue_as :default
  
  # Retry with exponential backoff
  retry_on StandardError, wait: :exponentially_longer, attempts: 3

  def perform
    Rails.logger.info "Starting discount code cleanup job"
    
    cleanup_stats = {
      expired_codes_deactivated: 0,
      exhausted_codes_deactivated: 0,
      cache_keys_cleared: 0,
      errors: []
    }

    begin
      # Deactivate expired codes
      expired_count = deactivate_expired_codes
      cleanup_stats[:expired_codes_deactivated] = expired_count
      
      # Deactivate codes that have reached their usage limit
      exhausted_count = deactivate_exhausted_codes
      cleanup_stats[:exhausted_codes_deactivated] = exhausted_count
      
      # Clear related cache entries
      cache_cleared = clear_discount_code_caches
      cleanup_stats[:cache_keys_cleared] = cache_cleared
      
      # Log audit entry for cleanup
      AuditLog.create!(
        event_type: 'discount_code_cleanup',
        details: cleanup_stats.except(:errors),
        ip_address: 'system'
      )
      
      Rails.logger.info "Discount code cleanup completed: #{cleanup_stats}"
      
    rescue StandardError => e
      cleanup_stats[:errors] << e.message
      Rails.logger.error "Discount code cleanup failed: #{e.message}"
      
      # Log error audit entry
      AuditLog.create!(
        event_type: 'discount_code_cleanup_error',
        details: { error: e.message, backtrace: e.backtrace.first(5) },
        ip_address: 'system'
      )
      
      raise e
    end
    
    cleanup_stats
  end

  private

  def deactivate_expired_codes
    expired_codes = DiscountCode.where(active: true)
                               .where('expires_at < ?', Time.current)
    
    count = expired_codes.count
    return 0 if count.zero?
    
    expired_codes.update_all(
      active: false,
      updated_at: Time.current
    )
    
    Rails.logger.info "Deactivated #{count} expired discount codes"
    count
  end

  def deactivate_exhausted_codes
    exhausted_codes = DiscountCode.where(active: true)
                                 .where.not(max_usage_count: nil)
                                 .where('current_usage_count >= max_usage_count')
    
    count = exhausted_codes.count
    return 0 if count.zero?
    
    exhausted_codes.update_all(
      active: false,
      updated_at: Time.current
    )
    
    Rails.logger.info "Deactivated #{count} exhausted discount codes"
    count
  end

  def clear_discount_code_caches
    cache_keys = [
      'discount_codes_dashboard_stats',
      'admin_discount_analytics',
      'admin_top_discount_codes',
      'admin_highest_revenue_codes',
      'admin_dashboard_discount_stats'
    ]
    
    cleared_count = 0
    cache_keys.each do |key|
      if Rails.cache.delete(key)
        cleared_count += 1
      end
    end
    
    Rails.logger.info "Cleared #{cleared_count} discount code cache entries"
    cleared_count
  end
end
</file>

<file path="jobs/google_sheets_export_job.rb">
# frozen_string_literal: true

class GoogleSheetsExportJob < ApplicationJob
  queue_as :google_sheets
  
  retry_on Google::Apis::RateLimitError, wait: :exponentially_longer, attempts: 5
  retry_on Google::Apis::ServerError, wait: 30.seconds, attempts: 3
  
  discard_on Google::Apis::AuthorizationError do |job, error|
    export_job = ExportJob.find(job.arguments.first)
    export_job.update!(
      status: :failed,
      error_details: { 
        type: 'authorization_error',
        message: 'Google authorization expired. User needs to reconnect.'
      }
    )
    
    # TODO: Implement GoogleSheetsMailer.authorization_expired
    # GoogleSheetsMailer.authorization_expired(export_job.user).deliver_now
  end
  
  def perform(export_job_id)
    @export_job = ExportJob.find(export_job_id)
    @export_job.update!(status: :processing, started_at: Time.current)
    
    # Verificaciones previas
    return fail_job("User is not premium") unless @export_job.user.premium?
    return fail_job("Form not found") unless @export_job.form
    
    integration = @export_job.user.google_integration
    return fail_job("Google integration not found") unless integration&.active?
    
    # Obtener respuestas del formulario
    responses = @export_job.form.form_responses.includes(:question_responses, :dynamic_questions)
    
    if responses.empty?
      return complete_job_with_warning("No responses found for export")
    end
    
    # Crear la hoja de clculo
    result = GoogleSheets::SpreadsheetCreatorService.call(
      integration: integration,
      form: @export_job.form,
      responses: responses,
      options: @export_job.configuration
    )
    
    if result.success?
      complete_job_successfully(result.result)
    else
      fail_job(result.errors.join(', '))
    end
    
  rescue StandardError => e
    Rails.logger.error "GoogleSheetsExportJob failed: #{e.message}\n#{e.backtrace.join("\n")}"
    fail_job("Unexpected error: #{e.message}")
    raise e # Re-raise para que Sidekiq pueda manejar el reintento
  end
  
  private
  
  def complete_job_successfully(result)
    @export_job.update!(
      status: :completed,
      completed_at: Time.current,
      spreadsheet_id: result[:spreadsheet_id],
      spreadsheet_url: result[:spreadsheet_url],
      records_exported: @export_job.form.form_responses.count
    )
    
    # TODO: Implement GoogleSheetsMailer.export_completed
    # GoogleSheetsMailer.export_completed(@export_job).deliver_now
    
    # Audit trail
    AuditLog.create!(
      user: @export_job.user,
      event_type: 'google_sheets_export_completed',
      details: {
        form_id: @export_job.form.id,
        spreadsheet_url: result[:spreadsheet_url],
        records_exported: @export_job.records_exported
      }
    )
  end
  
  def complete_job_with_warning(message)
    @export_job.update!(
      status: :completed,
      completed_at: Time.current,
      error_details: { type: 'warning', message: message }
    )
    
    # TODO: Implement GoogleSheetsMailer.export_completed_with_warning
    # GoogleSheetsMailer.export_completed_with_warning(@export_job, message).deliver_now
  end
  
  def fail_job(error_message)
    @export_job.update!(
      status: :failed,
      completed_at: Time.current,
      error_details: { 
        type: 'job_error',
        message: error_message,
        timestamp: Time.current
      }
    )
    
    # TODO: Implement GoogleSheetsMailer.export_failed
    # GoogleSheetsMailer.export_failed(@export_job, error_message).deliver_now
  end
end
</file>

<file path="jobs/google_sheets_sync_job.rb">
class GoogleSheetsSyncJob < ApplicationJob
  queue_as :integrations
  
  retry_on Google::Apis::ClientError, wait: :exponentially_longer, attempts: 3
  retry_on StandardError, wait: 5.seconds, attempts: 2

  def perform(form_id, action = 'export_all', response_id = nil)
    form = Form.find(form_id)
    integration = form.google_sheets_integration
    
    return unless integration&.can_sync?

    service = Integrations::GoogleSheetsService.new(form, integration)
    
    case action
    when 'export_all'
      result = service.export_all_responses
    when 'sync_response'
      response = form.form_responses.find(response_id)
      result = service.sync_new_response(response)
    else
      raise ArgumentError, "Unknown action: #{action}"
    end

    if result.failure?
      Rails.logger.error "Google Sheets sync failed for form #{form_id}: #{result.error}"
      raise StandardError, result.error
    end

    Rails.logger.info "Google Sheets sync completed for form #{form_id}: #{result.value}"
  end
end
</file>

<file path="jobs/google_token_refresh_job.rb">
# frozen_string_literal: true

class GoogleTokenRefreshJob < ApplicationJob
  queue_as :default
  
  def perform
    GoogleIntegration.needs_refresh.find_each do |integration|
      result = GoogleSheets::TokenRefreshService.call(integration: integration)
      
      if result.failure?
        Rails.logger.warn "Failed to refresh token for user #{integration.user_id}: #{result.errors.join(', ')}"
      end
    end
  end
end
</file>

<file path="jobs/notification_cleanup_job.rb">
class NotificationCleanupJob < ApplicationJob
  queue_as :default

  # Keep notifications for 90 days by default
  RETENTION_PERIOD = 90.days

  def perform(retention_period: RETENTION_PERIOD)
    cleanup_old_notifications(retention_period)
    log_cleanup_stats
  end

  private

  def cleanup_old_notifications(retention_period)
    cutoff_date = retention_period.ago
    
    @deleted_count = AdminNotification.where('created_at < ?', cutoff_date).delete_all
    
    Rails.logger.info "Cleaned up #{@deleted_count} old admin notifications (older than #{retention_period.inspect})"
  end

  def log_cleanup_stats
    remaining_count = AdminNotification.count
    unread_count = AdminNotification.unread.count
    
    Rails.logger.info "Notification cleanup completed:"
    Rails.logger.info "- Deleted: #{@deleted_count} notifications"
    Rails.logger.info "- Remaining: #{remaining_count} notifications"
    Rails.logger.info "- Unread: #{unread_count} notifications"

    # Create a system notification about the cleanup
    if @deleted_count > 0
      AdminNotification.create!(
        event_type: 'system',
        title: 'Notification cleanup completed',
        message: "Cleaned up #{@deleted_count} old notifications. #{remaining_count} notifications remaining.",
        priority: 'low',
        category: 'system',
        metadata: {
          deleted_count: @deleted_count,
          remaining_count: remaining_count,
          unread_count: unread_count,
          cleanup_date: Time.current
        }
      )
    end
  end
end
</file>

<file path="jobs/payment_analytics_job.rb">
# frozen_string_literal: true

class PaymentAnalyticsJob < ApplicationJob
  queue_as :analytics
  
  retry_on StandardError, wait: :exponentially_longer, attempts: 3

  def perform(event_type, user_id, context = {})
    user = User.find(user_id)
    
    PaymentAnalyticsService.new.track_event(
      event_type,
      user: user,
      context: context
    )
  rescue ActiveRecord::RecordNotFound => e
    Rails.logger.error "PaymentAnalyticsJob: User not found - #{e.message}"
    # Don't retry if user doesn't exist
  rescue StandardError => e
    Rails.logger.error "PaymentAnalyticsJob failed: #{e.message}"
    raise # This will trigger retry
  end
end
</file>

<file path="jobs/payment_setup_validation_job.rb">
class PaymentSetupValidationJob < ApplicationJob
  # High priority for user setup changes
  sidekiq_options queue: 'critical', retry: 3, backtrace: true, dead: false, retry_in: proc { |count|
    case count
    when 0
      5 # 5 seconds for first retry
    when 1
      30 # 30 seconds for second retry
    else
      120 # 2 minutes for final retry
    end
  }
  
  def perform(user_id, trigger_event = 'setup_change', options = {})
    @user = User.find(user_id)
    @trigger_event = trigger_event
    @options = options.with_indifferent_access
    
    Rails.logger.info "Starting payment setup validation for user #{user_id}, trigger: #{trigger_event}"
    
    begin
      # Validate current user setup
      validation_result = validate_user_payment_setup
      
      # Update affected forms
      updated_forms = update_form_statuses(validation_result)
      
      # Broadcast real-time updates
      broadcast_setup_status_updates(validation_result, updated_forms)
      
      Rails.logger.info "Completed payment setup validation for user #{user_id}, updated #{updated_forms.count} forms"
      
      {
        validation_result: validation_result,
        updated_forms_count: updated_forms.count,
        trigger_event: @trigger_event
      }
    rescue StandardError => e
      Rails.logger.error "Payment setup validation failed for user #{user_id}: #{e.message}"
      
      # Broadcast error notification
      broadcast_validation_error(e)
      
      raise e
    end
  end
  
  private
  
  def validate_user_payment_setup
    service = PaymentSetupValidationService.new
    
    # Get all required features from user's forms with payment questions
    required_features = determine_user_required_features
    
    # Validate user setup against requirements
    validation_result = service.validate_user_requirements(@user, required_features)
    
    # Add setup completion percentage
    validation_result[:setup_completion_percentage] = calculate_setup_completion_percentage(validation_result)
    
    validation_result
  end
  
  def determine_user_required_features
    payment_forms = @user.forms.joins(:template)
                         .where(form_templates: { payment_enabled: true })
    
    required_features = Set.new
    
    payment_forms.each do |form|
      template_features = form.template.required_features || []
      required_features.merge(template_features)
    end
    
    required_features.to_a
  end
  
  def calculate_setup_completion_percentage(validation_result)
    return 100 if validation_result[:valid]
    
    total_requirements = validation_result[:missing_requirements].count + 
                        (validation_result[:valid] ? 1 : 0)
    completed_requirements = validation_result[:valid] ? 1 : 0
    
    return 0 if total_requirements == 0
    
    (completed_requirements.to_f / total_requirements * 100).round
  end
  
  def update_form_statuses(validation_result)
    updated_forms = []
    
    # Find all forms with payment questions
    payment_forms = @user.forms.joins(:template)
                         .where(form_templates: { payment_enabled: true })
    
    payment_forms.each do |form|
      old_status = form.payment_setup_complete?
      
      # Update form's cached payment setup status
      form.update_column(:payment_setup_complete, validation_result[:valid])
      
      # Track forms that changed status
      if old_status != validation_result[:valid]
        updated_forms << form
        
        # Update form metadata
        form.update!(
          metadata: (form.metadata || {}).merge(
            payment_validation: {
              last_validated_at: Time.current,
              validation_result: validation_result,
              trigger_event: @trigger_event
            }
          )
        )
      end
    end
    
    updated_forms
  end
  
  def broadcast_setup_status_updates(validation_result, updated_forms)
    # Broadcast general setup status update
    Turbo::StreamsChannel.broadcast_update_to(
      "user_#{@user.id}",
      target: "payment_setup_status",
      partial: "shared/payment_setup_status",
      locals: { 
        user: @user, 
        validation_result: validation_result 
      }
    )
    
    # Broadcast updates for each affected form
    updated_forms.each do |form|
      broadcast_form_status_update(form, validation_result)
    end
    
    # Broadcast notification if setup is now complete
    if validation_result[:valid] && @trigger_event == 'setup_completion'
      broadcast_setup_completion_notification(validation_result)
    end
  end
  
  def broadcast_form_status_update(form, validation_result)
    Turbo::StreamsChannel.broadcast_update_to(
      "form_#{form.id}",
      target: "form_payment_status_#{form.id}",
      partial: "forms/payment_status_indicator",
      locals: { 
        form: form, 
        validation_result: validation_result 
      }
    )
    
    # Update form editor if form is being edited
    Turbo::StreamsChannel.broadcast_update_to(
      "form_editor_#{form.id}",
      target: "payment_notification_bar",
      partial: "forms/payment_notification_bar",
      locals: { 
        form: form, 
        validation_result: validation_result 
      }
    )
  end
  
  def broadcast_setup_completion_notification(validation_result)
    Turbo::StreamsChannel.broadcast_update_to(
      "user_#{@user.id}",
      target: "notifications",
      partial: "shared/setup_completion_notification",
      locals: { 
        user: @user, 
        validation_result: validation_result 
      }
    )
  end
  
  def broadcast_validation_error(error)
    Turbo::StreamsChannel.broadcast_update_to(
      "user_#{@user.id}",
      target: "payment_setup_status",
      partial: "shared/payment_validation_error",
      locals: { 
        user: @user, 
        error: error.message 
      }
    )
  end
end
</file>

<file path="jobs/response_volume_check_job.rb">
class ResponseVolumeCheckJob < ApplicationJob
  queue_as :default

  HIGH_VOLUME_THRESHOLD = 100 # responses per day

  def perform
    check_high_volume_forms
  end

  private

  def check_high_volume_forms
    # Find forms with high response volume today
    high_volume_forms = Form.joins(:form_responses)
                           .where(form_responses: { created_at: Date.current.beginning_of_day..Date.current.end_of_day })
                           .group('forms.id')
                           .having('COUNT(form_responses.id) >= ?', HIGH_VOLUME_THRESHOLD)
                           .includes(:user)

    high_volume_forms.find_each do |form|
      response_count = form.form_responses
                          .where(created_at: Date.current.beginning_of_day..Date.current.end_of_day)
                          .count

      # Only notify once per day per form
      existing_notification = AdminNotification.where(
        event_type: 'high_response_volume',
        metadata: { form_id: form.id },
        created_at: Date.current.beginning_of_day..Date.current.end_of_day
      ).exists?

      unless existing_notification
        AdminNotificationService.notify(:high_response_volume,
          user: form.user,
          form: form,
          response_count: response_count
        )
      end
    end
  end
end
</file>

<file path="jobs/template_payment_analysis_job.rb">
class TemplatePaymentAnalysisJob < ApplicationJob
  # High priority for user-initiated actions
  sidekiq_options queue: 'ai_processing', retry: 5, backtrace: true, dead: false, retry_in: proc { |count|
    case count
    when 0..2
      10 * (count + 1) # 10s, 20s, 30s
    when 3..4
      60 * (count - 2) # 60s, 120s
    else
      300 # 5 minutes for final attempt
    end
  }
  
  def perform(template_id, user_id = nil, options = {})
    @template = FormTemplate.find(template_id)
    @user = User.find(user_id) if user_id
    @options = options.with_indifferent_access
    
    Rails.logger.info "Starting template payment analysis for template #{template_id}"
    
    begin
      # Perform complex template analysis
      analysis_result = analyze_template_payment_requirements
      
      # Update template metadata
      update_template_metadata(analysis_result)
      
      # Notify completion via Turbo Streams if user is present
      broadcast_completion_notification(analysis_result) if @user
      
      Rails.logger.info "Completed template payment analysis for template #{template_id}"
      
      analysis_result
    rescue StandardError => e
      Rails.logger.error "Template payment analysis failed for template #{template_id}: #{e.message}"
      
      # Broadcast error notification if user is present
      broadcast_error_notification(e) if @user
      
      raise e
    end
  end
  
  private
  
  def analyze_template_payment_requirements
    # Use TemplateAnalysisService for complex analysis
    service = TemplateAnalysisService.new
    result = service.analyze_payment_requirements(@template)
    
    # Add additional processing for complex templates
    if @template.questions_config.count > 50
      result = perform_deep_analysis(result)
    end
    
    result
  end
  
  def perform_deep_analysis(initial_result)
    # Perform more detailed analysis for large templates
    payment_questions = @template.questions_config.select do |q|
      PaymentRequirementDetector::PAYMENT_QUESTION_TYPES.include?(q['question_type'])
    end
    
    # Analyze payment flow complexity
    flow_complexity = calculate_payment_flow_complexity(payment_questions)
    
    # Determine integration requirements
    integration_requirements = determine_integration_requirements(payment_questions)
    
    initial_result.merge(
      flow_complexity: flow_complexity,
      integration_requirements: integration_requirements,
      deep_analysis_performed: true
    )
  end
  
  def calculate_payment_flow_complexity(payment_questions)
    complexity_score = 0
    
    payment_questions.each do |question|
      case question['question_type']
      when 'payment'
        complexity_score += 3
      when 'subscription'
        complexity_score += 5
      when 'donation'
        complexity_score += 2
      end
      
      # Add complexity for conditional logic
      complexity_score += 1 if question['conditional_logic'].present?
    end
    
    case complexity_score
    when 0..5
      'simple'
    when 6..15
      'moderate'
    else
      'complex'
    end
  end
  
  def determine_integration_requirements(payment_questions)
    requirements = []
    
    if payment_questions.any? { |q| q['question_type'] == 'subscription' }
      requirements << 'recurring_payments'
    end
    
    if payment_questions.any? { |q| q['question_type'] == 'donation' }
      requirements << 'donation_processing'
    end
    
    if payment_questions.count > 1
      requirements << 'multi_payment_handling'
    end
    
    requirements
  end
  
  def update_template_metadata(analysis_result)
    @template.update!(
      payment_enabled: analysis_result[:has_payment_questions],
      required_features: analysis_result[:required_features],
      setup_complexity: analysis_result[:setup_complexity],
      metadata: (@template.metadata || {}).merge(
        payment_analysis: analysis_result,
        last_analyzed_at: Time.current
      )
    )
  end
  
  def broadcast_completion_notification(analysis_result)
    return unless @user
    
    Turbo::StreamsChannel.broadcast_update_to(
      "user_#{@user.id}",
      target: "template_analysis_status_#{@template.id}",
      partial: "shared/template_analysis_complete",
      locals: { 
        template: @template, 
        analysis_result: analysis_result,
        user: @user
      }
    )
  end
  
  def broadcast_error_notification(error)
    return unless @user
    
    Turbo::StreamsChannel.broadcast_update_to(
      "user_#{@user.id}",
      target: "template_analysis_status_#{@template.id}",
      partial: "shared/template_analysis_error",
      locals: { 
        template: @template, 
        error: error.message,
        user: @user
      }
    )
  end
end
</file>

<file path="jobs/trial_expiration_check_job.rb">
class TrialExpirationCheckJob < ApplicationJob
  queue_as :default

  def perform
    check_expiring_trials
    check_expired_trials
  end

  private

  def check_expiring_trials
    # Find trials expiring in 3 days
    expiring_soon = User.where(
      subscription_status: 'trialing',
      trial_ends_at: 3.days.from_now.beginning_of_day..3.days.from_now.end_of_day
    )

    expiring_soon.find_each do |user|
      AdminNotificationService.notify(:trial_ending_soon, user: user)
    end
  end

  def check_expired_trials
    # Find trials that expired today
    expired_today = User.where(
      subscription_status: 'trialing',
      trial_ends_at: 1.day.ago.beginning_of_day..Time.current
    )

    expired_today.find_each do |user|
      AdminNotificationService.notify(:trial_expired, user: user)
      
      # Update user status
      user.update!(
        subscription_status: 'inactive',
        subscription_tier: 'basic'
      )
    end
  end
end
</file>

<file path="jobs/trial_expiration_job.rb">
# frozen_string_literal: true

class TrialExpirationJob < ApplicationJob
  queue_as :default

  def perform
    # Find users whose trials have expired
    expired_users = User.where(
      'trial_expires_at < ? AND subscription_status = ?',
      Time.current,
      'trial'
    )

    expired_users.find_each do |user|
      # Update user status
      user.update!(subscription_status: 'expired')
      
      # Send expiration notification
      UserMailer.trial_expired(user).deliver_now
      
      Rails.logger.info "Trial expired for user #{user.id} (#{user.email})"
    end

    Rails.logger.info "Processed #{expired_users.count} expired trials"
  end
end
</file>

<file path="jobs/user_invitation_job.rb">
# frozen_string_literal: true

# Background job for sending user invitation emails
class UserInvitationJob < ApplicationJob
  queue_as :integrations
  
  # Retry with exponential backoff for email delivery failures
  retry_on Net::SMTPError, wait: :exponentially_longer, attempts: 5
  retry_on StandardError, wait: :exponentially_longer, attempts: 3

  def perform(user_id, temporary_password)
    user = User.find(user_id)
    
    Rails.logger.info "Sending invitation email to user #{user.email}"
    
    begin
      UserMailer.admin_invitation(user, temporary_password).deliver_now
      
      # Log successful email delivery
      AuditLog.create!(
        user: user,
        event_type: 'user_invitation_sent',
        details: {
          user_id: user.id,
          email: user.email,
          sent_at: Time.current
        },
        ip_address: 'system'
      )
      
      Rails.logger.info "Invitation email sent successfully to #{user.email}"
      
    rescue StandardError => e
      Rails.logger.error "Failed to send invitation email to #{user.email}: #{e.message}"
      
      # Log email delivery failure
      AuditLog.create!(
        user: user,
        event_type: 'user_invitation_failed',
        details: {
          user_id: user.id,
          email: user.email,
          error: e.message,
          failed_at: Time.current
        },
        ip_address: 'system'
      )
      
      raise e
    end
  rescue ActiveRecord::RecordNotFound
    Rails.logger.error "User with ID #{user_id} not found for invitation email"
  end
end
</file>

<file path="jobs/user_reactivation_job.rb">
# frozen_string_literal: true

# Background job for sending user reactivation notification emails
class UserReactivationJob < ApplicationJob
  queue_as :integrations
  
  # Retry with exponential backoff for email delivery failures
  retry_on Net::SMTPError, wait: :exponentially_longer, attempts: 5
  retry_on StandardError, wait: :exponentially_longer, attempts: 3
  
  def perform(user_id)
    user = User.find(user_id)
    
    Rails.logger.info "Sending reactivation notification to user #{user.email}"
    
    begin
      UserMailer.account_reactivated(user).deliver_now
      
      # Log successful email delivery
      AuditLog.create!(
        user: user,
        event_type: 'user_reactivation_notification_sent',
        details: {
          user_id: user.id,
          email: user.email,
          sent_at: Time.current
        },
        ip_address: 'system'
      )
      
      Rails.logger.info "Reactivation notification sent successfully to #{user.email}"
      
    rescue StandardError => e
      Rails.logger.error "Failed to send reactivation notification to #{user.email}: #{e.message}"
      
      # Log email delivery failure
      AuditLog.create!(
        user: user,
        event_type: 'user_reactivation_notification_failed',
        details: {
          user_id: user.id,
          email: user.email,
          error: e.message,
          failed_at: Time.current
        },
        ip_address: 'system'
      )
      
      raise e
    end
  rescue ActiveRecord::RecordNotFound
    Rails.logger.error "User with ID #{user_id} not found for reactivation notification"
  end
end
</file>

<file path="jobs/user_suspension_job.rb">
# frozen_string_literal: true

# Background job for sending user suspension notification emails
class UserSuspensionJob < ApplicationJob
  queue_as :integrations
  
  # Retry with exponential backoff for email delivery failures
  retry_on Net::SMTPError, wait: :exponentially_longer, attempts: 5
  retry_on StandardError, wait: :exponentially_longer, attempts: 3
  
  def perform(user_id, suspension_reason)
    user = User.find(user_id)
    
    Rails.logger.info "Sending suspension notification to user #{user.email}"
    
    begin
      UserMailer.account_suspended(user, suspension_reason).deliver_now
      
      # Log successful email delivery
      AuditLog.create!(
        user: user,
        event_type: 'user_suspension_notification_sent',
        details: {
          user_id: user.id,
          email: user.email,
          suspension_reason: suspension_reason,
          sent_at: Time.current
        },
        ip_address: 'system'
      )
      
      Rails.logger.info "Suspension notification sent successfully to #{user.email}"
      
    rescue StandardError => e
      Rails.logger.error "Failed to send suspension notification to #{user.email}: #{e.message}"
      
      # Log email delivery failure
      AuditLog.create!(
        user: user,
        event_type: 'user_suspension_notification_failed',
        details: {
          user_id: user.id,
          email: user.email,
          suspension_reason: suspension_reason,
          error: e.message,
          failed_at: Time.current
        },
        ip_address: 'system'
      )
      
      raise e
    end
  rescue ActiveRecord::RecordNotFound
    Rails.logger.error "User with ID #{user_id} not found for suspension notification"
  end
end
</file>

<file path="lib/circuit_breaker/job_integration.rb">
# frozen_string_literal: true

module CircuitBreaker
    class OpenError < StandardError; end
    
    module JobIntegration
      extend ActiveSupport::Concern
      
      included do
        class_attribute :circuit_breaker_config
      end
      
      class_methods do
        def circuit_breaker_options(options = {})
          self.circuit_breaker_config = {
            failure_threshold: options[:failure_threshold] || 5,
            recovery_timeout: options[:recovery_timeout] || 60,
            expected_errors: options[:expected_errors] || []
          }.freeze
        end
      end
      
      private
      
      def with_circuit_breaker(&block)
        circuit_breaker = get_or_create_circuit_breaker
        
        if circuit_breaker.open?
          if circuit_breaker.should_attempt_reset?
            circuit_breaker.attempt_reset
          else
            raise CircuitBreaker::OpenError, "Circuit breaker is open"
          end
        end
        
        begin
          result = block.call
          circuit_breaker.record_success
          result
        rescue => error
          if expected_error?(error)
            circuit_breaker.record_failure
            if circuit_breaker.should_trip?
              circuit_breaker.trip!
            end
          end
          raise error
        end
      end
      
      def get_or_create_circuit_breaker
        @circuit_breaker ||= CircuitBreakerState.new(
          job_class: self.class.name,
          config: self.class.circuit_breaker_config || {}
        )
      end
      
      def expected_error?(error)
        expected_errors = self.class.circuit_breaker_config&.dig(:expected_errors) || []
        expected_errors.any? { |error_class| error.is_a?(error_class) }
      end
    end
    
    class CircuitBreakerState
      attr_reader :job_class, :config, :failure_count, :last_failure_time, :state
      
      def initialize(job_class:, config:)
        @job_class = job_class
        @config = config
        @failure_count = get_failure_count
        @last_failure_time = get_last_failure_time
        @state = determine_state
      end
      
      def open?
        @state == :open
      end
      
      def closed?
        @state == :closed
      end
      
      def half_open?
        @state == :half_open
      end
      
      def should_attempt_reset?
        open? && time_since_last_failure > recovery_timeout
      end
      
      def should_trip?
        @failure_count >= failure_threshold
      end
      
      def record_success
        reset_circuit_breaker
      end
      
      def record_failure
        increment_failure_count
        update_last_failure_time
        @failure_count = get_failure_count
      end
      
      def trip!
        @state = :open
        Rails.logger.warn "Circuit breaker tripped for #{@job_class}"
      end
      
      def attempt_reset
        @state = :half_open
        Rails.logger.info "Circuit breaker attempting reset for #{@job_class}"
      end
      
      private
      
      def failure_threshold
        @config[:failure_threshold] || 5
      end
      
      def recovery_timeout
        @config[:recovery_timeout] || 60
      end
      
      def cache_key_prefix
        "circuit_breaker:#{@job_class}"
      end
      
      def failure_count_key
        "#{cache_key_prefix}:failures"
      end
      
      def last_failure_key
        "#{cache_key_prefix}:last_failure"
      end
      
      def get_failure_count
        Rails.cache.read(failure_count_key) || 0
      end
      
      def get_last_failure_time
        Rails.cache.read(last_failure_key)
      end
      
      def increment_failure_count
        Rails.cache.write(failure_count_key, get_failure_count + 1, expires_in: 1.hour)
      end
      
      def update_last_failure_time
        Rails.cache.write(last_failure_key, Time.current, expires_in: 1.hour)
      end
      
      def reset_circuit_breaker
        Rails.cache.delete(failure_count_key)
        Rails.cache.delete(last_failure_key)
        @failure_count = 0
        @last_failure_time = nil
        @state = :closed
        Rails.logger.info "Circuit breaker reset for #{@job_class}"
      end
      
      def time_since_last_failure
        return Float::INFINITY unless @last_failure_time
        Time.current - @last_failure_time
      end
      
      def determine_state
        if @failure_count >= failure_threshold
          if @last_failure_time && time_since_last_failure > recovery_timeout
            :half_open
          else
            :open
          end
        else
          :closed
        end
      end
    end
  end
</file>

<file path="mailers/application_mailer.rb">
# frozen_string_literal: true

class ApplicationMailer < ActionMailer::Base
  default from: 'noreply@agentform.com'
  layout 'mailer'
end
</file>

<file path="mailers/user_mailer.rb">
# frozen_string_literal: true

class UserMailer < ApplicationMailer
  default from: 'noreply@agentform.com'

  def trial_welcome(user)
    @user = user
    @trial_days = TrialConfig.trial_period_days
    @trial_end_date = user.trial_ends_at&.strftime('%B %d, %Y')
    @login_url = new_user_session_url
    
    mail(
      to: @user.email,
      subject: "Bienvenido a AgentForm! Tu perodo de prueba ha comenzado"
    )
  end

  def premium_welcome(user)
    @user = user
    @login_url = new_user_session_url
    
    mail(
      to: @user.email,
      subject: "Bienvenido a AgentForm Premium!"
    )
  end

  def trial_expiring_soon(user)
    @user = user
    @days_remaining = user.trial_days_remaining
    @upgrade_url = new_subscription_upgrade_url
    
    mail(
      to: @user.email,
      subject: "Tu perodo de prueba de AgentForm expira pronto"
    )
  end

  def trial_expiring_today(user)
    @user = user
    @upgrade_url = new_subscription_upgrade_url
    
    mail(
      to: @user.email,
      subject: "Tu perodo de prueba de AgentForm expira hoy"
    )
  end

  def trial_expired(user)
    @user = user
    @upgrade_url = new_subscription_upgrade_url
    @login_url = new_user_session_url
    
    mail(
      to: @user.email,
      subject: "Tu perodo de prueba de AgentForm ha expirado"
    )
  end

  def account_confirmation(user)
    @user = user
    @confirmation_url = user_confirmation_url(confirmation_token: user.confirmation_token)
    mail(
      to: @user.email,
      subject: "Confirma tu cuenta de AgentForm"
    )
  end
end
</file>

<file path="models/concerns/admin_cacheable.rb">
# frozen_string_literal: true

# Concern for models that should invalidate admin caches when changed
module AdminCacheable
  extend ActiveSupport::Concern

  included do
    after_commit :invalidate_admin_caches, on: [:create, :update, :destroy]
  end

  private

  def invalidate_admin_caches
    # Determine which caches to clear based on the model
    case self.class.name
    when 'User'
      AdminCacheService.clear_cache('users')
      AdminCacheService.clear_cache('dashboard')
    when 'DiscountCode', 'DiscountCodeUsage'
      AdminCacheService.clear_cache('discount_codes')
      AdminCacheService.clear_cache('dashboard')
    when 'AuditLog'
      AdminCacheService.clear_cache('analytics')
    when 'PaymentTransaction'
      AdminCacheService.clear_cache('dashboard')
    end
    
    Rails.logger.debug "Invalidated admin caches for #{self.class.name} change"
  end
end
</file>

<file path="models/concerns/cacheable.rb">
# frozen_string_literal: true

module Cacheable
  extend ActiveSupport::Concern

  included do
    after_commit :bust_cache
  end

  class_methods do
    def cached_find(id, expires_in: 1.hour)
      Rails.cache.fetch("#{name.downcase}/#{id}", expires_in: expires_in) do
        find(id)
      end
    end

    def cached_count(scope_name = nil, expires_in: 5.minutes)
      cache_key = scope_name ? "#{name.downcase}/#{scope_name}/count" : "#{name.downcase}/count"
      Rails.cache.fetch(cache_key, expires_in: expires_in) do
        scope_name ? public_send(scope_name).count : count
      end
    end
  end

  # Instance methods
  def cache_key_with_version
    "#{model_name.cache_key}/#{id}-#{updated_at.to_i}"
  end

  private

  def bust_cache
    Rails.cache.delete_matched("#{self.class.name.downcase}/*")
  end
end
</file>

<file path="models/concerns/encryptable.rb">
# frozen_string_literal: true

module Encryptable
  extend ActiveSupport::Concern

  included do
    # Manual encryption using Base64 encoding
    # No automatic field encryption to avoid Active Record Encryption dependency
  end

  # Instance methods for manual encryption/decryption
  def encrypt_data(data)
    return nil if data.blank?
    
    # Use simple Base64 encoding with a salt for basic obfuscation
    # Note: This is not cryptographically secure, just basic obfuscation
    salt = Rails.application.secret_key_base[0..15]
    encrypted = Base64.strict_encode64("#{salt}#{data}#{salt}")
    "encrypted:#{encrypted}"
  end

  def decrypt_data(encrypted_data)
    return nil if encrypted_data.blank?
    
    # Remove the 'encrypted:' prefix and decrypt
    if encrypted_data.start_with?('encrypted:')
      encrypted_value = encrypted_data.sub('encrypted:', '')
      decoded = Base64.strict_decode64(encrypted_value)
      salt = Rails.application.secret_key_base[0..15]
      # Remove salt from both ends
      decoded.sub(/^#{Regexp.escape(salt)}/, '').sub(/#{Regexp.escape(salt)}$/, '')
    else
      encrypted_data
    end
  rescue => e
    # If decryption fails, return the original data
    encrypted_data
  end

  class_methods do
    def encrypt_field(field_name, **options)
      # Custom field encryption using manual methods
      # This is a placeholder for future implementation if needed
      Rails.logger.info "Field encryption requested for #{field_name} but using manual encryption instead"
    end
  end
end
</file>

<file path="models/concerns/payment_analytics_trackable.rb">
# frozen_string_literal: true

module PaymentAnalyticsTrackable
  extend ActiveSupport::Concern

  private

  def track_payment_event(event_type, user:, context: {})
    # Add request context if available
    enhanced_context = context.merge(extract_request_context)
    
    PaymentAnalyticsService.new.track_event(
      event_type,
      user: user,
      context: enhanced_context
    )
  rescue StandardError => e
    Rails.logger.error "Failed to track payment event #{event_type}: #{e.message}"
    # Don't let analytics failures break the main flow
  end

  def extract_request_context
    return {} unless defined?(request) && request

    {
      session_id: session.id,
      user_agent: request.user_agent,
      ip_address: request.remote_ip,
      referer: request.referer,
      controller: controller_name,
      action: action_name
    }
  rescue StandardError
    {}
  end
end
</file>

<file path="models/concerns/payment_validation_error.rb">
# frozen_string_literal: true

# Custom error class for payment validation failures
# Provides structured error information with actionable guidance
class PaymentValidationError < StandardError
  attr_reader :error_type, :required_actions, :user_guidance

  def initialize(error_type:, required_actions: [], user_guidance: {})
    @error_type = error_type
    @required_actions = required_actions
    @user_guidance = user_guidance
    
    message = user_guidance[:message] || "Payment validation failed: #{error_type}"
    super(message)
  end

  # Returns a hash representation of the error for API responses
  def to_hash
    {
      error_type: error_type,
      message: message,
      required_actions: required_actions,
      user_guidance: user_guidance
    }
  end

  # Returns a JSON representation of the error
  def to_json(*args)
    to_hash.to_json(*args)
  end

  # Checks if this error is of a specific type
  def type?(check_type)
    error_type.to_s == check_type.to_s
  end

  # Returns true if the error has actionable steps
  def actionable?
    required_actions.any?
  end

  # Returns the primary action URL if available
  def primary_action_url
    user_guidance[:action_url]
  end

  # Returns the primary action text if available
  def primary_action_text
    user_guidance[:action_text]
  end
end
</file>

<file path="models/concerns/payment_validation_errors.rb">
# frozen_string_literal: true

# Module containing predefined payment validation error types and responses
# Provides consistent error messaging and guidance across the application
module PaymentValidationErrors
  # Error type for missing Stripe configuration
  STRIPE_NOT_CONFIGURED = {
    type: 'stripe_not_configured',
    message: 'Stripe configuration required for payment questions',
    description: 'Your form contains payment questions but Stripe is not configured. Set up Stripe to accept payments.',
    action_url: '/stripe_settings',
    action_text: 'Configure Stripe',
    severity: 'error',
    category: 'payment_setup'
  }.freeze

  # Error type for missing Premium subscription
  PREMIUM_REQUIRED = {
    type: 'premium_subscription_required',
    message: 'Premium subscription required for payment features',
    description: 'Payment questions are a Premium feature. Upgrade your subscription to use payment functionality.',
    action_url: '/subscription_management',
    action_text: 'Upgrade to Premium',
    severity: 'error',
    category: 'subscription'
  }.freeze

  # Error type for multiple missing requirements
  MULTIPLE_REQUIREMENTS = {
    type: 'multiple_requirements_missing',
    message: 'Multiple setup steps required for payment features',
    description: 'Your form requires payment functionality, but several setup steps are incomplete.',
    action_url: '/payment_setup_guide',
    action_text: 'Complete Setup',
    severity: 'error',
    category: 'payment_setup'
  }.freeze

  # Error type for invalid payment question configuration
  INVALID_PAYMENT_CONFIGURATION = {
    type: 'invalid_payment_configuration',
    message: 'Payment questions are not properly configured',
    description: 'One or more payment questions in your form have invalid configuration.',
    action_url: nil,
    action_text: 'Review Questions',
    severity: 'warning',
    category: 'configuration'
  }.freeze

  # Error type for insufficient permissions
  INSUFFICIENT_PERMISSIONS = {
    type: 'insufficient_permissions',
    message: 'Insufficient permissions for payment features',
    description: 'Your account does not have the necessary permissions to use payment features.',
    action_url: '/profile',
    action_text: 'Contact Support',
    severity: 'error',
    category: 'permissions'
  }.freeze

  # All available error types
  ALL_ERROR_TYPES = [
    STRIPE_NOT_CONFIGURED,
    PREMIUM_REQUIRED,
    MULTIPLE_REQUIREMENTS,
    INVALID_PAYMENT_CONFIGURATION,
    INSUFFICIENT_PERMISSIONS
  ].freeze

  class << self
    # Creates a PaymentValidationError for Stripe not configured
    def stripe_not_configured(additional_actions: [])
      PaymentValidationError.new(
        error_type: STRIPE_NOT_CONFIGURED[:type],
        required_actions: ['configure_stripe'] + additional_actions,
        user_guidance: STRIPE_NOT_CONFIGURED
      )
    end

    # Creates a PaymentValidationError for Premium subscription required
    def premium_required(additional_actions: [])
      PaymentValidationError.new(
        error_type: PREMIUM_REQUIRED[:type],
        required_actions: ['upgrade_subscription'] + additional_actions,
        user_guidance: PREMIUM_REQUIRED
      )
    end

    # Creates a PaymentValidationError for multiple missing requirements
    def multiple_requirements(missing_requirements, additional_actions: [])
      actions = missing_requirements.map { |req| "complete_#{req}" } + additional_actions
      
      PaymentValidationError.new(
        error_type: MULTIPLE_REQUIREMENTS[:type],
        required_actions: actions,
        user_guidance: MULTIPLE_REQUIREMENTS.merge(
          missing_requirements: missing_requirements
        )
      )
    end

    # Creates a PaymentValidationError for invalid payment configuration
    def invalid_payment_configuration(details: nil, additional_actions: [])
      guidance = INVALID_PAYMENT_CONFIGURATION.dup
      guidance[:details] = details if details

      PaymentValidationError.new(
        error_type: INVALID_PAYMENT_CONFIGURATION[:type],
        required_actions: ['review_payment_questions'] + additional_actions,
        user_guidance: guidance
      )
    end

    # Creates a PaymentValidationError for insufficient permissions
    def insufficient_permissions(additional_actions: [])
      PaymentValidationError.new(
        error_type: INSUFFICIENT_PERMISSIONS[:type],
        required_actions: ['contact_support'] + additional_actions,
        user_guidance: INSUFFICIENT_PERMISSIONS
      )
    end

    # Creates a custom PaymentValidationError
    def custom_error(error_type:, message:, required_actions: [], **user_guidance_options)
      PaymentValidationError.new(
        error_type: error_type,
        required_actions: required_actions,
        user_guidance: {
          type: error_type,
          message: message
        }.merge(user_guidance_options)
      )
    end

    # Finds error definition by type
    def find_error_definition(error_type)
      ALL_ERROR_TYPES.find { |error| error[:type] == error_type.to_s }
    end

    # Returns all error types grouped by category
    def errors_by_category
      ALL_ERROR_TYPES.group_by { |error| error[:category] }
    end

    # Returns all error types with specific severity
    def errors_by_severity(severity)
      ALL_ERROR_TYPES.select { |error| error[:severity] == severity.to_s }
    end
  end
end
</file>

<file path="models/admin_notification.rb">
class AdminNotification < ApplicationRecord
  belongs_to :user, optional: true

  # Event types
  EVENT_TYPES = {
    user_registered: 'user_registered',
    user_upgraded: 'user_upgraded',
    user_downgraded: 'user_downgraded',
    trial_started: 'trial_started',
    trial_expired: 'trial_expired',
    trial_ending_soon: 'trial_ending_soon',
    payment_failed: 'payment_failed',
    payment_succeeded: 'payment_succeeded',
    form_created: 'form_created',
    form_published: 'form_published',
    high_response_volume: 'high_response_volume',
    integration_connected: 'integration_connected',
    integration_failed: 'integration_failed',
    user_inactive: 'user_inactive',
    suspicious_activity: 'suspicious_activity',
    system: 'system'
  }.freeze

  # Priorities
  PRIORITIES = {
    low: 'low',
    normal: 'normal',
    high: 'high',
    critical: 'critical'
  }.freeze

  # Categories
  CATEGORIES = {
    user_activity: 'user_activity',
    billing: 'billing',
    system: 'system',
    security: 'security'
  }.freeze

  validates :event_type, presence: true, inclusion: { in: EVENT_TYPES.values }
  validates :title, presence: true
  validates :priority, inclusion: { in: PRIORITIES.values }
  validates :category, inclusion: { in: CATEGORIES.values }, allow_nil: true

  scope :unread, -> { where(read_at: nil) }
  scope :read, -> { where.not(read_at: nil) }
  scope :by_priority, ->(priority) { where(priority: priority) }
  scope :by_event_type, ->(event_type) { where(event_type: event_type) }
  scope :recent, -> { order(created_at: :desc) }
  scope :today, -> { where(created_at: Date.current.beginning_of_day..Date.current.end_of_day) }
  scope :this_week, -> { where(created_at: 1.week.ago..Time.current) }

  def read?
    read_at.present?
  end

  def unread?
    !read?
  end

  def mark_as_read!
    update!(read_at: Time.current) unless read?
  end

  def priority_color
    case priority
    when 'critical' then 'text-red-600 bg-red-50'
    when 'high' then 'text-orange-600 bg-orange-50'
    when 'normal' then 'text-blue-600 bg-blue-50'
    when 'low' then 'text-gray-600 bg-gray-50'
    else 'text-gray-600 bg-gray-50'
    end
  end

  def priority_icon
    case priority
    when 'critical' then ''
    when 'high' then ''
    when 'normal' then ''
    when 'low' then ''
    else ''
    end
  end

  def event_icon
    case event_type
    when 'user_registered' then ''
    when 'user_upgraded' then ''
    when 'user_downgraded' then ''
    when 'trial_started' then ''
    when 'trial_expired' then ''
    when 'trial_ending_soon' then ''
    when 'payment_failed' then ''
    when 'payment_succeeded' then ''
    when 'form_created' then ''
    when 'form_published' then ''
    when 'high_response_volume' then ''
    when 'integration_connected' then ''
    when 'integration_failed' then ''
    when 'user_inactive' then ''
    when 'suspicious_activity' then ''
    when 'system' then ''
    else ''
    end
  end

  # Class methods for creating notifications
  class << self
    def notify_user_registered(user)
      create!(
        event_type: EVENT_TYPES[:user_registered],
        title: "New user registered",
        message: "#{user.email} has joined AgentForm",
        user: user,
        priority: PRIORITIES[:normal],
        category: CATEGORIES[:user_activity],
        metadata: {
          user_email: user.email,
          user_role: user.role,
          registration_time: user.created_at
        }
      )
    end

    def notify_user_upgraded(user, from_plan, to_plan)
      create!(
        event_type: EVENT_TYPES[:user_upgraded],
        title: "User upgraded subscription",
        message: "#{user.email} upgraded from #{from_plan} to #{to_plan}",
        user: user,
        priority: PRIORITIES[:high],
        category: CATEGORIES[:billing],
        metadata: {
          user_email: user.email,
          from_plan: from_plan,
          to_plan: to_plan,
          upgrade_time: Time.current
        }
      )
    end

    def notify_trial_started(user)
      create!(
        event_type: EVENT_TYPES[:trial_started],
        title: "Trial started",
        message: "#{user.email} started their premium trial",
        user: user,
        priority: PRIORITIES[:normal],
        category: CATEGORIES[:billing],
        metadata: {
          user_email: user.email,
          trial_start: user.trial_started_at,
          trial_end: user.trial_ends_at
        }
      )
    end

    def notify_trial_expired(user)
      create!(
        event_type: EVENT_TYPES[:trial_expired],
        title: "Trial expired",
        message: "#{user.email}'s premium trial has expired",
        user: user,
        priority: PRIORITIES[:high],
        category: CATEGORIES[:billing],
        metadata: {
          user_email: user.email,
          trial_end: user.trial_ends_at,
          expired_at: Time.current
        }
      )
    end

    def notify_payment_failed(user, amount, error_message = nil)
      create!(
        event_type: EVENT_TYPES[:payment_failed],
        title: "Payment failed",
        message: "Payment of $#{amount} failed for #{user.email}",
        user: user,
        priority: PRIORITIES[:high],
        category: CATEGORIES[:billing],
        metadata: {
          user_email: user.email,
          amount: amount,
          error_message: error_message,
          failed_at: Time.current
        }
      )
    end

    def notify_high_response_volume(user, form, response_count)
      create!(
        event_type: EVENT_TYPES[:high_response_volume],
        title: "High response volume detected",
        message: "Form '#{form.title}' by #{user.email} received #{response_count} responses today",
        user: user,
        priority: PRIORITIES[:normal],
        category: CATEGORIES[:user_activity],
        metadata: {
          user_email: user.email,
          form_id: form.id,
          form_title: form.title,
          response_count: response_count,
          detected_at: Time.current
        }
      )
    end

    def notify_suspicious_activity(user, activity_type, details)
      create!(
        event_type: EVENT_TYPES[:suspicious_activity],
        title: "Suspicious activity detected",
        message: "Suspicious #{activity_type} detected for #{user.email}",
        user: user,
        priority: PRIORITIES[:critical],
        category: CATEGORIES[:security],
        metadata: {
          user_email: user.email,
          activity_type: activity_type,
          details: details,
          detected_at: Time.current
        }
      )
    end
  end
end
</file>

<file path="models/analysis_report.rb">
class AnalysisReport < ApplicationRecord
  belongs_to :form_response

  validates :report_type, presence: true
  validates :markdown_content, presence: true, unless: :generating?
  validates :status, inclusion: { in: %w[generating completed failed] }

  scope :completed, -> { where(status: 'completed') }
  scope :recent, -> { order(created_at: :desc) }
  scope :by_type, ->(type) { where(report_type: type) }

  def completed?
    status == 'completed'
  end

  def failed?
    status == 'failed'
  end

  def generating?
    status == 'generating'
  end

  def download_url
    return nil unless completed? && file_path.present?
    Rails.application.routes.url_helpers.download_analysis_report_path(self)
  end

  def file_exists?
    file_path.present? && File.exist?(file_path)
  end

  def formatted_file_size
    return 'Unknown' unless file_size.present?
    
    if file_size < 1024
      "#{file_size} bytes"
    elsif file_size < 1024 * 1024
      "#{(file_size / 1024.0).round(1)} KB"
    else
      "#{(file_size / (1024.0 * 1024)).round(1)} MB"
    end
  end

  def sections_included
    metadata&.dig('sections_included') || []
  end

  def ai_models_used
    metadata&.dig('ai_models_used') || []
  end

  def generation_duration
    return nil unless generated_at.present? && created_at.present?
    ((generated_at - created_at) / 1.minute).round(2)
  end

  # Cleanup old reports
  def self.cleanup_expired
    where('expires_at < ?', Time.current).find_each do |report|
      File.delete(report.file_path) if report.file_path && File.exist?(report.file_path)
      report.destroy
    end
  end
end
</file>

<file path="models/api_token.rb">
# frozen_string_literal: true

class ApiToken < ApplicationRecord
  # Associations
  belongs_to :user

  # Validations
  validates :name, presence: true
  validates :token, presence: true, uniqueness: true

  # Callbacks
  before_create :generate_token

  # Scopes
  scope :active, -> { where(active: true) }
  scope :expired, -> { where('expires_at < ?', Time.current) }
  scope :valid, -> { active.where('expires_at IS NULL OR expires_at > ?', Time.current) }
  scope :recent, -> { order(created_at: :desc) }

  # Core Methods
  def active?
    active && !expired?
  end

  def expired?
    expires_at.present? && expires_at < Time.current
  end

  def can_access?(resource, action)
    return false unless active?
    
    # Check if token has permission for this resource and action
    return true if permissions.blank? # No restrictions means full access
    
    resource_permissions = permissions[resource.to_s]
    return false if resource_permissions.nil?
    
    # Check if action is allowed
    case resource_permissions
    when Array
      resource_permissions.include?(action.to_s)
    when Hash
      resource_permissions[action.to_s] == true
    when true
      true # Full access to resource
    else
      false
    end
  end

  def record_usage!
    increment!(:usage_count)
    update!(last_used_at: Time.current)
  end

  def revoke!
    update!(active: false)
  end

  def extend_expiration(duration)
    new_expiration = expires_at ? expires_at + duration : Time.current + duration
    update!(expires_at: new_expiration)
  end

  def usage_summary
    {
      name: name,
      token_preview: "#{token[0..7]}...",
      created_at: created_at,
      last_used_at: last_used_at,
      usage_count: usage_count,
      expires_at: expires_at,
      active: active?,
      permissions: permissions_summary
    }
  end

  def permissions_summary
    return 'Full access' if permissions.blank?
    
    summary = []
    permissions.each do |resource, actions|
      case actions
      when true
        summary << "#{resource}: full access"
      when Array
        summary << "#{resource}: #{actions.join(', ')}"
      when Hash
        allowed_actions = actions.select { |_, allowed| allowed }.keys
        summary << "#{resource}: #{allowed_actions.join(', ')}"
      end
    end
    
    summary.join('; ')
  end

  def self.authenticate(token_string)
    return nil if token_string.blank?
    
    # Remove 'Bearer ' prefix if present
    clean_token = token_string.gsub(/^Bearer\s+/, '')
    
    token = find_by(token: clean_token)
    return nil unless token&.active?
    
    token.record_usage!
    token
  end

  def self.create_for_user(user, name:, expires_in: nil, permissions: {})
    create!(
      user: user,
      name: name,
      expires_at: expires_in ? Time.current + expires_in : nil,
      permissions: permissions
    )
  end

  def self.cleanup_expired
    expired.update_all(active: false)
  end

  # Default permission templates
  def self.readonly_permissions
    {
      'forms' => ['index', 'show'],
      'responses' => ['index', 'show'],
      'analytics' => ['show']
    }
  end

  def self.full_permissions
    {
      'forms' => true,
      'responses' => true,
      'analytics' => true,
      'users' => ['show', 'update']
    }
  end

  def self.forms_only_permissions
    {
      'forms' => true,
      'responses' => ['create', 'show']
    }
  end

  private

  def generate_token
    return if token.present?
    
    loop do
      # Generate a secure random token
      self.token = SecureRandom.urlsafe_base64(32)
      break unless self.class.exists?(token: token)
    end
  end
end
</file>

<file path="models/application_record.rb">
class ApplicationRecord < ActiveRecord::Base
  primary_abstract_class
end
</file>

<file path="models/audit_log.rb">
# frozen_string_literal: true

class AuditLog < ApplicationRecord
  belongs_to :user, optional: true

  validates :event_type, presence: true
  validates :ip_address, presence: false
  validate :valid_ip_address_format, if: -> { ip_address.present? }

  scope :security_events, -> { where(event_type: security_event_types) }
  scope :recent, -> { order(created_at: :desc) }
  scope :for_user, ->(user_id) { where(user_id: user_id) }
  scope :admin_actions, -> { where(event_type: 'admin_action') }
  scope :failed_attempts, -> { where(event_type: ['sql_injection_attempt', 'xss_attempt', 'csrf_failure', 'unauthorized_admin_access']) }
  scope :by_ip, ->(ip) { where(ip_address: ip) }
  scope :today, -> { where(created_at: Date.current.beginning_of_day..Date.current.end_of_day) }

  def self.security_event_types
    [
      'file_validation_failed',
      'suspicious_content_detected',
      'inappropriate_content_detected',
      'rate_limit_exceeded',
      'prompt_injection_attempt',
      'api_key_rotation',
      'usage_anomaly_detected',
      'admin_rate_limit_exceeded',
      'sql_injection_attempt',
      'xss_attempt',
      'csrf_failure',
      'unauthorized_admin_access',
      'suspicious_admin_activity'
    ]
  end

  def security_event?
    self.class.security_event_types.include?(event_type)
  end

  def admin_action?
    event_type == 'admin_action'
  end

  def failed_security_attempt?
    %w[sql_injection_attempt xss_attempt csrf_failure unauthorized_admin_access].include?(event_type)
  end

  # Class methods for security monitoring
  def self.suspicious_activity_for_ip(ip_address, hours = 24)
    where(ip_address: ip_address)
      .where(created_at: hours.hours.ago..Time.current)
      .failed_attempts
      .count
  end

  def self.admin_activity_summary(user_id, days = 7)
    admin_actions
      .for_user(user_id)
      .where(created_at: days.days.ago..Time.current)
      .group(:event_type)
      .count
  end

  def self.security_alerts_today
    security_events.today.count
  end

  def self.top_suspicious_ips(limit = 10)
    failed_attempts
      .where(created_at: 24.hours.ago..Time.current)
      .group(:ip_address)
      .order('count_id DESC')
      .limit(limit)
      .count(:id)
  end

  private

  def valid_ip_address_format
    return if ip_address.blank?
    
    begin
      # Use Ruby's built-in IPAddr class for proper IP validation
      IPAddr.new(ip_address)
    rescue IPAddr::InvalidAddressError
      errors.add(:ip_address, 'is not a valid IP address')
    end
  end
end
</file>

<file path="models/current.rb">
# frozen_string_literal: true

# Current context for tracking request-scoped data
# This provides a thread-safe way to access the current user and other request data
class Current < ActiveSupport::CurrentAttributes
  attribute :user, :request_id, :user_agent, :ip_address, :api_token

  # Convenience methods
  def user_id
    user&.id
  end

  def authenticated?
    user.present?
  end

  def admin?
    user&.admin?
  end

  def premium?
    user&.premium? || user&.admin?
  end

  # Reset callback to ensure clean state between requests
  resets do
    Time.zone = nil
  end
end
</file>

<file path="models/discount_code_usage.rb">
class DiscountCodeUsage < ApplicationRecord
  include AdminCacheable
  
  belongs_to :discount_code
  belongs_to :user

  validates :user_id, uniqueness: true, presence: true
  validates :discount_code_id, presence: true
  validates :original_amount, presence: true, numericality: { greater_than: 0 }
  validates :discount_amount, presence: true, numericality: { greater_than: 0 }
  validates :final_amount, presence: true, numericality: { greater_than_or_equal_to: 0 }
  validates :used_at, presence: true

  validate :final_amount_calculation_is_correct
  validate :discount_amount_not_greater_than_original

  scope :recent, -> { order(used_at: :desc) }
  scope :by_discount_code, ->(code) { where(discount_code: code) }
  scope :by_user, ->(user) { where(user: user) }

  def savings_percentage
    return 0 if original_amount.zero?
    (discount_amount.to_f / original_amount * 100).round(1)
  end

  def formatted_original_amount
    ActionController::Base.helpers.number_to_currency(original_amount / 100.0)
  end

  def formatted_discount_amount
    ActionController::Base.helpers.number_to_currency(discount_amount / 100.0)
  end

  def formatted_final_amount
    ActionController::Base.helpers.number_to_currency(final_amount / 100.0)
  end

  private

  def final_amount_calculation_is_correct
    return unless original_amount.present? && discount_amount.present? && final_amount.present?
    
    expected_final_amount = original_amount - discount_amount
    unless final_amount == expected_final_amount
      errors.add(:final_amount, "must equal original amount minus discount amount (#{expected_final_amount})")
    end
  end

  def discount_amount_not_greater_than_original
    return unless original_amount.present? && discount_amount.present?
    
    if discount_amount > original_amount
      errors.add(:discount_amount, "cannot be greater than original amount")
    end
  end
end
</file>

<file path="models/discount_code.rb">
class DiscountCode < ApplicationRecord
  include AdminCacheable
  
  belongs_to :created_by, class_name: 'User'
  has_many :discount_code_usages, dependent: :destroy
  has_many :users, through: :discount_code_usages

  validates :code, presence: true, uniqueness: { case_sensitive: false }
  validates :discount_percentage, presence: true, inclusion: { in: 1..99 }
  validates :max_usage_count, numericality: { greater_than: 0 }, allow_nil: true
  validates :current_usage_count, presence: true, numericality: { greater_than_or_equal_to: 0 }

  before_validation :normalize_code

  scope :active, -> { where(active: true) }
  scope :expired, -> { where('expires_at < ?', Time.current) }
  scope :available, -> { active.where('expires_at IS NULL OR expires_at > ?', Time.current) }

  def expired?
    expires_at.present? && expires_at < Time.current
  end

  def usage_limit_reached?
    max_usage_count.present? && current_usage_count >= max_usage_count
  end

  def available?
    active? && !expired? && !usage_limit_reached?
  end

  def usage_percentage
    return 0 if max_usage_count.nil?
    return 100 if max_usage_count.zero?
    (current_usage_count.to_f / max_usage_count * 100).round(1)
  end

  def remaining_uses
    return nil if max_usage_count.nil?
    [max_usage_count - current_usage_count, 0].max
  end

  def revenue_impact
    discount_code_usages.sum(:discount_amount)
  end

  # Analytics methods
  def average_discount_amount
    return 0 if current_usage_count.zero?
    revenue_impact / current_usage_count
  end

  def total_original_amount
    discount_code_usages.sum(:original_amount)
  end

  def conversion_rate
    return 0 if current_usage_count.zero?
    (current_usage_count.to_f / total_views * 100).round(2) if respond_to?(:total_views)
  end

  def usage_by_month
    discount_code_usages
      .group_by_month(:used_at, last: 12)
      .count
  end

  def recent_usage_trend
    last_30_days = discount_code_usages.where(used_at: 30.days.ago..Time.current)
    previous_30_days = discount_code_usages.where(used_at: 60.days.ago..30.days.ago)
    
    current_count = last_30_days.count
    previous_count = previous_30_days.count
    
    return 0 if previous_count.zero?
    
    ((current_count - previous_count).to_f / previous_count * 100).round(1)
  end

  # Class methods for admin analytics (optimized)
  def self.total_revenue_impact
    DiscountCodeUsage.sum(:discount_amount)
  end

  def self.most_used(limit = 10)
    select('discount_codes.*, discount_codes.current_usage_count')
      .order(current_usage_count: :desc)
      .limit(limit)
  end

  def self.highest_revenue_impact(limit = 10)
    select('discount_codes.*, SUM(discount_code_usages.discount_amount) as revenue_impact')
      .joins(:discount_code_usages)
      .group('discount_codes.id')
      .order('revenue_impact DESC')
      .limit(limit)
  end

  def self.usage_stats_summary
    # Use a single query with aggregations for better performance
    stats = connection.select_one(<<~SQL)
      SELECT 
        COUNT(*) as total_codes,
        COUNT(CASE WHEN active = true THEN 1 END) as active_codes,
        COUNT(CASE WHEN expires_at < NOW() THEN 1 END) as expired_codes,
        SUM(current_usage_count) as total_usage,
        AVG(discount_percentage) as avg_discount_percentage
      FROM discount_codes
    SQL
    
    {
      total_codes: stats['total_codes'].to_i,
      active_codes: stats['active_codes'].to_i,
      expired_codes: stats['expired_codes'].to_i,
      total_usage: stats['total_usage'].to_i,
      total_revenue_impact: total_revenue_impact,
      average_discount_percentage: stats['avg_discount_percentage'].to_f.round(1)
    }
  end

  # Optimized method for dashboard statistics
  def self.dashboard_stats
    Rails.cache.fetch('discount_codes_dashboard_stats', expires_in: 5.minutes) do
      usage_stats_summary
    end
  end

  private

  def normalize_code
    self.code = code&.upcase&.strip
  end
end
</file>

<file path="models/dynamic_question.rb">
# frozen_string_literal: true

class DynamicQuestion < ApplicationRecord
  # Associations
  belongs_to :form_response
  belongs_to :generated_from_question, class_name: 'FormQuestion', optional: true

  # Validations
  validates :title, presence: true
  validates :question_type, inclusion: { in: FormQuestion::QUESTION_TYPES }

  # Aliases for backward compatibility
  alias_attribute :configuration, :question_config

  # Scopes
  scope :answered, -> { where.not(answer_data: {}) }
  scope :unanswered, -> { where(answer_data: {}) }
  scope :recent, -> { order(created_at: :desc) }
  scope :by_confidence, ->(min_confidence) { where('ai_confidence >= ?', min_confidence) }

  # Callbacks
  before_save :ensure_configuration_defaults

  # Core Methods
  def question_type_handler
    # Reuse the same handler system as FormQuestion
    "QuestionTypes::#{question_type.classify}".constantize.new(self)
  rescue NameError
    QuestionTypes::Base.new(self)
  end

  def validate_answer(answer)
    question_type_handler.validate_answer(answer)
  end

  def process_answer(raw_answer)
    processed = question_type_handler.process_answer(raw_answer)
    
    # Store the processed answer
    self.answer_data = {
      'raw_answer' => raw_answer,
      'processed_answer' => processed,
      'answered_at' => Time.current.iso8601,
      'question_type' => question_type
    }
    
    processed
  end

  def render_component
    question_type_handler.render_component
  end

  def generation_reasoning
    generation_context&.dig('reasoning') || 'No reasoning provided'
  end

  def was_answered?
    answer_data.present? && answer_data != {}
  end

  def formatted_answer
    return 'Not answered' unless was_answered?
    
    processed_answer = answer_data['processed_answer']
    
    case question_type
    when 'multiple_choice', 'checkbox'
      format_choice_answer(processed_answer)
    when 'rating', 'scale'
      format_rating_answer(processed_answer)
    when 'nps_score'
      format_nps_answer(processed_answer)
    when 'date'
      format_date_answer(processed_answer)
    when 'datetime'
      format_datetime_answer(processed_answer)
    when 'file_upload', 'image_upload'
      format_file_answer(processed_answer)
    else
      processed_answer.to_s
    end
  end

  def answer_text
    return '' unless was_answered?
    
    answer_data['processed_answer'].to_s
  end

  def generation_metadata
    {
      generated_from: generated_from_question&.title,
      generation_model: generation_model,
      ai_confidence: ai_confidence,
      generation_prompt: generation_prompt,
      context: generation_context,
      created_at: created_at
    }
  end

  def response_summary
    {
      id: id,
      title: title,
      question_type: question_type,
      answer: formatted_answer,
      was_answered: was_answered?,
      response_time: response_time_ms,
      ai_confidence: ai_confidence,
      generation_metadata: generation_metadata
    }
  end

  def similar_to_original?
    return false unless generated_from_question
    
    # Check if the dynamic question is similar to the original
    title_similarity = calculate_text_similarity(title, generated_from_question.title)
    type_match = question_type == generated_from_question.question_type
    
    title_similarity > 0.7 || type_match
  end

  def effectiveness_score
    # Calculate how effective this dynamic question was
    base_score = was_answered? ? 0.5 : 0.0
    
    # Add points for AI confidence
    confidence_score = (ai_confidence || 0.0) * 0.3
    
    # Add points for response time (faster is better, but not too fast)
    time_score = if response_time_ms.present?
      optimal_time = 5000.0 # 5 seconds
      if response_time_ms < 1000 # Too fast, might be careless
        0.1
      elsif response_time_ms <= optimal_time
        0.2
      elsif response_time_ms <= 30000 # Up to 30 seconds is reasonable
        0.15
      else
        0.05 # Too slow
      end
    else
      0.1
    end
    
    (base_score + confidence_score + time_score).round(3)
  end

  def should_generate_followup?
    return false unless was_answered?
    
    # Generate followup if:
    # 1. AI confidence is high enough
    # 2. Answer suggests more information could be gathered
    # 3. Original question was configured for followups
    
    high_confidence = (ai_confidence || 0.0) >= 0.7
    original_supports_followups = generated_from_question&.generates_followups? || false
    answer_suggests_followup = answer_suggests_more_info?
    
    high_confidence && (original_supports_followups || answer_suggests_followup)
  end

  def next_followup_context
    return {} unless should_generate_followup?
    
    {
      previous_question: title,
      previous_answer: formatted_answer,
      original_question: generated_from_question&.title,
      form_context: form_response.answers_hash,
      confidence_level: ai_confidence,
      suggested_direction: suggest_followup_direction
    }
  end

  private

  def ensure_configuration_defaults
    self.configuration ||= {}
    self.generation_context ||= {}
    
    # Set default configuration based on question type
    case question_type
    when 'text_short'
      self.configuration['max_length'] ||= 255
    when 'text_long'
      self.configuration['max_length'] ||= 5000
    when 'rating'
      self.configuration['min_value'] ||= 1
      self.configuration['max_value'] ||= 5
    when 'scale'
      self.configuration['min_value'] ||= 0
      self.configuration['max_value'] ||= 10
    end
  end

  def format_choice_answer(processed_answer)
    return '' if processed_answer.blank?
    
    choices = processed_answer.is_a?(Array) ? processed_answer : [processed_answer]
    choices.join(', ')
  end

  def format_rating_answer(processed_answer)
    max_value = configuration.dig('max_value') || 5
    "#{processed_answer}/#{max_value}"
  end

  def format_nps_answer(processed_answer)
    score = processed_answer.to_i
    category = case score
               when 0..6 then 'Detractor'
               when 7..8 then 'Passive'
               when 9..10 then 'Promoter'
               else 'Unknown'
               end
    "#{score} (#{category})"
  end

  def format_date_answer(processed_answer)
    Date.parse(processed_answer.to_s).strftime('%B %d, %Y')
  rescue
    processed_answer.to_s
  end

  def format_datetime_answer(processed_answer)
    Time.parse(processed_answer.to_s).strftime('%B %d, %Y at %I:%M %p')
  rescue
    processed_answer.to_s
  end

  def format_file_answer(processed_answer)
    return 'No files' if processed_answer.blank?
    
    files = processed_answer.is_a?(Array) ? processed_answer : [processed_answer]
    filenames = files.map { |f| f['filename'] || 'Unknown file' }
    "#{files.count} file(s): #{filenames.join(', ')}"
  end

  def calculate_text_similarity(text1, text2)
    # Simple similarity calculation based on common words
    return 0.0 if text1.blank? || text2.blank?
    
    words1 = text1.downcase.split(/\W+/).reject(&:blank?)
    words2 = text2.downcase.split(/\W+/).reject(&:blank?)
    
    return 0.0 if words1.empty? || words2.empty?
    
    common_words = words1 & words2
    total_unique_words = (words1 | words2).length
    
    common_words.length.to_f / total_unique_words
  end

  def answer_suggests_more_info?
    return false unless was_answered?
    
    answer = answer_text.downcase
    
    # Look for indicators that suggest more information could be gathered
    followup_indicators = [
      'because', 'since', 'due to', 'reason', 'explain', 'detail',
      'specifically', 'particularly', 'especially', 'mainly', 'primarily',
      'however', 'but', 'although', 'though', 'except', 'besides',
      'additionally', 'also', 'furthermore', 'moreover', 'plus'
    ]
    
    followup_indicators.any? { |indicator| answer.include?(indicator) }
  end

  def suggest_followup_direction
    return 'general' unless was_answered?
    
    answer = answer_text.downcase
    
    if answer.match?(/\b(why|reason|because|since)\b/)
      'reasoning'
    elsif answer.match?(/\b(how|method|process|way)\b/)
      'methodology'
    elsif answer.match?(/\b(when|time|date|schedule)\b/)
      'timing'
    elsif answer.match?(/\b(where|location|place)\b/)
      'location'
    elsif answer.match?(/\b(who|person|people|team)\b/)
      'people'
    elsif answer.match?(/\b(what|which|specific|detail)\b/)
      'specifics'
    else
      'elaboration'
    end
  end
end
</file>

<file path="models/export_job.rb">
# frozen_string_literal: true

class ExportJob < ApplicationRecord
  belongs_to :user
  belongs_to :form
  
  enum :status, {
    pending: 'pending',
    processing: 'processing', 
    completed: 'completed',
    failed: 'failed',
    cancelled: 'cancelled'
  }
  
  validates :export_type, inclusion: { in: %w[google_sheets excel csv] }
  validates :job_id, presence: true, uniqueness: true
  
  scope :recent, -> { order(created_at: :desc) }
  scope :for_export_type, ->(type) { where(export_type: type) }
  scope :google_sheets, -> { where(export_type: 'google_sheets') }
  
  def duration
    return nil unless started_at && completed_at
    completed_at - started_at
  end
  
  def success_rate
    return 0 if records_exported.zero?
    total_responses = form.form_responses.count
    return 100 if total_responses.zero?
    (records_exported.to_f / total_responses * 100).round(2)
  end
  
  def progress_percentage
    case status
    when 'pending' then 0
    when 'processing' then 50
    when 'completed' then 100
    when 'failed', 'cancelled' then 0
    else 25
    end
  end
end
</file>

<file path="models/form_analytic.rb">
# frozen_string_literal: true

class FormAnalytic < ApplicationRecord
  # Associations
  belongs_to :form

  # Validations
  validates :date, presence: true
  validates :period_type, presence: true

  # Scopes
  scope :for_period, ->(start_date, end_date) { where(date: start_date..end_date) }
  scope :by_period_type, ->(type) { where(period_type: type) }
  scope :recent, -> { order(date: :desc) }
  scope :daily, -> { where(period_type: 'daily') }
  scope :weekly, -> { where(period_type: 'weekly') }
  scope :monthly, -> { where(period_type: 'monthly') }

  # Class Methods
  def self.aggregate_for_period(form, start_date, end_date)
    analytics = for_period(start_date, end_date).where(form: form)
    
    {
      total_views: analytics.sum(:views_count),
      total_starts: analytics.sum(:started_responses_count),
      total_completions: analytics.sum(:completed_responses_count),
      total_abandons: analytics.sum(:abandoned_responses_count),
      avg_completion_time: analytics.average(:avg_completion_time)&.round(2) || 0.0
    }
  end

  def self.create_daily_snapshot(form, date = Date.current)
    # Calculate metrics for the given date
    responses = form.form_responses.where(created_at: date.beginning_of_day..date.end_of_day)
    
    views_count = form.views_count || 0 # Assuming form tracks views
    starts_count = responses.count
    completions_count = responses.completed.count
    abandons_count = responses.abandoned.count
    
    # Calculate average times
    completed_responses = responses.completed.where.not(completed_at: nil)
    avg_completion_time = if completed_responses.any?
      completed_responses.average('EXTRACT(EPOCH FROM (completed_at - created_at))')&.to_f || 0.0
    else
      0.0
    end
    
    # Calculate average response time per question
    question_responses = QuestionResponse.joins(form_response: :form)
                                        .where(forms: { id: form.id })
                                        .where(created_at: date.beginning_of_day..date.end_of_day)
                                        .where.not(response_time_ms: nil)
    
    avg_time_per_question_ms = question_responses.average(:response_time_ms)&.to_f || 0.0
    
    # Create or update the analytic record
    find_or_create_by(form: form, date: date, period_type: 'daily') do |analytic|
      analytic.views_count = views_count
      analytic.started_responses_count = starts_count
      analytic.completed_responses_count = completions_count
      analytic.abandoned_responses_count = abandons_count
      analytic.avg_completion_time = avg_completion_time.to_i
      analytic.avg_time_per_question = avg_time_per_question_ms.to_i
    end
  end

  # Instance Methods
  def calculated_completion_rate
    return 0.0 if started_responses_count.zero?
    
    (completed_responses_count.to_f / started_responses_count * 100).round(2)
  end

  def calculated_abandonment_rate
    return 0.0 if started_responses_count.zero?
    
    (abandoned_responses_count.to_f / started_responses_count * 100).round(2)
  end

  def performance_score
    # Calculate a composite performance score (0-100)
    completion_weight = 0.4
    speed_weight = 0.3
    engagement_weight = 0.3
    
    # Completion score (0-100)
    completion_score = calculated_completion_rate
    
    # Speed score (inverse of completion time, normalized)
    # Assume 5 minutes (300 seconds) is optimal, 30 minutes (1800 seconds) is poor
    speed_score = if avg_completion_time > 0
      optimal_time = 300.0
      max_acceptable_time = 1800.0
      
      if avg_completion_time <= optimal_time
        100.0
      elsif avg_completion_time >= max_acceptable_time
        20.0
      else
        # Linear interpolation between optimal and max acceptable
        100.0 - ((avg_completion_time - optimal_time) / (max_acceptable_time - optimal_time) * 80.0)
      end
    else
      50.0 # Neutral score if no data
    end
    
    # Engagement score (based on view-to-start conversion)
    engagement_score = if views_count > 0
      (started_responses_count.to_f / views_count * 100).clamp(0, 100)
    else
      50.0 # Neutral score if no view data
    end
    
    # Weighted average
    total_score = (completion_score * completion_weight) + 
                  (speed_score * speed_weight) + 
                  (engagement_score * engagement_weight)
    
    total_score.round(2)
  end

  def trend_direction
    # Compare with previous period to determine trend
    previous_analytic = self.class.where(form: form, period_type: period_type)
                                  .where('date < ?', date)
                                  .order(date: :desc)
                                  .first
    
    return 'neutral' unless previous_analytic
    
    current_score = performance_score
    previous_score = previous_analytic.performance_score
    
    difference = current_score - previous_score
    
    case difference
    when -Float::INFINITY..-5.0
      'declining'
    when -5.0..5.0
      'stable'
    when 5.0..Float::INFINITY
      'improving'
    else
      'neutral'
    end
  end

  def conversion_funnel
    {
      views: views_count,
      starts: started_responses_count,
      completions: completed_responses_count,
      abandons: abandoned_responses_count,
      view_to_start_rate: views_count > 0 ? (started_responses_count.to_f / views_count * 100).round(2) : 0.0,
      start_to_completion_rate: calculated_completion_rate,
      abandonment_rate: calculated_abandonment_rate
    }
  end

  def time_metrics
    {
      avg_completion_time_seconds: avg_completion_time,
      avg_completion_time_formatted: format_duration(avg_completion_time),
      avg_response_time_ms: avg_time_per_question,
      avg_response_time_formatted: "#{avg_time_per_question.round(0)}ms"
    }
  end

  def summary
    {
      date: date,
      period_type: period_type,
      performance_score: performance_score,
      trend: trend_direction,
      completion_rate: calculated_completion_rate,
      abandonment_rate: calculated_abandonment_rate,
      funnel: conversion_funnel,
      timing: time_metrics
    }
  end

  private

  def format_duration(seconds)
    return '0s' if seconds.nil? || seconds.zero?
    
    if seconds < 60
      "#{seconds.round(0)}s"
    elsif seconds < 3600
      minutes = (seconds / 60).round(0)
      remaining_seconds = (seconds % 60).round(0)
      "#{minutes}m #{remaining_seconds}s"
    else
      hours = (seconds / 3600).round(0)
      remaining_minutes = ((seconds % 3600) / 60).round(0)
      "#{hours}h #{remaining_minutes}m"
    end
  end
end
</file>

<file path="models/form_question.rb">
# frozen_string_literal: true

class FormQuestion < ApplicationRecord
  # Associations
  belongs_to :form
  has_many :question_responses, dependent: :destroy
  has_many :dynamic_questions, foreign_key: 'generated_from_question_id', dependent: :destroy

  # Constants
  QUESTION_TYPES = %w[
    text_short text_long email phone url number
    multiple_choice single_choice checkbox
    rating scale slider yes_no boolean
    date datetime time
    file_upload image_upload
    address location payment signature
    nps_score matrix ranking drag_drop
  ].freeze

  # Enums
  enum :question_type, QUESTION_TYPES.index_with(&:itself)

  # Validations
  validates :title, presence: true, length: { maximum: 500 }
  validates :position, presence: true, numericality: { greater_than: 0 }
  validates :form, presence: true
  validates :question_type, inclusion: { in: QUESTION_TYPES }

  # Custom validations
  validate :validate_question_config
  validate :validate_conditional_logic

  # Aliases for backward compatibility
  alias_attribute :configuration, :question_config

  # Scopes
  scope :visible, -> { where(hidden: false) }
  scope :required_questions, -> { where(required: true) }
  scope :ai_enhanced, -> { where(ai_enhanced: true) }

  # Core Methods
  def question_type_handler
    # Simplified handler for now
    @question_type_handler ||= BasicQuestionHandler.new(self)
  end
  
  class BasicQuestionHandler
    def initialize(question)
      @question = question
    end
    
    def validate_answer(answer)
      [] # Return empty errors array for now
    end
    
    def process_answer(answer)
      answer # Return answer as-is
    end
    
    def render_component
      @question.question_type
    end
    
    def default_value
      nil
    end
  end

  def render_component
    question_type_handler.render_component
  end

  def validate_answer(answer)
    question_type_handler.validate_answer(answer)
  end

  def process_answer(raw_answer)
    question_type_handler.process_answer(raw_answer)
  end

  def default_value
    question_type_handler.default_value
  end

  def ai_enhanced?
    ai_enhanced && ai_config.present?
  end

  def ai_features
    return [] unless ai_enhanced?
    
    ai_config.fetch('features', [])
  end

  def position_rationale
    metadata&.dig('position_rationale')
  end

  def generation_data
    metadata&.dig('generation_data') || {}
  end

  def ai_confidence_threshold
    ai_config&.dig('confidence_threshold') || 0.7
  end

  def validation_enhancement_enabled?
    ai_features.include?('validation_enhancement')
  end

  def sentiment_analysis_enabled?
    ai_features.include?('sentiment_analysis')
  end

  def format_suggestions_enabled?
    ai_features.include?('format_suggestions')
  end

  def generates_followups?
    ai_features.include?('dynamic_followup')
  end

  def has_smart_validation?
    ai_features.include?('smart_validation')
  end

  def has_response_analysis?
    ai_features.include?('response_analysis')
  end

  def has_conditional_logic?
    conditional_enabled? && conditional_logic.present?
  end

  def conditional_rules
    return [] unless has_conditional_logic?
    
    conditional_logic.fetch('rules', [])
  end

def should_show_for_response?(form_response)
  return true unless has_conditional_logic?
  
  Rails.logger.info "    Evaluating conditional logic for question: #{title}"
  
  rules = conditional_rules
  return true if rules.empty?
  
  Rails.logger.info "    Rules to evaluate: #{rules.length}"
  
  # Verificar si alguna de las preguntas dependientes fue saltada
  dependency_check = check_dependency_chain(rules, form_response)
  if dependency_check[:has_skipped_dependencies]
    Rails.logger.info "    Question depends on skipped questions, handling gracefully"
    return handle_skipped_dependencies(dependency_check, rules, form_response)
  end
  
  # Evaluar todas las reglas - por defecto usamos AND logic
  logic_operator = conditional_logic.fetch('operator', 'and').downcase
  
  case logic_operator
  when 'and'
    # Todas las reglas deben ser verdaderas
    result = rules.all? { |rule| evaluate_condition(rule, form_response) }
  when 'or'
    # Al menos una regla debe ser verdadera
    result = rules.any? { |rule| evaluate_condition(rule, form_response) }
  else
    # Fallback a AND
    result = rules.all? { |rule| evaluate_condition(rule, form_response) }
  end
  
  Rails.logger.info "    Final conditional result: #{result}"
  result
end

  def choice_options
    return [] unless %w[multiple_choice single_choice checkbox].include?(question_type)
    
    question_config.fetch('options', [])
  end

  def rating_config
    return {} unless %w[rating scale nps_score].include?(question_type)
    
    {
      min: question_config.fetch('min_value', 1),
      max: question_config.fetch('max_value', 5),
      step: question_config.fetch('step', 1),
      labels: question_config.fetch('labels', {})
    }
  end

  def file_upload_config
    return {} unless %w[file_upload image_upload].include?(question_type)
    
    {
      max_size: question_config.fetch('max_size_mb', 10),
      allowed_types: question_config.fetch('allowed_types', []),
      multiple: question_config.fetch('multiple', false)
    }
  end

  def text_config
    return {} unless %w[text_short text_long].include?(question_type)
    
    {
      min_length: question_config.fetch('min_length', 0),
      max_length: question_config.fetch('max_length', question_type == 'text_short' ? 255 : 5000),
      placeholder: question_config.fetch('placeholder', ''),
      format: question_config.fetch('format', nil)
    }
  end

  def average_response_time_seconds
    question_responses.where.not(time_spent_seconds: 0).average(:time_spent_seconds)&.to_i || 0
  end

  def completion_rate
    return 0.0 if responses_count.zero?
    
    completed_responses = question_responses.where(skipped: false).count
    (completed_responses.to_f / responses_count * 100).round(2)
  end

  def analytics_summary(period = 30.days)
    {
      total_responses: question_responses.count,
      completion_rate: 100.0, # Placeholder
      avg_response_time: 30.0 # Placeholder
    }
  end

  def debug_conditional_setup(form_response = nil)
    puts "\n=== DEBUG: CONDITIONAL SETUP FOR #{title} ==="
    puts "Has conditional logic: #{has_conditional_logic?}"
    puts "Conditional enabled: #{conditional_enabled?}"
    puts "Conditional logic: #{conditional_logic}"
    puts "Conditional rules: #{conditional_rules}"
    
    if has_conditional_logic? && form_response
      puts "\n--- DEPENDENCY ANALYSIS ---"
      conditional_rules.each_with_index do |rule, index|
        puts "Rule #{index + 1}:"
        puts "  Question ID: #{rule['question_id']}"
        puts "  Operator: #{rule['operator']}"
        puts "  Expected Value: #{rule['value']}"
        
        # Find the dependent question
        dependent_question = FormQuestion.find_by(id: rule['question_id'])
        if dependent_question
          puts "  Dependent Question: #{dependent_question.title}"
          puts "  Dependent Question Type: #{dependent_question.question_type}"
          
          # Find the response
          response = form_response.question_responses.joins(:form_question)
                                .find_by(form_questions: { id: rule['question_id'] })
          
          if response
            puts "  Response exists: YES"
            puts "  Response skipped: #{response.skipped?}"
            puts "  Answer data: #{response.answer_data}"
            puts "  Answer text: #{response.answer_text}"
            actual_value = extract_actual_value(response)
            puts "  Extracted value: '#{actual_value}'"
            
            normalized_actual = normalize_value_for_comparison(actual_value, dependent_question.question_type)
            normalized_expected = normalize_value_for_comparison(rule['value'], dependent_question.question_type)
            puts "  Normalized actual: '#{normalized_actual}'"
            puts "  Normalized expected: '#{normalized_expected}'"
            
            result = evaluate_condition(rule, form_response)
            puts "  Evaluation result: #{result}"
          else
            puts "  Response exists: NO"
          end
        else
          puts "  Dependent Question: NOT FOUND"
        end
        puts ""
      end
    end
    puts "=== END DEBUG ===\n"
  end

  private

  def handle_skipped_dependencies(dependency_check, rules, form_response)
    Rails.logger.info "      Handling skipped dependencies: #{dependency_check[:skipped_dependencies]}"
    
    # Estrategia: Si una pregunta depende de preguntas que fueron saltadas,
    # evaluar solo las reglas que NO dependen de preguntas saltadas
    
    valid_rules = rules.reject do |rule|
      dependency_check[:skipped_dependencies].include?(rule['question_id'])
    end
    
    Rails.logger.info "      Valid rules after filtering: #{valid_rules.length}/#{rules.length}"
    
    if valid_rules.empty?
      # Si todas las dependencias fueron saltadas, la pregunta tambin se salta
      Rails.logger.info "      All dependencies were skipped, skipping this question"
      return false
    end
    
    # Evaluar solo las reglas vlidas
    logic_operator = conditional_logic.fetch('operator', 'and').downcase
    
    case logic_operator
    when 'and'
      result = valid_rules.all? { |rule| evaluate_condition(rule, form_response) }
    when 'or'
      result = valid_rules.any? { |rule| evaluate_condition(rule, form_response) }
    else
      result = valid_rules.all? { |rule| evaluate_condition(rule, form_response) }
    end
    
    Rails.logger.info "      Result after filtering skipped dependencies: #{result}"
    result
  end

  def check_dependency_chain(rules, form_response)
    skipped_dependencies = []
    missing_dependencies = []
    
    rules.each do |rule|
      question_id = rule['question_id']
      response = form_response.question_responses.joins(:form_question)
                            .find_by(form_questions: { id: question_id })
      
      if response.nil?
        missing_dependencies << question_id
      elsif response.skipped?
        skipped_dependencies << question_id
      end
    end
    
    {
      has_skipped_dependencies: skipped_dependencies.any?,
      has_missing_dependencies: missing_dependencies.any?,
      skipped_dependencies: skipped_dependencies,
      missing_dependencies: missing_dependencies
    }
  end

  def clean_numeric_value(value_str)
    return '' if value_str.blank?
    
    # Remueve smbolos de moneda comunes y espacios
    cleaned = value_str.gsub(/[$,\s]/, '')
    
    # Verifica si es un nmero vlido
    begin
      Float(cleaned)
      cleaned
    rescue ArgumentError
      # Si no es un nmero vlido, devuelve el valor original
      value_str
    end
  end

  def handle_skipped_response(operator, expected_value)
    # Si la pregunta dependiente fue saltada explcitamente
    Rails.logger.info "        Handling skipped response with operator: #{operator}"
    
    case operator
    when 'is_empty'
      true  # Las preguntas saltadas se consideran vacas
    when 'is_not_empty'
      false # Las preguntas saltadas no tienen contenido
    when 'equals'
      # Solo es verdadero si esperamos explcitamente un valor que represente "saltado"
      expected_value.to_s.downcase.in?(['skipped', 'skip', 'empty', ''])
    when 'not_equals'
      # Es verdadero para cualquier valor que NO sea "saltado"
      !expected_value.to_s.downcase.in?(['skipped', 'skip', 'empty', ''])
    when 'contains', 'starts_with', 'ends_with', 'matches_pattern'
      false # Las preguntas saltadas no contienen nada
    when 'greater_than', 'less_than', 'greater_than_or_equal', 'less_than_or_equal'
      false # No se puede comparar numricamente
    when 'in_list'
      # Solo verdadero si la lista incluye valores que representen "saltado"
      list_values = expected_value.is_a?(Array) ? expected_value : expected_value.to_s.split(',').map(&:strip)
      list_values.any? { |v| v.to_s.downcase.in?(['skipped', 'skip', 'empty', '']) }
    when 'not_in_list'
      # Verdadero si la lista NO incluye valores que representen "saltado"
      list_values = expected_value.is_a?(Array) ? expected_value : expected_value.to_s.split(',').map(&:strip)
      !list_values.any? { |v| v.to_s.downcase.in?(['skipped', 'skip', 'empty', '']) }
    else
      Rails.logger.warn "        Unknown operator for skipped response: #{operator}"
      false
    end
  end

  def handle_empty_response(operator, expected_value)
    # Si la pregunta tiene una respuesta registrada pero el valor est vaco
    Rails.logger.info "        Handling empty response with operator: #{operator}"
    
    case operator
    when 'is_empty'
      true
    when 'is_not_empty'
      false
    when 'equals'
      # Solo verdadero si esperamos explcitamente un valor vaco
      expected_value.blank? || expected_value.to_s.downcase.in?(['empty', '', 'null'])
    when 'not_equals'
      # Verdadero para cualquier valor no vaco
      expected_value.present? && !expected_value.to_s.downcase.in?(['empty', '', 'null'])
    when 'contains', 'starts_with', 'ends_with', 'matches_pattern'
      false # Los valores vacos no contienen nada
    when 'greater_than', 'less_than', 'greater_than_or_equal', 'less_than_or_equal'
      false # No se puede comparar numricamente con vaco
    when 'in_list'
      # Solo verdadero si la lista incluye valores vacos
      list_values = expected_value.is_a?(Array) ? expected_value : expected_value.to_s.split(',').map(&:strip)
      list_values.any? { |v| v.blank? || v.to_s.downcase.in?(['empty', '', 'null']) }
    when 'not_in_list'
      # Verdadero si la lista NO incluye valores vacos
      list_values = expected_value.is_a?(Array) ? expected_value : expected_value.to_s.split(',').map(&:strip)
      !list_values.any? { |v| v.blank? || v.to_s.downcase.in?(['empty', '', 'null']) }
    else
      Rails.logger.warn "        Unknown operator for empty response: #{operator}"
      false
    end
  end

  def extract_actual_value(response)
    # Prioridad en el orden de extraccin:
    # 1. answer_data['value'] si existe y no est vaco
    # 2. answer_text si existe y no est vaco  
    # 3. answer_data como string si no est vaco
    
    if response.answer_data.present? && response.answer_data.is_a?(Hash)
      value = response.answer_data['value']
      return value if value.present? && value != '{}'
    end
    
    if response.answer_text.present?
      return response.answer_text
    end
    
    if response.answer_data.present? && response.answer_data != '{}'
      return response.answer_data.to_s
    end
    
    nil
  end

  def validate_question_config
    # Always validate choice questions even if config is blank
    case question_type
    when 'multiple_choice', 'single_choice', 'checkbox'
      validate_choice_config
    when 'rating', 'scale', 'nps_score'
      validate_rating_config if question_config.present?
    when 'file_upload', 'image_upload'
      validate_file_config if question_config.present?
    when 'text_short', 'text_long'
      validate_text_config if question_config.present?
    end
  end

  def validate_choice_config
    options = question_config['options']
    if options.blank? || !options.is_a?(Array) || options.empty?
      errors.add(:question_config, 'must include at least one option for choice questions')
    end
  end

  def validate_rating_config
    min_val = question_config['min_value']
    max_val = question_config['max_value']
    
    if min_val.present? && max_val.present? && min_val >= max_val
      errors.add(:question_config, 'min_value must be less than max_value')
    end
  end

  def validate_file_config
    max_size = question_config['max_size_mb']
    if max_size.present? && (max_size <= 0 || max_size > 100)
      errors.add(:question_config, 'max_size_mb must be between 1 and 100')
    end
  end

  def validate_text_config
    min_length = question_config['min_length']
    max_length = question_config['max_length']
    
    if min_length.present? && max_length.present? && min_length > max_length
      errors.add(:question_config, 'min_length must be less than or equal to max_length')
    end
  end

  def validate_conditional_logic
    return unless conditional_enabled? && conditional_logic.present?
    
    rules = conditional_logic['rules']
    return if rules.blank?
    
    unless rules.is_a?(Array)
      errors.add(:conditional_logic, 'rules must be an array')
      return
    end
    
    rules.each_with_index do |rule, index|
      validate_conditional_rule(rule, index)
    end
  end

  def validate_conditional_rule(rule, index)
    required_keys = %w[question_id operator value]
    missing_keys = required_keys - rule.keys
    
    if missing_keys.any?
      errors.add(:conditional_logic, "rule #{index + 1} is missing required keys: #{missing_keys.join(', ')}")
    end
  end

  def normalize_value_for_comparison(value, question_type)
    return '' if value.blank? || value == '{}' || value == {}
    
    case question_type
    when 'yes_no', 'boolean'
      # Manejo robusto de valores booleanos
      val = value.to_s.downcase.strip
      case val
      when 'true', '1', 'yes', 'y', 's', 'si', 'ok', 'okay'
        'true'
      when 'false', '0', 'no', 'n', 'not', 'nope'
        'false'
      when '{}'
        '' # Valor vaco
      else
        # Para valores como "Yes" (con mayscula), normalizar a 'true'
        if val.in?(['yes', 's', 'si'])
          'true'
        elsif val.in?(['no'])
          'false'
        else
          val # Mantener valor original si no encaja en patrones conocidos
        end
      end
    when 'text_short', 'text_long', 'email', 'phone', 'url'
      # Para tipos de texto, normalizar case y whitespace
      value.to_s.downcase.strip
    when 'multiple_choice', 'single_choice', 'checkbox'
      # Para preguntas de eleccin, normalizar case
      value.to_s.downcase.strip
    when 'rating', 'scale', 'nps_score', 'number'
      # Para tipos numricos, mantener como string pero limpiar
      clean_numeric_value(value.to_s.strip)
    when 'date', 'datetime', 'time'
      # Para tipos de fecha/hora, normalizar formato
      begin
        if value.to_s.strip.present?
          Date.parse(value.to_s).strftime('%Y-%m-%d')
        else
          ''
        end
      rescue
        value.to_s.strip
      end
    else
      # Normalizacin por defecto
      value.to_s.downcase.strip
    end
  end

  def should_use_case_insensitive?(question_type)
    # Use case-insensitive comparison for text-based question types
    # where case doesn't typically matter for logic
    case question_type
    when 'yes_no', 'boolean', 'text_short', 'text_long', 'multiple_choice', 'single_choice', 'checkbox'
      true
    when 'email', 'phone', 'url'
      # For these types, case might matter (especially URLs)
      false
    when 'rating', 'scale', 'nps_score', 'number', 'date', 'datetime', 'time'
      # Numeric/date types don't need case normalization
      false
    else
      # Default to case-insensitive for safety
      true
    end
  end

def evaluate_condition(rule, form_response)
  question_id = rule['question_id']
  operator = rule['operator']
  expected_value = rule['value']

  Rails.logger.info "      Evaluating rule: #{question_id} #{operator} #{expected_value}"

  # Encuentra la respuesta para la pregunta de la que dependemos
  response = form_response.question_responses.joins(:form_question)
                        .find_by(form_questions: { id: question_id })

  if response.nil?
    Rails.logger.info "      No response found for question #{question_id}"
    return handle_missing_response(operator)
  end

  # CLAVE: Verifica si la respuesta fue saltada
  if response.skipped?
    Rails.logger.info "      Response was skipped for question #{question_id}"
    return handle_skipped_response(operator, expected_value)
  end

  # Obtiene la pregunta de origen para saber su tipo
  source_question = FormQuestion.find_by(id: question_id)
  unless source_question
    Rails.logger.info "      Source question not found: #{question_id}"
    return false
  end

  # Extrae el valor real de la respuesta
  actual_value = extract_actual_value(response)

  # Verifica si el valor est realmente vaco/no respondido
  if actual_value.blank? || actual_value == '{}' || actual_value == {}
    Rails.logger.info "      Response exists but value is empty for question #{question_id}"
    return handle_empty_response(operator, expected_value)
  end

  Rails.logger.info "      Actual value: '#{actual_value}'"
  Rails.logger.info "      Expected value: '#{expected_value}'"
  Rails.logger.info "      Source question type: #{source_question.question_type}"

  # Normaliza ambos valores para comparacin
  normalized_actual = normalize_value_for_comparison(actual_value, source_question.question_type)
  normalized_expected = normalize_value_for_comparison(expected_value, source_question.question_type)

  Rails.logger.info "      Normalized actual: '#{normalized_actual}'"
  Rails.logger.info "      Normalized expected: '#{normalized_expected}'"

  # Realiza la comparacin
  result = perform_comparison(operator, normalized_actual, normalized_expected, actual_value, expected_value)
  
  Rails.logger.info "      Comparison result: #{result}"
  result
end
  
def handle_missing_response(operator)
  # Si la pregunta dependiente no ha sido respondida en absoluto
  Rails.logger.info "        Handling missing response with operator: #{operator}"
  
  case operator
  when 'is_empty'
    true  # Efectivamente est vaca
  when 'is_not_empty'
    false # No est llena
  when 'equals', 'not_equals', 'contains', 'starts_with', 'ends_with', 
       'greater_than', 'less_than', 'greater_than_or_equal', 'less_than_or_equal',
       'matches_pattern', 'in_list', 'not_in_list'
    false # No se puede evaluar sin respuesta
  else
    Rails.logger.warn "        Unknown operator for missing response: #{operator}"
    false
  end
end

  def perform_comparison(operator, normalized_actual, normalized_expected, actual_value, expected_value)
    case operator
    when 'equals', 'equals_ignore_case'
      normalized_actual == normalized_expected
    when 'not_equals', 'not_equals_ignore_case'
      normalized_actual != normalized_expected
    when 'contains', 'contains_ignore_case'
      normalized_actual.to_s.include?(normalized_expected.to_s)
    when 'starts_with', 'starts_with_ignore_case'
      normalized_actual.to_s.start_with?(normalized_expected.to_s)
    when 'ends_with', 'ends_with_ignore_case'
      normalized_actual.to_s.end_with?(normalized_expected.to_s)
    when 'greater_than'
      convert_to_numeric(actual_value) > convert_to_numeric(expected_value)
    when 'greater_than_or_equal'
      convert_to_numeric(actual_value) >= convert_to_numeric(expected_value)
    when 'less_than'
      convert_to_numeric(actual_value) < convert_to_numeric(expected_value)
    when 'less_than_or_equal'
      convert_to_numeric(actual_value) <= convert_to_numeric(expected_value)
    when 'is_empty'
      actual_value.blank?
    when 'is_not_empty'
      actual_value.present?
    when 'matches_pattern'
      begin
        regex = Regexp.new(expected_value.to_s, Regexp::IGNORECASE)
        actual_value.to_s.match?(regex)
      rescue RegexpError => e
        Rails.logger.error "Invalid regex pattern: #{expected_value} - #{e.message}"
        false
      end
    when 'in_list'
      # expected_value debe ser un array o string separado por comas
      list_values = expected_value.is_a?(Array) ? expected_value : expected_value.to_s.split(',').map(&:strip)
      list_values.map { |v| normalize_value_for_comparison(v, 'text_short') }
                .include?(normalized_actual)
    when 'not_in_list'
      # expected_value debe ser un array o string separado por comas
      list_values = expected_value.is_a?(Array) ? expected_value : expected_value.to_s.split(',').map(&:strip)
      !list_values.map { |v| normalize_value_for_comparison(v, 'text_short') }
                  .include?(normalized_actual)
    else
      Rails.logger.warn "Unknown operator: #{operator}"
      false
    end
  end

  def convert_to_numeric(value)
    return 0.0 if value.blank?
    
    # Remove common currency symbols and spaces
    cleaned_value = value.to_s.gsub(/[$,\s]/, '')
    
    # Try to convert to float
    Float(cleaned_value)
  rescue ArgumentError
    # If conversion fails, return 0
    0.0
  end

  def normalize_value_for_comparison(value, question_type)
    return '' if value.blank?
    
    case question_type
    when 'yes_no', 'boolean'
      # Normalize boolean values
      val = value.to_s.downcase.strip
      case val
      when 'true', '1', 'yes', 'y', 's', 'si'
        'true'
      when 'false', '0', 'no', 'n'
        'false'
      else
        val
      end
    when 'text_short', 'text_long', 'email', 'phone', 'url'
      # For text types, normalize case and whitespace
      value.to_s.downcase.strip
    when 'multiple_choice', 'single_choice', 'checkbox'
      # For choice questions, normalize case
      value.to_s.downcase.strip
    when 'rating', 'scale', 'nps_score', 'number'
      # For numeric types, keep as string but strip whitespace
      value.to_s.strip
    when 'date', 'datetime', 'time'
      # For date/time types, normalize format
      begin
        Date.parse(value.to_s).strftime('%Y-%m-%d')
      rescue
        value.to_s.strip
      end
    else
      # Default normalization
      value.to_s.downcase.strip
    end
  end
end
</file>

<file path="models/form_response.rb">
# frozen_string_literal: true

class FormResponse < ApplicationRecord
  # Associations
  belongs_to :form, counter_cache: :responses_count
  has_many :question_responses, dependent: :destroy
  has_many :dynamic_questions, dependent: :destroy
  has_many :analysis_reports, dependent: :destroy

  # Enums
  enum :status, { 
    in_progress: 'in_progress', 
    completed: 'completed', 
    abandoned: 'abandoned',
    paused: 'paused'
  }

  # Validations
  validates :session_id, presence: true
  validates :form, presence: true

  # Callbacks
  before_create :set_started_at
  before_save :update_last_activity
  after_update :sync_to_google_sheets, if: :saved_change_to_status?

  # Scopes
  scope :recent, -> { order(created_at: :desc) }
  scope :this_week, -> { where(created_at: 1.week.ago..) }
  scope :this_month, -> { where(created_at: 1.month.ago..) }

  # Core Methods
  def progress_percentage
    return 0.0 if form.form_questions.count.zero?
    
    answered_count = question_responses.where.not(answer_data: {}).count
    total_count = form.form_questions.count
    
    (answered_count.to_f / total_count * 100).round(2)
  end

  def duration_minutes
    return 0 unless started_at
    
    end_time = completed_at || Time.current
    ((end_time - started_at) / 60.0).round(2)
  end

  def time_since_last_activity
    return 0 unless last_activity_at
    
    Time.current - last_activity_at
  end

  def is_stale?
    return false unless last_activity_at
    
    time_since_last_activity > 30.minutes
  end

  def answers_hash
    question_responses.includes(:form_question).each_with_object({}) do |qr, hash|
      question_title = qr.form_question.title
      hash[question_title] = qr.formatted_answer
    end
  end

  def get_answer(question_title_or_id)
    question = find_question(question_title_or_id)
    return nil unless question
    
    qr = question_responses.find_by(form_question: question)
    qr&.formatted_answer
  end

  def set_answer(question, answer_data)
    question_obj = question.is_a?(FormQuestion) ? question : find_question(question)
    return false unless question_obj
    
    qr = question_responses.find_or_initialize_by(form_question: question_obj)
    qr.answer_data = answer_data
    qr.save
  end

  def trigger_ai_analysis!
    return false unless form.ai_enabled?
    
    # Trigger AI analysis workflow
    # Forms::ResponseAnalysisJob.perform_later(self) if defined?(Forms::ResponseAnalysisJob)
    
    update(ai_analysis: ai_analysis.merge('requested_at' => Time.current.iso8601))
  end

  def ai_sentiment
    ai_analysis&.dig('sentiment') || 'neutral'
  end

  def ai_confidence
    ai_analysis&.dig('confidence_score') || 0.0
  end

  def ai_risk_indicators
    ai_analysis&.dig('risk_indicators') || []
  end

  def needs_human_review?
    return false unless ai_analysis.present?
    
    ai_confidence < 0.7 || ai_risk_indicators.any?
  end

  def calculate_quality_score!
    # Calculate quality based on completion, response times, and AI analysis
    completion_score = progress_percentage / 100.0
    time_score = duration_minutes < 30 ? 1.0 : [0.5, 30.0 / duration_minutes].max
    ai_score = ai_confidence
    
    quality = (completion_score * 0.5) + (time_score * 0.3) + (ai_score * 0.2)
    
    update(quality_score: quality.round(3))
    quality
  end

  def calculate_sentiment_score!
    return 0.0 unless ai_analysis.present?
    
    sentiment_mapping = {
      'very_positive' => 1.0,
      'positive' => 0.75,
      'neutral' => 0.5,
      'negative' => 0.25,
      'very_negative' => 0.0
    }
    
    score = sentiment_mapping[ai_sentiment] || 0.5
    update(sentiment_score: score)
    score
  end

  def mark_completed!(completion_data = {})
    return false unless can_be_completed?
    
    update!(
      status: :completed,
      completed_at: Time.current,
      completion_data: completion_data
    )
    
    # Trigger completion workflows
    # Forms::CompletionWorkflowJob.perform_later(self) if defined?(Forms::CompletionWorkflowJob)
    
    true
  end

  def mark_abandoned!(reason = nil)
    update!(
      status: :abandoned,
      abandoned_at: Time.current,
      abandonment_reason: reason
    )
  end

  def pause!(context = {})
    update!(
      status: :paused,
      paused_at: Time.current,
      metadata: metadata.merge('pause_context' => context)
    )
  end

  def resume!
    return false unless paused?
    
    update!(
      status: :in_progress,
      resumed_at: Time.current
    )
  end

  def workflow_context
    {
      form_id: form_id,
      response_id: id,
      session_id: session_id,
      status: status,
      progress: progress_percentage,
      current_question: current_question_position,
      answers: answers_hash,
      ai_analysis: ai_analysis,
      visitor_info: {
        ip_address: ip_address,
        user_agent: user_agent,
        referrer: referrer_url
      }
    }
  end

  def current_question_position
    answered_questions = question_responses.joins(:form_question)
                                          .where.not(answer_data: {})
                                          .order('form_questions.position')
    
    return 1 if answered_questions.empty?
    
    last_answered = answered_questions.last
    last_answered.form_question.position + 1
  end

  def can_be_completed?
    Rails.logger.info "    === CAN_BE_COMPLETED CHECK ==="
    
    # Obtiene todas las preguntas requeridas del formulario
    all_required_questions = form.form_questions.where(required: true).order(:position)
    Rails.logger.info "    Total required questions: #{all_required_questions.count}"
    
    # Filtra las preguntas requeridas que deben mostrarse segn la lgica condicional actual
    visible_required_questions = all_required_questions.select do |question|
      should_show = question.should_show_for_response?(self)
      Rails.logger.info "    Required question '#{question.title}' should show: #{should_show}"
      should_show
    end
    
    Rails.logger.info "    Visible required questions: #{visible_required_questions.count}"
    
    visible_required_question_ids = visible_required_questions.map(&:id)
    
    # Cuenta cuntas de las preguntas requeridas visibles han sido respondidas (no saltadas)
    answered_visible_required_count = self.question_responses
                                        .where(form_question_id: visible_required_question_ids)
                                        .where(skipped: false)
                                        .where.not(answer_data: {})
                                        .count
    
    Rails.logger.info "    Answered visible required questions: #{answered_visible_required_count}"
    
    # Verifica si todas las preguntas requeridas visibles han sido respondidas
    can_complete = visible_required_question_ids.count == answered_visible_required_count
    
    Rails.logger.info "    Can be completed: #{can_complete}"
    Rails.logger.info "    === END CAN_BE_COMPLETED CHECK ==="
    
    can_complete
  end

  def next_question
    current_pos = current_question_position
    form.form_questions.where('position >= ?', current_pos).order(:position).first
  end

  def previous_question
    current_pos = current_question_position
    return nil if current_pos <= 1
    
    form.form_questions.where('position < ?', current_pos).order(:position).last
  end

  def response_summary
    {
      id: id,
      form_name: form.name,
      status: status,
      progress: progress_percentage,
      duration: duration_minutes,
      quality_score: quality_score,
      sentiment_score: sentiment_score,
      created_at: created_at,
      completed_at: completed_at
    }
  end

  # Method to get all responses including dynamic questions
  def complete_response_summary
    summary = {
      form_questions: answers_hash,
      dynamic_questions: dynamic_question_responses,
      metadata: {
        completed_at: completed_at,
        total_response_time: duration_minutes,
        form_name: form.name,
        response_id: id
      }
    }
    
    summary
  end

  # Get all dynamic question responses
  def dynamic_question_responses
    return {} unless dynamic_questions.any?
    
    dynamic_responses = {}
    
    dynamic_questions.answered.each do |dq|
      dynamic_responses[dq.title] = {
        answer: dq.answer_data['value'],
        answered_at: dq.answered_at || dq.answer_data['submitted_at'],
        trigger: dq.generation_context&.dig('trigger') || 'budget_analysis',
        question_type: dq.question_type,
        question_id: dq.id
      }
    end
    
    dynamic_responses
  end

  # Check if form response has dynamic questions answered
  def has_answered_dynamic_questions?
    dynamic_questions.where.not(answer_data: {}).exists?
  end

  # Get summary for thank you page
  def thank_you_summary
    {
      total_questions_answered: question_responses.count,
      dynamic_questions_answered: dynamic_questions.where.not(answer_data: {}).count,
      completion_time: duration_minutes,
      quality_score: calculate_response_quality_score
    }
  end

  def calculate_response_quality_score
    # Simple quality scoring based on completeness and engagement
    base_score = (question_responses.count.to_f / form.form_questions.count * 70).round
    
    # Bonus for dynamic question responses
    dynamic_bonus = dynamic_questions.where.not(answer_data: {}).count * 15
    
    # Ensure score doesn't exceed 100
    [[base_score + dynamic_bonus, 100].min, 0].max
  end

  # Mtodo auxiliar para obtener preguntas no respondidas
  def unanswered_questions
    answered_question_ids = question_responses.pluck(:form_question_id)
    
    form.form_questions
        .where.not(id: answered_question_ids)
        .order(:position)
  end

  # Mtodo auxiliar para obtener preguntas requeridas no respondidas
  def unanswered_required_questions
    answered_question_ids = question_responses.where(skipped: false)
                                            .where.not(answer_data: {})
                                            .pluck(:form_question_id)
    
    form.form_questions
        .where(required: true)
        .where.not(id: answered_question_ids)
        .select { |q| q.should_show_for_response?(self) }
  end

  private

  def set_started_at
    self.started_at = Time.current if started_at.blank?
  end

  def update_last_activity
    self.last_activity_at = Time.current
  end

  def sync_to_google_sheets
    return unless completed?
    return unless form.google_sheets_integration&.auto_sync?
    
    GoogleSheetsSyncJob.perform_later(form.id, 'sync_response', id)
  end

  def find_question(identifier)
    case identifier
    when String
      # Try to find by title first, then by ID
      form.form_questions.find_by(title: identifier) ||
        form.form_questions.find_by(id: identifier)
    when Integer, /\A\d+\z/
      form.form_questions.find_by(id: identifier.to_i)
    when FormQuestion
      identifier
    else
      nil
    end
  end
end
</file>

<file path="models/form_template.rb">
# frozen_string_literal: true

class FormTemplate < ApplicationRecord
  # Associations
  belongs_to :creator, class_name: 'User', optional: true
  has_many :form_instances, class_name: 'Form', foreign_key: 'template_id'

  # Explicit attribute declarations for enums
  attribute :category, :string, default: 'general'
  attribute :visibility, :string, default: 'public'

  # Enums
  enum :category, { 
    general: 'general',
    lead_qualification: 'lead_qualification',
    customer_feedback: 'customer_feedback',
    job_application: 'job_application',
    event_registration: 'event_registration',
    survey: 'survey',
    contact_form: 'contact_form'
  }, prefix: true
  enum :visibility, { 
    template_private: 'private', 
    template_public: 'public', 
    featured: 'featured' 
  }, prefix: true

  # Validations
  validates :name, presence: true
  validates :template_data, presence: true

  # Scopes will be added after database migration
  # scope :public_templates, -> { where(visibility: 'template_public') }
  # scope :featured, -> { where(visibility: 'featured') }

  # Scopes
  scope :public_templates, -> { where(visibility: :template_public) }
  scope :featured, -> { where(visibility: :featured) }
  scope :by_category, ->(category) { where(category: category) }
  scope :popular, -> { order(usage_count: :desc) }
  scope :recent, -> { order(created_at: :desc) }

  # Callbacks
  before_save :calculate_estimated_time, :extract_features

  # Core Methods
  def questions_config
    template_data&.dig('questions') || []
  end

  def form_settings_template
    template_data&.dig('settings') || {}
  end

  def ai_configuration_template
    template_data&.dig('ai_configuration') || {}
  end

  def instantiate_for_user(user, customizations = {})
    # Validate premium access for AI templates
    if ai_enhanced? && !user.can_use_ai_features?
      raise Pundit::NotAuthorizedError, "AI templates require a premium subscription."
    end

    form_attributes = {
      name: customizations[:name] || name,
      description: customizations[:description] || description,
      category: customizations[:category] || category,
      user: user,
      template_id: id,
      ai_enabled: ai_enhanced?,
      form_settings: merge_settings(form_settings_template, customizations[:settings] || {}),
      ai_configuration: merge_ai_config(ai_configuration_template, customizations[:ai_configuration] || {})
    }

    form = Form.create!(form_attributes)

    # Create questions from template
    questions_config.each_with_index do |question_config, index|
      question_attributes = {
        form: form,
        title: question_config['title'],
        description: question_config['description'],
        question_type: question_config['question_type'],
        required: question_config['required'] || false,
        position: index + 1,
        question_config: question_config['configuration'] || {},
        ai_enhanced: question_config['ai_enhanced'] || false,
        ai_config: question_config['ai_config'] || {},
        conditional_enabled: question_config['conditional_enabled'] || false,
        conditional_logic: question_config['conditional_logic'] || {}
      }

      # Apply customizations to specific questions if provided
      if customizations[:questions] && customizations[:questions][index]
        question_customizations = customizations[:questions][index]
        question_attributes.merge!(question_customizations)
      end

      FormQuestion.create!(question_attributes)
    end

    # Increment usage count
    increment!(:usage_count)

    form
  end

  def preview_data
    {
      id: id,
      name: name,
      description: description,
      category: category,
      visibility: visibility,
      estimated_time: estimated_time_minutes,
      features: features_list,
      questions_count: questions_config.length,
      ai_enhanced: ai_enhanced?,
      usage_count: usage_count,
      creator: creator&.full_name,
      created_at: created_at,
      sample_questions: sample_questions_preview
    }
  end

  def ai_enhanced?
    ai_configuration_template.present? && ai_configuration_template.any?
  end

  def features_list
    return [] if features.blank?
    
    case features
    when String
      begin
        JSON.parse(features)
      rescue JSON::ParserError
        []
      end
    when Array
      features
    else
      []
    end
  end

  def sample_questions_preview(limit = 3)
    questions_config.first(limit).map do |question|
      {
        title: question['title'],
        type: question['question_type'],
        required: question['required'] || false,
        ai_enhanced: question['ai_enhanced'] || false
      }
    end
  end

  def complexity_score
    # Calculate template complexity based on various factors
    base_score = questions_config.length * 2

    # Add complexity for different question types
    complex_types = %w[matrix ranking drag_drop payment signature]
    complex_questions = questions_config.count { |q| complex_types.include?(q['question_type']) }
    base_score += complex_questions * 5

    # Add complexity for AI features
    ai_questions = questions_config.count { |q| q['ai_enhanced'] }
    base_score += ai_questions * 3

    # Add complexity for conditional logic
    conditional_questions = questions_config.count { |q| q['conditional_enabled'] }
    base_score += conditional_questions * 4

    # Add complexity for integrations
    integrations_count = form_settings_template.dig('integrations')&.length || 0
    base_score += integrations_count * 3

    base_score
  end

  def duplicate_for_user(user, new_name = nil)
    new_template = self.dup
    new_template.name = new_name || "#{name} (Copy)"
    new_template.creator = user
    new_template.visibility = :private
    new_template.usage_count = 0
    new_template.save!

    new_template
  end

  def export_data
    {
      template: {
        name: name,
        description: description,
        category: category,
        estimated_time: estimated_time_minutes,
        features: features_list,
        template_data: template_data
      },
      metadata: {
        version: '1.0',
        exported_at: Time.current.iso8601,
        creator: creator&.email,
        usage_count: usage_count
      }
    }
  end

  def self.import_from_data(import_data, user)
    template_data = import_data['template']
    
    create!(
      name: template_data['name'],
      description: template_data['description'],
      category: template_data['category'],
      template_data: template_data['template_data'],
      creator: user,
      visibility: :private,
      estimated_time_minutes: template_data['estimated_time'],
      features: template_data['features'].is_a?(Array) ? template_data['features'].to_json : template_data['features']
    )
  end

  def self.popular_templates(limit = 10)
    public_templates.popular.limit(limit)
  end

  def self.featured_templates
    featured.order(:created_at)
  end

  def self.search(query)
    return all if query.blank?
    
    where(
      'name ILIKE ? OR description ILIKE ? OR features @> ?',
      "%#{query}%",
      "%#{query}%",
      [query].to_json
    )
  end

  # Payment validation methods
  def payment_requirements
    @payment_requirements ||= TemplateAnalysisService.call(template: self).result
  end

  def has_payment_questions?
    payment_requirements[:has_payment_questions] || false
  end

  def required_features
    payment_requirements[:required_features] || []
  end

  def setup_complexity
    payment_requirements[:setup_complexity] || 'none'
  end

  private

  def calculate_estimated_time
    return if questions_config.blank?

    # Base time per question type (in seconds)
    time_estimates = {
      'text_short' => 15,
      'text_long' => 45,
      'email' => 10,
      'phone' => 15,
      'number' => 10,
      'multiple_choice' => 8,
      'single_choice' => 6,
      'checkbox' => 12,
      'rating' => 5,
      'scale' => 8,
      'yes_no' => 3,
      'date' => 10,
      'datetime' => 15,
      'file_upload' => 30,
      'image_upload' => 25,
      'signature' => 20,
      'payment' => 60,
      'matrix' => 45,
      'ranking' => 30,
      'drag_drop' => 25,
      'nps_score' => 8
    }

    total_seconds = questions_config.sum do |question|
      base_time = time_estimates[question['question_type']] || 20
      
      # Add time for AI processing
      base_time += 5 if question['ai_enhanced']
      
      # Add time for conditional logic complexity
      base_time += 3 if question['conditional_enabled']
      
      base_time
    end

    # Add buffer time (20% extra)
    total_seconds = (total_seconds * 1.2).round

    # Convert to minutes and round up
    self.estimated_time_minutes = (total_seconds / 60.0).ceil
  end

  def extract_features
    features_set = Set.new

    questions_config.each do |question|
      # Add question type features
      features_set << question['question_type']
      
      # Add AI features
      if question['ai_enhanced']
        features_set << 'ai_enhanced'
        
        ai_config = question['ai_config'] || {}
        ai_config.keys.each { |feature| features_set << "ai_#{feature}" }
      end
      
      # Add conditional logic
      features_set << 'conditional_logic' if question['conditional_enabled']
      
      # Add validation features
      if question['configuration']&.dig('validation')
        features_set << 'validation'
      end
    end

    # Add form-level features
    settings = form_settings_template
    features_set << 'multi_step' if settings['multi_step']
    features_set << 'progress_bar' if settings['show_progress']
    features_set << 'save_progress' if settings['allow_save_progress']
    
    # Add integration features
    if settings['integrations']
      settings['integrations'].each do |integration|
        features_set << "integration_#{integration['type']}"
      end
    end

    self.features = features_set.to_a.to_json
  end

  def merge_settings(template_settings, custom_settings)
    template_settings.deep_merge(custom_settings)
  end

  def merge_ai_config(template_ai_config, custom_ai_config)
    template_ai_config.deep_merge(custom_ai_config)
  end
end
</file>

<file path="models/form.rb">
# frozen_string_literal: true

class Form < ApplicationRecord
  include Cacheable

  # Associations
  belongs_to :user
  has_many :form_questions, -> { order(:position) }, dependent: :destroy
  has_many :form_responses, dependent: :destroy
  has_many :form_analytics, dependent: :destroy
  has_many :dynamic_questions, through: :form_responses
  belongs_to :template, class_name: 'FormTemplate', optional: true
  has_one :google_sheets_integration, dependent: :destroy

  # Enums
  enum :status, { draft: 'draft', published: 'published', archived: 'archived', template: 'template' }
  enum :category, { 
    general: 'general',
    lead_qualification: 'lead_qualification',
    customer_feedback: 'customer_feedback',
    job_application: 'job_application',
    event_registration: 'event_registration',
    survey: 'survey',
    contact_form: 'contact_form'
  }

  # Aliases for database fields
  alias_attribute :workflow_class_name, :workflow_class

  # Validations
  validates :name, presence: true
  validates :share_token, uniqueness: true, allow_blank: true
  validates :category, inclusion: { in: categories.keys }
  validates :status, inclusion: { in: statuses.keys }

  # Callbacks
  before_create :generate_share_token
  before_save :set_workflow_class_name, :update_form_cache

  # Core Methods
  def workflow_class
    return nil unless workflow_class_name.present?
    
    workflow_class_name.constantize
  rescue NameError
    nil
  end

  def create_workflow_class!
    # Generate dynamic workflow class based on form configuration
    # This will be implemented when SuperAgent workflows are created
    # For now, return a placeholder
    "Forms::Form#{id.to_s.gsub('-', '').first(8).capitalize}Workflow"
  end

  def regenerate_workflow!
    self.workflow_class_name = create_workflow_class!
    save!
  end

  def ai_enhanced?
    ai_enabled? && ai_configuration.present?
  end

  def ai_features_enabled
    return [] unless ai_enhanced?
    
    ai_configuration.fetch('features', [])
  end

  def generated_by_ai?
    metadata.present? && metadata['generated_by_ai'] == true
  end

  def generation_timestamp
    metadata&.dig('generation_timestamp')
  end

  def ai_generation_cost
    metadata&.dig('ai_cost')
  end

  def estimated_ai_cost_per_response
    return 0.0 unless ai_enhanced?
    
    # Base cost calculation - will be refined based on actual usage
    base_cost = 0.01 # $0.01 per response
    feature_multiplier = ai_features_enabled.length * 0.005
    
    base_cost + feature_multiplier
  end

  def completion_rate
    return 0.0 if responses_count.zero?
    
    (completion_count.to_f / responses_count * 100).round(2)
  end

  def questions_ordered
    form_questions.order(:position)
  end

  def next_question_position
    (form_questions.maximum(:position) || 0) + 1
  end

  def public_url
    begin
      Rails.application.routes.url_helpers.public_form_url(share_token)
    rescue ActionController::UrlGenerationError
      # Fallback to path if host is not configured
      Rails.application.routes.url_helpers.public_form_path(share_token)
    end
  end

  def embed_code(options = {})
    width = options[:width] || '100%'
    height = options[:height] || '600px'
    
    <<~HTML
      <iframe 
        src="#{public_url}" 
        width="#{width}" 
        height="#{height}" 
        frameborder="0" 
        style="border: none;">
      </iframe>
    HTML
  end

  def analytics_summary(period: 30.days)
    start_date = period.ago.to_date
    
    {
      period: period,
      views: views_count,
      responses: form_responses.where(created_at: start_date..).count,
      completions: form_responses.where(completed_at: start_date..).count,
      completion_rate: cached_completion_rate,
      avg_time: form_responses.where(completed_at: start_date..).average(:time_spent_seconds)&.to_i || 0
    }
  end

  def cached_analytics_summary(period: 30.days)
    Rails.cache.fetch("form/#{id}/analytics/#{period.to_i}", expires_in: 1.hour) do
      analytics_summary(period: period)
    end
  end

  def cached_completion_rate
    Rails.cache.fetch("form/#{id}/completion_rate", expires_in: 30.minutes) do
      completion_rate
    end
  end

  def questions_count
    form_questions.count
  end

  def cached_questions_count
    Rails.cache.fetch("form/#{id}/questions_count", expires_in: 1.hour) do
      questions_count
    end
  end

  def ai_enabled?
    # Check the ai_enabled column first, then fall back to configuration
    return read_attribute(:ai_enabled) if has_attribute?(:ai_enabled) && !read_attribute(:ai_enabled).nil?
    
    ai_configuration.present? && ai_configuration['enabled'] == true
  end

  def ai_model
    ai_configuration&.dig('model') || 'gpt-4o-mini'
  end

  def lead_scoring_enabled?
    ai_enabled? && ai_configuration&.dig('lead_scoring') == "1"
  end

  def lead_qualification_framework
    ai_configuration&.dig('qualification_framework') || 'bant'
  end

  def hot_lead_threshold
    ai_configuration&.dig('hot_lead_threshold')&.to_i || 80
  end

  def warm_lead_threshold
    ai_configuration&.dig('warm_lead_threshold')&.to_i || 60
  end

  def cold_lead_threshold
    ai_configuration&.dig('cold_lead_threshold')&.to_i || 40
  end

  def integrations_enabled?
    integration_settings&.dig('enabled') == true
  end

  def ai_feature_enabled?(feature_name)
    ai_enhanced? && ai_configuration.dig('enabled_features')&.include?(feature_name)
  end

  def ai_config_cached
    Rails.cache.fetch("form_ai_config/#{id}/#{updated_at.to_i}", expires_in: 1.hour) do
      ai_configuration
    end
  end

  def ai_usage_stats(period = 30.days)
    form_responses.joins(:dynamic_questions)
                  .where(dynamic_questions: { created_at: period.ago.. })
                  .group('date(dynamic_questions.created_at)')
                  .count
  end

  def ai_enhanced?
    ai_enabled? && ai_configuration.present?
  end

  def has_payment_questions?
    form_questions.where(question_type: 'payment').exists?
  end

  def payment_questions
    form_questions.where(question_type: 'payment')
  end

  def requires_premium_features?
    has_payment_questions?
  end

  # Payment setup validation methods
  def payment_setup_complete?
    return true unless has_payment_questions?
    
    user.stripe_configured? && user.premium?
  end

  def payment_setup_requirements
    return [] unless has_payment_questions?
    
    requirements = []
    requirements << 'stripe_configuration' unless user.stripe_configured?
    requirements << 'premium_subscription' unless user.premium?
    requirements
  end

  def can_publish_with_payments?
    !has_payment_questions? || payment_setup_complete?
  end

  validate :validate_ai_configuration, if: :ai_enhanced?
  validate :validate_premium_features

  private

  def generate_share_token
    return if share_token.present?
    
    loop do
      self.share_token = SecureRandom.urlsafe_base64(12)
      break unless self.class.exists?(share_token: share_token)
    end
  end

  def set_workflow_class_name
    return unless ai_enabled? && workflow_class_name.blank?
    
    self.workflow_class_name = create_workflow_class!
  end

  def update_form_cache
    # Bust related caches when form is updated
    Rails.cache.delete_matched("form/#{id}/*") if persisted?
  end

  def validate_ai_configuration
    return unless ai_enhanced?
    return unless ai_configuration.present?

    # Ensure the validator class is loaded
    begin
      require_relative '../../lib/ai_configuration_validator'
    rescue LoadError
      # Fallback for development/testing
      return true
    end
    
    validator = AIConfigurationValidator.new(ai_configuration)
    unless validator.validate
      errors.add(:ai_configuration, "Invalid configuration: #{validator.errors.join(', ')}")
    end
  end

  def validate_premium_features
    return unless requires_premium_features?
    
    unless user&.premium?
      errors.add(:base, 'Payment questions require a Premium subscription')
    end
    
    # Additional validation for published forms with payment questions
    if status == 'published' && has_payment_questions? && !user&.can_accept_payments?
      errors.add(:base, 'To publish forms with payment questions, you must configure Stripe in your settings')
    end
  end
end
</file>

<file path="models/google_integration.rb">
class GoogleIntegration < ApplicationRecord
  belongs_to :user
  has_many :google_sheets_integrations, dependent: :destroy

  validates :access_token, presence: true
  validates :refresh_token, presence: true
  validates :scope, presence: true

  scope :active, -> { where(active: true) }
  scope :expired, -> { where('token_expires_at < ?', Time.current) }

  def expired?
    token_expires_at < Time.current
  end

  def needs_refresh?
    token_expires_at < 5.minutes.from_now
  end

  def refresh_access_token!
    return unless refresh_token.present?

    begin
      credentials = Rails.application.credentials.google_sheets_integration[Rails.env.to_sym]
      
      client = Signet::OAuth2::Client.new(
        client_id: credentials[:client_id],
        client_secret: credentials[:client_secret],
        token_credential_uri: 'https://oauth2.googleapis.com/token',
        refresh_token: refresh_token
      )

      client.refresh!

      update!(
        access_token: client.access_token,
        token_expires_at: Time.current + client.expires_in.seconds,
        last_used_at: Time.current,
        error_log: []
      )

      true
    rescue => e
      update!(
        active: false,
        error_log: (error_log || []) << {
          timestamp: Time.current.iso8601,
          error: e.message,
          type: 'token_refresh_failed'
        }
      )
      false
    end
  end

  def valid_token?
    return false unless active?
    return false if expired?
    
    refresh_access_token! if needs_refresh?
    
    active? && !expired?
  end

  def revoke!
    # Revoke the token with Google
    begin
      uri = URI('https://oauth2.googleapis.com/revoke')
      response = Net::HTTP.post_form(uri, token: access_token)
    rescue => e
      Rails.logger.warn "Failed to revoke Google token: #{e.message}"
    end

    # Mark as inactive
    update!(active: false)
  end
end
</file>

<file path="models/google_sheets_integration.rb">
class GoogleSheetsIntegration < ApplicationRecord
  belongs_to :form

  validates :spreadsheet_id, presence: true
  validates :sheet_name, presence: true
  
  scope :active, -> { where(active: true) }
  scope :auto_sync_enabled, -> { where(auto_sync: true) }

  def spreadsheet_url
    "https://docs.google.com/spreadsheets/d/#{spreadsheet_id}/edit"
  end

  def mark_sync_success!
    update!(
      last_sync_at: Time.current,
      error_message: nil,
      sync_count: sync_count + 1
    )
  end

  def mark_sync_error!(error)
    update!(
      error_message: error.to_s,
      active: false
    )
  end

  def can_sync?
    active? && spreadsheet_id.present?
  end
end
</file>

<file path="models/lead_routing.rb">
# frozen_string_literal: true

# Model for storing lead routing decisions and actions
class LeadRouting < ApplicationRecord
  belongs_to :form_response
  belongs_to :lead_scoring, optional: true
  
  validates :routing_actions, presence: true
  validates :status, inclusion: { in: %w[pending processing completed failed] }
  validates :priority, inclusion: { in: %w[low medium high critical] }
  
  # Store routing actions as JSON
  store_accessor :routing_actions, :actions, :channels, :assignees
  
  # Scopes for filtering
  scope :pending, -> { where(status: 'pending') }
  scope :processing, -> { where(status: 'processing') }
  scope :completed, -> { where(status: 'completed') }
  scope :failed, -> { where(status: 'failed') }
  scope :by_priority, -> { order(Arel.sql("CASE priority WHEN 'critical' THEN 1 WHEN 'high' THEN 2 WHEN 'medium' THEN 3 ELSE 4 END")) }
  scope :overdue, -> { where('scheduled_at < ? AND status != ?', Time.current, 'completed') }
  scope :recent, -> { where('created_at > ?', 7.days.ago) }
  
  # Status methods
  def pending?
    status == 'pending'
  end
  
  def processing?
    status == 'processing'
  end
  
  def completed?
    status == 'completed'
  end
  
  def failed?
    status == 'failed'
  end
  
  # Priority methods
  def critical_priority?
    priority == 'critical'
  end
  
  def high_priority?
    priority == 'high'
  end
  
  def medium_priority?
    priority == 'medium'
  end
  
  def low_priority?
    priority == 'low'
  end
  
  def routing_actions_array
    return [] unless routing_actions.is_a?(Array)
    routing_actions
  end
  
  def primary_action
    routing_actions_array.first
  end
  
  def assignee
    primary_action&.dig(:assign_to) || 'unassigned'
  end
  
  def sla_hours
    primary_action&.dig(:sla_hours) || 24
  end
  
  def sla_deadline
    scheduled_at + sla_hours.hours
  end
  
  def sla_status
    return 'completed' if completed?
    return 'processing' if processing?
    
    if Time.current > sla_deadline
      'overdue'
    elsif Time.current > (sla_deadline - 2.hours)
      'due_soon'
    else
      'on_track'
    end
  end
  
  def channels
    primary_action&.dig(:channels) || ['email']
  end
  
  def priority_label
    priority.humanize
  end
  
  def status_label
    status.humanize
  end
  
  def priority_color
    case priority
    when 'critical' then 'red'
    when 'high' then 'orange'
    when 'medium' then 'yellow'
    when 'low' then 'blue'
    else 'gray'
    end
  end
  
  def status_color
    case status
    when 'completed' then 'green'
    when 'processing' then 'blue'
    when 'failed' then 'red'
    else 'yellow'
    end
  end
  
  def form_name
    form_response.form.name
  end
  
  def lead_score
    lead_scoring&.score || 0
  end
  
  def lead_tier
    lead_scoring&.tier || 'unknown'
  end
  
  def respondent_email
    form_response.answers_hash['email'] || form_response.answers_hash['work_email']
  end
  
  def respondent_name
    form_response.answers_hash['name'] || form_response.answers_hash['full_name'] || 'Anonymous'
  end
  
  def company_name
    if lead_scoring&.enriched_data.present?
      lead_scoring.enriched_data['company_name']
    else
      form_response.answers_hash['company'] || 'Unknown'
    end
  end
  
  def mark_processing!
    update!(status: 'processing', processing_started_at: Time.current)
  end
  
  def mark_completed!(result = {})
    update!(
      status: 'completed',
      completed_at: Time.current,
      result_data: result
    )
  end
  
  def mark_failed!(error = nil)
    update!(
      status: 'failed',
      completed_at: Time.current,
      error_message: error
    )
  end
  
  # Class methods for analytics
  def self.by_status
    group(:status).count
  end
  
  def self.by_priority
    group(:priority).count
  end
  
  def self.overdue_count
    overdue.count
  end
  
  def self.completion_rate
    total = count
    return 0 if total.zero?
    
    completed_count.to_f / total * 100
  end
  
  def self.average_processing_time
    where.not(completed_at: nil).where.not(processing_started_at: nil).average(
      Arel.sql("EXTRACT(EPOCH FROM (completed_at - processing_started_at)) / 3600")
    ).to_f
  end
  
  def self.daily_volume(days = 7)
    where('created_at > ?', days.days.ago)
      .group_by_day(:created_at)
      .count
  end
  
  def self.assignee_distribution
    all.map { |r| r.assignee }.tally
  end
  
  private
  
  def completed_count
    where(status: 'completed').count
  end
end
</file>

<file path="models/lead_scoring.rb">
# frozen_string_literal: true

# Model for storing lead scoring results from AI analysis
class LeadScoring < ApplicationRecord
  belongs_to :form_response
  belongs_to :lead_routing, optional: true
  
  validates :score, presence: true, numericality: { greater_than_or_equal_to: 0, less_than_or_equal_to: 100 }
  validates :tier, presence: true, inclusion: { in: %w[hot warm lukewarm cold] }
  validates :form_response_id, uniqueness: true
  
  # Scoring tiers
  TIER_DEFINITIONS = {
    hot: { min_score: 80, max_score: 100, priority: 'immediate', sla_hours: 1 },
    warm: { min_score: 60, max_score: 79, priority: 'high', sla_hours: 24 },
    lukewarm: { min_score: 40, max_score: 59, priority: 'medium', sla_hours: 72 },
    cold: { min_score: 0, max_score: 39, priority: 'low', sla_hours: 168 }
  }.freeze
  
  # Scopes for filtering
  scope :hot_leads, -> { where(tier: 'hot') }
  scope :warm_leads, -> { where(tier: 'warm') }
  scope :cold_leads, -> { where(tier: 'cold') }
  scope :recent, -> { where('scored_at > ?', 7.days.ago) }
  scope :by_score_range, ->( min, max ) { where(score: min..max) }
  
  # Instance methods
  def tier_config
    TIER_DEFINITIONS[tier.to_sym]
  end
  
  def priority_level
    tier_config[:priority]
  end
  
  def sla_deadline
    scored_at + tier_config[:sla_hours].hours
  end
  
  def sla_status
    return 'overdue' if Time.current > sla_deadline
    return 'due_soon' if Time.current > (sla_deadline - 2.hours)
    'on_track'
  end
  
  def quality_factors_summary
    return [] unless quality_factors.is_a?(Array)
    
    quality_factors.map do |factor|
      {
        factor: factor['factor'],
        score: factor['score'],
        reasoning: factor['reasoning']
      }
    end
  end
  
  def risk_factors_summary
    return [] unless risk_factors.is_a?(Array)
    
    risk_factors.map do |factor|
      {
        factor: factor['factor'],
        impact: factor['impact'],
        reasoning: factor['reasoning']
      }
    end
  end
  
  def estimated_value_numeric
    return 0 unless estimated_value.present?
    
    # Parse estimated value from string format
    value = estimated_value.to_s.gsub(/[^\d.]/, '').to_f
    value * 1000 if estimated_value.include?('K')
    value * 1000000 if estimated_value.include?('M')
    value
  end
  
  def confidence_percentage
    return 0 unless confidence_level.present?
    (confidence_level * 100).round
  end
  
  def formatted_score
    score.round
  end
  
  def tier_label
    tier.humanize
  end
  
  def tier_color
    case tier
    when 'hot' then 'red'
    when 'warm' then 'orange'
    when 'lukewarm' then 'yellow'
    when 'cold' then 'blue'
    else 'gray'
    end
  end
  
  def buying_signals_summary
    return [] unless analysis_data.is_a?(Hash)
    analysis_data['buying_signals'] || []
  end
  
  def timing_indicators
    return {} unless analysis_data.is_a?(Hash)
    analysis_data['timing_indicators'] || {}
  end
  
  def next_best_action
    return '' unless analysis_data.is_a?(Hash)
    analysis_data['next_best_action'] || ''
  end
  
  # Class methods for analytics
  def self.average_score
    average(:score)
  end
  
  def self.tier_distribution
    group(:tier).count
  end
  
  def self.score_distribution
    ranges = [
      [0, 20], [21, 40], [41, 60], [61, 80], [81, 100]
    ]
    
    ranges.map do |min, max|
      count = where(score: min..max).count
      {
        range: "#{min}-#{max}",
        count: count,
        percentage: count.to_f / total_count * 100
      }
    end
  end
  
  def self.recent_leads_by_tier
    recent.group(:tier).count
  end
  
  def self.high_value_leads(min_value = 10000)
    where("estimated_value ILIKE ? OR estimated_value ILIKE ?", "%$#{min_value}%", "%#{min_value / 1000}K%")
  end
  
  private
  
  def total_count
    @total_count ||= count
  end
end
</file>

<file path="models/payment_analytic.rb">
# frozen_string_literal: true

class PaymentAnalytic < ApplicationRecord
  belongs_to :user

  validates :event_type, presence: true, inclusion: { in: PaymentAnalyticsService::PAYMENT_EVENTS }
  validates :timestamp, presence: true
  # Context can be empty hash but not nil
  validates :context, exclusion: { in: [nil] }

  scope :by_event_type, ->(type) { where(event_type: type) }
  scope :by_date_range, ->(range) { where(timestamp: range) }
  scope :by_user_tier, ->(tier) { where(user_subscription_tier: tier) }

  # Indexes for performance
  # These would be added in a migration
  # add_index :payment_analytics, [:event_type, :timestamp]
  # add_index :payment_analytics, [:user_id, :timestamp]
  # add_index :payment_analytics, :user_subscription_tier

  def error_type
    context['error_type'] if event_type == 'payment_validation_errors'
  end

  def resolution_path
    context['resolution_path'] if event_type == 'payment_validation_errors'
  end

  def template_id
    context['template_id'] if event_type == 'template_payment_interaction'
  end

  def setup_step
    context['setup_step'] if %w[payment_setup_started payment_setup_completed payment_setup_abandoned].include?(event_type)
  end
end
</file>

<file path="models/payment_transaction.rb">
class PaymentTransaction < ApplicationRecord
  belongs_to :user
  belongs_to :form
  belongs_to :form_response

  # Validations
  validates :stripe_payment_intent_id, presence: true, uniqueness: true
  validates :amount, presence: true, numericality: { greater_than: 0 }
  validates :currency, presence: true, length: { is: 3 }
  validates :status, presence: true, inclusion: { 
    in: %w[pending processing succeeded failed canceled requires_action] 
  }
  validates :payment_method, presence: true, inclusion: { 
    in: %w[credit_card paypal apple_pay google_pay] 
  }

  # Scopes
  scope :successful, -> { where(status: 'succeeded') }
  scope :failed, -> { where(status: 'failed') }
  scope :pending, -> { where(status: 'pending') }
  scope :recent, -> { order(created_at: :desc) }
  scope :for_user, ->(user) { where(user: user) }
  scope :for_form, ->(form) { where(form: form) }

  # Callbacks
  before_validation :set_defaults, on: :create
  after_update :update_processed_at, if: :saved_change_to_status?

  def successful?
    status == 'succeeded'
  end

  def failed?
    status == 'failed'
  end

  def pending?
    status == 'pending'
  end

  def processing?
    status == 'processing'
  end

  def amount_in_cents
    (amount * 100).to_i
  end

  def formatted_amount
    "$#{'%.2f' % amount}"
  end

  def stripe_client
    user.stripe_client
  end

  def retrieve_payment_intent
    return nil unless stripe_client && stripe_payment_intent_id.present?
    
    begin
      stripe_client.payment_intents.retrieve(stripe_payment_intent_id)
    rescue Stripe::StripeError => e
      Rails.logger.error "Failed to retrieve payment intent #{stripe_payment_intent_id}: #{e.message}"
      nil
    end
  end

  def sync_with_stripe!
    payment_intent = retrieve_payment_intent
    return false unless payment_intent

    update!(
      status: payment_intent.status,
      metadata: metadata.merge(
        stripe_status: payment_intent.status,
        last_synced_at: Time.current.iso8601
      )
    )
    
    true
  rescue StandardError => e
    Rails.logger.error "Failed to sync payment transaction #{id} with Stripe: #{e.message}"
    false
  end

  private

  def set_defaults
    self.currency ||= 'USD'
    self.status ||= 'pending'
    self.metadata ||= {}
  end

  def update_processed_at
    if status_changed? && %w[succeeded failed canceled].include?(status)
      update_column(:processed_at, Time.current)
    end
  end
end
</file>

<file path="models/question_response.rb">
# frozen_string_literal: true

class QuestionResponse < ApplicationRecord
  # Associations
  belongs_to :form_response
  belongs_to :form_question

  # Validations
  validates :answer_data, presence: true, unless: :skipped?

  # Callbacks
  before_save :process_answer_data, :calculate_response_time
  after_create :trigger_ai_analysis, :update_question_analytics

  # Scopes
  scope :answered, -> { where.not(answer_data: {}).where(skipped: false) }
  scope :skipped, -> { where(skipped: true) }
  scope :recent, -> { order(created_at: :desc) }

  # Core Methods
  def processed_answer_data
    return {} if answer_data.blank?
    
    case form_question.question_type
    when 'multiple_choice', 'checkbox'
      process_choice_answer
    when 'rating', 'scale', 'nps_score'
      process_numeric_answer
    when 'file_upload', 'image_upload'
      process_file_answer
    when 'email'
      process_email_answer
    when 'phone'
      process_phone_answer
    else
      process_text_answer
    end
  end

  def raw_answer
    answer_data.is_a?(Hash) ? answer_data['value'] : answer_data
  end

  def formatted_answer
    processed_data = processed_answer_data
    
    case form_question.question_type
    when 'multiple_choice', 'checkbox'
      format_choice_answer(processed_data)
    when 'rating', 'scale'
      format_rating_answer(processed_data)
    when 'nps_score'
      format_nps_answer(processed_data)
    when 'date'
      format_date_answer(processed_data)
    when 'datetime'
      format_datetime_answer(processed_data)
    when 'file_upload', 'image_upload'
      format_file_answer(processed_data)
    else
      processed_data.to_s
    end
  end

  def answer_text
    formatted_answer.to_s
  end

  def trigger_ai_analysis!
    return false unless should_trigger_ai_analysis?
    
    # Trigger AI analysis workflow
    # Forms::ResponseAnalysisJob.perform_later(self) if defined?(Forms::ResponseAnalysisJob)
    
    update(ai_analysis_requested_at: Time.current)
  end

  def ai_sentiment
    ai_analysis_results&.dig('sentiment') || 'neutral'
  end

  def ai_confidence_score
    ai_analysis_results&.dig('confidence_score') || 0.0
  end

  def ai_insights
    ai_analysis_results&.dig('insights') || []
  end

  def needs_followup?
    return false unless ai_analysis_results.present?
    
    ai_insights.any? { |insight| insight['type'] == 'followup_suggested' } ||
      ai_confidence_score < 0.6
  end

  def answer_valid?
    validation_errors.empty?
  end

  def validation_errors
    errors = []
    
    # Check if answer meets question requirements
    if form_question.required? && answer_blank?
      errors << 'Answer is required'
    end
    
    # Type-specific validation
    case form_question.question_type
    when 'email'
      errors << 'Invalid email format' unless valid_email?
    when 'phone'
      errors << 'Invalid phone format' unless valid_phone?
    when 'number'
      errors << 'Must be a valid number' unless valid_number?
    when 'url'
      errors << 'Invalid URL format' unless valid_url?
    end
    
    # Custom validation rules
    validation_rules = form_question.validation_rules
    if validation_rules.present?
      errors.concat(validate_against_rules(validation_rules))
    end
    
    errors
  end

  def quality_indicators
    {
      completeness: calculate_completeness_score,
      response_time: response_time_category,
      ai_confidence: ai_confidence_score,
      validation_passed: answer_valid?,
      needs_review: needs_human_review?
    }
  end

  def response_time_category
    return 'unknown' if response_time_ms.nil?
    
    case response_time_ms
    when 0..2000
      'very_fast'
    when 2001..5000
      'fast'
    when 5001..15000
      'normal'
    when 15001..60000
      'slow'
    else
      'very_slow'
    end
  end

  def unusually_fast?
    response_time_ms.present? && response_time_ms < 1000
  end

  def unusually_slow?
    response_time_ms.present? && response_time_ms > 120000 # 2 minutes
  end

  def needs_human_review?
    unusually_fast? || 
      unusually_slow? || 
      ai_confidence_score < 0.5 || 
      !answer_valid?
  end

  def response_summary
    {
      question_title: form_question.title,
      question_type: form_question.question_type,
      answer: formatted_answer,
      response_time: response_time_ms,
      quality_score: calculate_completeness_score,
      ai_confidence: ai_confidence_score,
      needs_review: needs_human_review?
    }
  end

  private

  def process_answer_data
    return if answer_data.blank?
    
    # Ensure answer_data is properly structured
    if answer_data.is_a?(String)
      self.answer_data = { 'value' => answer_data }
    end
    
    # Add metadata
    self.answer_data['processed_at'] = Time.current.iso8601
    self.answer_data['question_type'] = form_question.question_type
  end

  def calculate_response_time
    return unless answer_data.present?
    
    # Calculate response time if timestamps are available
    if answer_data.is_a?(Hash) && answer_data['started_at'] && answer_data['completed_at']
      begin
        started = Time.parse(answer_data['started_at'])
        completed = Time.parse(answer_data['completed_at'])
        self.response_time_ms = ((completed - started) * 1000).to_i
      rescue ArgumentError
        # Invalid date format, skip response time calculation
        self.response_time_ms = nil
      end
    end
  end

  def trigger_ai_analysis
    return unless should_trigger_ai_analysis?
    
    # Queue AI analysis job
    trigger_ai_analysis!
  end

  def should_trigger_ai_analysis?
    form_question.ai_enhanced? && 
      !skipped? &&
      answer_data.present?
  end

  def update_question_analytics
    # Update question-level analytics
    Rails.cache.delete("question_analytics/#{form_question_id}")
    
    # Update form-level analytics
    Rails.cache.delete_matched("form/#{form_response.form_id}/*")
  end

  def calculate_completeness_score
    return 0.0 if answer_blank?
    
    score = 0.5 # Base score for having an answer
    
    # Add points for answer quality
    case form_question.question_type
    when 'text_short', 'text_long'
      text_length = answer_text.length
      if text_length >= 10
        score += 0.3
      elsif text_length >= 5
        score += 0.2
      end
    when 'multiple_choice', 'single_choice'
      score += 0.4 # Full points for choice questions
    when 'rating', 'scale'
      score += 0.4 # Full points for rating questions
    end
    
    # Bonus for AI confidence
    score += (ai_confidence_score * 0.1) if ai_confidence_score > 0
    
    [score, 1.0].min.round(3)
  end

  def answer_blank?
    return true if answer_data.blank?
    
    value = raw_answer
    value.blank? || (value.is_a?(Array) && value.empty?)
  end

  def process_choice_answer
    value = raw_answer
    return value if value.is_a?(Array)
    
    # Convert single choice to array for consistency
    value.present? ? [value] : []
  end

  def process_numeric_answer
    value = raw_answer
    value.is_a?(Numeric) ? value : value.to_f
  end

  def process_file_answer
    value = raw_answer
    return [] unless value.present?
    
    # Ensure file data is properly structured
    files = value.is_a?(Array) ? value : [value]
    files.map do |file|
      {
        filename: file['filename'],
        size: file['size'],
        content_type: file['content_type'],
        url: file['url']
      }
    end
  end

  def process_email_answer
    raw_answer.to_s.downcase.strip
  end

  def process_phone_answer
    # Remove non-numeric characters except +
    raw_answer.to_s.gsub(/[^\d+]/, '')
  end

  def process_text_answer
    raw_answer.to_s.strip
  end

  def format_choice_answer(processed_data)
    return '' if processed_data.blank?
    
    choices = processed_data.is_a?(Array) ? processed_data : [processed_data]
    choices.join(', ')
  end

  def format_rating_answer(processed_data)
    "#{processed_data}/#{form_question.rating_config[:max] || 5}"
  end

  def format_nps_answer(processed_data)
    score = processed_data.to_i
    category = case score
               when 0..6 then 'Detractor'
               when 7..8 then 'Passive'
               when 9..10 then 'Promoter'
               else 'Unknown'
               end
    "#{score} (#{category})"
  end

  def format_date_answer(processed_data)
    Date.parse(processed_data.to_s).strftime('%B %d, %Y')
  rescue
    processed_data.to_s
  end

  def format_datetime_answer(processed_data)
    Time.parse(processed_data.to_s).strftime('%B %d, %Y at %I:%M %p')
  rescue
    processed_data.to_s
  end

  def format_file_answer(processed_data)
    return 'No files' if processed_data.blank?
    
    files = processed_data.is_a?(Array) ? processed_data : [processed_data]
    filenames = files.map { |f| f[:filename] || f['filename'] || 'Unknown file' }
    "#{files.count} file(s): #{filenames.join(', ')}"
  end

  def valid_email?
    return true if answer_text.blank? # Let presence validation handle blank
    
    answer_text.match?(/\A[\w+\-.]+@[a-z\d\-]+(\.[a-z\d\-]+)*\.[a-z]+\z/i)
  end

  def valid_phone?
    return true if answer_text.blank?
    
    # Basic phone validation - adjust regex as needed
    answer_text.match?(/\A\+?[\d\s\-\(\)]{10,}\z/)
  end

  def valid_number?
    return true if answer_text.blank?
    
    answer_text.match?(/\A-?\d*\.?\d+\z/)
  end

  def valid_url?
    return true if answer_text.blank?
    
    answer_text.match?(/\Ahttps?:\/\/[^\s]+\z/)
  end

  def validate_against_rules(rules)
    errors = []
    
    rules.each do |rule, value|
      case rule
      when 'min_length'
        errors << "Answer must be at least #{value} characters" if answer_text.length < value
      when 'max_length'
        errors << "Answer must be no more than #{value} characters" if answer_text.length > value
      when 'min_value'
        errors << "Value must be at least #{value}" if raw_answer.to_f < value
      when 'max_value'
        errors << "Value must be no more than #{value}" if raw_answer.to_f > value
      end
    end
    
    errors
  end
end
</file>

<file path="models/user.rb">
class User < ApplicationRecord
  include Encryptable
  include AdminCacheable

  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable, :trackable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :validatable, :trackable, :confirmable

  # Skip automatic confirmation email sending
  def send_on_create_confirmation_instructions
    # Override to prevent automatic sending
    # We'll send our custom confirmation email manually
  end

  # Auto-confirm admin and superadmin users
  before_create :auto_confirm_admin_users

  # Associations
  has_many :forms, dependent: :destroy
  has_many :form_responses, through: :forms
  has_many :api_tokens, dependent: :destroy
  has_many :payment_transactions, dependent: :destroy
  has_many :created_discount_codes, class_name: 'DiscountCode', foreign_key: 'created_by_id', dependent: :destroy
  has_one :discount_code_usage, dependent: :destroy
  has_one :used_discount_code, through: :discount_code_usage, source: :discount_code
  
  # Google Sheets Integration
  has_one :google_integration, dependent: :destroy
  has_many :export_jobs, dependent: :destroy

  # Role and subscription tier as string fields
  validates :role, inclusion: { in: %w[user admin superadmin] }, allow_nil: false
  validates :subscription_tier, inclusion: { in: %w[basic premium] }, allow_nil: false
  
  # Set defaults
  after_initialize :set_defaults, if: :new_record?

  # Validations
  validates :email, presence: true, uniqueness: true, format: { with: URI::MailTo::EMAIL_REGEXP }
  validates :first_name, :last_name, presence: true
  validates :ai_credits_used, presence: true, numericality: { greater_than_or_equal_to: 0 }
  validates :monthly_ai_limit, presence: true, numericality: { greater_than: 0 }
  
  # Stripe validations
  validates :stripe_publishable_key, presence: true, if: :stripe_enabled?
  validates :stripe_secret_key, presence: true, if: :stripe_enabled?
  validate :validate_stripe_keys, if: :stripe_enabled?

  # Callbacks
  before_create :set_default_preferences
  before_create :set_trial_end_date
  before_save :update_last_activity
  after_create :notify_admin_of_registration
  after_update :notify_admin_of_subscription_changes

  # Public instance methods
  def full_name
    "#{first_name} #{last_name}".strip
  end

  def ai_credits_used_this_month
    # For now, return total usage since we don't have monthly reset functionality yet
    # In a future enhancement, this could be filtered by date range
    (ai_credits_used || 0.0).to_f
  end

  def ai_credits_limit
    (monthly_ai_limit || 0.0).to_f
  end

  def ai_credits_remaining
    limit = ai_credits_limit
    used = ai_credits_used_this_month
    [limit - used, 0.0].max
  end

  def admin?
    role == 'admin' || role == 'superadmin'
  end

  def superadmin?
    role == 'superadmin'
  end

  def premium?
    subscription_tier == 'premium' || role == 'admin' || role == 'superadmin'
  end

  def freemium?
    false # Freemium plan has been deprecated, all users are now basic or premium
  end

  def active?
    # Check the active attribute from the database
    self.active
  end

  def can_use_ai_features?
    premium? || admin?
  end

  def consume_ai_credit(cost = 1.0)
    return false unless can_use_ai_features?
    
    cost = cost.to_f
    return false if cost <= 0
    
    # Check if user has enough credits before consuming
    return false if ai_credits_remaining < cost
    
    increment!(:ai_credits_used, cost)
    true
  end

  def can_consume_ai_credit?(cost = 1.0)
    return false unless can_use_ai_features?
    
    cost = cost.to_f
    return false if cost <= 0
    
    ai_credits_remaining >= cost
  end

  def form_usage_stats
    {
      total_forms: forms.count,
      published_forms: forms.published.count,
      total_responses: form_responses.count,
      avg_completion_rate: forms.average(:completion_rate) || 0.0
    }
  end

  # Stripe methods
  def stripe_configured?
    stripe_enabled? && stripe_publishable_key.present? && stripe_secret_key.present?
  end

  def stripe_client
    return nil unless stripe_configured?
    
    @stripe_client ||= Stripe::StripeClient.new(stripe_secret_key)
  end

  def can_accept_payments?
    stripe_configured? && premium?
  end

  # Google Sheets integration methods
  def google_sheets_connected?
    google_integration&.active?
  end

  def can_use_google_sheets?
    premium? || admin?
  end

  def can_export_to_google_sheets?
    can_use_google_sheets? && google_sheets_connected?
  end

  def time_zone
    preferences&.dig('time_zone') || 'UTC'
  end

  def encrypt_stripe_keys!
    if stripe_secret_key.present? && !stripe_secret_key.start_with?('encrypted:')
      self.stripe_secret_key = encrypt_data(stripe_secret_key)
    end
    
    if stripe_webhook_secret.present? && !stripe_webhook_secret.start_with?('encrypted:')
      self.stripe_webhook_secret = encrypt_data(stripe_webhook_secret)
    end
  end

  def decrypt_stripe_secret_key
    return nil unless stripe_secret_key.present?
    
    if stripe_secret_key.start_with?('encrypted:')
      decrypt_data(stripe_secret_key)
    else
      stripe_secret_key
    end
  end

  def decrypt_stripe_webhook_secret
    return nil unless stripe_webhook_secret.present?
    
    if stripe_webhook_secret.start_with?('encrypted:')
      decrypt_data(stripe_webhook_secret)
    else
      stripe_webhook_secret
    end
  end

  def set_defaults
    self.role ||= 'user'
    self.subscription_tier ||= 'basic'
    
    # Set subscription status based on trial configuration
    if self.subscription_status.nil?
      self.subscription_status = TrialConfig.trial_enabled? ? 'trialing' : 'active'
    end
  end

  # --- Lgica del Free Trial ---

  # Devuelve true si el usuario est en el periodo de prueba.
  def on_trial?
    # Un usuario est en trial si tiene una fecha de vencimiento y an no es premium.
    subscription_tier == 'basic' && trial_expires_at.present?
  end

  # Devuelve true si el trial ha terminado.
  def trial_expired?
    on_trial? && trial_expires_at < Time.current
  end

  # Devuelve true si el trial est activo.
  def trial_active?
    on_trial? && trial_expires_at >= Time.current
  end

  # Subscription management methods
  def subscription_active?
    subscription_status.in?(['active', 'trialing'])
  end

  def subscription_canceling?
    subscription_status == 'canceling'
  end

  def subscription_past_due?
    subscription_status == 'past_due'
  end

  def subscription_canceled?
    subscription_status == 'canceled'
  end

  def subscription_expires_soon?
    subscription_expires_at.present? && 
    subscription_expires_at <= 7.days.from_now
  end

  def days_until_subscription_expires
    return nil unless subscription_expires_at.present?
    
    days = (subscription_expires_at.to_date - Date.current).to_i
    [days, 0].max
  end

  def subscription_renewal_date
    subscription_expires_at
  end

  def has_valid_subscription?
    premium? && subscription_active? && 
    (subscription_expires_at.nil? || subscription_expires_at > Time.current)
  end

  # Trial management methods
  def trial_days_remaining
    return 0 unless trial_ends_at && subscription_status == 'trialing'
    
    days = ((trial_ends_at - Time.current) / 1.day).ceil
    [days, 0].max
  end

  def trial_expired?
    return false unless trial_ends_at
    Time.current >= trial_ends_at
  end

  def trial_expires_soon?
    trial_days_remaining <= 7 && trial_days_remaining > 0
  end

  def trial_expires_today?
    trial_days_remaining == 1
  end

  def trial_status_message
    return nil unless subscription_status == 'trialing'
    
    days = trial_days_remaining
    case days
    when 0
      "Your trial has expired"
    when 1
      "Your trial expires today"
    when 2..3
      "Your trial expires in #{days} days"
    when 4..7
      "#{days} days left in your trial"
    else
      "Trial active (#{days} days remaining)"
    end
  end

  # Discount code eligibility methods
  def eligible_for_discount?
    !discount_code_used? && !suspended? && subscription_tier != 'premium'
  end

  def can_use_discount_code?
    eligible_for_discount?
  end

  def discount_code_used?
    discount_code_used || discount_code_usage.present?
  end

  def mark_discount_code_as_used!
    update!(discount_code_used: true)
  end

  # User suspension methods
  def suspended?
    suspended_at.present?
  end

  def active_user?
    !suspended?
  end

  def suspend!(reason)
    update!(
      suspended_at: Time.current,
      suspended_reason: reason
    )
  end

  def reactivate!
    update!(
      suspended_at: nil,
      suspended_reason: nil
    )
  end

  def suspension_duration
    return nil unless suspended?
    Time.current - suspended_at
  end

  def suspension_duration_in_days
    return nil unless suspended?
    (suspension_duration / 1.day).round
  end

  # Payment setup status methods
  def payment_setup_status
    {
      stripe_configured: stripe_configured?,
      premium_subscription: premium?,
      can_accept_payments: can_accept_payments?,
      setup_completion_percentage: calculate_setup_completion
    }
  end

  def calculate_setup_completion
    total_steps = 2 # Stripe + Premium
    completed_steps = 0
    completed_steps += 1 if stripe_configured?
    completed_steps += 1 if premium?
    (completed_steps.to_f / total_steps * 100).round
  end

  def payment_setup_complete_for?(required_features)
    return true if required_features.blank?
    
    required_features.all? do |feature|
      case feature
      when 'stripe_payments'
        stripe_configured?
      when 'premium_subscription'
        premium?
      else
        true # Unknown features are considered complete
      end
    end
  end

  private

  def auto_confirm_admin_users
    if admin? || superadmin?
      self.confirmed_at = Time.current
      self.confirmation_token = nil
    end
  end

  def set_default_preferences
    self.preferences ||= default_preferences
    self.ai_settings ||= default_ai_settings
    self.monthly_ai_limit ||= default_ai_credits
  end

  def set_trial_end_date
    if subscription_status == 'trialing' && trial_ends_at.nil? && TrialConfig.trial_enabled?
      self.trial_ends_at = TrialConfig.trial_end_date(created_at || Time.current)
    end
  end

  def default_preferences
    {
      theme: 'light',
      notifications: {
        email: true,
        browser: true,
        form_responses: true,
        ai_insights: true
      },
      dashboard: {
        default_view: 'grid',
        items_per_page: 20
      }
    }
  end

  def default_ai_settings
    {
      auto_analysis: true,
      confidence_threshold: 0.7,
      preferred_model: 'gpt-3.5-turbo',
      max_tokens: 1000
    }
  end

  def default_ai_credits
    case role
    when 'superadmin'
      10000.0
    when 'admin'
      1000.0
    when 'premium'
      100.0
    else
      10.0
    end
  end

  def update_last_activity
    self.last_activity_at = Time.current if changed?
  end

  def validate_stripe_keys
    return unless stripe_enabled?
    
    if stripe_publishable_key.present?
      unless stripe_publishable_key.start_with?('pk_')
        errors.add(:stripe_publishable_key, 'must start with pk_')
      end
    end
    
    if stripe_secret_key.present?
      decrypted_key = decrypt_stripe_secret_key
      unless decrypted_key&.start_with?('sk_')
        errors.add(:stripe_secret_key, 'must start with sk_')
      end
    end
  end

  # Admin notification methods
  def notify_admin_of_registration
    AdminNotificationService.notify(:user_registered, user: self)
  rescue Redis::CannotConnectError, Redis::ConnectionError, Redis::TimeoutError => e
    Rails.logger.warn "Redis unavailable during user registration notification: #{e.message}"
    Rails.logger.info "User registration completed successfully, but admin notification skipped due to Redis connectivity"
    # Don't re-raise the error - allow user creation to continue
  rescue => e
    Rails.logger.error "Unexpected error during user registration notification: #{e.message}"
    Rails.logger.error "User ID: #{id}, Email: #{email}"
    
    # Send to error tracking service if available
    if defined?(Sentry)
      Sentry.capture_exception(e, extra: {
        context: 'user_registration_notification',
        user_id: id,
        user_email: email
      })
    end
    
    # Don't re-raise the error - allow user creation to continue
  end

  def notify_admin_of_subscription_changes
    begin
      if subscription_tier_changed? && subscription_tier_was.present?
        if subscription_tier == 'premium' && subscription_tier_was == 'basic'
          AdminNotificationService.notify(:user_upgraded, 
            user: self, 
            from_plan: subscription_tier_was, 
            to_plan: subscription_tier
          )
        elsif subscription_tier == 'basic' && subscription_tier_was == 'premium'
          AdminNotificationService.notify(:user_downgraded, 
            user: self, 
            from_plan: subscription_tier_was, 
            to_plan: subscription_tier
          )
        end
      end

      # Notify when trial starts
      if trial_ends_at_changed? && trial_ends_at.present? && trial_ends_at_was.nil?
        AdminNotificationService.notify(:trial_started, user: self)
      end
    rescue Redis::CannotConnectError, Redis::ConnectionError, Redis::TimeoutError => e
      Rails.logger.warn "Redis unavailable during subscription change notification: #{e.message}"
      Rails.logger.info "Subscription change completed successfully, but admin notification skipped due to Redis connectivity"
      # Don't re-raise the error - allow subscription change to continue
    rescue => e
      Rails.logger.error "Unexpected error during subscription change notification: #{e.message}"
      Rails.logger.error "User ID: #{id}, Email: #{email}"
      
      # Send to error tracking service if available
      if defined?(Sentry)
        Sentry.capture_exception(e, extra: {
          context: 'subscription_change_notification',
          user_id: id,
          user_email: email,
          subscription_tier_was: subscription_tier_was,
          subscription_tier: subscription_tier
        })
      end
      
      # Don't re-raise the error - allow subscription change to continue
    end
  end
end
</file>

<file path="policies/application_policy.rb">
# frozen_string_literal: true

class ApplicationPolicy
  attr_reader :user, :record

  def initialize(user, record)
    @user = user
    @record = record
  end

  def index?
    false
  end

  def show?
    false
  end

  def create?
    false
  end

  def new?
    create?
  end

  def update?
    false
  end

  def edit?
    update?
  end

  def destroy?
    false
  end

  class Scope
    def initialize(user, scope)
      @user = user
      @scope = scope
    end

    def resolve
      raise NoMethodError, "You must define #resolve in #{self.class}"
    end

    private

    attr_reader :user, :scope
  end
end
</file>

<file path="policies/form_policy.rb">
# frozen_string_literal: true

class FormPolicy < ApplicationPolicy
  class Scope < Scope
    def resolve
      # Superadmin can see all forms, regular users see only their own
      return scope.all if user&.superadmin?
      return scope.where(user: user) if user
      scope.none
    end
  end

  def index?
    user.present?
  end

  def show?
    owner? || admin?
  end

  def create?
    true
  end

  def new?
    create?
  end

  def update?
    owner? || admin?
  end

  def edit?
    update?
  end

  def destroy?
    owner? || admin?
  end

  def publish?
    owner? || admin?
  end

  def unpublish?
    owner? || admin?
  end

  def duplicate?
    show?
  end

  def analytics?
    owner? || admin?
  end

  def export?
    owner? || admin?
  end

  def preview?
    show?
  end

  def test_ai_feature?
    owner? || admin?
  end

  def embed_code?
    show?
  end

  def responses?
    owner? || admin?
  end

  def download_responses?
    owner? || admin?
  end

  def ai_features?
    user.premium? || user.admin? || user.superadmin?
  end

  def enable_ai?
    owner? && ai_features?
  end

  def test_connection?
    owner? || admin?
  end

  private

  def owner?
    record.user == user
  end

  def admin?
    user&.admin? || user&.superadmin?
  end
end
</file>

<file path="policies/form_question_policy.rb">
# frozen_string_literal: true

class FormQuestionPolicy < ApplicationPolicy
  def index?
    user.present? && (record.form.user == user || user.admin?)
  end

  def show?
    user.present? && (record.form.user == user || user.admin?)
  end

  def create?
    user.present? && (record.form.user == user || user.admin?)
  end

  def update?
    user.present? && (record.form.user == user || user.admin?)
  end

  def destroy?
    user.present? && (record.form.user == user || user.admin?)
  end

  def edit?
    update?
  end

  def new?
    create?
  end

  def move_up?
    update?
  end

  def move_down?
    update?
  end

  def duplicate?
    create?
  end

  def ai_enhance?
    update? && record.form.ai_enhanced?
  end

  def preview?
    show?
  end

  def analytics?
    show?
  end

  def reorder?
    update?
  end

  class Scope < Scope
    def resolve
      if user.admin?
        scope.all
      else
        scope.joins(:form).where(forms: { user: user })
      end
    end
  end
end
</file>

<file path="policies/form_response_policy.rb">
class FormResponsePolicy < ApplicationPolicy
  def show?
    user_owns_form?
  end

  def create?
    true # Anyone can create form responses (public forms)
  end

  def update?
    user_owns_form?
  end

  def destroy?
    user_owns_form?
  end

  def generate_report?
    user_owns_form?
  end

  private

  def user_owns_form?
    record.form.user == user
  end

  class Scope < Scope
    def resolve
      scope.joins(:form).where(forms: { user: user })
    end
  end
end
</file>

<file path="policies/form_template_policy.rb">
class FormTemplatePolicy < ApplicationPolicy
  class Scope < Scope
    def resolve
      scope.all
    end
  end

  def index?
    user.present?
  end

  def show?
    user.present?
  end

  def instantiate?
    user.present? && record.visibility == 'template_public' || record.visibility == 'featured'
  end

  def create?
    user&.admin? || user&.creator?
  end

  def update?
    user&.admin? || user&.creator? || record.creator == user
  end

  def destroy?
    user&.admin? || user&.creator? || record.creator == user
  end
end
</file>

<file path="policies/google_integration_policy.rb">
# frozen_string_literal: true

class GoogleIntegrationPolicy < ApplicationPolicy
  def show?
    user_owns_integration?
  end

  def create?
    user.present?
  end

  def update?
    user_owns_integration?
  end

  def destroy?
    user_owns_integration?
  end

  private

  def user_owns_integration?
    user.present? && record.user == user
  end
end
</file>

<file path="policies/google_sheets_integration_policy.rb">
class GoogleSheetsIntegrationPolicy < ApplicationPolicy
  def show?
    user_owns_form? && user_has_premium_access?
  end

  def create?
    user_owns_form? && user_has_premium_access?
  end

  def update?
    user_owns_form? && user_has_premium_access?
  end

  def destroy?
    user_owns_form? && user_has_premium_access?
  end

  def export?
    user_owns_form? && user_has_premium_access?
  end

  def toggle_auto_sync?
    user_owns_form? && user_has_premium_access?
  end

  def test_connection?
    user_owns_form? && user_has_premium_access?
  end

  private

  def user_owns_form?
    return false unless user && record

    # If record is a GoogleSheetsIntegration
    if record.is_a?(GoogleSheetsIntegration)
      record.form.user == user
    # If record is a Form (for create action)
    elsif record.is_a?(Form)
      record.user == user
    else
      false
    end
  end

  def user_has_premium_access?
    user&.can_use_google_sheets?
  end
end
</file>

<file path="policies/user_policy.rb">
# frozen_string_literal: true

class UserPolicy < ApplicationPolicy
  def show?
    user == record || user.admin?
  end

  def update?
    user == record || user.admin?
  end

  def destroy?
    user.admin? && user != record
  end

  class Scope < Scope
    def resolve
      if user.admin?
        scope.all
      else
        scope.where(id: user.id)
      end
    end
  end
end
</file>

<file path="services/ai/api_key_management_service.rb">
# frozen_string_literal: true

module Ai
  class ApiKeyManagementService < ApplicationService
    include ActiveModel::Model
    include ActiveModel::Attributes

    # API key rotation schedule (in hours)
    ROTATION_SCHEDULE = {
      openai: 168, # 7 days
      anthropic: 168, # 7 days
      google: 168 # 7 days
    }.freeze

    # Key validation patterns
    KEY_PATTERNS = {
      openai: /\Ask-[a-zA-Z0-9]{48}\z/,
      anthropic: /\Ask-ant-api03-[a-zA-Z0-9_-]{95}\z/,
      google: /\AAIza[a-zA-Z0-9_-]{35}\z/
    }.freeze

    attribute :provider, :string
    attribute :environment, :string, default: Rails.env
    attribute :force_rotation, :boolean, default: false

    def rotate_api_keys
      return { success: false, errors: ['Provider is required'] } if provider.blank?
      return { success: false, errors: ['Invalid provider'] } unless valid_provider?

      begin
        current_key_info = get_current_key_info
        
        # Check if rotation is needed
        unless force_rotation || rotation_needed?(current_key_info)
          return {
            success: true,
            message: 'Key rotation not needed',
            next_rotation: current_key_info[:next_rotation]
          }
        end

        # Generate new key (this would typically involve calling the provider's API)
        new_key_result = generate_new_api_key
        return new_key_result unless new_key_result[:success]

        # Validate new key
        validation_result = validate_api_key(new_key_result[:api_key])
        return validation_result unless validation_result[:success]

        # Store new key securely
        storage_result = store_api_key_securely(new_key_result[:api_key])
        return storage_result unless storage_result[:success]

        # Test new key functionality
        test_result = test_api_key_functionality(new_key_result[:api_key])
        if test_result[:success]
          # Update key rotation record
          update_rotation_record(new_key_result[:api_key])
          
          # Log successful rotation
          log_key_rotation('success')
          
          {
            success: true,
            message: 'API key rotated successfully',
            provider: provider,
            rotated_at: Time.current,
            next_rotation: Time.current + ROTATION_SCHEDULE[provider.to_sym].hours
          }
        else
          # Rollback if test fails
          rollback_key_rotation
          log_key_rotation('failed', test_result[:error])
          
          {
            success: false,
            errors: ['New API key failed functionality test'],
            details: test_result
          }
        end

      rescue => e
        Rails.logger.error "API key rotation failed: #{e.message}"
        log_key_rotation('error', e.message)
        
        {
          success: false,
          errors: ['API key rotation failed'],
          error_details: e.message
        }
      end
    end

    def validate_current_keys
      results = {}
      
      ROTATION_SCHEDULE.keys.each do |provider_name|
        self.provider = provider_name.to_s
        
        begin
          current_key = get_current_api_key
          if current_key
            validation_result = validate_api_key(current_key)
            test_result = test_api_key_functionality(current_key)
            
            results[provider_name] = {
              valid_format: validation_result[:success],
              functional: test_result[:success],
              last_rotation: get_last_rotation_time,
              next_rotation: get_next_rotation_time,
              needs_rotation: rotation_needed?
            }
          else
            results[provider_name] = {
              valid_format: false,
              functional: false,
              error: 'API key not found'
            }
          end
        rescue => e
          results[provider_name] = {
            valid_format: false,
            functional: false,
            error: e.message
          }
        end
      end
      
      {
        success: true,
        validation_results: results,
        overall_health: results.values.all? { |r| r[:functional] }
      }
    end

    def get_usage_analytics
      return { success: false, errors: ['Provider is required'] } if provider.blank?

      begin
        # Get usage data from cache or database
        usage_data = Rails.cache.fetch("api_usage_analytics:#{provider}", expires_in: 1.hour) do
          calculate_usage_analytics
        end

        # Detect anomalies
        anomalies = detect_usage_anomalies(usage_data)

        {
          success: true,
          provider: provider,
          usage_data: usage_data,
          anomalies: anomalies,
          generated_at: Time.current
        }
      rescue => e
        Rails.logger.error "Failed to get usage analytics: #{e.message}"
        { success: false, errors: ['Failed to retrieve usage analytics'] }
      end
    end

    private

    def valid_provider?
      ROTATION_SCHEDULE.key?(provider.to_sym)
    end

    def get_current_key_info
      {
        api_key: get_current_api_key,
        last_rotation: get_last_rotation_time,
        next_rotation: get_next_rotation_time
      }
    end

    def rotation_needed?(key_info = nil)
      key_info ||= get_current_key_info
      return true if key_info[:last_rotation].nil?
      
      hours_since_rotation = (Time.current - key_info[:last_rotation]) / 1.hour
      hours_since_rotation >= ROTATION_SCHEDULE[provider.to_sym]
    end

    def generate_new_api_key
      # In a real implementation, this would call the provider's API to generate a new key
      # For now, we'll simulate this process
      
      case provider.to_sym
      when :openai
        # Simulate OpenAI key generation
        new_key = "sk-#{SecureRandom.alphanumeric(48)}"
      when :anthropic
        # Simulate Anthropic key generation
        new_key = "sk-ant-api03-#{SecureRandom.urlsafe_base64(95).tr('=', '')}"
      when :google
        # Simulate Google key generation
        new_key = "AIza#{SecureRandom.urlsafe_base64(35).tr('=', '')}"
      else
        return { success: false, errors: ['Unsupported provider for key generation'] }
      end

      { success: true, api_key: new_key }
    end

    def validate_api_key(api_key)
      pattern = KEY_PATTERNS[provider.to_sym]
      
      if pattern && api_key.match?(pattern)
        { success: true }
      else
        { success: false, errors: ['Invalid API key format'] }
      end
    end

    def store_api_key_securely(api_key)
      # Store in Rails credentials or environment variables
      # This is a simplified implementation
      
      credential_key = "#{provider}_api_key"
      
      # In production, you would update Rails credentials or use a secure key management service
      Rails.application.credentials.config[credential_key.to_sym] = api_key
      
      { success: true }
    rescue => e
      Rails.logger.error "Failed to store API key: #{e.message}"
      { success: false, errors: ['Failed to store API key securely'] }
    end

    def test_api_key_functionality(api_key)
      # Test the API key with a simple request
      case provider.to_sym
      when :openai
        test_openai_key(api_key)
      when :anthropic
        test_anthropic_key(api_key)
      when :google
        test_google_key(api_key)
      else
        { success: false, error: 'Unsupported provider for testing' }
      end
    end

    def test_openai_key(api_key)
      # Simulate OpenAI API test
      # In reality, you would make a simple API call to verify the key works
      { success: true }
    rescue => e
      { success: false, error: e.message }
    end

    def test_anthropic_key(api_key)
      # Simulate Anthropic API test
      { success: true }
    rescue => e
      { success: false, error: e.message }
    end

    def test_google_key(api_key)
      # Simulate Google API test
      { success: true }
    rescue => e
      { success: false, error: e.message }
    end

    def get_current_api_key
      credential_key = "#{provider}_api_key"
      Rails.application.credentials.dig(credential_key.to_sym) || ENV["#{provider.upcase}_API_KEY"]
    end

    def get_last_rotation_time
      Rails.cache.read("api_key_rotation:#{provider}:last_rotation")
    end

    def get_next_rotation_time
      last_rotation = get_last_rotation_time
      return nil unless last_rotation
      
      last_rotation + ROTATION_SCHEDULE[provider.to_sym].hours
    end

    def update_rotation_record(api_key)
      cache_key = "api_key_rotation:#{provider}"
      rotation_data = {
        last_rotation: Time.current,
        key_hash: Digest::SHA256.hexdigest(api_key),
        rotation_count: (Rails.cache.read("#{cache_key}:rotation_count") || 0) + 1
      }
      
      Rails.cache.write("#{cache_key}:last_rotation", Time.current, expires_in: 1.year)
      Rails.cache.write("#{cache_key}:rotation_count", rotation_data[:rotation_count], expires_in: 1.year)
    end

    def rollback_key_rotation
      # In a real implementation, you would restore the previous key
      Rails.logger.warn "Rolling back API key rotation for #{provider}"
    end

    def calculate_usage_analytics
      # Calculate usage metrics from logs or monitoring data
      {
        requests_today: rand(100..1000),
        requests_this_week: rand(500..5000),
        requests_this_month: rand(2000..20000),
        average_response_time: rand(200..2000),
        error_rate: rand(0.0..5.0).round(2),
        cost_today: rand(1.0..50.0).round(2),
        cost_this_month: rand(50.0..500.0).round(2)
      }
    end

    def detect_usage_anomalies(usage_data)
      anomalies = []
      
      # Check for unusual request volume
      if usage_data[:requests_today] > usage_data[:requests_this_week] / 7 * 3
        anomalies << {
          type: 'high_request_volume',
          severity: 'medium',
          description: 'Request volume is significantly higher than average'
        }
      end
      
      # Check for high error rate
      if usage_data[:error_rate] > 10.0
        anomalies << {
          type: 'high_error_rate',
          severity: 'high',
          description: 'Error rate is above acceptable threshold'
        }
      end
      
      # Check for unusual costs
      if usage_data[:cost_today] > usage_data[:cost_this_month] / 30 * 5
        anomalies << {
          type: 'high_cost',
          severity: 'medium',
          description: 'Daily cost is significantly higher than average'
        }
      end
      
      anomalies
    end

    def log_key_rotation(status, error_message = nil)
      AuditLog.create!(
        event_type: 'api_key_rotation',
        details: {
          provider: provider,
          status: status,
          error_message: error_message,
          environment: environment,
          force_rotation: force_rotation
        }
      )
    rescue => e
      Rails.logger.error "Failed to log key rotation: #{e.message}"
    end
  end
end
</file>

<file path="services/ai/cache_management_service.rb">
# frozen_string_literal: true

module Ai
  class CacheManagementService
    include ActiveModel::Model
    
    class << self
      # Schedule cache warming
      def schedule_cache_warming(cache_types = [:form_templates, :user_preferences])
        Ai::CacheWarmingJob.perform_later(cache_types)
        Rails.logger.info "Scheduled cache warming for types: #{cache_types.join(', ')}"
      end
      
      # Perform cache maintenance
      def perform_maintenance
        Rails.logger.info "Starting AI cache maintenance"
        
        stats_before = Ai::CachingService.cache_statistics
        
        # Clean expired entries
        clean_expired_entries
        
        # Optimize cache usage
        optimize_cache_usage
        
        # Update cache statistics
        stats_after = Ai::CachingService.cache_statistics
        
        maintenance_report = {
          started_at: Time.current.iso8601,
          stats_before: stats_before,
          stats_after: stats_after,
          actions_performed: [
            'cleaned_expired_entries',
            'optimized_cache_usage'
          ]
        }
        
        Rails.logger.info "AI cache maintenance completed"
        maintenance_report
      end
      
      # Clean expired or stale cache entries
      def clean_expired_entries
        Rails.logger.info "Cleaning expired cache entries"
        
        # Clean old content analysis results (older than 7 days)
        clean_old_entries(:content_analysis, 7.days.ago)
        
        # Clean unused form templates (not accessed in 30 days)
        clean_unused_templates(30.days.ago)
        
        # Clean old document processing results (older than 1 day)
        clean_old_entries(:document_processing, 1.day.ago)
        
        Rails.logger.info "Expired cache entries cleaned"
      end
      
      # Optimize cache usage by removing low-value entries
      def optimize_cache_usage
        Rails.logger.info "Optimizing cache usage"
        
        # Remove form templates with low usage
        remove_low_usage_templates
        
        # Consolidate similar content analysis results
        consolidate_similar_analyses
        
        Rails.logger.info "Cache usage optimized"
      end
      
      # Get comprehensive cache health report
      def cache_health_report
        stats = Ai::CachingService.cache_statistics
        
        health_report = {
          timestamp: Time.current.iso8601,
          overall_health: calculate_overall_health(stats),
          cache_statistics: stats,
          recommendations: generate_recommendations(stats),
          performance_metrics: calculate_performance_metrics,
          storage_usage: calculate_storage_usage(stats)
        }
        
        health_report
      end
      
      # Monitor cache performance
      def monitor_cache_performance
        Rails.logger.info "Monitoring cache performance"
        
        performance_data = {
          timestamp: Time.current.iso8601,
          hit_rates: calculate_hit_rates,
          response_times: calculate_response_times,
          error_rates: calculate_error_rates,
          storage_efficiency: calculate_storage_efficiency
        }
        
        # Track performance metrics
        Ai::UsageAnalyticsService.track_event({
          event_type: 'cache_performance_monitoring',
          data: performance_data
        })
        
        performance_data
      end
      
      # Invalidate cache intelligently based on patterns
      def intelligent_cache_invalidation(trigger_event, context = {})
        Rails.logger.info "Performing intelligent cache invalidation for event: #{trigger_event}"
        
        case trigger_event.to_sym
        when :user_preferences_changed
          user_id = context[:user_id]
          Ai::CachingService.invalidate_cache(:user_preferences, user_id) if user_id
          
        when :form_template_updated
          # Invalidate related form templates
          category = context[:category]
          approach = context[:approach]
          invalidate_related_templates(category, approach)
          
        when :ai_model_updated
          # Invalidate all LLM response caches
          Ai::CachingService.invalidate_cache(:llm_responses)
          Ai::CachingService.invalidate_cache(:content_analysis)
          
        when :system_maintenance
          # Selective invalidation during maintenance
          perform_maintenance_invalidation
          
        else
          Rails.logger.warn "Unknown cache invalidation trigger: #{trigger_event}"
        end
      end
      
      # Preload cache for high-traffic patterns
      def preload_high_traffic_cache
        Rails.logger.info "Preloading cache for high-traffic patterns"
        
        # Identify high-traffic patterns from analytics
        high_traffic_patterns = identify_high_traffic_patterns
        
        high_traffic_patterns.each do |pattern|
          case pattern[:type]
          when 'content_analysis'
            preload_content_analysis_cache(pattern[:data])
          when 'form_template'
            preload_form_template_cache(pattern[:data])
          when 'user_preferences'
            preload_user_preferences_cache(pattern[:data])
          end
        end
        
        Rails.logger.info "High-traffic cache preloading completed"
      end
      
      # Configure cache warming schedule
      def configure_cache_warming_schedule
        # Schedule regular cache warming
        # This would typically be called from an initializer or scheduled job
        
        # Warm form templates every 6 hours
        schedule_recurring_job('form_templates_warming', 6.hours) do
          Ai::CacheWarmingJob.perform_later([:form_templates])
        end
        
        # Warm user preferences every 12 hours
        schedule_recurring_job('user_preferences_warming', 12.hours) do
          Ai::CacheWarmingJob.perform_later([:user_preferences])
        end
        
        # Full cache maintenance daily
        schedule_recurring_job('cache_maintenance', 24.hours) do
          perform_maintenance
        end
        
        Rails.logger.info "Cache warming schedule configured"
      end
      
      private
      
      # Clean old entries by type and age
      def clean_old_entries(cache_type, cutoff_time)
        # This would need to be implemented based on the cache store
        # For Redis, we could use pattern matching and TTL checking
        Rails.logger.debug "Cleaning old #{cache_type} entries older than #{cutoff_time}"
      end
      
      # Clean unused form templates
      def clean_unused_templates(cutoff_time)
        Rails.logger.debug "Cleaning unused form templates older than #{cutoff_time}"
        
        # Implementation would check template usage counts and last access times
        # Remove templates with usage_count < 2 and not accessed recently
      end
      
      # Remove form templates with low usage
      def remove_low_usage_templates
        Rails.logger.debug "Removing low-usage form templates"
        
        # Implementation would analyze template usage patterns
        # Remove templates with very low usage counts
      end
      
      # Consolidate similar content analysis results
      def consolidate_similar_analyses
        Rails.logger.debug "Consolidating similar content analysis results"
        
        # Implementation would find similar content hashes
        # and consolidate their analysis results
      end
      
      # Calculate overall cache health score
      def calculate_overall_health(stats)
        # Simple health calculation based on cache statistics
        total_entries = stats.values.sum { |stat| stat[:total_entries] }
        
        if total_entries > 10000
          'poor' # Too many entries, might need cleanup
        elsif total_entries > 1000
          'good'
        elsif total_entries > 100
          'excellent'
        else
          'fair' # Too few entries, might need warming
        end
      end
      
      # Generate cache optimization recommendations
      def generate_recommendations(stats)
        recommendations = []
        
        stats.each do |cache_type, stat|
          if stat[:total_entries] > 1000
            recommendations << "Consider cleaning old #{cache_type} entries"
          elsif stat[:total_entries] < 10
            recommendations << "Consider warming #{cache_type} cache"
          end
        end
        
        recommendations
      end
      
      # Calculate performance metrics
      def calculate_performance_metrics
        # This would analyze recent cache operations
        # and calculate performance metrics
        {
          average_hit_rate: 0.85,
          average_response_time_ms: 2.5,
          cache_efficiency: 0.92
        }
      end
      
      # Calculate storage usage
      def calculate_storage_usage(stats)
        total_size = stats.values.sum { |stat| stat[:cache_size_estimate] }
        
        {
          total_size_bytes: total_size,
          total_size_mb: (total_size / 1024.0 / 1024.0).round(2),
          breakdown: stats.transform_values { |stat| stat[:cache_size_estimate] }
        }
      end
      
      # Calculate cache hit rates
      def calculate_hit_rates
        # This would analyze recent cache operations from analytics
        {
          content_analysis: 0.78,
          form_templates: 0.65,
          document_processing: 0.82,
          user_preferences: 0.71
        }
      end
      
      # Calculate cache response times
      def calculate_response_times
        {
          content_analysis: 1.2,
          form_templates: 0.8,
          document_processing: 2.1,
          user_preferences: 0.5
        }
      end
      
      # Calculate cache error rates
      def calculate_error_rates
        {
          content_analysis: 0.02,
          form_templates: 0.01,
          document_processing: 0.03,
          user_preferences: 0.01
        }
      end
      
      # Calculate storage efficiency
      def calculate_storage_efficiency
        # Ratio of useful cache entries to total entries
        0.89
      end
      
      # Invalidate related templates
      def invalidate_related_templates(category, approach)
        Rails.logger.debug "Invalidating templates for category: #{category}, approach: #{approach}"
        
        # Implementation would find and invalidate related template cache entries
      end
      
      # Perform maintenance-specific invalidation
      def perform_maintenance_invalidation
        Rails.logger.debug "Performing maintenance-specific cache invalidation"
        
        # Selectively invalidate caches that might be affected by maintenance
        # Keep user preferences and frequently used templates
      end
      
      # Identify high-traffic patterns from analytics
      def identify_high_traffic_patterns
        # This would analyze usage analytics to identify patterns
        # that are accessed frequently and should be preloaded
        [
          {
            type: 'form_template',
            data: { approach: 'lead_capture', category: 'lead_generation' },
            frequency: 150
          },
          {
            type: 'content_analysis',
            data: { content_type: 'contact_form_request' },
            frequency: 120
          }
        ]
      end
      
      # Preload content analysis cache
      def preload_content_analysis_cache(pattern_data)
        Rails.logger.debug "Preloading content analysis cache for pattern: #{pattern_data}"
        
        # Implementation would generate and cache common content analysis results
      end
      
      # Preload form template cache
      def preload_form_template_cache(pattern_data)
        Rails.logger.debug "Preloading form template cache for pattern: #{pattern_data}"
        
        # Implementation would generate and cache common form templates
      end
      
      # Preload user preferences cache
      def preload_user_preferences_cache(pattern_data)
        Rails.logger.debug "Preloading user preferences cache for pattern: #{pattern_data}"
        
        # Implementation would generate and cache common user preferences
      end
      
      # Schedule recurring jobs (placeholder - would use actual job scheduler)
      def schedule_recurring_job(job_name, interval, &block)
        Rails.logger.debug "Scheduling recurring job: #{job_name} every #{interval}"
        
        # In a real implementation, this would use a job scheduler like
        # whenever gem, sidekiq-cron, or similar
        block.call if block_given?
      end
    end
  end
end
</file>

<file path="services/ai/caching_service.rb">
# frozen_string_literal: true

module Ai
  class CachingService
    include ActiveModel::Model
    
    # Cache TTL configurations (in seconds)
    CACHE_TTLS = {
      content_analysis: 24.hours.to_i,      # Content analysis results
      form_templates: 7.days.to_i,          # Common form patterns
      document_processing: 1.hour.to_i,     # Document extraction results
      llm_responses: 12.hours.to_i,         # LLM response caching
      user_preferences: 30.days.to_i        # User form preferences
    }.freeze
    
    # Cache key prefixes for organization
    CACHE_PREFIXES = {
      content_analysis: 'ai:content_analysis',
      form_templates: 'ai:form_templates',
      document_processing: 'ai:document_processing',
      llm_responses: 'ai:llm_responses',
      user_preferences: 'ai:user_preferences'
    }.freeze
    
    class << self
      # Cache content analysis results based on content hash
      def cache_content_analysis(content_hash, analysis_result)
        cache_key = build_cache_key(:content_analysis, content_hash)
        
        cache_data = {
          analysis_result: analysis_result,
          cached_at: Time.current.iso8601,
          cache_version: '1.0'
        }
        
        begin
          Rails.cache.write(cache_key, cache_data, expires_in: CACHE_TTLS[:content_analysis])
          
          Rails.logger.info "Cached content analysis for hash: #{content_hash[0..8]}..."
          cache_data
        rescue Redis::CannotConnectError, Redis::ConnectionError, Redis::TimeoutError => e
          RedisErrorLogger.log_connection_error(e, {
            component: 'ai_caching_service',
            operation: 'cache_content_analysis',
            cache_key: cache_key,
            content_hash: content_hash[0..8]
          })
          
          # Return the data even if caching failed
          cache_data
        end
      end
      
      # Retrieve cached content analysis
      def get_cached_content_analysis(content_hash)
        cache_key = build_cache_key(:content_analysis, content_hash)
        
        begin
          cached_data = Rails.cache.read(cache_key)
          
          if cached_data
            Rails.logger.info "Cache hit for content analysis: #{content_hash[0..8]}..."
            
            # Track cache hit for analytics
            track_cache_hit(:content_analysis, content_hash)
            
            cached_data[:analysis_result]
          else
            Rails.logger.debug "Cache miss for content analysis: #{content_hash[0..8]}..."
            
            # Track cache miss for analytics
            track_cache_miss(:content_analysis, content_hash)
            
            nil
          end
        rescue Redis::CannotConnectError, Redis::ConnectionError, Redis::TimeoutError => e
          RedisErrorLogger.log_connection_error(e, {
            component: 'ai_caching_service',
            operation: 'get_cached_content_analysis',
            cache_key: cache_key,
            content_hash: content_hash[0..8]
          })
          
          # Return nil when cache is unavailable
          nil
        end
      end
      
      # Cache form templates for common patterns
      def cache_form_template(template_key, form_structure)
        cache_key = build_cache_key(:form_templates, template_key)
        
        cache_data = {
          form_structure: form_structure,
          usage_count: 1,
          cached_at: Time.current.iso8601,
          cache_version: '1.0'
        }
        
        # Try to increment usage count if template already exists
        existing_data = Rails.cache.read(cache_key)
        if existing_data
          cache_data[:usage_count] = existing_data[:usage_count] + 1
        end
        
        Rails.cache.write(cache_key, cache_data, expires_in: CACHE_TTLS[:form_templates])
        
        Rails.logger.info "Cached form template: #{template_key}"
        cache_data
      end
      
      # Retrieve cached form template
      def get_cached_form_template(template_key)
        cache_key = build_cache_key(:form_templates, template_key)
        cached_data = Rails.cache.read(cache_key)
        
        if cached_data
          Rails.logger.info "Cache hit for form template: #{template_key}"
          
          # Update usage count
          cached_data[:usage_count] += 1
          Rails.cache.write(cache_key, cached_data, expires_in: CACHE_TTLS[:form_templates])
          
          track_cache_hit(:form_templates, template_key)
          cached_data[:form_structure]
        else
          Rails.logger.debug "Cache miss for form template: #{template_key}"
          track_cache_miss(:form_templates, template_key)
          nil
        end
      end
      
      # Cache document processing results
      def cache_document_processing(file_hash, processing_result)
        cache_key = build_cache_key(:document_processing, file_hash)
        
        cache_data = {
          processing_result: processing_result,
          cached_at: Time.current.iso8601,
          cache_version: '1.0'
        }
        
        Rails.cache.write(cache_key, cache_data, expires_in: CACHE_TTLS[:document_processing])
        
        Rails.logger.info "Cached document processing for hash: #{file_hash[0..8]}..."
        cache_data
      end
      
      # Retrieve cached document processing result
      def get_cached_document_processing(file_hash)
        cache_key = build_cache_key(:document_processing, file_hash)
        cached_data = Rails.cache.read(cache_key)
        
        if cached_data
          Rails.logger.info "Cache hit for document processing: #{file_hash[0..8]}..."
          track_cache_hit(:document_processing, file_hash)
          cached_data[:processing_result]
        else
          Rails.logger.debug "Cache miss for document processing: #{file_hash[0..8]}..."
          track_cache_miss(:document_processing, file_hash)
          nil
        end
      end
      
      # Cache LLM responses for similar prompts
      def cache_llm_response(prompt_hash, model, temperature, response)
        cache_key = build_cache_key(:llm_responses, "#{prompt_hash}_#{model}_#{temperature}")
        
        cache_data = {
          response: response,
          model: model,
          temperature: temperature,
          cached_at: Time.current.iso8601,
          cache_version: '1.0'
        }
        
        Rails.cache.write(cache_key, cache_data, expires_in: CACHE_TTLS[:llm_responses])
        
        Rails.logger.info "Cached LLM response for model #{model}: #{prompt_hash[0..8]}..."
        cache_data
      end
      
      # Retrieve cached LLM response
      def get_cached_llm_response(prompt_hash, model, temperature)
        cache_key = build_cache_key(:llm_responses, "#{prompt_hash}_#{model}_#{temperature}")
        cached_data = Rails.cache.read(cache_key)
        
        if cached_data
          Rails.logger.info "Cache hit for LLM response (#{model}): #{prompt_hash[0..8]}..."
          track_cache_hit(:llm_responses, prompt_hash)
          cached_data[:response]
        else
          Rails.logger.debug "Cache miss for LLM response (#{model}): #{prompt_hash[0..8]}..."
          track_cache_miss(:llm_responses, prompt_hash)
          nil
        end
      end
      
      # Cache user form preferences
      def cache_user_preferences(user_id, preferences)
        cache_key = build_cache_key(:user_preferences, user_id)
        
        cache_data = {
          preferences: preferences,
          cached_at: Time.current.iso8601,
          cache_version: '1.0'
        }
        
        Rails.cache.write(cache_key, cache_data, expires_in: CACHE_TTLS[:user_preferences])
        
        Rails.logger.info "Cached user preferences for user: #{user_id}"
        cache_data
      end
      
      # Retrieve cached user preferences
      def get_cached_user_preferences(user_id)
        cache_key = build_cache_key(:user_preferences, user_id)
        cached_data = Rails.cache.read(cache_key)
        
        if cached_data
          Rails.logger.info "Cache hit for user preferences: #{user_id}"
          track_cache_hit(:user_preferences, user_id)
          cached_data[:preferences]
        else
          Rails.logger.debug "Cache miss for user preferences: #{user_id}"
          track_cache_miss(:user_preferences, user_id)
          nil
        end
      end
      
      # Invalidate cache entries
      def invalidate_cache(cache_type, identifier = nil)
        if identifier
          cache_key = build_cache_key(cache_type, identifier)
          Rails.cache.delete(cache_key)
          Rails.logger.info "Invalidated cache: #{cache_key}"
        else
          # Invalidate all entries of this type (pattern-based deletion)
          pattern = "#{CACHE_PREFIXES[cache_type]}:*"
          invalidate_cache_pattern(pattern)
          Rails.logger.info "Invalidated all cache entries for type: #{cache_type}"
        end
      end
      
      # Warm cache with common patterns
      def warm_cache
        Rails.logger.info "Starting cache warming process..."
        
        # Warm form templates cache with common patterns
        warm_form_templates_cache
        
        # Warm user preferences for active users
        warm_user_preferences_cache
        
        Rails.logger.info "Cache warming completed"
      end
      
      # Get cache statistics
      def cache_statistics
        stats = {}
        
        CACHE_PREFIXES.each do |type, prefix|
          pattern = "#{prefix}:*"
          keys = get_cache_keys_by_pattern(pattern)
          
          stats[type] = {
            total_entries: keys.length,
            cache_size_estimate: estimate_cache_size(keys),
            oldest_entry: find_oldest_cache_entry(keys),
            newest_entry: find_newest_cache_entry(keys)
          }
        end
        
        stats
      end
      
      # Generate content hash for caching
      def generate_content_hash(content, additional_params = {})
        hash_input = {
          content: content.to_s.strip,
          params: additional_params.sort.to_h
        }.to_json
        
        Digest::SHA256.hexdigest(hash_input)
      end
      
      # Generate template key for form patterns
      def generate_template_key(analysis_result)
        key_components = [
          analysis_result['recommended_approach'],
          analysis_result['complexity_level'],
          analysis_result['suggested_question_count'],
          analysis_result['form_category']
        ].compact
        
        Digest::SHA256.hexdigest(key_components.join('_'))
      end
      
      private
      
      # Build standardized cache keys
      def build_cache_key(cache_type, identifier)
        prefix = CACHE_PREFIXES[cache_type]
        "#{prefix}:#{identifier}"
      end
      
      # Track cache hits for analytics
      def track_cache_hit(cache_type, identifier)
        Ai::UsageAnalyticsService.track_event({
          event_type: 'cache_hit',
          cache_type: cache_type.to_s,
          identifier: identifier.to_s[0..16], # Truncate for privacy
          timestamp: Time.current.iso8601
        })
      end
      
      # Track cache misses for analytics
      def track_cache_miss(cache_type, identifier)
        Ai::UsageAnalyticsService.track_event({
          event_type: 'cache_miss',
          cache_type: cache_type.to_s,
          identifier: identifier.to_s[0..16], # Truncate for privacy
          timestamp: Time.current.iso8601
        })
      end
      
      # Invalidate cache entries by pattern
      def invalidate_cache_pattern(pattern)
        # This implementation depends on the cache store
        # For Redis-based cache stores, we can use pattern matching
        if Rails.cache.respond_to?(:delete_matched)
          Rails.cache.delete_matched(pattern)
        else
          # Fallback for other cache stores
          Rails.logger.warn "Pattern-based cache invalidation not supported by current cache store"
        end
      end
      
      # Warm form templates cache with common patterns
      def warm_form_templates_cache
        common_patterns = [
          {
            recommended_approach: 'lead_capture',
            complexity_level: 'simple',
            suggested_question_count: 5,
            form_category: 'lead_generation'
          },
          {
            recommended_approach: 'feedback',
            complexity_level: 'moderate',
            suggested_question_count: 8,
            form_category: 'customer_feedback'
          },
          {
            recommended_approach: 'survey',
            complexity_level: 'complex',
            suggested_question_count: 12,
            form_category: 'market_research'
          }
        ]
        
        common_patterns.each do |pattern|
          template_key = generate_template_key(pattern)
          
          # Only warm if not already cached
          unless get_cached_form_template(template_key)
            # Generate a basic template structure for this pattern
            template_structure = generate_basic_template(pattern)
            cache_form_template(template_key, template_structure)
          end
        end
      end
      
      # Warm user preferences cache for active users
      def warm_user_preferences_cache
        # Get recently active users (last 7 days)
        active_users = User.where('updated_at > ?', 7.days.ago)
                          .where.not(ai_credits_used: 0)
                          .limit(100)
        
        active_users.find_each do |user|
          # Generate basic preferences based on user's form history
          preferences = generate_user_preferences(user)
          cache_user_preferences(user.id, preferences)
        end
      end
      
      # Generate basic template structure for warming
      def generate_basic_template(pattern)
        {
          form_meta: {
            title: "#{pattern[:recommended_approach].humanize} Form",
            description: "Generated template for #{pattern[:form_category]}",
            category: pattern[:form_category],
            instructions: "Please fill out this form completely."
          },
          questions: generate_template_questions(pattern),
          form_settings: {
            one_question_per_page: pattern[:complexity_level] == 'complex',
            show_progress_bar: pattern[:suggested_question_count] > 5,
            allow_multiple_submissions: false,
            thank_you_message: "Thank you for your response!"
          }
        }
      end
      
      # Generate template questions based on pattern
      def generate_template_questions(pattern)
        base_questions = []
        
        case pattern[:recommended_approach]
        when 'lead_capture'
          base_questions = [
            { title: "What's your name?", question_type: "text_short", required: true },
            { title: "Email address", question_type: "email", required: true },
            { title: "Company name", question_type: "text_short", required: false },
            { title: "Phone number", question_type: "phone", required: false },
            { title: "How can we help you?", question_type: "text_long", required: true }
          ]
        when 'feedback'
          base_questions = [
            { title: "How would you rate your experience?", question_type: "rating", required: true },
            { title: "What did you like most?", question_type: "text_long", required: false },
            { title: "What could we improve?", question_type: "text_long", required: false },
            { title: "Would you recommend us?", question_type: "yes_no", required: true }
          ]
        when 'survey'
          base_questions = [
            { title: "Age range", question_type: "multiple_choice", required: false },
            { title: "Location", question_type: "text_short", required: false },
            { title: "Primary interest", question_type: "multiple_choice", required: true },
            { title: "Additional comments", question_type: "text_long", required: false }
          ]
        end
        
        # Limit to suggested question count
        base_questions.take(pattern[:suggested_question_count])
      end
      
      # Generate user preferences based on history
      def generate_user_preferences(user)
        {
          preferred_complexity: 'moderate',
          preferred_question_count: 8,
          common_categories: ['lead_generation', 'customer_feedback'],
          ai_features_usage: {
            sentiment_analysis: true,
            lead_scoring: true,
            dynamic_followup: false
          },
          last_updated: Time.current.iso8601
        }
      end
      
      # Get cache keys by pattern (Redis-specific)
      def get_cache_keys_by_pattern(pattern)
        if Rails.cache.respond_to?(:redis)
          begin
            Rails.cache.redis.keys(pattern)
          rescue Redis::CannotConnectError, Redis::ConnectionError, Redis::TimeoutError => e
            RedisErrorLogger.log_connection_error(e, {
              component: 'ai_caching_service',
              operation: 'get_cache_keys_by_pattern',
              pattern: pattern
            })
            
            # Return empty array when Redis is unavailable
            []
          end
        else
          []
        end
      end
      
      # Estimate cache size for keys
      def estimate_cache_size(keys)
        return 0 if keys.empty?
        
        sample_size = [keys.length, 10].min
        sample_keys = keys.sample(sample_size)
        
        total_size = sample_keys.sum do |key|
          data = Rails.cache.read(key)
          data ? data.to_json.bytesize : 0
        end
        
        # Extrapolate to all keys
        (total_size * keys.length / sample_size).round
      end
      
      # Find oldest cache entry
      def find_oldest_cache_entry(keys)
        return nil if keys.empty?
        
        oldest_time = nil
        keys.each do |key|
          data = Rails.cache.read(key)
          if data && data[:cached_at]
            cached_time = Time.parse(data[:cached_at])
            oldest_time = cached_time if oldest_time.nil? || cached_time < oldest_time
          end
        end
        
        oldest_time&.iso8601
      end
      
      # Find newest cache entry
      def find_newest_cache_entry(keys)
        return nil if keys.empty?
        
        newest_time = nil
        keys.each do |key|
          data = Rails.cache.read(key)
          if data && data[:cached_at]
            cached_time = Time.parse(data[:cached_at])
            newest_time = cached_time if newest_time.nil? || cached_time > newest_time
          end
        end
        
        newest_time&.iso8601
      end
    end
  end
end
</file>

<file path="services/ai/connection_pool_service.rb">
# frozen_string_literal: true

module Ai
  class ConnectionPoolService
    include ActiveModel::Model
    
    class << self
      # Configure connection pool for AI operations
      def configure_ai_connection_pool
        Rails.logger.info "Configuring connection pool for AI operations"
        
        # Get current pool configuration
        current_config = ActiveRecord::Base.connection_pool.db_config.configuration_hash
        
        # Calculate optimal pool size based on AI workload
        optimal_pool_size = calculate_optimal_pool_size
        
        # Configure pool settings
        configure_pool_settings(optimal_pool_size)
        
        Rails.logger.info "AI connection pool configured with size: #{optimal_pool_size}"
      end
      
      # Execute AI operations with dedicated connection
      def with_ai_connection(&block)
        ActiveRecord::Base.connection_pool.with_connection do |connection|
          # Set AI-specific connection parameters
          configure_connection_for_ai(connection)
          
          yield connection
        end
      end
      
      # Batch execute AI operations with connection optimization
      def batch_execute_ai_operations(operations, batch_size: 25)
        results = []
        
        operations.each_slice(batch_size) do |batch|
          batch_results = with_ai_connection do |connection|
            ActiveRecord::Base.transaction do
              batch.map { |operation| yield operation, connection }
            end
          end
          
          results.concat(batch_results)
          
          # Brief pause between batches to prevent connection exhaustion
          sleep(0.05) if operations.length > batch_size
        end
        
        results
      end
      
      # Monitor connection pool health
      def monitor_connection_pool_health
        pool = ActiveRecord::Base.connection_pool
        
        health_metrics = {
          timestamp: Time.current.iso8601,
          pool_size: pool.size,
          checked_out_connections: pool.checked_out.length,
          available_connections: pool.available.length,
          waiting_count: pool.waiting_count,
          pool_utilization: calculate_pool_utilization(pool),
          connection_health: check_connection_health(pool)
        }
        
        # Track health metrics
        Ai::UsageAnalyticsService.track_event({
          event_type: 'connection_pool_health',
          data: health_metrics
        })
        
        # Log warnings if pool is under stress
        log_pool_warnings(health_metrics)
        
        health_metrics
      end
      
      # Optimize connection pool based on AI usage patterns
      def optimize_pool_for_ai_usage
        Rails.logger.info "Optimizing connection pool for AI usage patterns"
        
        # Analyze recent AI operation patterns
        usage_patterns = analyze_ai_usage_patterns
        
        # Calculate optimal settings
        optimal_settings = calculate_optimal_settings(usage_patterns)
        
        # Apply optimizations
        apply_pool_optimizations(optimal_settings)
        
        Rails.logger.info "Connection pool optimized for AI usage"
        optimal_settings
      end
      
      # Preload connections for AI operations
      def preload_ai_connections(count: 5)
        Rails.logger.info "Preloading #{count} connections for AI operations"
        
        connections = []
        
        count.times do
          connection = ActiveRecord::Base.connection_pool.checkout
          configure_connection_for_ai(connection)
          connections << connection
        end
        
        # Return connections to pool
        connections.each do |connection|
          ActiveRecord::Base.connection_pool.checkin(connection)
        end
        
        Rails.logger.info "Preloaded #{connections.length} AI-optimized connections"
      end
      
      # Handle connection pool exhaustion
      def handle_pool_exhaustion
        Rails.logger.warn "Connection pool exhaustion detected"
        
        pool = ActiveRecord::Base.connection_pool
        
        # Try to free up connections
        freed_connections = 0
        
        # Clear idle connections
        pool.flush!
        freed_connections += 1
        
        # Force garbage collection to free up resources
        GC.start
        
        # Log recovery attempt
        Rails.logger.info "Pool exhaustion recovery: freed #{freed_connections} connections"
        
        # Track exhaustion event
        Ai::UsageAnalyticsService.track_event({
          event_type: 'connection_pool_exhaustion',
          data: {
            timestamp: Time.current.iso8601,
            freed_connections: freed_connections,
            pool_size: pool.size,
            recovery_action: 'flush_and_gc'
          }
        })
      end
      
      # Get connection pool statistics
      def connection_pool_statistics
        pool = ActiveRecord::Base.connection_pool
        
        {
          pool_size: pool.size,
          checked_out: pool.checked_out.length,
          available: pool.available.length,
          waiting: pool.waiting_count,
          utilization_percentage: calculate_pool_utilization(pool),
          health_status: determine_pool_health_status(pool)
        }
      end
      
      private
      
      # Calculate optimal pool size for AI operations
      def calculate_optimal_pool_size
        # Base pool size
        base_size = ENV.fetch('DATABASE_POOL_SIZE', 5).to_i
        
        # Factor in AI operation concurrency
        ai_concurrency_factor = calculate_ai_concurrency_factor
        
        # Calculate optimal size
        optimal_size = [base_size + ai_concurrency_factor, 25].min # Cap at 25
        
        optimal_size
      end
      
      # Calculate AI concurrency factor
      def calculate_ai_concurrency_factor
        # Estimate based on Sidekiq AI queue concurrency
        sidekiq_ai_concurrency = ENV.fetch('SIDEKIQ_AI_CONCURRENCY', 5).to_i
        
        # Add buffer for web requests with AI operations
        web_ai_buffer = 3
        
        sidekiq_ai_concurrency + web_ai_buffer
      end
      
      # Configure pool settings
      def configure_pool_settings(pool_size)
        # This would typically be done in database.yml or environment configuration
        # Here we log the recommended settings
        
        recommended_settings = {
          pool: pool_size,
          checkout_timeout: 10, # seconds
          reaping_frequency: 60, # seconds
          idle_timeout: 300 # seconds
        }
        
        Rails.logger.info "Recommended pool settings: #{recommended_settings}"
        recommended_settings
      end
      
      # Configure connection for AI operations
      def configure_connection_for_ai(connection)
        # Set connection-specific parameters for AI workloads
        ai_settings = [
          "SET work_mem = '256MB'",           # Increase memory for complex queries
          "SET random_page_cost = 1.1",       # Optimize for SSD storage
          "SET effective_cache_size = '4GB'", # Assume reasonable cache size
          "SET statement_timeout = '300s'"    # 5 minute timeout for AI operations
        ]
        
        ai_settings.each do |setting|
          begin
            connection.execute(setting)
          rescue ActiveRecord::StatementInvalid => e
            Rails.logger.debug "Could not set AI connection parameter: #{e.message}"
          end
        end
      end
      
      # Calculate pool utilization percentage
      def calculate_pool_utilization(pool)
        return 0 if pool.size == 0
        
        ((pool.checked_out.length.to_f / pool.size) * 100).round(2)
      end
      
      # Check connection health
      def check_connection_health(pool)
        healthy_connections = 0
        total_connections = pool.size
        
        # Sample a few connections to check health
        sample_size = [total_connections, 3].min
        
        sample_size.times do
          begin
            connection = pool.checkout
            connection.execute('SELECT 1')
            healthy_connections += 1
            pool.checkin(connection)
          rescue => e
            Rails.logger.warn "Unhealthy connection detected: #{e.message}"
          end
        end
        
        health_percentage = (healthy_connections.to_f / sample_size * 100).round(2)
        
        {
          healthy_connections: healthy_connections,
          total_sampled: sample_size,
          health_percentage: health_percentage
        }
      end
      
      # Log pool warnings
      def log_pool_warnings(health_metrics)
        utilization = health_metrics[:pool_utilization]
        waiting_count = health_metrics[:waiting_count]
        
        if utilization > 80
          Rails.logger.warn "High connection pool utilization: #{utilization}%"
        end
        
        if waiting_count > 0
          Rails.logger.warn "Connections waiting in queue: #{waiting_count}"
        end
        
        if health_metrics[:connection_health][:health_percentage] < 100
          Rails.logger.warn "Some connections are unhealthy: #{health_metrics[:connection_health][:health_percentage]}%"
        end
      end
      
      # Analyze AI usage patterns
      def analyze_ai_usage_patterns
        # This would analyze recent AI operations to understand patterns
        {
          avg_concurrent_operations: 3.5,
          peak_concurrent_operations: 8,
          avg_operation_duration: 45.2, # seconds
          operations_per_hour: 120,
          peak_hours: [9, 10, 14, 15, 16] # Hours with highest AI usage
        }
      end
      
      # Calculate optimal settings based on usage patterns
      def calculate_optimal_settings(usage_patterns)
        peak_concurrency = usage_patterns[:peak_concurrent_operations]
        avg_duration = usage_patterns[:avg_operation_duration]
        
        # Calculate optimal pool size with buffer
        optimal_pool_size = (peak_concurrency * 1.5).ceil
        
        # Calculate optimal timeout based on operation duration
        optimal_timeout = (avg_duration * 2).ceil
        
        {
          pool_size: optimal_pool_size,
          checkout_timeout: optimal_timeout,
          reaping_frequency: 60,
          idle_timeout: 300
        }
      end
      
      # Apply pool optimizations
      def apply_pool_optimizations(settings)
        # Log the optimizations that should be applied
        Rails.logger.info "Recommended pool optimizations:"
        settings.each do |key, value|
          Rails.logger.info "  #{key}: #{value}"
        end
        
        # In a real implementation, these would be applied to the pool configuration
        # For now, we just track the recommendations
        Ai::UsageAnalyticsService.track_event({
          event_type: 'connection_pool_optimization',
          data: {
            timestamp: Time.current.iso8601,
            recommended_settings: settings,
            current_pool_size: ActiveRecord::Base.connection_pool.size
          }
        })
      end
      
      # Determine pool health status
      def determine_pool_health_status(pool)
        utilization = calculate_pool_utilization(pool)
        waiting_count = pool.waiting_count
        
        if waiting_count > 0 || utilization > 90
          'critical'
        elsif utilization > 80
          'warning'
        elsif utilization > 60
          'good'
        else
          'excellent'
        end
      end
    end
  end
end
</file>

<file path="services/ai/database_optimization_service.rb">
# frozen_string_literal: true

module Ai
  class DatabaseOptimizationService
    def self.create_form_with_questions_optimized(user, form_data, questions_data)
      ActiveRecord::Base.transaction do
        # Create the form
        form = user.forms.create!(form_data)
        
        # Create questions in batch
        questions = questions_data.map.with_index do |question_data, index|
          form.form_questions.create!(
            title: question_data['title'],
            question_type: question_data['type'],
            required: question_data['required'] || false,
            position: index + 1,
            question_config: question_data['config'] || {}
          )
        end
        
        {
          form: form,
          questions: questions
        }
      end
    end
  end
end
</file>

<file path="services/ai/document_processor.rb">
# frozen_string_literal: true

module Ai
  class DocumentProcessor
    include ActiveModel::Model
    include ActiveModel::Attributes
    include ActiveModel::Validations

    # Supported file types
    SUPPORTED_CONTENT_TYPES = [
      'application/pdf',
      'text/markdown',
      'text/plain'
    ].freeze

    # Maximum file size (10 MB)
    MAX_FILE_SIZE = 10.megabytes

    # Content length constraints (10-5000 words)
    MIN_WORD_COUNT = 10
    MAX_WORD_COUNT = 5000

    attribute :file
    attribute :content_type, :string
    attribute :file_size, :integer

    validates :file, presence: { message: "File is required" }
    validates :content_type, inclusion: { 
      in: SUPPORTED_CONTENT_TYPES, 
      message: "Unsupported file type. Supported types: PDF, Markdown, Plain text" 
    }
    validates :file_size, numericality: { 
      less_than: MAX_FILE_SIZE, 
      message: "File size must be less than 10 MB" 
    }

    def initialize(attributes = {})
      super
      extract_file_attributes if file.present?
    end

    def process
      return validation_error_response unless valid?

      begin
        # Security validation first
        security_result = Ai::SecurityService.new(file: file).validate_file_upload
        return security_result unless security_result[:success]

        # Generate file hash for caching
        file_hash = generate_file_hash
        
        # Check cache first
        cached_result = Ai::CachingService.get_cached_document_processing(file_hash)
        if cached_result
          Rails.logger.info "Using cached document processing result for file: #{file&.original_filename}"
          return cached_result
        end
        
        # Process document if not cached
        content = extract_content
        
        # Sanitize extracted content
        sanitization_result = Ai::SecurityService.new(content: content).sanitize_content(content)
        return sanitization_result unless sanitization_result[:success]
        
        sanitized_content = sanitization_result[:content]
        word_count = count_words(sanitized_content)
        
        return word_count_error_response(word_count) unless valid_word_count?(word_count)

        result = success_response(sanitized_content, word_count)
        
        # Cache the successful result
        Ai::CachingService.cache_document_processing(file_hash, result)
        
        result
      rescue StandardError => e
        Rails.logger.error "Document processing failed: #{e.message}"
        Rails.logger.error e.backtrace.join("\n")
        
        # Track the error for monitoring
        Ai::ErrorTrackingService.track_error({
          error_type: 'document_processing_error',
          error_message: "Document processing failed: #{e.message}",
          context: {
            file_size: file_size,
            content_type: content_type,
            file_name: file&.original_filename,
            error_class: e.class.name
          },
          severity: 'error'
        })
        
        error_response(['Failed to process document. Please try again.'])
      end
    end

    private

    def extract_file_attributes
      self.content_type = file.content_type
      self.file_size = file.size
    end

    def extract_content
      case content_type
      when 'application/pdf'
        extract_pdf_content
      when 'text/markdown', 'text/plain'
        extract_text_content
      else
        raise "Unsupported content type: #{content_type}"
      end
    end

    def extract_pdf_content
      require 'pdf-reader'
      
      content_parts = []
      page_count = 0
      
      PDF::Reader.open(file.tempfile) do |reader|
        reader.pages.each do |page|
          page_count += 1
          page_text = page.text.strip
          content_parts << page_text if page_text.present?
        end
      end

      content = content_parts.join("\n\n")
      
      # Store metadata for response
      @extraction_metadata = {
        page_count: page_count,
        pages_with_content: content_parts.size
      }

      content
    rescue PDF::Reader::MalformedPDFError => e
      Rails.logger.error "Malformed PDF: #{e.message}"
      raise "Invalid or corrupted PDF file"
    rescue PDF::Reader::UnsupportedFeatureError => e
      Rails.logger.error "Unsupported PDF feature: #{e.message}"
      raise "PDF contains unsupported features"
    end

    def extract_text_content
      content = file.read.force_encoding('UTF-8')
      
      # Handle encoding issues
      unless content.valid_encoding?
        content = content.encode('UTF-8', invalid: :replace, undef: :replace, replace: '')
      end

      # Store metadata for response
      line_count = content.lines.count
      @extraction_metadata = {
        line_count: line_count,
        encoding: content.encoding.name
      }

      content.strip
    rescue Encoding::InvalidByteSequenceError, Encoding::UndefinedConversionError => e
      Rails.logger.error "Text encoding error: #{e.message}"
      raise "Unable to process file due to encoding issues"
    ensure
      file.rewind if file.respond_to?(:rewind)
    end

    def count_words(content)
      return 0 if content.blank?
      
      # Remove markdown formatting and count words
      clean_content = content.gsub(/[#*_`\[\](){}]/, ' ')
                            .gsub(/\s+/, ' ')
                            .strip
      
      clean_content.split.size
    end

    def valid_word_count?(word_count)
      word_count >= MIN_WORD_COUNT && word_count <= MAX_WORD_COUNT
    end

    def success_response(content, word_count)
      {
        success: true,
        content: content,
        metadata: base_metadata.merge(
          word_count: word_count,
          **(@extraction_metadata || {})
        ),
        source_type: determine_source_type
      }
    end

    def validation_error_response
      {
        success: false,
        errors: errors.full_messages
      }
    end

    def word_count_error_response(word_count)
      if word_count < MIN_WORD_COUNT
        error_message = "Content too short (#{word_count} words). Please provide more detailed information (minimum #{MIN_WORD_COUNT} words)."
      else
        error_message = "Content too long (#{word_count} words). Maximum #{MAX_WORD_COUNT} words allowed."
      end

      {
        success: false,
        errors: [error_message],
        metadata: { word_count: word_count }
      }
    end

    def error_response(errors)
      {
        success: false,
        errors: errors
      }
    end

    def base_metadata
      {
        file_name: file.original_filename,
        file_size: file_size,
        content_type: content_type,
        processed_at: Time.current.iso8601
      }
    end

    def determine_source_type
      case content_type
      when 'application/pdf'
        'pdf_document'
      when 'text/markdown'
        'markdown_document'
      when 'text/plain'
        'text_document'
      else
        'unknown'
      end
    end
    
    def generate_file_hash
      # Create a hash based on file content and metadata for caching
      hash_input = {
        file_size: file_size,
        content_type: content_type,
        file_name: file&.original_filename,
        # For small files, include content in hash; for large files, use metadata
        content_sample: file_size < 1.megabyte ? file.read.first(1000) : "#{file_size}_#{content_type}"
      }
      
      # Reset file position after reading
      file.rewind if file.respond_to?(:rewind)
      
      Digest::SHA256.hexdigest(hash_input.to_json)
    end
  end
end
</file>

<file path="services/ai/error_message_service.rb">
# frozen_string_literal: true

module Ai
  class ErrorMessageService < ApplicationService
    include ActiveModel::Model
    include ActiveModel::Attributes

    attribute :error_type, :string
    attribute :error_message, :string
    attribute :context, :string, default: {}
    attribute :user, :string
    attribute :retry_count, :integer, default: 0

    ERROR_MESSAGES = {
      # Credit and subscription errors
      'credit_limit_exceeded' => {
        title: 'Monthly AI Usage Limit Reached',
        message: 'You\'ve used all your AI credits for this month.',
        guidance: 'Upgrade your plan to continue using AI features or wait until next month for your credits to reset.',
        actions: [
          { label: 'Upgrade Plan', action: 'upgrade', primary: true },
          { label: 'View Usage', action: 'view_usage', primary: false }
        ],
        severity: 'warning',
        recoverable: true
      },
      'insufficient_credits' => {
        title: 'Insufficient AI Credits',
        message: 'This operation requires more AI credits than you have remaining.',
        guidance: 'Try creating a simpler form or upgrade your plan for more credits.',
        actions: [
          { label: 'Upgrade Plan', action: 'upgrade', primary: true },
          { label: 'Simplify Request', action: 'retry', primary: false }
        ],
        severity: 'warning',
        recoverable: true
      },
      'subscription_required' => {
        title: 'Premium Feature',
        message: 'AI form generation is available with premium plans.',
        guidance: 'Upgrade to access AI-powered form creation and advanced features.',
        actions: [
          { label: 'View Plans', action: 'upgrade', primary: true },
          { label: 'Create Manual Form', action: 'manual_form', primary: false }
        ],
        severity: 'info',
        recoverable: true
      },

      # Content validation errors
      'content_length_error' => {
        title: 'Content Length Issue',
        message: 'The content provided doesn\'t meet our requirements.',
        guidance: 'Please provide content between 10 and 5,000 words for optimal form generation.',
        actions: [
          { label: 'Edit Content', action: 'retry', primary: true },
          { label: 'Upload Document', action: 'switch_input', primary: false }
        ],
        severity: 'warning',
        recoverable: true
      },
      'empty_prompt' => {
        title: 'Missing Content',
        message: 'Please provide a description of the form you want to create.',
        guidance: 'Describe your form\'s purpose, target audience, and what information you need to collect.',
        actions: [
          { label: 'Try Again', action: 'retry', primary: true },
          { label: 'See Examples', action: 'show_examples', primary: false }
        ],
        severity: 'info',
        recoverable: true
      },

      # Document processing errors
      'document_processing_error' => {
        title: 'Document Processing Failed',
        message: 'We couldn\'t process your uploaded document.',
        guidance: 'Try uploading a different file or use the text prompt option instead.',
        actions: [
          { label: 'Upload Different File', action: 'retry', primary: true },
          { label: 'Use Text Prompt', action: 'switch_input', primary: false }
        ],
        severity: 'error',
        recoverable: true
      },
      'invalid_file_type' => {
        title: 'Unsupported File Type',
        message: 'Please upload a PDF, Markdown (.md), or text (.txt) file.',
        guidance: 'Convert your document to a supported format or copy the text into the prompt field.',
        actions: [
          { label: 'Upload Supported File', action: 'retry', primary: true },
          { label: 'Use Text Prompt', action: 'switch_input', primary: false }
        ],
        severity: 'warning',
        recoverable: true
      },
      'file_too_large' => {
        title: 'File Too Large',
        message: 'The uploaded file exceeds our 10MB size limit.',
        guidance: 'Try uploading a smaller file or extract the key content into a text prompt.',
        actions: [
          { label: 'Upload Smaller File', action: 'retry', primary: true },
          { label: 'Use Text Prompt', action: 'switch_input', primary: false }
        ],
        severity: 'warning',
        recoverable: true
      },

      # AI processing errors
      'llm_error' => {
        title: 'AI Processing Error',
        message: 'Our AI service encountered an issue while processing your request.',
        guidance: 'This is usually temporary. Please try again in a few moments.',
        actions: [
          { label: 'Try Again', action: 'retry', primary: true },
          { label: 'Contact Support', action: 'support', primary: false }
        ],
        severity: 'error',
        recoverable: true
      },
      'json_parse_error' => {
        title: 'AI Response Error',
        message: 'The AI generated an invalid response format.',
        guidance: 'This is a temporary issue. Please try again with the same or simplified content.',
        actions: [
          { label: 'Try Again', action: 'retry', primary: true },
          { label: 'Simplify Content', action: 'edit_content', primary: false }
        ],
        severity: 'error',
        recoverable: true
      },
      'analysis_validation_error' => {
        title: 'Content Analysis Failed',
        message: 'We couldn\'t properly analyze your content for form generation.',
        guidance: 'Try providing more specific details about your form\'s purpose and target audience.',
        actions: [
          { label: 'Add More Details', action: 'retry', primary: true },
          { label: 'Use Template', action: 'use_template', primary: false }
        ],
        severity: 'warning',
        recoverable: true
      },
      'generation_validation_error' => {
        title: 'Form Generation Failed',
        message: 'The AI couldn\'t generate a valid form structure from your content.',
        guidance: 'Try being more specific about the questions you need or the form\'s purpose.',
        actions: [
          { label: 'Refine Content', action: 'retry', primary: true },
          { label: 'Manual Creation', action: 'manual_form', primary: false }
        ],
        severity: 'warning',
        recoverable: true
      },

      # Validation errors
      'structure_validation_error' => {
        title: 'Form Structure Invalid',
        message: 'The generated form structure doesn\'t meet our quality standards.',
        guidance: 'We\'ll try again with adjusted parameters. This usually resolves automatically.',
        actions: [
          { label: 'Try Again', action: 'retry', primary: true },
          { label: 'Manual Creation', action: 'manual_form', primary: false }
        ],
        severity: 'warning',
        recoverable: true
      },
      'business_rules_error' => {
        title: 'Form Requirements Not Met',
        message: 'The generated form doesn\'t meet our platform requirements.',
        guidance: 'Try simplifying your requirements or being more specific about your needs.',
        actions: [
          { label: 'Simplify Request', action: 'retry', primary: true },
          { label: 'Contact Support', action: 'support', primary: false }
        ],
        severity: 'warning',
        recoverable: true
      },

      # Database errors
      'database_error' => {
        title: 'Save Error',
        message: 'We couldn\'t save your generated form due to a technical issue.',
        guidance: 'Your form was generated successfully but couldn\'t be saved. Please try again.',
        actions: [
          { label: 'Try Saving Again', action: 'retry', primary: true },
          { label: 'Contact Support', action: 'support', primary: false }
        ],
        severity: 'error',
        recoverable: true
      },

      # Network and timeout errors
      'timeout_error' => {
        title: 'Request Timeout',
        message: 'The AI processing took longer than expected.',
        guidance: 'Try again with simpler content or check your internet connection.',
        actions: [
          { label: 'Try Again', action: 'retry', primary: true },
          { label: 'Simplify Content', action: 'edit_content', primary: false }
        ],
        severity: 'warning',
        recoverable: true
      },
      'network_error' => {
        title: 'Connection Error',
        message: 'We couldn\'t connect to our AI services.',
        guidance: 'Check your internet connection and try again in a few moments.',
        actions: [
          { label: 'Try Again', action: 'retry', primary: true },
          { label: 'Check Status', action: 'status_page', primary: false }
        ],
        severity: 'error',
        recoverable: true
      },

      # Rate limiting
      'rate_limit_error' => {
        title: 'Too Many Requests',
        message: 'You\'re making requests too quickly.',
        guidance: 'Please wait a moment before trying again.',
        actions: [
          { label: 'Wait and Retry', action: 'retry_later', primary: true }
        ],
        severity: 'warning',
        recoverable: true
      },

      # Generic fallback
      'unknown_error' => {
        title: 'Unexpected Error',
        message: 'Something went wrong while processing your request.',
        guidance: 'Please try again or contact support if the problem persists.',
        actions: [
          { label: 'Try Again', action: 'retry', primary: true },
          { label: 'Contact Support', action: 'support', primary: false }
        ],
        severity: 'error',
        recoverable: true
      }
    }.freeze

    def self.get_user_friendly_error(error_type, context = {})
      service = new(error_type: error_type, context: context)
      service.get_user_friendly_error
    end

    def get_user_friendly_error
      error_config = ERROR_MESSAGES[error_type] || ERROR_MESSAGES['unknown_error']
      
      # Customize message based on context
      customized_config = customize_error_message(error_config)
      
      # Add retry information if applicable
      if retry_count > 0
        customized_config = add_retry_context(customized_config)
      end
      
      # Add escalation path for persistent failures
      if retry_count >= 3
        customized_config = add_escalation_path(customized_config)
      end
      
      customized_config
    end

    private

    def customize_error_message(base_config)
      config = base_config.deep_dup
      
      case error_type
      when 'content_length_error'
        word_count = context[:word_count] || 0
        if word_count < 10
          config[:message] = "Your content is too short (#{word_count} words). We need at least 10 words to generate a meaningful form."
          config[:guidance] = "Add more details about your form's purpose, target audience, and the information you want to collect."
        elsif word_count > 5000
          config[:message] = "Your content is too long (#{word_count} words). Please keep it under 5,000 words for optimal processing."
          config[:guidance] = "Focus on the essential information needed for your form. You can always add more questions manually later."
        end
        
      when 'credit_limit_exceeded'
        credits_used = context[:credits_used] || 0
        monthly_limit = context[:monthly_limit] || 10
        config[:message] = "You've used #{credits_used} of your #{monthly_limit} monthly AI credits."
        
      when 'insufficient_credits'
        required = context[:required_credits] || 0
        available = context[:available_credits] || 0
        config[:message] = "This operation requires #{required} credits, but you only have #{available} remaining."
        
      when 'file_too_large'
        file_size = context[:file_size]
        if file_size
          size_mb = (file_size / 1.megabyte).round(1)
          config[:message] = "Your file is #{size_mb}MB, but our limit is 10MB."
        end
        
      when 'document_processing_error'
        if context[:error_class] == 'PDF::Reader::MalformedPDFError'
          config[:message] = "The PDF file appears to be corrupted or invalid."
          config[:guidance] = "Try re-saving the PDF or converting it to a text file."
        elsif context[:error_class] == 'Encoding::InvalidByteSequenceError'
          config[:message] = "The text file has encoding issues that prevent processing."
          config[:guidance] = "Try saving the file with UTF-8 encoding or copy the text directly into the prompt field."
        end
      end
      
      config
    end

    def add_retry_context(config)
      config = config.deep_dup
      
      if retry_count == 1
        config[:message] += " (Attempt #{retry_count + 1})"
      elsif retry_count >= 2
        config[:message] += " (Multiple attempts failed)"
        config[:guidance] = "This error has occurred #{retry_count + 1} times. " + config[:guidance]
        
        # Add alternative suggestions for persistent failures
        case error_type
        when 'llm_error', 'json_parse_error'
          config[:guidance] += " Consider trying with simpler content or using a form template instead."
          config[:actions] << { label: 'Use Template', action: 'use_template', primary: false }
        when 'document_processing_error'
          config[:guidance] += " Consider copying the text content directly into the prompt field."
        end
      end
      
      config
    end

    def add_escalation_path(config)
      config = config.deep_dup
      
      config[:title] = "Persistent Issue: #{config[:title]}"
      config[:message] = "This error has occurred multiple times. #{config[:message]}"
      config[:guidance] = "Since this issue persists, we recommend contacting our support team for assistance. " + config[:guidance]
      config[:severity] = 'error'
      
      # Add support action as primary if not already present
      unless config[:actions].any? { |action| action[:action] == 'support' }
        config[:actions].unshift({ label: 'Contact Support', action: 'support', primary: true })
        # Make other actions secondary
        config[:actions][1..-1].each { |action| action[:primary] = false }
      end
      
      config
    end

    # Generate action URLs based on action type
    def self.get_action_url(action_type, context = {})
      case action_type
      when 'upgrade'
        '/subscriptions/upgrade'
      when 'view_usage'
        '/profile/usage'
      when 'manual_form'
        '/forms/new'
      when 'use_template'
        '/templates'
      when 'support'
        '/support'
      when 'status_page'
        'https://status.agentform.com'
      when 'show_examples'
        '/help/examples'
      when 'retry'
        context[:current_url] || '/forms/new_from_ai'
      when 'switch_input'
        '/forms/new_from_ai'
      when 'edit_content'
        context[:current_url] || '/forms/new_from_ai'
      when 'retry_later'
        context[:current_url] || '/forms/new_from_ai'
      else
        '/forms/new_from_ai'
      end
    end

    # Check if error is recoverable by user action
    def self.recoverable?(error_type)
      ERROR_MESSAGES[error_type]&.dig(:recoverable) || false
    end

    # Get error severity level
    def self.get_severity(error_type)
      ERROR_MESSAGES[error_type]&.dig(:severity) || 'error'
    end

    # Get suggested retry delay for rate limiting
    def self.get_retry_delay(error_type, retry_count = 0)
      case error_type
      when 'rate_limit_error'
        [30, 60, 120][retry_count] || 300 # 30s, 1m, 2m, then 5m
      when 'llm_error', 'network_error'
        [5, 15, 30][retry_count] || 60 # 5s, 15s, 30s, then 1m
      when 'timeout_error'
        [10, 30, 60][retry_count] || 120 # 10s, 30s, 1m, then 2m
      else
        0 # No delay for other errors
      end
    end
  end
end
</file>

<file path="services/ai/error_tracking_service.rb">
# frozen_string_literal: true

module Ai
  class ErrorTrackingService < ApplicationService
    include ActiveModel::Model
    include ActiveModel::Attributes

    attribute :error_type, :string
    attribute :error_message, :string
    attribute :context, :string, default: {}
    attribute :user_id, :string
    attribute :workflow_id, :string
    attribute :task_name, :string
    attribute :retry_count, :integer, default: 0
    attribute :severity, :string, default: 'error'

    SEVERITY_LEVELS = %w[debug info warn error fatal].freeze
    ERROR_CATEGORIES = %w[
      validation_error
      llm_error
      document_processing_error
      database_error
      credit_limit_error
      business_rules_error
      network_error
      timeout_error
      authentication_error
      authorization_error
      rate_limit_error
      unknown_error
    ].freeze

    validates :error_type, presence: true, inclusion: { in: ERROR_CATEGORIES }
    validates :error_message, presence: true
    validates :severity, inclusion: { in: SEVERITY_LEVELS }

    def self.track_error(error_data)
      service = new(error_data)
      service.track_error
    end

    def track_error
      return false unless valid?

      # Log structured error
      log_structured_error

      # Track metrics
      track_error_metrics

      # Send to external monitoring if configured
      send_to_external_monitoring if should_send_to_external?

      # Store in database for analysis
      store_error_record

      true
    rescue StandardError => e
      Rails.logger.error "Failed to track error: #{e.message}"
      false
    end

    private

    def log_structured_error
      log_data = {
        timestamp: Time.current.iso8601,
        error_type: error_type,
        error_message: error_message,
        severity: severity,
        user_id: user_id,
        workflow_id: workflow_id,
        task_name: task_name,
        retry_count: retry_count,
        context: context,
        environment: Rails.env,
        request_id: Current.request_id,
        session_id: Current.session&.id
      }

      case severity
      when 'debug'
        Rails.logger.debug structured_log_message(log_data)
      when 'info'
        Rails.logger.info structured_log_message(log_data)
      when 'warn'
        Rails.logger.warn structured_log_message(log_data)
      when 'error'
        Rails.logger.error structured_log_message(log_data)
      when 'fatal'
        Rails.logger.fatal structured_log_message(log_data)
      end
    end

    def structured_log_message(data)
      "[AI_ERROR] #{data.to_json}"
    end

    def track_error_metrics
      # Track error counts by type
      Rails.cache.increment("ai_errors:#{error_type}:#{Date.current}", 1, expires_in: 7.days)
      
      # Track error counts by user
      if user_id.present?
        Rails.cache.increment("ai_errors:user:#{user_id}:#{Date.current}", 1, expires_in: 7.days)
      end

      # Track error counts by workflow task
      if task_name.present?
        Rails.cache.increment("ai_errors:task:#{task_name}:#{Date.current}", 1, expires_in: 7.days)
      end

      # Track retry patterns
      if retry_count > 0
        Rails.cache.increment("ai_errors:retries:#{error_type}:#{Date.current}", retry_count, expires_in: 7.days)
      end
    end

    def should_send_to_external?
      # Send to external monitoring for error and fatal levels
      %w[error fatal].include?(severity) && external_monitoring_configured?
    end

    def external_monitoring_configured?
      # Check if Sentry, Bugsnag, or other monitoring is configured
      defined?(Sentry) || defined?(Bugsnag) || Rails.application.config.respond_to?(:error_monitoring)
    end

    def send_to_external_monitoring
      error_data = {
        message: error_message,
        level: severity,
        tags: {
          error_type: error_type,
          workflow_id: workflow_id,
          task_name: task_name,
          user_id: user_id
        },
        extra: {
          context: context,
          retry_count: retry_count,
          timestamp: Time.current.iso8601
        }
      }

      if defined?(Sentry)
        Sentry.capture_message(error_message, level: severity.to_sym, tags: error_data[:tags], extra: error_data[:extra])
      elsif defined?(Bugsnag)
        Bugsnag.notify(error_message) do |report|
          report.severity = severity
          report.add_tab(:error_details, error_data)
        end
      end
    end

    def store_error_record
      # Store error in database for analysis and reporting
      # This could be a separate ErrorLog model if needed for detailed analysis
      Rails.cache.write(
        "ai_error_log:#{SecureRandom.uuid}",
        {
          error_type: error_type,
          error_message: error_message,
          severity: severity,
          user_id: user_id,
          workflow_id: workflow_id,
          task_name: task_name,
          retry_count: retry_count,
          context: context,
          created_at: Time.current.iso8601
        },
        expires_in: 30.days
      )
    end
  end
end
</file>

<file path="services/ai/llm_monitoring_service.rb">
# frozen_string_literal: true

module Ai
  class LlmMonitoringService < ApplicationService
    include ActiveModel::Model
    include ActiveModel::Attributes

    attribute :model_name, :string
    attribute :operation_type, :string
    attribute :request_tokens, :integer
    attribute :response_tokens, :integer
    attribute :response_time_ms, :integer
    attribute :success, :boolean, default: true
    attribute :error_type, :string
    attribute :error_message, :string
    attribute :retry_count, :integer, default: 0
    attribute :temperature, :float
    attribute :max_tokens, :integer
    attribute :user_id, :string

    MODELS = %w[gpt-4o gpt-4o-mini gpt-3.5-turbo claude-3-sonnet claude-3-haiku].freeze
    OPERATION_TYPES = %w[content_analysis form_generation question_enhancement validation].freeze

    validates :model_name, presence: true, inclusion: { in: MODELS }
    validates :operation_type, presence: true, inclusion: { in: OPERATION_TYPES }

    def self.monitor_request(request_data)
      service = new(request_data)
      service.monitor_request
    end

    def monitor_request
      return false unless valid?

      # Track model performance
      track_model_performance

      # Track API reliability
      track_api_reliability

      # Monitor cost efficiency
      monitor_cost_efficiency

      # Track quality metrics
      track_quality_metrics

      # Alert on anomalies
      check_for_anomalies

      true
    rescue StandardError => e
      Rails.logger.error "Failed to monitor LLM request: #{e.message}"
      false
    end

    private

    def track_model_performance
      # Track response times by model
      response_time_key = "llm_performance:#{model_name}:response_times"
      current_times = Rails.cache.read(response_time_key) || []
      current_times << response_time_ms if response_time_ms.present?
      current_times = current_times.last(100) # Keep rolling window
      Rails.cache.write(response_time_key, current_times, expires_in: 1.day)

      # Track token usage efficiency
      if request_tokens.present? && response_tokens.present?
        total_tokens = request_tokens + response_tokens
        token_key = "llm_performance:#{model_name}:tokens:#{Date.current}"
        Rails.cache.increment(token_key, total_tokens, expires_in: 32.days)

        # Track token efficiency by operation
        operation_token_key = "llm_performance:#{operation_type}:tokens:#{Date.current}"
        Rails.cache.increment(operation_token_key, total_tokens, expires_in: 32.days)
      end

      # Track request volume by model
      volume_key = "llm_performance:#{model_name}:requests:#{Date.current}"
      Rails.cache.increment(volume_key, 1, expires_in: 32.days)
    end

    def track_api_reliability
      # Track success rates by model
      success_key = "llm_reliability:#{model_name}:success:#{Date.current}"
      total_key = "llm_reliability:#{model_name}:total:#{Date.current}"
      
      Rails.cache.increment(total_key, 1, expires_in: 32.days)
      if success
        Rails.cache.increment(success_key, 1, expires_in: 32.days)
      end

      # Track error patterns
      if !success && error_type.present?
        error_key = "llm_reliability:#{model_name}:errors:#{error_type}:#{Date.current}"
        Rails.cache.increment(error_key, 1, expires_in: 32.days)
      end

      # Track retry patterns
      if retry_count > 0
        retry_key = "llm_reliability:#{model_name}:retries:#{Date.current}"
        Rails.cache.increment(retry_key, retry_count, expires_in: 32.days)
      end
    end

    def monitor_cost_efficiency
      return unless request_tokens.present? && response_tokens.present?

      # Calculate estimated cost based on model pricing
      estimated_cost = calculate_estimated_cost
      
      # Track cost per operation type
      cost_key = "llm_cost:#{operation_type}:#{Date.current}"
      Rails.cache.increment_float(cost_key, estimated_cost, expires_in: 32.days)

      # Track cost per model
      model_cost_key = "llm_cost:#{model_name}:#{Date.current}"
      Rails.cache.increment_float(model_cost_key, estimated_cost, expires_in: 32.days)

      # Track cost efficiency (cost per successful operation)
      if success
        efficiency_key = "llm_efficiency:#{operation_type}:cost_per_success:#{Date.current}"
        current_costs = Rails.cache.read(efficiency_key) || []
        current_costs << estimated_cost
        current_costs = current_costs.last(100)
        Rails.cache.write(efficiency_key, current_costs, expires_in: 32.days)
      end
    end

    def track_quality_metrics
      # Track temperature usage patterns
      if temperature.present?
        temp_key = "llm_quality:#{operation_type}:temperature:#{Date.current}"
        current_temps = Rails.cache.read(temp_key) || []
        current_temps << temperature
        current_temps = current_temps.last(100)
        Rails.cache.write(temp_key, current_temps, expires_in: 32.days)
      end

      # Track max_tokens usage
      if max_tokens.present?
        max_tokens_key = "llm_quality:#{operation_type}:max_tokens:#{Date.current}"
        current_max_tokens = Rails.cache.read(max_tokens_key) || []
        current_max_tokens << max_tokens
        current_max_tokens = current_max_tokens.last(100)
        Rails.cache.write(max_tokens_key, current_max_tokens, expires_in: 32.days)
      end

      # Track response quality indicators
      if success && response_tokens.present?
        # Track response length patterns
        response_length_key = "llm_quality:#{operation_type}:response_length:#{Date.current}"
        current_lengths = Rails.cache.read(response_length_key) || []
        current_lengths << response_tokens
        current_lengths = current_lengths.last(100)
        Rails.cache.write(response_length_key, current_lengths, expires_in: 32.days)
      end
    end

    def check_for_anomalies
      # Check for response time anomalies
      check_response_time_anomalies

      # Check for error rate spikes
      check_error_rate_anomalies

      # Check for cost anomalies
      check_cost_anomalies
    end

    def check_response_time_anomalies
      return unless response_time_ms.present?

      # Get recent response times for this model
      response_time_key = "llm_performance:#{model_name}:response_times"
      recent_times = Rails.cache.read(response_time_key) || []
      
      return if recent_times.length < 10 # Need enough data

      # Calculate average and threshold
      avg_time = recent_times.sum.to_f / recent_times.length
      threshold = avg_time * 2.5 # Alert if 2.5x slower than average

      if response_time_ms > threshold
        alert_data = {
          alert_type: 'response_time_anomaly',
          model_name: model_name,
          operation_type: operation_type,
          current_time: response_time_ms,
          average_time: avg_time.round(0),
          threshold: threshold.round(0),
          severity: 'warning'
        }

        send_anomaly_alert(alert_data)
      end
    end

    def check_error_rate_anomalies
      # Get current error rate for this model
      success_key = "llm_reliability:#{model_name}:success:#{Date.current}"
      total_key = "llm_reliability:#{model_name}:total:#{Date.current}"
      
      successes = Rails.cache.read(success_key) || 0
      total = Rails.cache.read(total_key) || 0
      
      return if total < 10 # Need enough data

      error_rate = ((total - successes).to_f / total * 100).round(2)
      
      # Alert if error rate exceeds 20%
      if error_rate > 20.0
        alert_data = {
          alert_type: 'error_rate_spike',
          model_name: model_name,
          error_rate: error_rate,
          total_requests: total,
          failed_requests: total - successes,
          severity: 'error'
        }

        send_anomaly_alert(alert_data)
      end
    end

    def check_cost_anomalies
      return unless request_tokens.present? && response_tokens.present?

      estimated_cost = calculate_estimated_cost
      
      # Get recent costs for this operation type
      efficiency_key = "llm_efficiency:#{operation_type}:cost_per_success:#{Date.current}"
      recent_costs = Rails.cache.read(efficiency_key) || []
      
      return if recent_costs.length < 10

      avg_cost = recent_costs.sum / recent_costs.length
      threshold = avg_cost * 3.0 # Alert if 3x more expensive than average

      if estimated_cost > threshold
        alert_data = {
          alert_type: 'cost_anomaly',
          operation_type: operation_type,
          model_name: model_name,
          current_cost: estimated_cost,
          average_cost: avg_cost.round(4),
          threshold: threshold.round(4),
          severity: 'warning'
        }

        send_anomaly_alert(alert_data)
      end
    end

    def send_anomaly_alert(alert_data)
      # Log the anomaly
      Rails.logger.warn "[LLM_ANOMALY] #{alert_data.to_json}"

      # Store alert for dashboard
      alert_key = "llm_alerts:#{SecureRandom.uuid}"
      alert_record = alert_data.merge({
        timestamp: Time.current.iso8601,
        user_id: user_id
      })
      Rails.cache.write(alert_key, alert_record, expires_in: 7.days)

      # Send to external monitoring if configured
      if defined?(Sentry)
        Sentry.capture_message(
          "LLM Anomaly: #{alert_data[:alert_type]}",
          level: alert_data[:severity].to_sym,
          tags: {
            model: model_name,
            operation: operation_type,
            alert_type: alert_data[:alert_type]
          },
          extra: alert_data
        )
      end
    end

    def calculate_estimated_cost
      return 0.0 unless request_tokens.present? && response_tokens.present?

      # Pricing per 1K tokens (approximate as of 2024)
      pricing = {
        'gpt-4o' => { input: 0.005, output: 0.015 },
        'gpt-4o-mini' => { input: 0.00015, output: 0.0006 },
        'gpt-3.5-turbo' => { input: 0.001, output: 0.002 },
        'claude-3-sonnet' => { input: 0.003, output: 0.015 },
        'claude-3-haiku' => { input: 0.00025, output: 0.00125 }
      }

      model_pricing = pricing[model_name] || { input: 0.001, output: 0.002 }
      
      input_cost = (request_tokens / 1000.0) * model_pricing[:input]
      output_cost = (response_tokens / 1000.0) * model_pricing[:output]
      
      (input_cost + output_cost).round(6)
    end

    # Class methods for retrieving monitoring data
    def self.get_model_success_rate(model_name, date = Date.current)
      success_key = "llm_reliability:#{model_name}:success:#{date}"
      total_key = "llm_reliability:#{model_name}:total:#{date}"
      
      successes = Rails.cache.read(success_key) || 0
      total = Rails.cache.read(total_key) || 0
      
      return 0.0 if total.zero?
      (successes.to_f / total * 100).round(2)
    end

    def self.get_average_response_time(model_name)
      key = "llm_performance:#{model_name}:response_times"
      times = Rails.cache.read(key) || []
      
      return 0 if times.empty?
      (times.sum.to_f / times.length).round(0)
    end

    def self.get_daily_token_usage(model_name, date = Date.current)
      key = "llm_performance:#{model_name}:tokens:#{date}"
      Rails.cache.read(key) || 0
    end

    def self.get_recent_alerts(limit = 10)
      # This would need a more sophisticated implementation in production
      # For now, return empty array as alerts are logged
      []
    end
  end
end
</file>

<file path="services/ai/prompt_security_service.rb">
# frozen_string_literal: true

module Ai
  class PromptSecurityService
    def initialize(content:, context:, user_id:)
      @content = content
      @context = context
      @user_id = user_id
    end

    def analyze_prompt_security
      # Basic security check - implement proper security analysis later
      {
        success: true,
        sanitized_content: @content,
        security_issues: [],
        risk_level: 'low',
        blocked: false
      }
    end

    private

    attr_reader :content, :context, :user_id
  end
end
</file>

<file path="services/ai/rate_limiting_service.rb">
# frozen_string_literal: true

module Ai
  class RateLimitingService
    def initialize(user_id:, action:, ip_address: nil)
      @user_id = user_id
      @action = action
      @ip_address = ip_address
    end

    def check_rate_limit
      # For now, always allow - implement proper rate limiting later
      {
        success: true,
        remaining_requests: 100,
        reset_time: 1.hour.from_now
      }
    end

    private

    attr_reader :user_id, :action, :ip_address
  end
end
</file>

<file path="services/ai/retry_mechanism_service.rb">
# frozen_string_literal: true

module Ai
  class RetryMechanismService < ApplicationService
    include ActiveModel::Model
    include ActiveModel::Attributes

    attribute :operation_type, :string
    attribute :error_type, :string
    attribute :retry_count, :integer, default: 0
    attribute :user_id, :string
    attribute :context, :string, default: {}

    MAX_RETRIES = {
      'llm_error' => 3,
      'json_parse_error' => 3,
      'analysis_validation_error' => 2,
      'generation_validation_error' => 2,
      'document_processing_error' => 2,
      'network_error' => 3,
      'timeout_error' => 2,
      'database_error' => 3,
      'structure_validation_error' => 2,
      'business_rules_error' => 1
    }.freeze

    RETRY_DELAYS = {
      'llm_error' => [2, 5, 10], # seconds
      'json_parse_error' => [1, 3, 5],
      'network_error' => [3, 10, 30],
      'timeout_error' => [5, 15, 30],
      'database_error' => [1, 2, 5],
      'rate_limit_error' => [30, 60, 120]
    }.freeze

    RETRY_STRATEGIES = {
      'llm_error' => 'exponential_backoff',
      'json_parse_error' => 'immediate_with_modification',
      'analysis_validation_error' => 'immediate_with_modification',
      'generation_validation_error' => 'immediate_with_modification',
      'document_processing_error' => 'alternative_approach',
      'network_error' => 'exponential_backoff',
      'timeout_error' => 'exponential_backoff',
      'database_error' => 'immediate',
      'rate_limit_error' => 'fixed_delay'
    }.freeze

    def self.should_retry?(error_type, retry_count)
      max_retries = MAX_RETRIES[error_type] || 0
      retry_count < max_retries
    end

    def self.get_retry_delay(error_type, retry_count)
      delays = RETRY_DELAYS[error_type] || [0]
      delays[retry_count] || delays.last || 0
    end

    def self.get_retry_strategy(error_type)
      RETRY_STRATEGIES[error_type] || 'immediate'
    end

    def self.create_retry_plan(error_type, retry_count, context = {})
      service = new(
        error_type: error_type,
        retry_count: retry_count,
        context: context
      )
      service.create_retry_plan
    end

    def create_retry_plan
      return nil unless self.class.should_retry?(error_type, retry_count)

      strategy = self.class.get_retry_strategy(error_type)
      delay = self.class.get_retry_delay(error_type, retry_count)

      plan = {
        can_retry: true,
        retry_count: retry_count + 1,
        delay_seconds: delay,
        strategy: strategy,
        modifications: get_retry_modifications,
        user_guidance: get_user_retry_guidance,
        automatic: should_auto_retry?,
        estimated_success_rate: estimate_success_rate
      }

      # Add strategy-specific details
      case strategy
      when 'exponential_backoff'
        plan[:next_delay] = calculate_exponential_backoff(delay, retry_count + 1)
      when 'alternative_approach'
        plan[:alternative_methods] = get_alternative_approaches
      when 'immediate_with_modification'
        plan[:required_modifications] = get_required_modifications
      end

      plan
    end

    private

    def get_retry_modifications
      modifications = {}

      case error_type
      when 'json_parse_error'
        modifications[:llm_temperature] = [0.1, 0.0, 0.0][retry_count] || 0.0
        modifications[:response_format] = 'strict_json'
        modifications[:max_tokens] = context[:max_tokens] ? context[:max_tokens] * 0.8 : nil
        
      when 'analysis_validation_error'
        modifications[:prompt_template] = 'simplified'
        modifications[:validation_strictness] = 'relaxed'
        
      when 'generation_validation_error'
        modifications[:question_count_limit] = [15, 10, 5][retry_count] || 5
        modifications[:complexity_level] = 'simple'
        modifications[:prompt_template] = 'basic'
        
      when 'llm_error'
        modifications[:model_fallback] = get_model_fallback
        modifications[:timeout_increase] = true
        
      when 'document_processing_error'
        modifications[:processing_method] = get_alternative_processing_method
        modifications[:content_extraction] = 'text_only'
        
      when 'timeout_error'
        modifications[:timeout_multiplier] = 2.0
        modifications[:content_chunking] = true
        
      when 'network_error'
        modifications[:connection_timeout] = 30
        modifications[:read_timeout] = 60
      end

      modifications
    end

    def get_user_retry_guidance
      case error_type
      when 'json_parse_error', 'analysis_validation_error'
        "We'll try again with adjusted AI parameters to improve response quality."
        
      when 'generation_validation_error'
        "We'll attempt to generate a simpler form structure that meets our quality standards."
        
      when 'llm_error'
        if retry_count == 0
          "We'll try again with our backup AI system."
        else
          "Attempting retry with extended timeout and error recovery."
        end
        
      when 'document_processing_error'
        "We'll try an alternative method to extract content from your document."
        
      when 'network_error', 'timeout_error'
        "We'll retry with improved connection settings and longer timeout."
        
      when 'database_error'
        "We'll attempt to save your form again with error recovery."
        
      else
        "We'll try again with optimized settings."
      end
    end

    def should_auto_retry?
      # Auto-retry for technical errors, but not for user input issues
      auto_retry_types = %w[
        llm_error
        json_parse_error
        network_error
        timeout_error
        database_error
        structure_validation_error
      ]
      
      auto_retry_types.include?(error_type) && retry_count < 2
    end

    def estimate_success_rate
      # Estimated success rates based on error type and retry count
      base_rates = {
        'llm_error' => [70, 85, 95],
        'json_parse_error' => [80, 90, 95],
        'analysis_validation_error' => [60, 75, 85],
        'generation_validation_error' => [65, 80, 90],
        'document_processing_error' => [50, 70, 80],
        'network_error' => [75, 85, 90],
        'timeout_error' => [70, 80, 85],
        'database_error' => [85, 95, 98],
        'structure_validation_error' => [60, 75, 85]
      }
      
      rates = base_rates[error_type] || [50, 60, 70]
      rates[retry_count] || rates.last || 50
    end

    def calculate_exponential_backoff(base_delay, attempt)
      # Exponential backoff with jitter
      delay = base_delay * (2 ** (attempt - 1))
      jitter = rand(0.1..0.3) * delay
      (delay + jitter).round(1)
    end

    def get_alternative_approaches
      approaches = []
      
      case error_type
      when 'document_processing_error'
        approaches << {
          method: 'text_extraction_only',
          description: 'Extract plain text without formatting'
        }
        approaches << {
          method: 'manual_input',
          description: 'Copy content manually into text prompt'
        }
        
      when 'llm_error'
        approaches << {
          method: 'template_based',
          description: 'Use a pre-built form template'
        }
        approaches << {
          method: 'manual_creation',
          description: 'Create form manually with guided assistance'
        }
        
      when 'analysis_validation_error'
        approaches << {
          method: 'simplified_analysis',
          description: 'Use basic content analysis'
        }
        approaches << {
          method: 'template_matching',
          description: 'Match content to existing templates'
        }
      end
      
      approaches
    end

    def get_required_modifications
      case error_type
      when 'analysis_validation_error'
        [
          'Simplify content analysis requirements',
          'Use more flexible validation rules',
          'Focus on core form elements only'
        ]
        
      when 'generation_validation_error'
        [
          'Reduce maximum question count',
          'Use simpler question types only',
          'Apply basic form structure template'
        ]
        
      when 'json_parse_error'
        [
          'Use stricter JSON formatting',
          'Reduce response complexity',
          'Apply response validation'
        ]
        
      else
        []
      end
    end

    def get_model_fallback
      case context[:current_model]
      when 'gpt-4o'
        'gpt-4o-mini'
      when 'gpt-4o-mini'
        'gpt-3.5-turbo'
      else
        'gpt-3.5-turbo'
      end
    end

    def get_alternative_processing_method
      case context[:current_method]
      when 'pdf_reader'
        'text_extraction'
      when 'full_processing'
        'simple_text_only'
      else
        'basic_extraction'
      end
    end

    # Class methods for workflow integration
    def self.execute_with_retry(operation_type, max_retries = 3, &block)
      retry_count = 0
      last_error = nil

      while retry_count <= max_retries
        begin
          result = yield(retry_count)
          
          # Track successful retry if this wasn't the first attempt
          if retry_count > 0
            track_retry_success(operation_type, retry_count, last_error&.class&.name)
          end
          
          return result
          
        rescue StandardError => e
          last_error = e
          error_type = classify_error(e)
          
          # Check if we should retry this error type
          unless should_retry?(error_type, retry_count)
            track_retry_failure(operation_type, retry_count, error_type, e.message)
            raise e
          end
          
          # Get retry delay and wait if necessary
          delay = get_retry_delay(error_type, retry_count)
          if delay > 0
            Rails.logger.info "Retrying #{operation_type} after #{delay}s delay (attempt #{retry_count + 1})"
            sleep(delay)
          end
          
          retry_count += 1
          
          # Track retry attempt
          track_retry_attempt(operation_type, retry_count, error_type, e.message)
        end
      end

      # If we get here, all retries failed
      track_retry_exhausted(operation_type, max_retries, last_error&.class&.name, last_error&.message)
      raise last_error
    end

    def self.classify_error(error)
      case error
      when JSON::ParserError
        'json_parse_error'
      when Net::TimeoutError, Timeout::Error
        'timeout_error'
      when Net::HTTPError, SocketError
        'network_error'
      when ActiveRecord::RecordInvalid, ActiveRecord::RecordNotSaved
        'database_error'
      when PDF::Reader::MalformedPDFError, PDF::Reader::UnsupportedFeatureError
        'document_processing_error'
      else
        if error.message.include?('LLM')
          'llm_error'
        elsif error.message.include?('validation')
          'validation_error'
        else
          'unknown_error'
        end
      end
    end

    def self.track_retry_attempt(operation_type, retry_count, error_type, error_message)
      Rails.logger.info "[RETRY_ATTEMPT] Operation: #{operation_type}, Attempt: #{retry_count}, Error: #{error_type}"
      
      # Track in cache for analytics
      key = "retry_attempts:#{operation_type}:#{Date.current}"
      Rails.cache.increment(key, 1, expires_in: 32.days)
    end

    def self.track_retry_success(operation_type, retry_count, error_type)
      Rails.logger.info "[RETRY_SUCCESS] Operation: #{operation_type}, Succeeded after #{retry_count} retries"
      
      # Track successful retries
      key = "retry_success:#{operation_type}:#{Date.current}"
      Rails.cache.increment(key, 1, expires_in: 32.days)
    end

    def self.track_retry_failure(operation_type, retry_count, error_type, error_message)
      Rails.logger.warn "[RETRY_FAILURE] Operation: #{operation_type}, Failed after #{retry_count} attempts, Error: #{error_type}"
      
      # Track failed retries
      key = "retry_failures:#{operation_type}:#{Date.current}"
      Rails.cache.increment(key, 1, expires_in: 32.days)
    end

    def self.track_retry_exhausted(operation_type, max_retries, error_type, error_message)
      Rails.logger.error "[RETRY_EXHAUSTED] Operation: #{operation_type}, All #{max_retries} retries failed, Final error: #{error_type}"
      
      # Track exhausted retries
      key = "retry_exhausted:#{operation_type}:#{Date.current}"
      Rails.cache.increment(key, 1, expires_in: 32.days)
    end
  end
end
</file>

<file path="services/ai/security_service.rb">
# frozen_string_literal: true

module Ai
  class SecurityService < ApplicationService
    include ActiveModel::Model
    include ActiveModel::Attributes

    # File upload security constants
    ALLOWED_MIME_TYPES = [
      'application/pdf',
      'text/plain',
      'text/markdown',
      'text/x-markdown'
    ].freeze

    ALLOWED_FILE_EXTENSIONS = %w[.pdf .txt .md .markdown].freeze
    MAX_FILE_SIZE = 10.megabytes
    MAX_CONTENT_LENGTH = 50_000 # characters
    MIN_CONTENT_LENGTH = 10 # characters

    # Content security patterns
    SUSPICIOUS_PATTERNS = [
      # Prompt injection attempts
      /ignore\s+previous\s+instructions/i,
      /forget\s+everything\s+above/i,
      /system\s*:\s*you\s+are\s+now/i,
      /act\s+as\s+if\s+you\s+are/i,
      /pretend\s+to\s+be/i,
      /roleplay\s+as/i,
      # Code injection attempts
      /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/mi,
      /javascript\s*:/i,
      /on\w+\s*=/i,
      # SQL injection patterns
      /union\s+select/i,
      /drop\s+table/i,
      /delete\s+from/i,
      # Command injection
      /\|\s*[a-z]/i,
      /&&\s*[a-z]/i,
      /;\s*[a-z]/i
    ].freeze

    # Inappropriate content patterns
    INAPPROPRIATE_PATTERNS = [
      # Hate speech indicators
      /\b(hate|kill|murder|terrorist)\b.*\b(people|group|race|religion)\b/i,
      # Adult content indicators
      /\b(porn|sex|nude|naked)\b/i,
      # Violence indicators
      /\b(bomb|weapon|gun|knife)\b.*\b(make|build|create)\b/i,
      # More specific inappropriate patterns
      /how\s+to\s+make.*\b(bomb|weapon|explosive)\b/i
    ].freeze

    attribute :file
    attribute :content, :string
    attribute :user_id
    attribute :ip_address, :string

    def validate_file_upload
      return { success: false, errors: ['No file provided'] } unless file

      errors = []
      
      # Validate file size
      if file.size > MAX_FILE_SIZE
        errors << "File size exceeds maximum allowed size of #{MAX_FILE_SIZE / 1.megabyte}MB"
      end

      # Validate MIME type
      unless ALLOWED_MIME_TYPES.include?(file.content_type)
        errors << "File type '#{file.content_type}' is not allowed. Allowed types: #{ALLOWED_MIME_TYPES.join(', ')}"
      end

      # Validate file extension
      file_extension = File.extname(file.original_filename).downcase
      unless ALLOWED_FILE_EXTENSIONS.include?(file_extension)
        errors << "File extension '#{file_extension}' is not allowed. Allowed extensions: #{ALLOWED_FILE_EXTENSIONS.join(', ')}"
      end

      # Additional security checks
      errors.concat(perform_file_security_scan)

      if errors.any?
        log_security_event('file_validation_failed', { errors: errors })
        { success: false, errors: errors }
      else
        { success: true }
      end
    end

    def sanitize_content(raw_content)
      return { success: false, errors: ['No content provided'] } if raw_content.blank?

      sanitized_content = raw_content.dup
      security_issues = []

      # Length validation
      if sanitized_content.length > MAX_CONTENT_LENGTH
        security_issues << "Content exceeds maximum length of #{MAX_CONTENT_LENGTH} characters"
      elsif sanitized_content.length < MIN_CONTENT_LENGTH
        security_issues << "Content is too short (minimum #{MIN_CONTENT_LENGTH} characters)"
      end

      # Check for suspicious patterns
      SUSPICIOUS_PATTERNS.each do |pattern|
        if sanitized_content.match?(pattern)
          security_issues << "Content contains potentially malicious patterns"
          log_security_event('suspicious_content_detected', { 
            pattern: pattern.source,
            content_preview: sanitized_content[0..100] 
          })
          break # Don't reveal specific patterns to potential attackers
        end
      end

      # Check for inappropriate content
      INAPPROPRIATE_PATTERNS.each do |pattern|
        if sanitized_content.match?(pattern)
          security_issues << "Content contains inappropriate material"
          log_security_event('inappropriate_content_detected', { 
            content_preview: sanitized_content[0..100] 
          })
          break
        end
      end

      # Basic HTML/script sanitization
      sanitized_content = sanitize_html_content(sanitized_content)

      # Remove potential command injection characters
      sanitized_content = sanitize_command_injection(sanitized_content)

      if security_issues.any?
        { success: false, errors: security_issues }
      else
        { success: true, content: sanitized_content }
      end
    end

    def check_rate_limit
      return { success: false, errors: ['User ID required for rate limiting'] } unless user_id

      cache_key = "ai_generation_rate_limit:#{user_id}"
      current_count = Rails.cache.read(cache_key) || 0
      
      # Allow 10 requests per hour for AI generation
      rate_limit = 10
      time_window = 1.hour

      if current_count >= rate_limit
        log_security_event('rate_limit_exceeded', { 
          user_id: user_id,
          current_count: current_count,
          limit: rate_limit 
        })
        return { success: false, errors: ['Rate limit exceeded. Please try again later.'] }
      else
        Rails.cache.write(cache_key, current_count + 1, expires_in: time_window)
        return { success: true, remaining_requests: rate_limit - current_count - 1 }
      end
    end

    private

    def perform_file_security_scan
      errors = []
      
      # Check file header/magic bytes
      if file.respond_to?(:read)
        file.rewind
        header = file.read(1024)
        file.rewind

        # Basic magic byte validation for PDF
        if file.content_type == 'application/pdf' && !header.start_with?('%PDF-')
          errors << 'File appears to be corrupted or not a valid PDF'
        end

        # Check for embedded scripts in text files
        if file.content_type.start_with?('text/') && header.match?(/<script|javascript:/i)
          errors << 'File contains potentially malicious script content'
        end
      end

      errors
    end

    def sanitize_html_content(content)
      # Remove HTML tags and decode entities
      content = ActionController::Base.helpers.strip_tags(content)
      content = CGI.unescapeHTML(content)
      content
    end

    def sanitize_command_injection(content)
      # Remove or escape potentially dangerous characters
      dangerous_chars = ['|', '&', ';', '`', '$', '(', ')', '{', '}']
      dangerous_chars.each do |char|
        content = content.gsub(char, '')
      end
      content
    end

    def log_security_event(event_type, details = {})
      Rails.logger.warn "[SECURITY] #{event_type}: #{details.to_json}"
      
      # Store in audit log
      begin
        AuditLog.create!(
          event_type: event_type,
          user_id: user_id,
          ip_address: ip_address,
          details: details,
          created_at: Time.current
        )
      rescue => e
        Rails.logger.error "Failed to log security event: #{e.message}"
      end
    end
  end
end
</file>

<file path="services/ai/usage_analytics_service.rb">
# frozen_string_literal: true

module Ai
  class UsageAnalyticsService < ApplicationService
    include ActiveModel::Model
    include ActiveModel::Attributes

    attribute :user_id, :string
    attribute :operation_type, :string
    attribute :cost, :decimal
    attribute :model_used, :string
    attribute :tokens_used, :integer
    attribute :response_time_ms, :integer
    attribute :success, :boolean, default: true
    attribute :metadata, :string, default: {}

    OPERATION_TYPES = %w[
      content_analysis
      form_generation
      document_processing
      question_enhancement
      validation
      optimization
    ].freeze

    validates :user_id, presence: true
    validates :operation_type, presence: true, inclusion: { in: OPERATION_TYPES }
    validates :cost, presence: true, numericality: { greater_than_or_equal_to: 0 }

    def self.track_usage(usage_data)
      service = new(usage_data)
      service.track_usage
    end

    def track_usage
      return false unless valid?

      # Track cost metrics
      track_cost_metrics

      # Track performance metrics
      track_performance_metrics

      # Track usage patterns
      track_usage_patterns

      # Store detailed usage record
      store_usage_record

      true
    rescue StandardError => e
      Rails.logger.error "Failed to track AI usage: #{e.message}"
      false
    end

    private

    def track_cost_metrics
      # Daily cost tracking by user
      daily_key = "ai_cost:user:#{user_id}:#{Date.current}"
      Rails.cache.increment_float(daily_key, cost.to_f, expires_in: 32.days)

      # Monthly cost tracking by user
      monthly_key = "ai_cost:user:#{user_id}:#{Date.current.beginning_of_month}"
      Rails.cache.increment_float(monthly_key, cost.to_f, expires_in: 32.days)

      # Daily cost tracking by operation type
      operation_daily_key = "ai_cost:operation:#{operation_type}:#{Date.current}"
      Rails.cache.increment_float(operation_daily_key, cost.to_f, expires_in: 32.days)

      # Total platform cost tracking
      platform_daily_key = "ai_cost:platform:#{Date.current}"
      Rails.cache.increment_float(platform_daily_key, cost.to_f, expires_in: 32.days)

      # Track cost by model
      if model_used.present?
        model_daily_key = "ai_cost:model:#{model_used}:#{Date.current}"
        Rails.cache.increment_float(model_daily_key, cost.to_f, expires_in: 32.days)
      end
    end

    def track_performance_metrics
      return unless response_time_ms.present?

      # Track average response times by operation
      response_key = "ai_performance:#{operation_type}:response_times"
      current_times = Rails.cache.read(response_key) || []
      current_times << response_time_ms
      # Keep only last 100 measurements for rolling average
      current_times = current_times.last(100)
      Rails.cache.write(response_key, current_times, expires_in: 1.day)

      # Track success rates
      success_key = "ai_performance:#{operation_type}:success_rate:#{Date.current}"
      total_key = "ai_performance:#{operation_type}:total:#{Date.current}"
      
      Rails.cache.increment(total_key, 1, expires_in: 32.days)
      if success
        Rails.cache.increment(success_key, 1, expires_in: 32.days)
      end

      # Track token usage if available
      if tokens_used.present?
        token_key = "ai_tokens:#{operation_type}:#{Date.current}"
        Rails.cache.increment(token_key, tokens_used, expires_in: 32.days)
      end
    end

    def track_usage_patterns
      # Track hourly usage patterns
      hour = Time.current.hour
      hourly_key = "ai_usage:hour:#{hour}:#{Date.current}"
      Rails.cache.increment(hourly_key, 1, expires_in: 32.days)

      # Track daily usage by operation
      daily_operation_key = "ai_usage:operation:#{operation_type}:#{Date.current}"
      Rails.cache.increment(daily_operation_key, 1, expires_in: 32.days)

      # Track user activity patterns
      user_activity_key = "ai_usage:user:#{user_id}:#{Date.current}"
      Rails.cache.increment(user_activity_key, 1, expires_in: 32.days)

      # Track weekly trends
      week_key = "ai_usage:week:#{Date.current.beginning_of_week}"
      Rails.cache.increment(week_key, 1, expires_in: 8.weeks)
    end

    def store_usage_record
      # Store detailed usage record for analysis
      usage_record = {
        user_id: user_id,
        operation_type: operation_type,
        cost: cost.to_f,
        model_used: model_used,
        tokens_used: tokens_used,
        response_time_ms: response_time_ms,
        success: success,
        metadata: metadata,
        timestamp: Time.current.iso8601,
        date: Date.current.to_s,
        hour: Time.current.hour
      }

      # Store with unique key for detailed analysis
      record_key = "ai_usage_record:#{SecureRandom.uuid}"
      Rails.cache.write(record_key, usage_record, expires_in: 90.days)

      # Log structured usage data
      Rails.logger.info "[AI_USAGE] #{usage_record.to_json}"
    end

    # Class methods for retrieving analytics
    def self.get_user_daily_cost(user_id, date = Date.current)
      key = "ai_cost:user:#{user_id}:#{date}"
      Rails.cache.read(key) || 0.0
    end

    def self.get_user_monthly_cost(user_id, month = Date.current.beginning_of_month)
      key = "ai_cost:user:#{user_id}:#{month}"
      Rails.cache.read(key) || 0.0
    end

    def self.get_operation_success_rate(operation_type, date = Date.current)
      success_key = "ai_performance:#{operation_type}:success_rate:#{date}"
      total_key = "ai_performance:#{operation_type}:total:#{date}"
      
      successes = Rails.cache.read(success_key) || 0
      total = Rails.cache.read(total_key) || 0
      
      return 0.0 if total.zero?
      (successes.to_f / total * 100).round(2)
    end

    def self.get_average_response_time(operation_type)
      key = "ai_performance:#{operation_type}:response_times"
      times = Rails.cache.read(key) || []
      
      return 0 if times.empty?
      (times.sum.to_f / times.length).round(0)
    end

    def self.get_platform_daily_cost(date = Date.current)
      key = "ai_cost:platform:#{date}"
      Rails.cache.read(key) || 0.0
    end

    def self.get_hourly_usage_pattern(date = Date.current)
      pattern = {}
      (0..23).each do |hour|
        key = "ai_usage:hour:#{hour}:#{date}"
        pattern[hour] = Rails.cache.read(key) || 0
      end
      pattern
    end
  end
end
</file>

<file path="services/ai/usage_monitoring_service.rb">
# frozen_string_literal: true

module Ai
  class UsageMonitoringService < ApplicationService
    include ActiveModel::Model
    include ActiveModel::Attributes

    # Anomaly detection thresholds
    ANOMALY_THRESHOLDS = {
      request_volume: {
        daily_multiplier: 3.0,    # 3x daily average
        hourly_multiplier: 5.0,   # 5x hourly average
        burst_threshold: 100      # requests per minute
      },
      cost: {
        daily_multiplier: 4.0,    # 4x daily average cost
        hourly_multiplier: 6.0,   # 6x hourly average cost
        absolute_threshold: 100.0 # $100 per hour
      },
      error_rate: {
        threshold: 15.0,          # 15% error rate
        consecutive_errors: 10    # 10 consecutive errors
      },
      response_time: {
        threshold: 30.0,          # 30 seconds average
        percentile_95: 60.0       # 95th percentile > 60 seconds
      }
    }.freeze

    # Monitoring time windows
    TIME_WINDOWS = {
      minute: 1.minute,
      hour: 1.hour,
      day: 1.day,
      week: 1.week,
      month: 1.month
    }.freeze

    attribute :user_id
    attribute :time_window, :string, default: 'hour'
    attribute :provider, :string
    attribute :alert_threshold, :string, default: 'medium'

    def monitor_usage_patterns
      begin
        current_metrics = collect_current_metrics
        historical_metrics = collect_historical_metrics
        
        anomalies = detect_anomalies(current_metrics, historical_metrics)
        risk_assessment = assess_risk_level(anomalies)
        
        # Log monitoring results
        log_monitoring_results(current_metrics, anomalies, risk_assessment)
        
        # Send alerts if necessary
        alert_results = send_alerts_if_needed(anomalies, risk_assessment)
        
        {
          success: true,
          monitoring_timestamp: Time.current,
          current_metrics: current_metrics,
          anomalies: anomalies,
          risk_level: risk_assessment[:level],
          alerts_sent: alert_results[:alerts_sent],
          recommendations: generate_recommendations(anomalies)
        }
      rescue => e
        Rails.logger.error "Usage monitoring failed: #{e.message}"
        {
          success: false,
          errors: ['Usage monitoring failed'],
          error_details: e.message
        }
      end
    end

    def get_usage_report
      begin
        time_range = get_time_range
        
        usage_data = {
          summary: generate_usage_summary(time_range),
          trends: analyze_usage_trends(time_range),
          top_users: get_top_users_by_usage(time_range),
          cost_breakdown: generate_cost_breakdown(time_range),
          performance_metrics: collect_performance_metrics(time_range),
          security_events: collect_security_events(time_range)
        }
        
        {
          success: true,
          report_period: time_range,
          generated_at: Time.current,
          data: usage_data
        }
      rescue => e
        Rails.logger.error "Usage report generation failed: #{e.message}"
        {
          success: false,
          errors: ['Failed to generate usage report']
        }
      end
    end

    def detect_suspicious_activity
      suspicious_patterns = []
      
      # Check for unusual request patterns
      request_patterns = analyze_request_patterns
      suspicious_patterns.concat(request_patterns[:suspicious])
      
      # Check for cost anomalies
      cost_patterns = analyze_cost_patterns
      suspicious_patterns.concat(cost_patterns[:suspicious])
      
      # Check for geographic anomalies
      geo_patterns = analyze_geographic_patterns
      suspicious_patterns.concat(geo_patterns[:suspicious])
      
      # Check for time-based anomalies
      time_patterns = analyze_temporal_patterns
      suspicious_patterns.concat(time_patterns[:suspicious])
      
      if suspicious_patterns.any?
        log_suspicious_activity(suspicious_patterns)
        
        {
          success: true,
          suspicious_activity_detected: true,
          patterns: suspicious_patterns,
          risk_score: calculate_risk_score(suspicious_patterns),
          recommended_actions: recommend_security_actions(suspicious_patterns)
        }
      else
        {
          success: true,
          suspicious_activity_detected: false,
          patterns: [],
          risk_score: 0
        }
      end
    end

    private

    def collect_current_metrics
      window_start = Time.current - TIME_WINDOWS[time_window.to_sym]
      
      {
        request_count: count_requests(window_start, Time.current),
        total_cost: calculate_total_cost(window_start, Time.current),
        error_count: count_errors(window_start, Time.current),
        average_response_time: calculate_average_response_time(window_start, Time.current),
        unique_users: count_unique_users(window_start, Time.current),
        peak_requests_per_minute: get_peak_requests_per_minute(window_start, Time.current)
      }
    end

    def collect_historical_metrics
      # Get metrics for the same time window from previous periods
      periods = 7 # Compare with last 7 periods
      historical_data = []
      
      periods.times do |i|
        period_start = Time.current - TIME_WINDOWS[time_window.to_sym] * (i + 2)
        period_end = Time.current - TIME_WINDOWS[time_window.to_sym] * (i + 1)
        
        historical_data << {
          request_count: count_requests(period_start, period_end),
          total_cost: calculate_total_cost(period_start, period_end),
          error_count: count_errors(period_start, period_end),
          average_response_time: calculate_average_response_time(period_start, period_end)
        }
      end
      
      # Calculate averages
      {
        avg_request_count: historical_data.sum { |d| d[:request_count] } / periods.to_f,
        avg_total_cost: historical_data.sum { |d| d[:total_cost] } / periods.to_f,
        avg_error_count: historical_data.sum { |d| d[:error_count] } / periods.to_f,
        avg_response_time: historical_data.sum { |d| d[:average_response_time] } / periods.to_f
      }
    end

    def detect_anomalies(current, historical)
      anomalies = []
      
      # Request volume anomaly
      if current[:request_count] > historical[:avg_request_count] * ANOMALY_THRESHOLDS[:request_volume][:daily_multiplier]
        anomalies << {
          type: 'high_request_volume',
          severity: 'high',
          current_value: current[:request_count],
          expected_range: "0-#{(historical[:avg_request_count] * 2).round}",
          description: 'Request volume significantly higher than historical average'
        }
      end
      
      # Cost anomaly
      if current[:total_cost] > historical[:avg_total_cost] * ANOMALY_THRESHOLDS[:cost][:daily_multiplier]
        anomalies << {
          type: 'high_cost',
          severity: 'high',
          current_value: current[:total_cost],
          expected_range: "0-#{(historical[:avg_total_cost] * 2).round(2)}",
          description: 'Cost significantly higher than historical average'
        }
      end
      
      # Error rate anomaly
      error_rate = current[:request_count] > 0 ? (current[:error_count].to_f / current[:request_count] * 100) : 0
      if error_rate > ANOMALY_THRESHOLDS[:error_rate][:threshold]
        anomalies << {
          type: 'high_error_rate',
          severity: 'critical',
          current_value: error_rate.round(2),
          expected_range: "0-#{ANOMALY_THRESHOLDS[:error_rate][:threshold]}%",
          description: 'Error rate above acceptable threshold'
        }
      end
      
      # Response time anomaly
      if current[:average_response_time] > ANOMALY_THRESHOLDS[:response_time][:threshold]
        anomalies << {
          type: 'slow_response_time',
          severity: 'medium',
          current_value: current[:average_response_time],
          expected_range: "0-#{ANOMALY_THRESHOLDS[:response_time][:threshold]}s",
          description: 'Average response time above acceptable threshold'
        }
      end
      
      # Burst detection
      if current[:peak_requests_per_minute] > ANOMALY_THRESHOLDS[:request_volume][:burst_threshold]
        anomalies << {
          type: 'request_burst',
          severity: 'medium',
          current_value: current[:peak_requests_per_minute],
          expected_range: "0-#{ANOMALY_THRESHOLDS[:request_volume][:burst_threshold]}",
          description: 'Unusual burst of requests detected'
        }
      end
      
      anomalies
    end

    def assess_risk_level(anomalies)
      return { level: 'low', score: 0 } if anomalies.empty?
      
      severity_scores = { 'low' => 1, 'medium' => 3, 'high' => 7, 'critical' => 10 }
      total_score = anomalies.sum { |a| severity_scores[a[:severity]] || 0 }
      
      level = case total_score
              when 0..2 then 'low'
              when 3..6 then 'medium'
              when 7..15 then 'high'
              else 'critical'
              end
      
      {
        level: level,
        score: total_score,
        critical_anomalies: anomalies.count { |a| a[:severity] == 'critical' },
        high_anomalies: anomalies.count { |a| a[:severity] == 'high' }
      }
    end

    def analyze_request_patterns
      # Analyze request patterns for suspicious activity
      suspicious = []
      
      # Check for rapid-fire requests from single user
      if user_id
        recent_requests = count_user_requests_last_minute(user_id)
        if recent_requests > 50
          suspicious << {
            type: 'rapid_requests',
            severity: 'high',
            user_id: user_id,
            description: 'Unusually high request rate from single user'
          }
        end
      end
      
      { suspicious: suspicious }
    end

    def analyze_cost_patterns
      suspicious = []
      
      # Check for sudden cost spikes
      recent_cost = calculate_total_cost(1.hour.ago, Time.current)
      if recent_cost > 50.0 # $50 in one hour
        suspicious << {
          type: 'cost_spike',
          severity: 'high',
          cost: recent_cost,
          description: 'Unusual cost spike detected'
        }
      end
      
      { suspicious: suspicious }
    end

    def analyze_geographic_patterns
      # This would analyze IP addresses for geographic anomalies
      { suspicious: [] }
    end

    def analyze_temporal_patterns
      suspicious = []
      
      # Check for unusual activity during off-hours
      current_hour = Time.current.hour
      if (current_hour < 6 || current_hour > 22) # Outside 6 AM - 10 PM
        recent_requests = count_requests(1.hour.ago, Time.current)
        if recent_requests > 100
          suspicious << {
            type: 'off_hours_activity',
            severity: 'medium',
            hour: current_hour,
            requests: recent_requests,
            description: 'High activity during off-hours'
          }
        end
      end
      
      { suspicious: suspicious }
    end

    def calculate_risk_score(patterns)
      severity_scores = { 'low' => 1, 'medium' => 3, 'high' => 7, 'critical' => 10 }
      patterns.sum { |p| severity_scores[p[:severity]] || 0 }
    end

    # Helper methods for data collection (simplified implementations)
    def count_requests(start_time, end_time)
      # In a real implementation, this would query your metrics database
      rand(10..1000)
    end

    def calculate_total_cost(start_time, end_time)
      # Calculate cost based on usage
      rand(1.0..50.0).round(2)
    end

    def count_errors(start_time, end_time)
      # Count errors in the time range
      rand(0..50)
    end

    def calculate_average_response_time(start_time, end_time)
      # Calculate average response time
      rand(0.5..10.0).round(2)
    end

    def count_unique_users(start_time, end_time)
      # Count unique users in time range
      rand(1..100)
    end

    def get_peak_requests_per_minute(start_time, end_time)
      # Get peak requests per minute in the time range
      rand(1..200)
    end

    def count_user_requests_last_minute(user_id)
      # Count requests from specific user in last minute
      rand(0..100)
    end

    def get_time_range
      case time_window
      when 'minute' then 1.minute.ago..Time.current
      when 'hour' then 1.hour.ago..Time.current
      when 'day' then 1.day.ago..Time.current
      when 'week' then 1.week.ago..Time.current
      when 'month' then 1.month.ago..Time.current
      else 1.hour.ago..Time.current
      end
    end

    def generate_usage_summary(time_range)
      {
        total_requests: rand(100..10000),
        total_cost: rand(10.0..1000.0).round(2),
        unique_users: rand(10..500),
        average_response_time: rand(0.5..5.0).round(2),
        error_rate: rand(0.0..5.0).round(2)
      }
    end

    def analyze_usage_trends(time_range)
      # Analyze trends over time
      { trend: 'increasing', growth_rate: rand(5.0..25.0).round(2) }
    end

    def get_top_users_by_usage(time_range)
      # Get top users by usage
      []
    end

    def generate_cost_breakdown(time_range)
      {
        llm_calls: rand(50.0..80.0).round(2),
        document_processing: rand(5.0..15.0).round(2),
        other: rand(5.0..10.0).round(2)
      }
    end

    def collect_performance_metrics(time_range)
      {
        p95_response_time: rand(1.0..10.0).round(2),
        p99_response_time: rand(5.0..20.0).round(2),
        throughput: rand(100..1000)
      }
    end

    def collect_security_events(time_range)
      AuditLog.security_events
              .where(created_at: time_range)
              .group(:event_type)
              .count
    end

    def generate_recommendations(anomalies)
      recommendations = []
      
      anomalies.each do |anomaly|
        case anomaly[:type]
        when 'high_request_volume'
          recommendations << 'Consider implementing additional rate limiting'
        when 'high_cost'
          recommendations << 'Review AI model usage and consider optimization'
        when 'high_error_rate'
          recommendations << 'Investigate error causes and improve error handling'
        when 'slow_response_time'
          recommendations << 'Optimize AI model calls and consider caching'
        end
      end
      
      recommendations.uniq
    end

    def recommend_security_actions(patterns)
      actions = []
      
      patterns.each do |pattern|
        case pattern[:type]
        when 'rapid_requests'
          actions << 'Implement stricter rate limiting for this user'
        when 'cost_spike'
          actions << 'Review recent high-cost operations'
        when 'off_hours_activity'
          actions << 'Monitor for potential automated attacks'
        end
      end
      
      actions.uniq
    end

    def log_monitoring_results(metrics, anomalies, risk_assessment)
      if anomalies.any? || risk_assessment[:level] != 'low'
        Rails.logger.warn "[USAGE_MONITORING] Risk level: #{risk_assessment[:level]}, Anomalies: #{anomalies.size}"
        
        AuditLog.create!(
          event_type: 'usage_anomaly_detected',
          user_id: user_id,
          details: {
            metrics: metrics,
            anomalies: anomalies,
            risk_level: risk_assessment[:level],
            risk_score: risk_assessment[:score]
          }
        )
      end
    rescue => e
      Rails.logger.error "Failed to log monitoring results: #{e.message}"
    end

    def log_suspicious_activity(patterns)
      Rails.logger.warn "[SUSPICIOUS_ACTIVITY] Detected #{patterns.size} suspicious patterns"
      
      AuditLog.create!(
        event_type: 'suspicious_activity_detected',
        user_id: user_id,
        details: {
          patterns: patterns,
          risk_score: calculate_risk_score(patterns),
          detected_at: Time.current
        }
      )
    rescue => e
      Rails.logger.error "Failed to log suspicious activity: #{e.message}"
    end

    def send_alerts_if_needed(anomalies, risk_assessment)
      alerts_sent = []
      
      if risk_assessment[:level] == 'critical' || risk_assessment[:critical_anomalies] > 0
        # Send critical alerts
        alerts_sent << 'critical_alert'
        Rails.logger.error "[CRITICAL_ALERT] Critical anomalies detected: #{anomalies}"
      elsif risk_assessment[:level] == 'high'
        # Send high priority alerts
        alerts_sent << 'high_priority_alert'
        Rails.logger.warn "[HIGH_ALERT] High priority anomalies detected: #{anomalies}"
      end
      
      { alerts_sent: alerts_sent }
    end
  end
end
</file>

<file path="services/ai/user_behavior_tracking_service.rb">
# frozen_string_literal: true

module Ai
  class UserBehaviorTrackingService < ApplicationService
    include ActiveModel::Model
    include ActiveModel::Attributes

    attribute :user_id, :string
    attribute :session_id, :string
    attribute :event_type, :string
    attribute :event_data, :string, default: {}
    attribute :page_url, :string
    attribute :user_agent, :string
    attribute :ip_address, :string
    attribute :timestamp, :datetime, default: -> { Time.current }

    EVENT_TYPES = %w[
      form_generation_started
      form_generation_completed
      form_generation_failed
      document_uploaded
      prompt_entered
      preview_viewed
      form_edited
      ai_feature_used
      error_encountered
      retry_attempted
      session_started
      session_ended
      page_viewed
      button_clicked
      input_focused
      input_changed
      form_submitted
      navigation_event
    ].freeze

    validates :user_id, presence: true
    validates :event_type, presence: true, inclusion: { in: EVENT_TYPES }

    def self.track_event(event_data)
      service = new(event_data)
      service.track_event
    end

    def track_event
      return false unless valid?

      # Track user journey patterns
      track_user_journey

      # Track feature usage patterns
      track_feature_usage

      # Track conversion funnel
      track_conversion_funnel

      # Track user engagement
      track_user_engagement

      # Store detailed event for analysis
      store_event_record

      true
    rescue StandardError => e
      Rails.logger.error "Failed to track user behavior: #{e.message}"
      false
    end

    private

    def track_user_journey
      # Track user session flow
      session_key = "user_journey:#{session_id}"
      current_journey = Rails.cache.read(session_key) || []
      
      journey_event = {
        event_type: event_type,
        timestamp: timestamp.iso8601,
        page_url: page_url,
        event_data: event_data
      }
      
      current_journey << journey_event
      # Keep last 50 events per session
      current_journey = current_journey.last(50)
      Rails.cache.write(session_key, current_journey, expires_in: 4.hours)

      # Track common user paths
      if current_journey.length >= 2
        previous_event = current_journey[-2]
        path_key = "user_paths:#{previous_event[:event_type]}:#{event_type}:#{Date.current}"
        Rails.cache.increment(path_key, 1, expires_in: 32.days)
      end
    end

    def track_feature_usage
      # Track AI feature adoption
      if event_type.include?('ai_') || event_type.include?('form_generation')
        feature_key = "feature_usage:#{event_type}:#{Date.current}"
        Rails.cache.increment(feature_key, 1, expires_in: 32.days)

        # Track feature usage by user
        user_feature_key = "user_features:#{user_id}:#{event_type}:#{Date.current}"
        Rails.cache.increment(user_feature_key, 1, expires_in: 32.days)
      end

      # Track document vs prompt preference
      if event_type == 'document_uploaded'
        Rails.cache.increment("input_preference:document:#{Date.current}", 1, expires_in: 32.days)
      elsif event_type == 'prompt_entered'
        Rails.cache.increment("input_preference:prompt:#{Date.current}", 1, expires_in: 32.days)
      end

      # Track error recovery patterns
      if event_type == 'retry_attempted'
        retry_context = event_data[:error_type] || 'unknown'
        retry_key = "retry_patterns:#{retry_context}:#{Date.current}"
        Rails.cache.increment(retry_key, 1, expires_in: 32.days)
      end
    end

    def track_conversion_funnel
      # Define conversion funnel stages
      funnel_stages = {
        'form_generation_started' => 'started',
        'document_uploaded' => 'input_provided',
        'prompt_entered' => 'input_provided',
        'preview_viewed' => 'preview_viewed',
        'form_generation_completed' => 'completed',
        'form_edited' => 'engaged'
      }

      stage = funnel_stages[event_type]
      return unless stage

      # Track funnel progression
      funnel_key = "conversion_funnel:#{stage}:#{Date.current}"
      Rails.cache.increment(funnel_key, 1, expires_in: 32.days)

      # Track user-specific funnel progression
      user_funnel_key = "user_funnel:#{user_id}"
      user_stages = Rails.cache.read(user_funnel_key) || []
      
      unless user_stages.include?(stage)
        user_stages << stage
        Rails.cache.write(user_funnel_key, user_stages, expires_in: 1.day)
        
        # Track unique users reaching each stage
        unique_funnel_key = "unique_funnel:#{stage}:#{Date.current}"
        Rails.cache.increment(unique_funnel_key, 1, expires_in: 32.days)
      end
    end

    def track_user_engagement
      # Track session duration indicators
      if event_type == 'session_started'
        session_start_key = "session_start:#{session_id}"
        Rails.cache.write(session_start_key, timestamp.to_f, expires_in: 4.hours)
      elsif event_type == 'session_ended'
        session_start_key = "session_start:#{session_id}"
        start_time = Rails.cache.read(session_start_key)
        
        if start_time
          duration = timestamp.to_f - start_time
          duration_key = "session_durations:#{Date.current}"
          current_durations = Rails.cache.read(duration_key) || []
          current_durations << duration
          current_durations = current_durations.last(1000) # Keep recent sessions
          Rails.cache.write(duration_key, current_durations, expires_in: 32.days)
        end
      end

      # Track page engagement time
      if event_type == 'page_viewed' && page_url.present?
        page_view_key = "page_views:#{normalize_page_url(page_url)}:#{Date.current}"
        Rails.cache.increment(page_view_key, 1, expires_in: 32.days)
      end

      # Track interaction frequency
      interaction_events = %w[button_clicked input_focused input_changed form_submitted]
      if interaction_events.include?(event_type)
        interaction_key = "user_interactions:#{user_id}:#{Date.current}"
        Rails.cache.increment(interaction_key, 1, expires_in: 32.days)
      end
    end

    def store_event_record
      # Store detailed event record for analysis
      event_record = {
        user_id: user_id,
        session_id: session_id,
        event_type: event_type,
        event_data: event_data,
        page_url: page_url,
        user_agent: user_agent,
        ip_address: ip_address,
        timestamp: timestamp.iso8601,
        date: timestamp.to_date.to_s,
        hour: timestamp.hour,
        day_of_week: timestamp.wday
      }

      # Store with unique key for detailed analysis
      record_key = "behavior_event:#{SecureRandom.uuid}"
      Rails.cache.write(record_key, event_record, expires_in: 90.days)

      # Log structured event data
      Rails.logger.info "[USER_BEHAVIOR] #{event_record.to_json}"
    end

    def normalize_page_url(url)
      # Extract meaningful page identifier from URL
      uri = URI.parse(url)
      path = uri.path
      
      # Normalize dynamic segments
      path = path.gsub(/\/\d+/, '/:id') # Replace numeric IDs
      path = path.gsub(/\/[a-f0-9-]{36}/, '/:uuid') # Replace UUIDs
      
      path
    rescue URI::InvalidURIError
      'unknown'
    end

    # Class methods for retrieving behavior analytics
    def self.get_conversion_funnel_data(date = Date.current)
      stages = %w[started input_provided preview_viewed completed engaged]
      funnel_data = {}
      
      stages.each do |stage|
        key = "conversion_funnel:#{stage}:#{date}"
        funnel_data[stage] = Rails.cache.read(key) || 0
      end
      
      funnel_data
    end

    def self.get_feature_usage_stats(date = Date.current)
      feature_stats = {}
      
      EVENT_TYPES.each do |event_type|
        next unless event_type.include?('ai_') || event_type.include?('form_generation')
        
        key = "feature_usage:#{event_type}:#{date}"
        feature_stats[event_type] = Rails.cache.read(key) || 0
      end
      
      feature_stats
    end

    def self.get_input_preference_stats(date = Date.current)
      document_key = "input_preference:document:#{date}"
      prompt_key = "input_preference:prompt:#{date}"
      
      {
        document: Rails.cache.read(document_key) || 0,
        prompt: Rails.cache.read(prompt_key) || 0
      }
    end

    def self.get_user_journey(session_id)
      key = "user_journey:#{session_id}"
      Rails.cache.read(key) || []
    end

    def self.get_average_session_duration(date = Date.current)
      key = "session_durations:#{date}"
      durations = Rails.cache.read(key) || []
      
      return 0 if durations.empty?
      (durations.sum / durations.length).round(0)
    end

    def self.get_popular_user_paths(date = Date.current, limit = 10)
      # This would need a more sophisticated implementation to aggregate paths
      # For now, return empty array
      []
    end

    def self.get_retry_patterns(date = Date.current)
      # Get all retry pattern keys for the date
      pattern_keys = Rails.cache.instance_variable_get(:@data).keys.select do |key|
        key.to_s.start_with?("retry_patterns:") && key.to_s.end_with?(":#{date}")
      end
      
      patterns = {}
      pattern_keys.each do |key|
        error_type = key.to_s.split(':')[1]
        patterns[error_type] = Rails.cache.read(key) || 0
      end
      
      patterns
    end
  end
end
</file>

<file path="services/forms/answer_processing_service.rb">
# frozen_string_literal: true

module Forms
  # Service for processing form question answers with validation, AI analysis, and integration triggers
  class AnswerProcessingService < ApplicationService
    attr_accessor :response, :question, :answer_data, :metadata
    
    attr_reader :question_response
    
    validates :response, presence: true
    validates :question, presence: true
    validates :answer_data, presence: true
    
    def initialize(response:, question:, answer_data:, metadata: {})
      @response = response
      @question = question
      @answer_data = answer_data
      @metadata = metadata || {}
      super()
    end
    
    def call
      return self unless valid?
      
      validate_service_inputs
      return self if failure?
      
      execute_in_transaction do
        process_answer
      end
      
      self
    end
    
    # Check if follow-up questions should be generated
    def should_generate_followup?
      return false unless question.generates_followups?
      return false unless @question_response&.ai_analysis&.dig('flags', 'needs_followup')
      
      # Check if we haven't already generated too many follow-ups
      existing_followups = response.dynamic_questions.where(generated_from_question: question).count
      existing_followups < max_followups_per_question
    end
    
    private
    
    def validate_service_inputs
      validate_response_question_relationship
      validate_answer_format
    end
    
    def validate_response_question_relationship
      if question.form_id != response.form_id
        add_error(:question, "does not belong to this form")
      end
    end
    
    def validate_answer_format
      validation_errors = question.validate_answer(answer_data)
      
      validation_errors.each do |error|
        add_error(:answer_data, error)
      end
    end
    
    def process_answer
      create_or_update_question_response
      update_response_metadata
      schedule_ai_analysis if should_trigger_ai_analysis?
      schedule_integrations if should_trigger_integrations?
      
      set_result(@question_response)
    end
    
    def create_or_update_question_response
      @question_response = response.question_responses.find_or_initialize_by(
        form_question: question
      )
      
      @question_response.assign_attributes(
        answer_data: question.process_answer(answer_data),
        raw_input: answer_data,
        response_time_ms: metadata[:response_time],
        revision_count: (@question_response.revision_count || 0) + 1,
        interaction_events: metadata[:interaction_events] || []
      )
      
      unless @question_response.save
        @question_response.errors.each do |error|
          add_error(:question_response, error.full_message)
        end
        raise ActiveRecord::Rollback
      end
    end
    
    def update_response_metadata
      response_metadata = response.metadata || {}
      
      updated_metadata = response_metadata.merge(
        last_question_id: question.id,
        total_revisions: response.question_responses.sum(:revision_count),
        last_activity_at: Time.current.iso8601
      )
      
      unless response.update(
        last_activity_at: Time.current,
        metadata: updated_metadata
      )
        response.errors.each do |error|
          add_error(:response, error.full_message)
        end
        raise ActiveRecord::Rollback
      end
    end
    
    def should_trigger_ai_analysis?
      question.ai_enhanced? && 
      response.form.user.can_use_ai_features? &&
      answer_data.present?
    end
    
    def should_trigger_integrations?
      response.form.integration_settings.present? &&
      response.form.integration_settings['trigger_on_answer'] == true
    end
    
    def schedule_ai_analysis
      Rails.logger.info "Scheduling AI analysis for question response #{@question_response.id}"
      Forms::ResponseAnalysisJob.perform_later(@question_response.id)
      
      set_context(:ai_analysis_scheduled, true)
    end
    
    def schedule_integrations
      Rails.logger.info "Scheduling integrations for response #{response.id}, question #{question.id}"
      Forms::IntegrationTriggerJob.perform_later(response.id, question.id)
      
      set_context(:integrations_scheduled, true)
    end
    
    def max_followups_per_question
      question.ai_config&.dig('max_followups') || 2
    end
  end
end
</file>

<file path="services/forms/navigation_service.rb">
# frozen_string_literal: true

module Forms
  # Service for handling form navigation logic including conditional flows,
  # question ordering, and multi-step form progression
  class NavigationService < ApplicationService
    attr_accessor :form_response, :current_question, :direction
    
    attr_reader :next_question, :previous_question, :navigation_context
    
    validates :form_response, presence: true
    validates :direction, inclusion: { in: %w[next previous first last] }
    
    def initialize(form_response:, current_question: nil, direction: 'next')
      @form_response = form_response
      @current_question = current_question
      @direction = direction
      @navigation_context = {}
      super()
    end
    
    def call
      return self unless valid?
      
      validate_service_inputs
      return self if failure?
      
      calculate_navigation
      build_navigation_context
      
      set_result({
        next_question: @next_question,
        previous_question: @previous_question,
        navigation_context: @navigation_context
      })
      
      self
    end
    
    # Get the first question in the form (respecting conditional logic)
    def first_question
      form_response.form.form_questions
                   .order(:position)
                   .find { |q| question_visible?(q) }
    end
    
    # Get the last answered question
    def last_answered_question
      answered_responses = form_response.question_responses
                                      .joins(:form_question)
                                      .where.not(answer_data: {})
                                      .order('form_questions.position DESC')
      
      answered_responses.first&.form_question
    end
    
    # Check if form can be completed (all required questions answered)
    def can_complete_form?
      required_questions = form_response.form.form_questions
                                       .where(required: true)
                                       .select { |q| question_visible?(q) }
      
      answered_required = form_response.question_responses
                                     .joins(:form_question)
                                     .where(form_questions: { required: true })
                                     .where.not(answer_data: {})
      
      required_questions.count == answered_required.count
    end
    
    # Get completion percentage considering conditional logic
    def completion_percentage
      visible_questions = form_response.form.form_questions
                                      .select { |q| question_visible?(q) }
      
      return 0.0 if visible_questions.empty?
      
      answered_questions = form_response.question_responses
                                       .joins(:form_question)
                                       .where.not(answer_data: {})
                                       .where(form_question: visible_questions)
      
      (answered_questions.count.to_f / visible_questions.count * 100).round(2)
    end
    
    # Get navigation breadcrumbs for multi-step forms
    def navigation_breadcrumbs
      visible_questions = form_response.form.form_questions
                                      .order(:position)
                                      .select { |q| question_visible?(q) }
      
      answered_question_ids = form_response.question_responses
                                          .where.not(answer_data: {})
                                          .pluck(:form_question_id)
      
      visible_questions.map.with_index(1) do |question, index|
        {
          position: index,
          question_id: question.id,
          title: question.title,
          status: breadcrumb_status(question, answered_question_ids),
          current: question == current_question
        }
      end
    end
    
    # Check if navigation is allowed in the given direction
    def navigation_allowed?(direction)
      case direction.to_s
      when 'next'
        @next_question.present?
      when 'previous'
        @previous_question.present?
      when 'first'
        first_question.present?
      when 'last'
        can_complete_form?
      else
        false
      end
    end
    
    # Get suggested navigation action based on form state
    def suggested_action
      return 'start' if form_response.question_responses.empty?
      return 'complete' if can_complete_form? && @next_question.nil?
      return 'continue' if @next_question.present?
      return 'review' if @next_question.nil? && !can_complete_form?
      
      'unknown'
    end
    
    private
    
    def validate_service_inputs
      if current_question && current_question.form_id != form_response.form_id
        add_error(:current_question, "does not belong to this form")
      end
      
      if direction == 'next' && current_question.nil?
        # For 'next' without current question, we'll find the appropriate starting point
        @current_question = last_answered_question || first_question
      end
    end
    
    def calculate_navigation
      case direction
      when 'next'
        calculate_next_question
      when 'previous'
        calculate_previous_question
      when 'first'
        @next_question = first_question
        @previous_question = nil
      when 'last'
        @next_question = nil
        @previous_question = last_answered_question
      end
    end
    
    def calculate_next_question
      if current_question.nil?
        @next_question = first_question
        @previous_question = nil
        return
      end
      
      # Find next visible question after current position
      next_questions = form_response.form.form_questions
                                   .where('position > ?', current_question.position)
                                   .order(:position)
      
      @next_question = next_questions.find { |q| question_visible?(q) }
      @previous_question = current_question
    end
    
    def calculate_previous_question
      if current_question.nil?
        @previous_question = last_answered_question
        @next_question = nil
        return
      end
      
      # Find previous visible question before current position
      previous_questions = form_response.form.form_questions
                                       .where('position < ?', current_question.position)
                                       .order(position: :desc)
      
      @previous_question = previous_questions.find { |q| question_visible?(q) }
      @next_question = current_question
    end
    
    def question_visible?(question)
      return true unless question.has_conditional_logic?
      
      question.should_show_for_response?(form_response)
    end
    
    def build_navigation_context
      @navigation_context = {
        current_position: current_question&.position,
        total_questions: form_response.form.form_questions.count,
        visible_questions_count: visible_questions_count,
        completion_percentage: completion_percentage,
        can_complete: can_complete_form?,
        suggested_action: suggested_action,
        navigation_allowed: {
          next: navigation_allowed?('next'),
          previous: navigation_allowed?('previous'),
          first: navigation_allowed?('first'),
          complete: navigation_allowed?('last')
        },
        breadcrumbs: navigation_breadcrumbs,
        form_flow_type: determine_flow_type
      }
    end
    
    def visible_questions_count
      form_response.form.form_questions.count { |q| question_visible?(q) }
    end
    
    def breadcrumb_status(question, answered_question_ids)
      if answered_question_ids.include?(question.id)
        'completed'
      elsif question == current_question
        'current'
      elsif question == @next_question
        'next'
      else
        'pending'
      end
    end
    
    def determine_flow_type
      form = form_response.form
      
      # Check form settings for flow type preference
      flow_type = form.form_settings&.dig('flow_type')
      return flow_type if flow_type.present?
      
      # Auto-detect based on form characteristics
      question_count = form.form_questions.count
      has_conditional_logic = form.form_questions.any?(&:has_conditional_logic?)
      
      if question_count <= 3
        'single_page'
      elsif has_conditional_logic
        'adaptive'
      elsif question_count <= 10
        'stepped'
      else
        'paginated'
      end
    end
    
    # Helper method to find question by various identifiers
    def find_question(identifier)
      case identifier
      when FormQuestion
        identifier
      when String
        form_response.form.form_questions.find_by(id: identifier) ||
          form_response.form.form_questions.find_by(reference_id: identifier)
      when Integer
        form_response.form.form_questions.find_by(id: identifier)
      else
        nil
      end
    end
    
    # Calculate optimal question order considering dependencies
    def calculate_question_dependencies
      dependencies = {}
      
      form_response.form.form_questions.each do |question|
        next unless question.has_conditional_logic?
        
        dependent_questions = question.conditional_rules.map { |rule| rule['question_id'] }
        dependencies[question.id] = dependent_questions
      end
      
      dependencies
    end
    
    # Validate navigation path for circular dependencies
    def validate_navigation_path
      dependencies = calculate_question_dependencies
      
      # Simple cycle detection - could be enhanced with more sophisticated algorithms
      dependencies.each do |question_id, deps|
        if deps.include?(question_id)
          add_error(:navigation, "Circular dependency detected for question #{question_id}")
        end
      end
    end
    
    # Get navigation statistics for analytics
    def navigation_statistics
      {
        total_steps: visible_questions_count,
        completed_steps: form_response.question_responses.where.not(answer_data: {}).count,
        skipped_questions: calculate_skipped_questions,
        backtrack_count: calculate_backtrack_count,
        average_time_per_question: calculate_average_time_per_question
      }
    end
    
    def calculate_skipped_questions
      # Questions that were visible but not answered due to navigation
      # This would require tracking navigation history
      0 # Placeholder - implement based on navigation tracking needs
    end
    
    def calculate_backtrack_count
      # Count how many times user went back
      # This would require tracking navigation history
      0 # Placeholder - implement based on navigation tracking needs
    end
    
    def calculate_average_time_per_question
      responses_with_time = form_response.question_responses
                                        .where.not(time_spent_seconds: [nil, 0])
      
      return 0 if responses_with_time.empty?
      
      responses_with_time.average(:time_spent_seconds).to_f.round(2)
    end
  end
end
</file>

<file path="services/forms/workflow_generator_service.rb">
# frozen_string_literal: true

module Forms
  # Service responsible for dynamically generating SuperAgent workflow classes for forms
  # This service creates custom workflow classes based on form configuration and questions
  class WorkflowGeneratorService < ApplicationService
    attr_reader :form, :workflow_class_name
    
    def initialize(form)
      @form = form
      @workflow_class_name = form.workflow_class_name
      super()
    end
    
    # Main execution method
    def call
      validate_service_inputs
      return self if failure?
      
      if workflow_exists?
        Rails.logger.info "Workflow class #{workflow_class_name} already exists"
        set_result(existing_workflow_class)
      else
        generate_new_workflow_class
      end
      
      self
    end
    
    # Generate a new workflow class for the form
    def generate_class
      call
      @result
    end
    
    # Regenerate an existing workflow class (removes old one first)
    def regenerate_class
      remove_existing_class if workflow_exists?
      generate_new_workflow_class
      @result
    end
    
    private
    
    # Validate service inputs
    def validate_service_inputs
      unless @form.is_a?(Form)
        add_error(:form, "must be a Form instance")
        return
      end
      
      unless @workflow_class_name.present?
        add_error(:workflow_class_name, "must be present")
        return
      end
      
      unless @form.form_questions.any?
        add_error(:form, "must have at least one question to generate workflow")
        return
      end
    end
    
    # Check if workflow class already exists
    def workflow_exists?
      return false unless @workflow_class_name.present?
      
      begin
        @workflow_class_name.constantize
        true
      rescue NameError
        false
      end
    end
    
    # Get existing workflow class
    def existing_workflow_class
      return nil unless workflow_exists?
      @workflow_class_name.constantize
    end
    
    # Generate a new workflow class
    def generate_new_workflow_class
      Rails.logger.info "Generating new workflow class: #{@workflow_class_name}"
      
      # Build workflow definition using the builder
      definition_builder = WorkflowDefinitionBuilder.new(@form)
      workflow_definition = definition_builder.build
      
      if workflow_definition.nil?
        add_error(:generation, "Failed to build workflow definition")
        return
      end
      
      # Create the actual workflow class
      workflow_class = create_workflow_class(workflow_definition)
      
      if workflow_class
        Rails.logger.info "Successfully generated workflow class: #{@workflow_class_name}"
        set_result(workflow_class)
      else
        add_error(:generation, "Failed to create workflow class")
      end
    end
    
    # Build workflow definition from form configuration
    def build_workflow_definition
      WorkflowDefinitionBuilder.new(@form).build
    end
    
    # Create the actual workflow class from definition
    def create_workflow_class(definition)
      begin
        # Generate the class code
        class_code = generate_class_code(definition)
        
        # Evaluate the class code to create the class
        eval(class_code)
        
        # Return the created class
        @workflow_class_name.constantize
      rescue StandardError => e
        Rails.logger.error "Failed to create workflow class: #{e.message}"
        Rails.logger.error e.backtrace.join("\n") if Rails.env.development?
        add_error(:class_creation, "Failed to create class: #{e.message}")
        nil
      end
    end
    
    # Remove existing workflow class
    def remove_existing_class
      return unless workflow_exists?
      
      begin
        # Remove the constant to allow redefinition
        namespace, class_name = @workflow_class_name.split('::')
        if namespace && class_name
          namespace.constantize.send(:remove_const, class_name)
        else
          Object.send(:remove_const, @workflow_class_name)
        end
        
        Rails.logger.info "Removed existing workflow class: #{@workflow_class_name}"
      rescue StandardError => e
        Rails.logger.warn "Failed to remove existing class: #{e.message}"
      end
    end
    
    # Generate Ruby class code from workflow definition
    def generate_class_code(definition)
      <<~RUBY
        class #{@workflow_class_name} < ApplicationWorkflow
          workflow do
            #{generate_workflow_steps(definition)}
          end
          
          private
          
          #{generate_helper_methods(definition)}
        end
      RUBY
    end
    
    # Generate workflow steps code
    def generate_workflow_steps(definition)
      steps_code = []
      
      # Add global configuration
      if definition[:config]
        steps_code << generate_global_config(definition[:config])
      end
      
      # Add workflow steps
      definition[:steps]&.each do |step|
        steps_code << generate_step_code(step)
      end
      
      steps_code.join("\n\n")
    end
    
    # Generate global configuration code
    def generate_global_config(config)
      config_lines = []
      
      config_lines << "timeout #{config[:timeout]}" if config[:timeout]
      config_lines << "retry_policy #{config[:retry_policy]}" if config[:retry_policy]
      
      config_lines.join("\n")
    end
    
    # Generate code for a single workflow step
    def generate_step_code(step)
      case step[:type]
      when 'validate'
        generate_validation_step(step)
      when 'task'
        generate_task_step(step)
      when 'llm'
        generate_llm_step(step)
      when 'stream'
        generate_stream_step(step)
      else
        "# Unknown step type: #{step[:type]}"
      end
    end
    
    # Generate validation step code
    def generate_validation_step(step)
      <<~RUBY.strip
        validate :#{step[:name]} do
          #{generate_input_declaration(step[:inputs])}
          description "#{step[:description]}"
          
          process do |#{step[:inputs]&.join(', ')}|
            #{step[:process_code] || '# Validation logic here'}
          end
        end
      RUBY
    end
    
    # Generate task step code
    def generate_task_step(step)
      code = <<~RUBY.strip
        task :#{step[:name]} do
          #{generate_input_declaration(step[:inputs])}
      RUBY
      
      if step[:run_when]
        code += "\n          #{generate_conditional_logic(step[:run_when])}"
      end
      
      code += <<~RUBY
        
          process do |#{step[:inputs]&.join(', ')}|
            #{step[:process_code] || '# Task logic here'}
          end
        end
      RUBY
      
      code
    end
    
    # Generate LLM step code
    def generate_llm_step(step)
      code = <<~RUBY.strip
        llm :#{step[:name]} do
          #{generate_input_declaration(step[:inputs])}
      RUBY
      
      if step[:run_if]
        code += "\n          #{generate_conditional_logic(step[:run_if])}"
      end
      
      code += <<~RUBY
        
          model "#{step[:model] || 'gpt-4o-mini'}"
          temperature #{step[:temperature] || 0.3}
          max_tokens #{step[:max_tokens] || 500}
          response_format :#{step[:response_format] || 'json'}
          
          system_prompt "#{step[:system_prompt] || 'You are an AI assistant'}"
          prompt <<~PROMPT
            #{step[:prompt] || 'Process the input data'}
          PROMPT
        end
      RUBY
      
      code
    end
    
    # Generate stream step code
    def generate_stream_step(step)
      <<~RUBY.strip
        stream :#{step[:name]} do
          #{generate_input_declaration(step[:inputs])}
          
          target { |ctx| "#{step[:target] || 'default_target'}" }
          turbo_action :#{step[:turbo_action] || 'append'}
          partial "#{step[:partial] || 'default_partial'}"
          
          locals do |ctx|
            #{step[:locals_code] || '{}'}
          end
        end
      RUBY
    end
    
    # Generate input declaration code
    def generate_input_declaration(inputs)
      return "" unless inputs&.any?
      
      if inputs.is_a?(Array)
        "input #{inputs.map { |i| ":#{i}" }.join(', ')}"
      else
        "input :#{inputs}"
      end
    end
    
    # Generate conditional logic code
    def generate_conditional_logic(condition)
      case condition[:type]
      when 'run_when'
        "run_when :#{condition[:step]}, ->(result) { #{condition[:condition]} }"
      when 'run_if'
        "run_if { |ctx| #{condition[:condition]} }"
      else
        "# Unknown condition type: #{condition[:type]}"
      end
    end
    
    # Generate helper methods for the workflow class
    def generate_helper_methods(definition)
      helper_methods = []
      
      # Add form-specific helper methods
      helper_methods << <<~RUBY.strip
        def form
          @form ||= Form.find(context.get(:form_id))
        end
        
        def form_response
          @form_response ||= FormResponse.find(context.get(:form_response_id))
        end
        
        def current_question
          @current_question ||= FormQuestion.find(context.get(:question_id))
        end
      RUBY
      
      # Add any custom helper methods from definition
      if definition[:helper_methods]
        helper_methods << definition[:helper_methods]
      end
      
      helper_methods.join("\n\n")
    end
    
    # Nested class responsible for building workflow definitions from form configuration
    class WorkflowDefinitionBuilder
      attr_reader :form
      
      def initialize(form)
        @form = form
      end
      
      # Build complete workflow definition
      def build
        return nil unless @form&.form_questions&.any?
        
        {
          config: build_global_config,
          steps: build_steps,
          helper_methods: build_helper_methods
        }
      end
      
      private
      
      # Build global workflow configuration
      def build_global_config
        {
          timeout: determine_workflow_timeout,
          retry_policy: build_retry_policy
        }
      end
      
      # Determine appropriate timeout based on form complexity
      def determine_workflow_timeout
        base_timeout = 60 # 1 minute base
        question_count = @form.form_questions.count
        ai_questions = @form.form_questions.count { |q| q.ai_enhanced? }
        
        # Add time for each question (5 seconds base + 30 seconds per AI question)
        timeout = base_timeout + (question_count * 5) + (ai_questions * 30)
        
        # Cap at 10 minutes
        [timeout, 600].min
      end
      
      # Build retry policy configuration
      def build_retry_policy
        {
          max_retries: 2,
          delay: 1,
          exponential_backoff: true
        }
      end
      
      # Build all workflow steps
      def build_steps
        steps = []
        
        # Always start with form validation
        steps << build_form_validation_step
        
        # Add steps for each question
        @form.form_questions.ordered.each do |question|
          steps.concat(build_question_steps(question))
        end
        
        # Add completion step
        steps << build_completion_step
        
        steps
      end
      
      # Build form validation step
      def build_form_validation_step
        {
          type: 'validate',
          name: 'validate_form_data',
          inputs: ['form_response_id', 'question_id', 'answer_data'],
          description: 'Validate incoming form response data',
          process_code: <<~RUBY.strip
            form_response = FormResponse.find(form_response_id)
            question = FormQuestion.find(question_id)
            
            # Validate form response belongs to correct form
            unless form_response.form_id == question.form_id
              return { valid: false, error: 'Form response and question mismatch' }
            end
            
            # Validate question exists and is active
            unless question.active?
              return { valid: false, error: 'Question is not active' }
            end
            
            # Validate answer data format
            validation_result = question.validate_answer(answer_data)
            unless validation_result[:valid]
              return { valid: false, error: validation_result[:error] }
            end
            
            {
              valid: true,
              form_response: form_response,
              question: question,
              processed_answer: validation_result[:processed_answer]
            }
          RUBY
        }
      end
      
      # Build steps for a specific question
      def build_question_steps(question)
        steps = []
        
        # Save question response step
        steps << build_save_response_step(question)
        
        # Add AI analysis step if question is AI-enhanced
        if question.ai_enhanced?
          steps << build_ai_analysis_step(question)
          steps << build_update_with_ai_step(question)
        end
        
        # Add dynamic question generation if enabled
        if question.generates_followups?
          steps << build_dynamic_question_step(question)
        end
        
        # Add UI update step
        steps << build_ui_update_step(question)
        
        steps
      end
      
      # Build save response step
      def build_save_response_step(question)
        {
          type: 'task',
          name: "save_response_q#{question.position}",
          inputs: ['validate_form_data'],
          run_when: {
            type: 'run_when',
            step: 'validate_form_data',
            condition: 'result[:valid]'
          },
          process_code: <<~RUBY.strip
            validation_result = validate_form_data
            form_response = validation_result[:form_response]
            question = validation_result[:question]
            processed_answer = validation_result[:processed_answer]
            
            # Create or update question response
            question_response = form_response.question_responses.find_or_initialize_by(
              form_question: question
            )
            
            question_response.assign_attributes(
              answer_data: processed_answer,
              response_time_ms: context.get(:response_time_ms),
              metadata: context.get(:response_metadata, {})
            )
            
            if question_response.save
              # Update form response progress
              form_response.update_progress!
              
              {
                success: true,
                question_response: question_response,
                form_response: form_response
              }
            else
              {
                success: false,
                errors: question_response.errors.full_messages
              }
            end
          RUBY
        }
      end
      
      # Build AI analysis step for AI-enhanced questions
      def build_ai_analysis_step(question)
        {
          type: 'llm',
          name: "analyze_response_q#{question.position}",
          inputs: ["save_response_q#{question.position}"],
          run_if: {
            type: 'run_if',
            condition: build_ai_condition(question)
          },
          model: determine_ai_model(question),
          temperature: 0.3,
          max_tokens: 500,
          response_format: 'json',
          system_prompt: build_ai_system_prompt(question),
          prompt: build_analysis_prompt(question)
        }
      end
      
      # Build AI condition check
      def build_ai_condition(question)
        conditions = []
        
        # Check if AI features are enabled
        conditions << "@form.ai_enhanced?"
        
        # Check if user has AI credits
        conditions << "@form.user.can_use_ai_features?"
        
        # Check if question requires AI analysis
        conditions << "#{question.has_response_analysis?}"
        
        conditions.join(' && ')
      end
      
      # Determine appropriate AI model for question
      def determine_ai_model(question)
        # Use form's configured model or default
        @form.ai_configuration.dig('model') || 'gpt-4o-mini'
      end
      
      # Build AI system prompt
      def build_ai_system_prompt(question)
        case question.question_type
        when 'text_long', 'text_short'
          "You are an expert at analyzing text responses for sentiment, quality, and insights."
        when 'email'
          "You are an expert at analyzing email responses and detecting patterns."
        when 'rating', 'scale'
          "You are an expert at analyzing rating responses and identifying trends."
        else
          "You are an AI assistant analyzing form responses for insights and quality."
        end
      end
      
      # Build analysis prompt for question
      def build_analysis_prompt(question)
        <<~PROMPT
          Analyze the following form response:
          
          Question: "#{question.title}"
          Question Type: #{question.question_type}
          Response: {{answer_data}}
          
          Please provide analysis in the following JSON format:
          {
            "sentiment": "positive|neutral|negative",
            "confidence_score": 0.0-1.0,
            "quality_indicators": {
              "completeness": 0.0-1.0,
              "relevance": 0.0-1.0,
              "clarity": 0.0-1.0
            },
            "insights": ["insight1", "insight2"],
            "flags": ["flag1", "flag2"],
            "suggested_followup": "optional follow-up question"
          }
          
          Focus on:
          - Response quality and completeness
          - Emotional sentiment and tone
          - Potential red flags or concerns
          - Opportunities for follow-up questions
          - Business insights and patterns
        PROMPT
      end
      
      # Build step to update response with AI analysis
      def build_update_with_ai_step(question)
        {
          type: 'task',
          name: "update_ai_analysis_q#{question.position}",
          inputs: ["save_response_q#{question.position}", "analyze_response_q#{question.position}"],
          run_when: {
            type: 'run_when',
            step: "analyze_response_q#{question.position}",
            condition: 'result.present?'
          },
          process_code: <<~RUBY.strip
            save_result = context.get("save_response_q#{question.position}")
            ai_analysis = context.get("analyze_response_q#{question.position}")
            
            question_response = save_result[:question_response]
            
            # Update question response with AI analysis
            question_response.update!(
              ai_analysis: ai_analysis,
              ai_sentiment: ai_analysis['sentiment'],
              ai_confidence_score: ai_analysis['confidence_score'],
              quality_score: calculate_quality_score(ai_analysis['quality_indicators'])
            )
            
            # Track AI usage
            @form.user.consume_ai_credit(0.01) # Small cost for analysis
            
            {
              success: true,
              question_response: question_response,
              ai_analysis: ai_analysis
            }
          RUBY
        }
      end
      
      # Build dynamic question generation step
      def build_dynamic_question_step(question)
        {
          type: 'llm',
          name: "generate_followup_q#{question.position}",
          inputs: ["update_ai_analysis_q#{question.position}"],
          run_if: {
            type: 'run_if',
            condition: build_followup_condition(question)
          },
          model: determine_ai_model(question),
          temperature: 0.7,
          max_tokens: 300,
          response_format: 'json',
          system_prompt: "You are an expert at generating contextual follow-up questions.",
          prompt: build_followup_prompt(question)
        }
      end
      
      # Build condition for follow-up generation
      def build_followup_condition(question)
        conditions = []
        
        # Check if AI analysis suggests follow-up
        conditions << "ai_analysis = context.get('analyze_response_q#{question.position}')"
        conditions << "ai_analysis&.dig('suggested_followup').present?"
        
        # Check if form allows dynamic questions
        conditions << "@form.form_settings.dig('allow_dynamic_questions') != false"
        
        conditions.join(' && ')
      end
      
      # Build follow-up generation prompt
      def build_followup_prompt(question)
        <<~PROMPT
          Based on the user's response to: "#{question.title}"
          
          Response: {{answer_data}}
          AI Analysis: {{ai_analysis}}
          
          Generate a contextual follow-up question that:
          1. Builds naturally on their response
          2. Gathers additional valuable information
          3. Feels conversational, not interrogative
          4. Is relevant to the form's purpose
          
          Return JSON format:
          {
            "question": "The follow-up question text",
            "question_type": "text_short|text_long|multiple_choice|rating",
            "reasoning": "Why this follow-up is valuable",
            "configuration": {}
          }
        PROMPT
      end
      
      # Build UI update step
      def build_ui_update_step(question)
        {
          type: 'stream',
          name: "update_ui_q#{question.position}",
          inputs: ["save_response_q#{question.position}"],
          target: "form_#{@form.share_token}",
          turbo_action: 'replace',
          partial: 'responses/question_response',
          locals_code: <<~RUBY.strip
            save_result = context.get("save_response_q#{question.position}")
            {
              question_response: save_result[:question_response],
              form_response: save_result[:form_response]
            }
          RUBY
        }
      end
      
      # Build completion step
      def build_completion_step
        {
          type: 'task',
          name: 'complete_form_response',
          inputs: build_completion_inputs,
          process_code: <<~RUBY.strip
            form_response = context.get(:validate_form_data)[:form_response]
            
            # Check if all required questions are answered
            required_questions = @form.form_questions.where(required: true)
            answered_questions = form_response.question_responses.joins(:form_question)
                                            .where(form_questions: { required: true })
            
            if required_questions.count == answered_questions.count
              # Mark form as completed
              form_response.update!(
                status: 'completed',
                completed_at: Time.current,
                completion_data: {
                  total_time: Time.current - form_response.started_at,
                  questions_answered: form_response.question_responses.count,
                  ai_enhanced_responses: form_response.question_responses.where.not(ai_analysis: nil).count
                }
              )
              
              # Trigger integrations
              Forms::IntegrationTriggerJob.perform_async(form_response.id)
              
              {
                success: true,
                completed: true,
                form_response: form_response
              }
            else
              {
                success: true,
                completed: false,
                missing_required: required_questions.count - answered_questions.count
              }
            end
          RUBY
        }
      end
      
      # Build inputs for completion step
      def build_completion_inputs
        inputs = ['validate_form_data']
        
        # Add all save response steps as inputs
        @form.form_questions.each do |question|
          inputs << "save_response_q#{question.position}"
        end
        
        inputs
      end
      
      # Build helper methods for the workflow
      def build_helper_methods
        <<~RUBY.strip
          def calculate_quality_score(quality_indicators)
            return 0.0 unless quality_indicators.is_a?(Hash)
            
            scores = quality_indicators.values.map(&:to_f)
            return 0.0 if scores.empty?
            
            scores.sum / scores.length
          end
          
          def should_generate_followup?(ai_analysis, question)
            return false unless ai_analysis.is_a?(Hash)
            
            # Generate follow-up if AI suggests it and confidence is high
            ai_analysis['suggested_followup'].present? && 
            ai_analysis['confidence_score'].to_f > 0.7
          end
          
          def track_workflow_metrics(step_name, duration, success)
            Rails.logger.info "Workflow step #{step_name}: #{success ? 'SUCCESS' : 'FAILURE'} in #{duration}ms"
            
            # Track metrics if monitoring is available
            if defined?(StatsD)
              StatsD.timing("workflow.step.duration", duration, tags: ["step:#{step_name}"])
              StatsD.increment("workflow.step.#{success ? 'success' : 'failure'}", tags: ["step:#{step_name}"])
            end
          end
        RUBY
      end
    end
  end
end
</file>

<file path="services/google_sheets/base_service.rb">
# frozen_string_literal: true

module GoogleSheets
  class BaseService
    include ServiceObject
    
    private
    
    def google_client(integration)
      @google_client ||= begin
        client = Google::Apis::SheetsV4::SheetsService.new
        client.authorization = build_authorization(integration)
        client
      end
    end
    
    def build_authorization(integration)
      # Verificar y refrescar token si es necesario
      integration.refresh_token! if integration.needs_refresh?
      
      auth = Signet::OAuth2::Client.new(
        access_token: integration.access_token,
        refresh_token: integration.refresh_token,
        client_id: GoogleSheets::ConfigService.oauth_client_id,
        client_secret: GoogleSheets::ConfigService.oauth_client_secret
      )
      
      auth
    end
    
    def with_rate_limiting(&block)
      rate_limiter = RateLimiter.new("google_sheets:#{@user.id}")
      rate_limiter.execute(&block)
    end
    
    def handle_google_api_error(error)
      case error
      when Google::Apis::AuthorizationError
        @integration&.update!(active: false)
        ServiceResult.failure("Google authorization expired. Please reconnect your account.")
      when Google::Apis::RateLimitError
        ServiceResult.failure("Rate limit exceeded. Please try again later.")
      when Google::Apis::ClientError
        ServiceResult.failure("Google API error: #{error.message}")
      else
        ServiceResult.failure("Unexpected error: #{error.message}")
      end
    end
  end
end
</file>

<file path="services/google_sheets/config_service.rb">
# frozen_string_literal: true

module GoogleSheets
  class ConfigService
    class << self
      # Get Google OAuth client credentials
      def oauth_client_id
        if Rails.env.production?
          ENV['GOOGLE_SHEETS_CLIENT_ID']
        else
          Rails.application.credentials.dig(:google_sheets_integration, :client_id)
        end
      end

      def oauth_client_secret
        if Rails.env.production?
          ENV['GOOGLE_SHEETS_CLIENT_SECRET']
        else
          Rails.application.credentials.dig(:google_sheets_integration, :client_secret)
        end
      end

      # Check if OAuth credentials are configured
      def oauth_configured?
        oauth_client_id.present? && oauth_client_secret.present?
      end

      # Get service account credentials (for API access)
      def service_account_credentials
        if Rails.env.production?
          # In production, we might use service account JSON from env var
          service_account_json = ENV['GOOGLE_SHEETS_SERVICE_ACCOUNT_JSON']
          if service_account_json.present?
            JSON.parse(service_account_json)
          else
            nil
          end
        else
          # In development, use Rails credentials
          Rails.application.credentials.google_sheets
        end
      end

      # Check if service account is configured
      def service_account_configured?
        if Rails.env.production?
          ENV['GOOGLE_SHEETS_SERVICE_ACCOUNT_JSON'].present?
        else
          Rails.application.credentials.google_sheets.present?
        end
      end

      # Get configuration summary for debugging
      def configuration_summary
        {
          environment: Rails.env,
          oauth_configured: oauth_configured?,
          service_account_configured: service_account_configured?,
          oauth_client_id_present: oauth_client_id.present?,
          oauth_client_secret_present: oauth_client_secret.present?,
          production_env_vars: Rails.env.production? ? {
            google_sheets_client_id: ENV['GOOGLE_SHEETS_CLIENT_ID'].present?,
            google_sheets_client_secret: ENV['GOOGLE_SHEETS_CLIENT_SECRET'].present?,
            google_sheets_service_account_json: ENV['GOOGLE_SHEETS_SERVICE_ACCOUNT_JSON'].present?
          } : nil
        }
      end

      # Log configuration status
      def log_configuration_status
        summary = configuration_summary
        
        Rails.logger.info "Google Sheets Configuration Summary:"
        Rails.logger.info "  Environment: #{summary[:environment]}"
        Rails.logger.info "  OAuth configured: #{summary[:oauth_configured]}"
        Rails.logger.info "  Service Account configured: #{summary[:service_account_configured]}"
        
        if Rails.env.production? && summary[:production_env_vars]
          Rails.logger.info "  Production Environment Variables:"
          summary[:production_env_vars].each do |key, present|
            status = present ? "" : ""
            Rails.logger.info "    #{key.to_s.upcase}: #{status}"
          end
        end

        unless summary[:oauth_configured]
          Rails.logger.warn "Google Sheets OAuth not configured - integration features will be disabled"
        end

        unless summary[:service_account_configured]
          Rails.logger.warn "Google Sheets Service Account not configured - API features may be limited"
        end
      end
    end
  end
end
</file>

<file path="services/google_sheets/connection_test_service.rb">
# frozen_string_literal: true

module GoogleSheets
  class ConnectionTestService < BaseService
    def initialize(integration:)
      @integration = integration
      @user = integration.user
    end
    
    def call
      with_rate_limiting do
        # Intentar hacer una llamada simple a la API para verificar la conexin
        test_api_connection
        
        ServiceResult.success(
          user_info: @integration.user_info,
          last_used: @integration.last_used_at,
          usage_count: @integration.usage_count
        )
      end
    rescue Google::Apis::Error => e
      @integration.log_error(e)
      handle_google_api_error(e)
    rescue StandardError => e
      Rails.logger.error "Connection test failed: #{e.message}"
      ServiceResult.failure(e.message)
    end
    
    private
    
    def test_api_connection
      # Crear una hoja de clculo de prueba muy simple
      spreadsheet_body = Google::Apis::SheetsV4::Spreadsheet.new(
        properties: Google::Apis::SheetsV4::SpreadsheetProperties.new(
          title: "AgentForm Connection Test - #{Time.current.strftime('%Y-%m-%d %H:%M:%S')}"
        )
      )
      
      # Crear la hoja de clculo
      spreadsheet = google_client(@integration).create_spreadsheet(spreadsheet_body)
      
      # Inmediatamente eliminarla (usando Drive API si est disponible)
      begin
        drive_service = Google::Apis::DriveV3::DriveService.new
        drive_service.authorization = build_authorization(@integration)
        drive_service.delete_file(spreadsheet.spreadsheet_id)
      rescue StandardError => e
        Rails.logger.warn "Could not delete test spreadsheet: #{e.message}"
        # No es crtico si no podemos eliminar la hoja de prueba
      end
      
      # Registrar el uso exitoso
      @integration.record_usage!
    end
  end
end
</file>

<file path="services/google_sheets/export_service.rb">
# frozen_string_literal: true

module GoogleSheets
  class ExportService < BaseService
    def initialize(user:, form:, options: {})
      @user = user
      @form = form
      @options = default_options.merge(options)
      @integration = user.google_integration
      @export_job = nil
    end
    
    def call
      return ServiceResult.failure("User is not premium") unless @user.premium?
      return ServiceResult.failure("Google integration not found") unless @integration
      return ServiceResult.failure("Google integration not active") unless @integration.active?
      
      create_export_job
      GoogleSheetsExportJob.perform_async(@export_job.id)
      
      ServiceResult.success(export_job: @export_job)
    rescue StandardError => e
      Rails.logger.error "Google Sheets export failed: #{e.message}"
      @export_job&.update!(status: :failed, error_details: { message: e.message })
      ServiceResult.failure(e.message)
    end
    
    private
    
    def create_export_job
      @export_job = ExportJob.create!(
        user: @user,
        form: @form,
        job_id: SecureRandom.uuid,
        export_type: 'google_sheets',
        configuration: @options,
        status: :pending
      )
    end
    
    def default_options
      {
        include_metadata: true,
        include_timestamps: true,
        include_dynamic_questions: true,
        date_format: '%Y-%m-%d %H:%M:%S',
        empty_value: '',
        max_rows_per_batch: 1000
      }
    end
  end
end
</file>

<file path="services/google_sheets/rate_limiter.rb">
# frozen_string_literal: true

module GoogleSheets
  class RateLimiter
    def initialize(key)
      @key = key
      @redis = Redis.current
    end
    
    def execute(&block)
      if within_limits?
        increment_counter
        yield
      else
        raise Google::Apis::RateLimitError.new("Rate limit exceeded for #{@key}")
      end
    rescue Redis::CannotConnectError, Redis::ConnectionError, Redis::TimeoutError => e
      # Log Redis error but allow operation to continue
      RedisErrorLogger.log_connection_error(e, {
        component: 'google_sheets_rate_limiter',
        operation: 'rate_limit_check',
        rate_limit_key: @key
      })
      
      # When Redis is unavailable, allow the operation to proceed
      # This ensures Google Sheets integration doesn't fail due to Redis issues
      Rails.logger.warn "Rate limiting disabled due to Redis connectivity issues for key: #{@key}"
      yield
    end
    
    private
    
    def within_limits?
      current_count < max_requests_per_minute
    rescue Redis::CannotConnectError, Redis::ConnectionError, Redis::TimeoutError => e
      RedisErrorLogger.log_connection_error(e, {
        component: 'google_sheets_rate_limiter',
        operation: 'within_limits_check',
        rate_limit_key: @key
      })
      
      # When Redis is unavailable, assume we're within limits to avoid blocking operations
      true
    end
    
    def current_count
      @redis.get("rate_limit:#{@key}:#{current_minute}").to_i
    rescue Redis::CannotConnectError, Redis::ConnectionError, Redis::TimeoutError => e
      RedisErrorLogger.log_connection_error(e, {
        component: 'google_sheets_rate_limiter',
        operation: 'current_count_check',
        rate_limit_key: @key
      })
      
      # Return 0 when Redis is unavailable
      0
    end
    
    def increment_counter
      key = "rate_limit:#{@key}:#{current_minute}"
      @redis.multi do |multi|
        multi.incr(key)
        multi.expire(key, 60)
      end
    rescue Redis::CannotConnectError, Redis::ConnectionError, Redis::TimeoutError => e
      RedisErrorLogger.log_connection_error(e, {
        component: 'google_sheets_rate_limiter',
        operation: 'increment_counter',
        rate_limit_key: @key,
        cache_key: key
      })
      
      # Don't raise error, just log it - rate limiting will be disabled
    end
    
    def current_minute
      Time.current.strftime('%Y%m%d%H%M')
    end
    
    def max_requests_per_minute
      # Use environment variable in production, fallback to credentials in development
      if Rails.env.production?
        ENV['GOOGLE_SHEETS_RATE_LIMIT_PER_MINUTE']&.to_i || 60
      else
        Rails.application.credentials.dig(:google_sheets_integration, :rate_limits, :requests_per_minute) || 60
      end
    end
  end
end
</file>

<file path="services/google_sheets/spreadsheet_creator_service.rb">
# frozen_string_literal: true

module GoogleSheets
  class SpreadsheetCreatorService < BaseService
    def initialize(integration:, form:, responses:, options: {})
      @integration = integration
      @form = form
      @responses = responses
      @options = options
      @user = integration.user
    end
    
    def call
      with_rate_limiting do
        spreadsheet = create_spreadsheet
        populate_data(spreadsheet.spreadsheet_id)
        format_spreadsheet(spreadsheet.spreadsheet_id)
        
        ServiceResult.success(
          spreadsheet_id: spreadsheet.spreadsheet_id,
          spreadsheet_url: spreadsheet.spreadsheet_url
        )
      end
    rescue Google::Apis::Error => e
      @integration.log_error(e)
      handle_google_api_error(e)
    rescue StandardError => e
      Rails.logger.error "Spreadsheet creation failed: #{e.message}"
      ServiceResult.failure(e.message)
    end
    
    private
    
    def create_spreadsheet
      spreadsheet_body = Google::Apis::SheetsV4::Spreadsheet.new(
        properties: Google::Apis::SheetsV4::SpreadsheetProperties.new(
          title: generate_spreadsheet_title,
          locale: 'en_US',
          time_zone: @user.time_zone || 'UTC'
        ),
        sheets: [create_main_sheet]
      )
      
      google_client(@integration).create_spreadsheet(spreadsheet_body)
    end
    
    def create_main_sheet
      Google::Apis::SheetsV4::Sheet.new(
        properties: Google::Apis::SheetsV4::SheetProperties.new(
          title: 'Form Responses',
          grid_properties: Google::Apis::SheetsV4::GridProperties.new(
            frozen_row_count: 1,
            frozen_column_count: 1
          )
        )
      )
    end
    
    def populate_data(spreadsheet_id)
      Rails.logger.info "Starting populate_data for form #{@form.id}"
      
      # Preparar headers
      headers = build_headers
      Rails.logger.info "Headers: #{headers.inspect}"
      
      # Escribir headers primero
      update_spreadsheet_batch(spreadsheet_id, [headers])
      Rails.logger.info "Headers written to spreadsheet"
      
      # Contar respuestas totales
      total_responses = @responses.count
      Rails.logger.info "Total responses to export: #{total_responses}"
      
      # Preparar filas de datos en lotes
      all_rows = []
      @responses.find_in_batches(batch_size: @options[:max_rows_per_batch]) do |batch|
        Rails.logger.info "Processing batch of #{batch.size} responses"
        batch.each do |response|
          all_rows << build_response_row(response)
        end
      end
      
      Rails.logger.info "Total rows prepared: #{all_rows.size}"
      
      # Escribir todas las filas de datos si hay respuestas
      if all_rows.any?
        Rails.logger.info "Writing #{all_rows.size} rows to spreadsheet"
        # Append data starting from row 2 (after headers)
        range = "Form Responses!A2:Z"
        value_range = Google::Apis::SheetsV4::ValueRange.new(values: all_rows)
        
        google_client(@integration).update_spreadsheet_values(
          spreadsheet_id,
          range,
          value_range,
          value_input_option: 'USER_ENTERED'
        )
        Rails.logger.info "Data successfully written to spreadsheet"
      else
        Rails.logger.warn "No rows to write to spreadsheet"
      end
    end
    
    def build_headers
      headers = ['Response ID', 'Submitted At', 'Status', 'IP Address']
      
      # Agregar headers de preguntas del formulario
      @form.form_questions.order(:position).each do |question|
        headers << question.title
      end
      
      # Agregar headers de preguntas dinmicas si est habilitado
      if @options[:include_dynamic_questions]
        headers += ['Dynamic Questions Count', 'Dynamic Responses']
      end
      
      headers
    end
    
    def build_response_row(response)
      Rails.logger.info "Building row for response #{response.id}"
      
      row = [
        response.id,
        response.completed_at&.strftime(@options[:date_format]) || 'In Progress',
        response.status.humanize,
        response.ip_address
      ]
      
      Rails.logger.info "Base row data: #{row.inspect}"
      
      # Agregar respuestas de preguntas del formulario
      @form.form_questions.order(:position).each do |question|
        answer = response.question_responses.find_by(form_question: question)
        answer_value = format_answer_value(answer&.answer_text)
        Rails.logger.info "Question '#{question.title}': answer = #{answer_value.inspect}"
        row << answer_value
      end
      
      # Agregar preguntas dinmicas si est habilitado
      if @options[:include_dynamic_questions]
        dynamic_count = response.dynamic_questions&.count || 0
        dynamic_responses = response.dynamic_questions&.map do |dq|
          "#{dq.title}: #{dq.answer_data}"
        end&.join(' | ') || ''
        
        row += [dynamic_count, dynamic_responses]
        Rails.logger.info "Added dynamic questions: count=#{dynamic_count}, responses=#{dynamic_responses}"
      end
      
      Rails.logger.info "Final row: #{row.inspect}"
      row
    end
    
    def format_answer_value(value)
      return @options[:empty_value] if value.blank?
      
      # Escapar valores que podran causar problemas en hojas de clculo
      value.to_s.gsub(/[\r\n]+/, ' ').strip
    end
    
    def update_spreadsheet_batch(spreadsheet_id, rows, range = "Form Responses!A1:Z")
      value_range = Google::Apis::SheetsV4::ValueRange.new(values: rows)
      
      google_client(@integration).update_spreadsheet_values(
        spreadsheet_id,
        range,
        value_range,
        value_input_option: 'USER_ENTERED'
      )
    end
    
    def format_spreadsheet(spreadsheet_id)
      requests = [
        create_header_format_request,
        create_autosize_request,
        create_freeze_request
      ]
      
      batch_update = Google::Apis::SheetsV4::BatchUpdateSpreadsheetRequest.new(
        requests: requests
      )
      
      google_client(@integration).batch_update_spreadsheet(spreadsheet_id, batch_update)
    end
    
    def create_header_format_request
      Google::Apis::SheetsV4::Request.new(
        repeat_cell: Google::Apis::SheetsV4::RepeatCellRequest.new(
          range: Google::Apis::SheetsV4::GridRange.new(
            sheet_id: 0,
            start_row_index: 0,
            end_row_index: 1
          ),
          cell: Google::Apis::SheetsV4::CellData.new(
            user_entered_format: Google::Apis::SheetsV4::CellFormat.new(
              background_color: Google::Apis::SheetsV4::Color.new(red: 0.9, green: 0.9, blue: 0.9),
              text_format: Google::Apis::SheetsV4::TextFormat.new(bold: true)
            )
          ),
          fields: 'userEnteredFormat(backgroundColor,textFormat)'
        )
      )
    end
    
    def create_autosize_request
      Google::Apis::SheetsV4::Request.new(
        auto_resize_dimensions: Google::Apis::SheetsV4::AutoResizeDimensionsRequest.new(
          dimensions: Google::Apis::SheetsV4::DimensionRange.new(
            sheet_id: 0,
            dimension: 'COLUMNS'
          )
        )
      )
    end
    
    def create_freeze_request
      Google::Apis::SheetsV4::Request.new(
        update_sheet_properties: Google::Apis::SheetsV4::UpdateSheetPropertiesRequest.new(
          properties: Google::Apis::SheetsV4::SheetProperties.new(
            sheet_id: 0,
            grid_properties: Google::Apis::SheetsV4::GridProperties.new(
              frozen_row_count: 1,
              frozen_column_count: 1
            )
          ),
          fields: 'gridProperties.frozenRowCount,gridProperties.frozenColumnCount'
        )
      )
    end
    
    def generate_spreadsheet_title
      timestamp = Time.current.strftime('%Y-%m-%d_%H-%M')
      "#{@form.name.truncate(50)} - Responses - #{timestamp}"
    end
  end
end
</file>

<file path="services/google_sheets/token_refresh_service.rb">
# frozen_string_literal: true

module GoogleSheets
  class TokenRefreshService < BaseService
    def initialize(integration:)
      @integration = integration
    end
    
    def call
      refresh_authorization_token
      ServiceResult.success(integration: @integration)
    rescue Google::Apis::AuthorizationError => e
      @integration.update!(active: false)
      @integration.log_error(e)
      ServiceResult.failure("Authorization expired. Please reconnect your Google account.")
    rescue StandardError => e
      @integration.log_error(e)
      ServiceResult.failure("Token refresh failed: #{e.message}")
    end
    
    private
    
    def refresh_authorization_token
      auth = Signet::OAuth2::Client.new(
        client_id: GoogleSheets::ConfigService.oauth_client_id,
        client_secret: GoogleSheets::ConfigService.oauth_client_secret,
        refresh_token: @integration.refresh_token
      )
      
      auth.refresh!
      
      @integration.update!(
        access_token: auth.access_token,
        token_expires_at: Time.current + auth.expires_in.seconds,
        last_used_at: Time.current
      )
      
      Rails.logger.info "Token refreshed for user #{@integration.user_id}"
    end
  end
end
</file>

<file path="services/integrations/google_sheets_service.rb">
require 'google/apis/sheets_v4'
require 'googleauth'

class Integrations::GoogleSheetsService < ApplicationService
  # Simple Result classes for this service
  class Result
    attr_reader :value, :error
    
    def initialize(value: nil, error: nil)
      @value = value
      @error = error
    end
    
    def success?
      @error.nil?
    end
    
    def failure?
      !success?
    end
  end
  
  def self.success(value)
    Result.new(value: value)
  end
  
  def self.failure(error)
    Result.new(error: error)
  end
  def initialize(form, integration = nil)
    @form = form
    @integration = integration || form.google_sheets_integration
    @service = Google::Apis::SheetsV4::SheetsService.new
    @service.authorization = authorize_service
  end

  def create_spreadsheet(title = nil)
    title ||= "#{@form.name} - Responses"
    
    spreadsheet = {
      properties: {
        title: title
      },
      sheets: [{
        properties: {
          title: 'Responses'
        }
      }]
    }

    result = @service.create_spreadsheet(spreadsheet)
    
    # Create headers
    setup_headers(result.spreadsheet_id)
    
    self.class.success({
      spreadsheet_id: result.spreadsheet_id,
      spreadsheet_url: "https://docs.google.com/spreadsheets/d/#{result.spreadsheet_id}/edit"
    })
  rescue => e
    self.class.failure("Error creating spreadsheet: #{e.message}")
  end

  def export_all_responses
    return self.class.failure("No integration configured") unless @integration&.can_sync?

    begin
      Rails.logger.info "Starting export for form #{@form.id} (#{@form.name})"
      
      # Validate form has questions
      if @form.form_questions.empty?
        return self.class.failure("Form has no questions to export")
      end
      
      # Load responses with proper associations
      responses = load_responses_for_export
      Rails.logger.info "Found #{responses.count} responses to export"
      
      # Validate responses have data
      responses_with_data = responses.select { |r| r.question_responses.any? }
      Rails.logger.info "#{responses_with_data.count} responses have answer data"
      
      if responses_with_data.empty?
        Rails.logger.warn "No responses with data found"
        return self.class.success("No responses with data to export")
      end
      
      # Clear and rebuild data
      clear_data_rows
      rows = build_response_rows(responses_with_data)
      
      Rails.logger.info "Built #{rows.size} data rows"
      rows.each_with_index do |row, index|
        Rails.logger.debug "Row #{index + 1}: #{row.inspect}"
      end
      
      append_rows(rows) if rows.any?
      
      @integration.mark_sync_success!
      self.class.success("Exported #{responses_with_data.count} responses successfully")
      
    rescue => e
      Rails.logger.error "Export failed: #{e.message}"
      Rails.logger.error e.backtrace.join("\n")
      @integration.mark_sync_error!(e)
      self.class.failure("Export failed: #{e.message}")
    end
  end

  def sync_new_response(response)
    return unless @integration&.can_sync? && @integration.auto_sync?

    begin
      # Validate response has data and is in exportable status
      unless ['completed', 'partial'].include?(response.status)
        Rails.logger.info "Skipping sync for response #{response.id} with status: #{response.status}"
        return self.class.success("Response not in exportable status")
      end
      
      unless response.question_responses.any?
        Rails.logger.info "Skipping sync for response #{response.id} - no answer data"
        return self.class.success("Response has no answer data")
      end
      
      # Ensure response is loaded with proper associations
      response = @form.form_responses
                      .includes(question_responses: :form_question)
                      .find(response.id)
      
      row = build_response_row(response)
      append_rows([row])
      
      self.class.success("Response synced successfully")
    rescue => e
      Rails.logger.error "Google Sheets sync failed for response #{response.id}: #{e.message}"
      self.class.failure("Sync failed: #{e.message}")
    end
  end

  private

  def load_responses_for_export
    @form.form_responses
      .includes(question_responses: :form_question)
      .where(status: ['completed', 'partial'])
      .order(created_at: :desc)
  end

  def authorize_service
    # Use user's OAuth token if available, fallback to service account
    user_integration = @form.user.google_integration
    
    if user_integration&.valid_token?
      # Use user's OAuth2 credentials
      Signet::OAuth2::Client.new(
        access_token: user_integration.access_token,
        refresh_token: user_integration.refresh_token,
        client_id: GoogleSheets::ConfigService.oauth_client_id,
        client_secret: GoogleSheets::ConfigService.oauth_client_secret,
        token_credential_uri: 'https://oauth2.googleapis.com/token'
      )
    else
      # Fallback to service account (for system operations)
      if Rails.application.credentials.google_sheets.present?
        credentials = Google::Auth::ServiceAccountCredentials.make_creds(
          json_key_io: StringIO.new(Rails.application.credentials.google_sheets.to_json),
          scope: Google::Apis::SheetsV4::AUTH_SPREADSHEETS
        )
        credentials.fetch_access_token!
        credentials
      else
        raise "No Google authentication available. User must connect their Google account first."
      end
    end
  end

  def setup_headers(spreadsheet_id)
    headers = build_headers
    
    range = "#{@integration&.sheet_name || 'Responses'}!A1"
    value_range = Google::Apis::SheetsV4::ValueRange.new(
      values: [headers]
    )

    @service.update_spreadsheet_value(
      spreadsheet_id,
      range,
      value_range,
      value_input_option: 'RAW'
    )
  end

  def build_headers
    headers = ['Submitted At', 'Response ID']
    
    @form.form_questions.order(:position).each do |question|
      headers << question.title
    end
    
    headers
  end

  def build_response_rows(responses)
    responses.map { |response| build_response_row(response) }
  end

  def build_response_row(response)
    Rails.logger.info "Building row for response #{response.id} (status: #{response.status})"
    
    row = [
      response.created_at.strftime('%Y-%m-%d %H:%M:%S'),
      response.id
    ]

    @form.form_questions.order(:position).each do |question|
      answer = response.question_responses.find_by(form_question_id: question.id)
      Rails.logger.info "Question '#{question.title}' (ID: #{question.id}): found answer = #{answer.present?}"
      
      if answer.present?
        Rails.logger.info "Answer data: #{answer.answer_data.inspect}"
        Rails.logger.info "Answer text: #{answer.answer_text.inspect}"
      end
      
      formatted_value = format_answer_value(answer, question)
      Rails.logger.info "Question '#{question.title}': formatted value = #{formatted_value.inspect}"
      row << formatted_value
    end

    Rails.logger.info "Final row: #{row.inspect}"
    row
  end

  def format_answer_value(answer, question)
    Rails.logger.debug "Formatting answer for question #{question.id}: #{answer.inspect}"
    
    return '' unless answer.present?

    # Use the formatted_answer method from QuestionResponse model
    formatted_value = answer.formatted_answer
    Rails.logger.debug "Formatted answer: #{formatted_value.inspect}"
    
    return '' if formatted_value.blank?
    
    formatted_value.to_s
  end

  def clear_data_rows
    # Get current data to determine range
    range = "#{@integration.sheet_name}!A2:ZZ"
    
    begin
      @service.clear_values(
        @integration.spreadsheet_id,
        range
      )
    rescue Google::Apis::ClientError => e
      # Sheet might not exist or be empty, that's ok
      Rails.logger.warn "Could not clear sheet data: #{e.message}"
    end
  end

  def append_rows(rows)
    return if rows.empty?

    range = "#{@integration.sheet_name}!A:A"
    value_range = Google::Apis::SheetsV4::ValueRange.new(
      values: rows
    )

    @service.append_spreadsheet_value(
      @integration.spreadsheet_id,
      range,
      value_range,
      value_input_option: 'RAW'
    )
  end
end
</file>

<file path="services/stripe/checkout_completed_service.rb">
# frozen_string_literal: true

module Stripe
  class CheckoutCompletedService
    def initialize(event)
      @event = event
    end

    def call
      session = @event.data.object
      user_id = session.metadata.user_id

      user = User.find_by(id: user_id)

      unless user
        Rails.logger.error "Stripe Webhook: User not found with ID #{user_id}"
        return
      end

      # Process discount usage if discount was applied
      process_discount_usage(session, user) if discount_applied?(session)

      # Update user to premium with active subscription (no trial in Stripe)
      user.update!(
        subscription_tier: 'premium',
        stripe_customer_id: session.customer,
        subscription_status: 'active'
      )

      # Confirm user so they can log in (if using Devise confirmable)
      user.confirm if user.respond_to?(:confirm)
      
      # Send premium welcome email
      UserMailer.premium_welcome(user).deliver_later

      Rails.logger.info "Stripe Webhook: User #{user.email} successfully upgraded to premium."
    end

    private

    def discount_applied?(session)
      session.metadata.discount_code.present?
    end

    def process_discount_usage(session, user)
      discount_code = DiscountCode.find_by(code: session.metadata.discount_code)
      
      unless discount_code
        Rails.logger.error "Stripe Webhook: Discount code '#{session.metadata.discount_code}' not found"
        return
      end

      # Prepare subscription details for usage recording
      subscription_details = {
        subscription_id: session.subscription,
        original_amount: session.metadata.original_amount.to_i,
        discount_amount: session.metadata.discount_amount.to_i,
        final_amount: session.metadata.final_amount.to_i
      }

      # Record discount usage
      discount_service = DiscountCodeService.new(user: user)
      discount_service.record_usage(discount_code, subscription_details)

      if discount_service.success?
        Rails.logger.info "Stripe Webhook: Discount usage recorded for user #{user.email} with code #{discount_code.code}"
      else
        Rails.logger.error "Stripe Webhook: Failed to record discount usage: #{discount_service.errors.full_messages.join(', ')}"
      end
    rescue StandardError => e
      Rails.logger.error "Stripe Webhook: Error processing discount usage: #{e.message}"
      Rails.logger.error e.backtrace.join("\n")
    end
  end
end
</file>

<file path="services/stripe/invoice_payment_failed_service.rb">
module Stripe
  class InvoicePaymentFailedService
    def initialize(event)
      @event = event
    end

    def call
      invoice = @event.data.object
      customer_id = invoice.customer
      
      user = User.find_by(stripe_customer_id: customer_id)
      unless user
        Rails.logger.error "Stripe Webhook: User not found with customer ID #{customer_id}"
        return
      end

      # Update subscription status to indicate payment issues
      user.update!(
        subscription_status: 'past_due'
      )

      # Log the failed payment
      Rails.logger.warn "Stripe Webhook: Payment failed for user #{user.email}, invoice #{invoice.id}"

      # Send payment failure notification email (optional)
      # UserMailer.payment_failed(user, invoice).deliver_later

      # If this is the final attempt, downgrade the user
      if invoice.attempt_count >= 3
        user.update!(
          subscription_status: 'canceled',
          subscription_tier: 'basic',
          subscription_expires_at: Time.current
        )
        
        Rails.logger.warn "Stripe Webhook: User #{user.email} downgraded due to failed payments"
        # UserMailer.subscription_canceled_due_to_payment_failure(user).deliver_later
      end

    rescue StandardError => e
      Rails.logger.error "Error processing invoice payment failed: #{e.message}"
    end
  end
end
</file>

<file path="services/stripe/invoice_payment_succeeded_service.rb">
module Stripe
  class InvoicePaymentSucceededService
    def initialize(event)
      @event = event
    end

    def call
      invoice = @event.data.object
      customer_id = invoice.customer
      subscription_id = invoice.subscription

      user = User.find_by(stripe_customer_id: customer_id)
      unless user
        Rails.logger.error "Stripe Webhook: User not found with customer ID #{customer_id}"
        return
      end

      # Get subscription details from Stripe
      subscription = ::Stripe::Subscription.retrieve(subscription_id)
      
      # Update user subscription status
      user.update!(
        subscription_status: 'active',
        subscription_tier: 'premium',
        subscription_expires_at: Time.at(subscription.current_period_end)
      )

      # Log successful renewal
      Rails.logger.info "Stripe Webhook: Subscription renewed for user #{user.email}"

      # Send renewal confirmation email (optional)
      # UserMailer.subscription_renewed(user).deliver_later

    rescue ::Stripe::StripeError => e
      Rails.logger.error "Stripe API error in invoice payment succeeded: #{e.message}"
    rescue StandardError => e
      Rails.logger.error "Error processing invoice payment succeeded: #{e.message}"
    end
  end
end
</file>

<file path="services/stripe/setup_intent_succeeded_service.rb">
module Stripe
  class SetupIntentSucceededService
    def initialize(event)
      @event = event
    end

    def call
      setup_intent = @event.data.object
      customer_id = setup_intent.customer
      
      user = User.find_by(stripe_customer_id: customer_id)
      unless user
        Rails.logger.error "Stripe Webhook: User not found with customer ID #{customer_id}"
        return
      end

      Rails.logger.info "Stripe Webhook: Payment method updated for user #{user.email}"

      # Send payment method update confirmation email (optional)
      # UserMailer.payment_method_updated(user).deliver_later

    rescue StandardError => e
      Rails.logger.error "Error processing setup intent succeeded: #{e.message}"
    end
  end
end
</file>

<file path="services/stripe/subscription_deleted_service.rb">
module Stripe
  class SubscriptionDeletedService
    def initialize(event)
      @event = event
    end

    def call
      subscription = @event.data.object
      customer_id = subscription.customer
      
      user = User.find_by(stripe_customer_id: customer_id)
      unless user
        Rails.logger.error "Stripe Webhook: User not found with customer ID #{customer_id}"
        return
      end

      # Update user to reflect canceled subscription
      user.update!(
        subscription_status: 'canceled',
        subscription_tier: 'basic',
        subscription_expires_at: Time.current
      )

      Rails.logger.info "Stripe Webhook: Subscription canceled for user #{user.email}"

      # Send cancellation confirmation email (optional)
      # UserMailer.subscription_canceled(user).deliver_later

    rescue StandardError => e
      Rails.logger.error "Error processing subscription deletion: #{e.message}"
    end
  end
end
</file>

<file path="services/stripe/subscription_updated_service.rb">
module Stripe
  class SubscriptionUpdatedService
    def initialize(event)
      @event = event
    end

    def call
      subscription = @event.data.object
      customer_id = subscription.customer
      
      user = User.find_by(stripe_customer_id: customer_id)
      unless user
        Rails.logger.error "Stripe Webhook: User not found with customer ID #{customer_id}"
        return
      end

      # Determine the appropriate status based on subscription state
      status = determine_subscription_status(subscription)
      
      # Update user subscription details
      user.update!(
        subscription_status: status,
        subscription_expires_at: subscription.cancel_at_period_end ? 
          Time.at(subscription.current_period_end) : nil
      )

      # Log the update
      Rails.logger.info "Stripe Webhook: Subscription updated for user #{user.email}, status: #{status}"

      # Send appropriate notification based on the change
      if subscription.cancel_at_period_end && status == 'canceling'
        # UserMailer.subscription_will_cancel(user, Time.at(subscription.current_period_end)).deliver_later
      elsif !subscription.cancel_at_period_end && user.subscription_status_was == 'canceling'
        # UserMailer.subscription_reactivated(user).deliver_later
      end

    rescue StandardError => e
      Rails.logger.error "Error processing subscription update: #{e.message}"
    end

    private

    def determine_subscription_status(subscription)
      case subscription.status
      when 'active'
        subscription.cancel_at_period_end ? 'canceling' : 'active'
      when 'trialing'
        'trialing'
      when 'past_due'
        'past_due'
      when 'canceled'
        'canceled'
      when 'unpaid'
        'past_due'
      else
        subscription.status
      end
    end
  end
end
</file>

<file path="services/admin_cache_service.rb">
# frozen_string_literal: true

# Service for managing admin dashboard caching
class AdminCacheService < ApplicationService
  # Cache expiration times
  DASHBOARD_STATS_TTL = 5.minutes
  USER_STATS_TTL = 10.minutes
  DISCOUNT_STATS_TTL = 10.minutes
  ANALYTICS_TTL = 15.minutes

  class << self
    # Get or set dashboard statistics with caching
    def dashboard_stats
      Rails.cache.fetch('admin_dashboard_stats', expires_in: DASHBOARD_STATS_TTL) do
        calculate_dashboard_stats
      end
    end

    # Get or set user statistics with caching
    def user_statistics
      Rails.cache.fetch('admin_user_statistics', expires_in: USER_STATS_TTL) do
        calculate_user_statistics
      end
    end

    # Get or set discount code statistics with caching
    def discount_code_statistics
      Rails.cache.fetch('admin_discount_statistics', expires_in: DISCOUNT_STATS_TTL) do
        calculate_discount_statistics
      end
    end

    # Get or set analytics data with caching
    def analytics_data(type)
      cache_key = "admin_analytics_#{type}"
      Rails.cache.fetch(cache_key, expires_in: ANALYTICS_TTL) do
        case type
        when 'top_discount_codes'
          DiscountCode.most_used(10)
        when 'highest_revenue_codes'
          DiscountCode.highest_revenue_impact(10)
        when 'recent_activity'
          calculate_recent_activity
        else
          {}
        end
      end
    end

    # Clear all admin caches
    def clear_all_caches
      cache_keys = [
        'admin_dashboard_stats',
        'admin_user_statistics',
        'admin_discount_statistics',
        'admin_analytics_top_discount_codes',
        'admin_analytics_highest_revenue_codes',
        'admin_analytics_recent_activity',
        'discount_codes_dashboard_stats',
        'admin_discount_analytics',
        'admin_top_discount_codes',
        'admin_highest_revenue_codes',
        'admin_dashboard_discount_stats'
      ]

      cleared_count = 0
      cache_keys.each do |key|
        if Rails.cache.delete(key)
          cleared_count += 1
        end
      end

      Rails.logger.info "Cleared #{cleared_count} admin cache entries"
      cleared_count
    end

    # Clear specific cache type
    def clear_cache(type)
      case type
      when 'dashboard'
        Rails.cache.delete('admin_dashboard_stats')
      when 'users'
        Rails.cache.delete('admin_user_statistics')
      when 'discount_codes'
        Rails.cache.delete('admin_discount_statistics')
        Rails.cache.delete('discount_codes_dashboard_stats')
      when 'analytics'
        Rails.cache.delete_matched('admin_analytics_*')
      end
    end

    # Warm up caches (useful for scheduled jobs)
    def warm_up_caches
      Rails.logger.info "Warming up admin caches"
      
      # Pre-load dashboard stats
      dashboard_stats
      user_statistics
      discount_code_statistics
      
      # Pre-load analytics
      analytics_data('top_discount_codes')
      analytics_data('highest_revenue_codes')
      analytics_data('recent_activity')
      
      Rails.logger.info "Admin caches warmed up successfully"
    end

    private

    def calculate_dashboard_stats
      {
        users: calculate_user_statistics,
        discount_codes: calculate_discount_statistics,
        system: calculate_system_statistics,
        generated_at: Time.current
      }
    end

    def calculate_user_statistics
      # Use optimized single query for user statistics
      one_month_ago = 1.month.ago.strftime('%Y-%m-%d %H:%M:%S')
      one_week_ago = 1.week.ago.strftime('%Y-%m-%d %H:%M:%S')
      
      stats = User.connection.select_one(<<~SQL)
        SELECT 
          COUNT(*) as total_users,
          COUNT(CASE WHEN suspended_at IS NULL THEN 1 END) as active_users,
          COUNT(CASE WHEN suspended_at IS NOT NULL THEN 1 END) as suspended_users,
          COUNT(CASE WHEN created_at >= '#{one_month_ago}' THEN 1 END) as new_users_this_month,
          COUNT(CASE WHEN created_at >= '#{one_week_ago}' THEN 1 END) as new_users_this_week,
          COUNT(CASE WHEN subscription_tier = 'premium' THEN 1 END) as premium_users,
          COUNT(CASE WHEN subscription_tier = 'basic' THEN 1 END) as basic_users,
          COUNT(CASE WHEN role IN ('admin', 'superadmin') THEN 1 END) as admin_users
        FROM users
      SQL

      total_users = stats['total_users'].to_i
      premium_users = stats['premium_users'].to_i

      {
        total: total_users,
        active: stats['active_users'].to_i,
        suspended: stats['suspended_users'].to_i,
        new_this_month: stats['new_users_this_month'].to_i,
        new_this_week: stats['new_users_this_week'].to_i,
        premium: premium_users,
        basic: stats['basic_users'].to_i,
        admin: stats['admin_users'].to_i,
        premium_percentage: total_users > 0 ? (premium_users.to_f / total_users * 100).round(1) : 0
      }
    end

    def calculate_discount_statistics
      # Optimized queries for discount code statistics
      code_stats = DiscountCode.connection.select_one(<<~SQL)
        SELECT 
          COUNT(*) as total_codes,
          COUNT(CASE WHEN active = true AND (expires_at IS NULL OR expires_at > NOW()) THEN 1 END) as active_codes,
          COUNT(CASE WHEN expires_at < NOW() THEN 1 END) as expired_codes,
          SUM(current_usage_count) as total_usage,
          AVG(discount_percentage) as avg_discount_percentage
        FROM discount_codes
      SQL

      usage_stats = DiscountCodeUsage.connection.select_one(<<~SQL)
        SELECT 
          SUM(discount_amount) as total_discount_amount,
          COUNT(*) as usage_count,
          AVG(discount_amount) as avg_discount_amount
        FROM discount_code_usages
      SQL

      total_usage = usage_stats['usage_count'].to_i
      total_discount_amount = usage_stats['total_discount_amount'].to_i

      {
        total_codes: code_stats['total_codes'].to_i,
        active_codes: code_stats['active_codes'].to_i,
        expired_codes: code_stats['expired_codes'].to_i,
        total_usage: total_usage,
        total_discount_amount: total_discount_amount,
        average_discount_percentage: code_stats['avg_discount_percentage'].to_f.round(1),
        average_discount_per_use: total_usage > 0 ? (total_discount_amount.to_f / total_usage).round(2) : 0
      }
    end

    def calculate_system_statistics
      {
        total_forms: Form.count,
        total_responses: FormResponse.count,
        total_payments: PaymentTransaction.where(status: 'succeeded').count,
        cache_hit_rate: calculate_cache_hit_rate
      }
    end

    def calculate_recent_activity
      activities = []

      # Recent user registrations (last 10)
      User.order(created_at: :desc).limit(10).find_each do |user|
        activities << {
          type: 'user_registration',
          message: "New user registered: #{user.email}",
          timestamp: user.created_at,
          icon: 'user-plus',
          color: 'text-green-600'
        }
      end

      # Recent discount code usage (last 10)
      DiscountCodeUsage.includes(:user, :discount_code)
                      .order(created_at: :desc)
                      .limit(10)
                      .find_each do |usage|
        activities << {
          type: 'discount_usage',
          message: "Discount code '#{usage.discount_code.code}' used by #{usage.user.email}",
          timestamp: usage.created_at,
          icon: 'tag',
          color: 'text-purple-600'
        }
      end

      # Recent user suspensions (last 5)
      User.where.not(suspended_at: nil)
          .order(suspended_at: :desc)
          .limit(5)
          .find_each do |user|
        activities << {
          type: 'user_suspension',
          message: "User suspended: #{user.email}",
          timestamp: user.suspended_at,
          icon: 'user-x',
          color: 'text-red-600'
        }
      end

      # Sort by timestamp and return most recent 15
      activities.sort_by { |activity| activity[:timestamp] }.reverse.first(15)
    end

    def calculate_cache_hit_rate
      # This would require Redis monitoring in a real implementation
      # For now, return a placeholder
      85.0
    end
  end
end
</file>

<file path="services/admin_monitoring_service.rb">
# frozen_string_literal: true

# Service for monitoring admin activities and security events
class AdminMonitoringService
  include ActiveModel::Model
  include ActiveModel::Attributes

  # Security thresholds
  SUSPICIOUS_ACTIVITY_THRESHOLD = 5 # Failed attempts per IP per hour
  ADMIN_SESSION_TIMEOUT = 2.hours
  MAX_ADMIN_ACTIONS_PER_HOUR = 100

  def initialize
    @alerts = []
  end

  # Check for suspicious activity and generate alerts
  def check_security_alerts
    check_suspicious_ips
    check_admin_activity_anomalies
    check_failed_login_patterns
    check_session_security
    
    @alerts
  end

  # Get security dashboard data
  def security_dashboard_data
    {
      security_alerts_today: AuditLog.security_alerts_today,
      failed_attempts_last_hour: failed_attempts_last_hour,
      top_suspicious_ips: AuditLog.top_suspicious_ips(5),
      admin_activity_summary: admin_activity_last_24h,
      recent_security_events: recent_security_events(10)
    }
  end

  # Monitor specific user's admin activity
  def monitor_user_activity(user_id, days = 7)
    return {} unless user_id

    {
      total_actions: AuditLog.admin_actions.for_user(user_id).where(created_at: days.days.ago..Time.current).count,
      activity_by_day: activity_by_day(user_id, days),
      most_common_actions: most_common_actions(user_id, days),
      security_events: AuditLog.security_events.for_user(user_id).where(created_at: days.days.ago..Time.current).count,
      last_activity: AuditLog.for_user(user_id).recent.first&.created_at
    }
  end

  # Check if IP should be blocked
  def should_block_ip?(ip_address)
    return false if ip_address.blank?
    
    suspicious_count = AuditLog.suspicious_activity_for_ip(ip_address, 1)
    suspicious_count >= SUSPICIOUS_ACTIVITY_THRESHOLD
  end

  # Generate security report
  def generate_security_report(start_date = 7.days.ago, end_date = Time.current)
    {
      period: "#{start_date.strftime('%Y-%m-%d')} to #{end_date.strftime('%Y-%m-%d')}",
      total_security_events: security_events_in_period(start_date, end_date),
      security_events_by_type: security_events_by_type(start_date, end_date),
      top_targeted_ips: top_targeted_ips(start_date, end_date),
      admin_activity_summary: admin_activity_in_period(start_date, end_date),
      recommendations: generate_security_recommendations
    }
  end

  private

  def check_suspicious_ips
    suspicious_ips = AuditLog.top_suspicious_ips(10)
    
    suspicious_ips.each do |ip, count|
      if count >= SUSPICIOUS_ACTIVITY_THRESHOLD
        @alerts << {
          type: 'suspicious_ip',
          severity: count >= 10 ? 'high' : 'medium',
          message: "IP #{ip} has #{count} failed security attempts in the last 24 hours",
          ip_address: ip,
          count: count,
          created_at: Time.current
        }
      end
    end
  end

  def check_admin_activity_anomalies
    # Check for unusual admin activity patterns
    recent_admin_actions = AuditLog.admin_actions.where(created_at: 1.hour.ago..Time.current)
    
    # Group by user and check for excessive activity
    activity_by_user = recent_admin_actions.group(:user_id).count
    
    activity_by_user.each do |user_id, count|
      if count >= MAX_ADMIN_ACTIONS_PER_HOUR
        user = User.find_by(id: user_id)
        @alerts << {
          type: 'excessive_admin_activity',
          severity: 'medium',
          message: "User #{user&.email || user_id} performed #{count} admin actions in the last hour",
          user_id: user_id,
          count: count,
          created_at: Time.current
        }
      end
    end
  end

  def check_failed_login_patterns
    # Check for patterns in failed login attempts
    failed_attempts = AuditLog.where(
      event_type: ['csrf_failure', 'unauthorized_admin_access'],
      created_at: 1.hour.ago..Time.current
    )
    
    # Group by IP to find coordinated attacks
    attempts_by_ip = failed_attempts.group(:ip_address).count
    
    attempts_by_ip.each do |ip, count|
      if count >= 10
        @alerts << {
          type: 'coordinated_attack',
          severity: 'high',
          message: "Potential coordinated attack from IP #{ip} with #{count} failed attempts",
          ip_address: ip,
          count: count,
          created_at: Time.current
        }
      end
    end
  end

  def check_session_security
    # Check for session-related security issues
    session_events = AuditLog.where(
      event_type: ['suspicious_admin_activity', 'admin_session_expired'],
      created_at: 24.hours.ago..Time.current
    )
    
    if session_events.count >= 5
      @alerts << {
        type: 'session_security_issues',
        severity: 'medium',
        message: "Multiple session security events detected (#{session_events.count} in last 24h)",
        count: session_events.count,
        created_at: Time.current
      }
    end
  end

  def failed_attempts_last_hour
    AuditLog.failed_attempts.where(created_at: 1.hour.ago..Time.current).count
  end

  def admin_activity_last_24h
    AuditLog.admin_actions.where(created_at: 24.hours.ago..Time.current).group(:user_id).count
  end

  def recent_security_events(limit = 10)
    AuditLog.security_events.recent.limit(limit).includes(:user).map do |event|
      {
        id: event.id,
        event_type: event.event_type,
        user_email: event.user&.email,
        ip_address: event.ip_address,
        details: event.details,
        created_at: event.created_at
      }
    end
  end

  def activity_by_day(user_id, days)
    # Simple grouping by date without external gem dependency
    logs = AuditLog.admin_actions
                   .for_user(user_id)
                   .where(created_at: days.days.ago..Time.current)
                   .pluck(:created_at)
    
    logs.group_by { |date| date.to_date }.transform_values(&:count)
  end

  def most_common_actions(user_id, days)
    AuditLog.admin_actions
           .for_user(user_id)
           .where(created_at: days.days.ago..Time.current)
           .joins("JOIN json_extract(details, '$.action') as action")
           .group("json_extract(details, '$.action')")
           .count
           .sort_by { |_, count| -count }
           .first(5)
  rescue
    # Fallback if JSON extraction doesn't work
    {}
  end

  def security_events_in_period(start_date, end_date)
    AuditLog.security_events.where(created_at: start_date..end_date).count
  end

  def security_events_by_type(start_date, end_date)
    AuditLog.security_events
           .where(created_at: start_date..end_date)
           .group(:event_type)
           .count
  end

  def top_targeted_ips(start_date, end_date)
    AuditLog.failed_attempts
           .where(created_at: start_date..end_date)
           .group(:ip_address)
           .count
           .sort_by { |_, count| -count }
           .first(10)
  end

  def admin_activity_in_period(start_date, end_date)
    AuditLog.admin_actions
           .where(created_at: start_date..end_date)
           .group(:user_id)
           .count
  end

  def generate_security_recommendations
    recommendations = []
    
    # Check for high-risk IPs
    high_risk_ips = AuditLog.top_suspicious_ips(5)
    if high_risk_ips.any? { |_, count| count >= 20 }
      recommendations << "Consider implementing IP blocking for addresses with excessive failed attempts"
    end
    
    # Check for admin activity patterns
    admin_activity = AuditLog.admin_actions.where(created_at: 7.days.ago..Time.current).count
    if admin_activity > 1000
      recommendations << "High admin activity detected - review admin access logs for unusual patterns"
    end
    
    # Check for security event trends
    recent_events = AuditLog.security_events.where(created_at: 24.hours.ago..Time.current).count
    previous_events = AuditLog.security_events.where(created_at: 48.hours.ago..24.hours.ago).count
    
    if recent_events > previous_events * 2
      recommendations << "Security events have doubled in the last 24 hours - investigate potential threats"
    end
    
    recommendations << "Regularly review and rotate admin credentials" if recommendations.empty?
    
    recommendations
  end
end
</file>

<file path="services/admin_notification_service.rb">
class AdminNotificationService < ApplicationService
  def self.notify(event_type, **options)
    new(event_type, **options).call
  end

  def initialize(event_type, **options)
    @event_type = event_type
    @options = options
  end

  def call
    return unless should_notify?

    notification = create_notification
    
    # Only attempt broadcast if notification was successfully created
    if notification&.persisted?
      broadcast_notification(notification)
    end
    
    notification
  end

  private

  attr_reader :event_type, :options

  def should_notify?
    # Skip notifications in test environment unless explicitly enabled
    return false if Rails.env.test? && !options[:force_in_test]
    
    # Skip if event type is not valid
    return false unless AdminNotification::EVENT_TYPES.value?(event_type.to_s)
    
    # Skip duplicate notifications for certain events (with Redis error handling)
    return false if duplicate_notification_exists_safely?
    
    true
  end

  def duplicate_notification_exists_safely?
    return false unless options[:user]

    begin
      duplicate_notification_exists?
    rescue Redis::CannotConnectError, Redis::ConnectionError, Redis::TimeoutError => e
      Rails.logger.warn "Redis unavailable for notification validation: #{e.message}"
      Rails.logger.info "Proceeding with notification due to Redis connectivity issues"
      # Continue with notification creation when Redis is unavailable
      false
    end
  end

  def create_notification
    case event_type.to_s
    when 'user_registered'
      AdminNotification.notify_user_registered(options[:user])
    when 'user_upgraded'
      AdminNotification.notify_user_upgraded(
        options[:user], 
        options[:from_plan], 
        options[:to_plan]
      )
    when 'trial_started'
      AdminNotification.notify_trial_started(options[:user])
    when 'trial_expired'
      AdminNotification.notify_trial_expired(options[:user])
    when 'payment_failed'
      AdminNotification.notify_payment_failed(
        options[:user], 
        options[:amount], 
        options[:error_message]
      )
    when 'high_response_volume'
      AdminNotification.notify_high_response_volume(
        options[:user], 
        options[:form], 
        options[:response_count]
      )
    when 'suspicious_activity'
      AdminNotification.notify_suspicious_activity(
        options[:user], 
        options[:activity_type], 
        options[:details]
      )
    else
      create_generic_notification
    end
  rescue Redis::CannotConnectError, Redis::ConnectionError, Redis::TimeoutError => e
    handle_redis_notification_error(e)
    nil
  rescue => e
    Rails.logger.error "Failed to create admin notification: #{e.message}"
    Rails.logger.error "Event type: #{event_type}, User ID: #{options[:user]&.id}"
    Rails.logger.error "Backtrace: #{e.backtrace.first(5).join("\n")}" if Rails.env.development?
    
    # Send to error tracking service if available
    if defined?(Sentry)
      Sentry.capture_exception(e, extra: {
        context: 'admin_notification_creation',
        event_type: event_type,
        user_id: options[:user]&.id,
        options: options.except(:user) # Exclude user object to avoid serialization issues
      })
    end
    
    nil
  end

  def handle_redis_notification_error(error)
    Rails.logger.warn "Redis unavailable during admin notification creation: #{error.message}"
    Rails.logger.info "Critical operation can continue, but notification creation failed due to Redis connectivity"
    
    # Log additional context for debugging
    Rails.logger.debug "Event type: #{event_type}"
    Rails.logger.debug "User ID: #{options[:user]&.id}"
    Rails.logger.debug "Redis URL: #{ENV['REDIS_URL']&.gsub(/:[^:@]*@/, ':***@')}"
    
    # Send to error tracking service if available
    if defined?(Sentry)
      Sentry.capture_exception(error, extra: {
        context: 'admin_notification_redis_failure',
        event_type: event_type,
        user_id: options[:user]&.id
      })
    end
  end

  def create_generic_notification
    AdminNotification.create!(
      event_type: event_type.to_s,
      title: options[:title] || "System notification",
      message: options[:message] || "A system event occurred",
      user: options[:user],
      priority: options[:priority] || 'normal',
      category: options[:category] || 'system',
      metadata: options[:metadata] || {}
    )
  end

  def duplicate_notification_exists?
    # Prevent duplicate notifications for the same user and event within a short time
    AdminNotification.where(
      event_type: event_type.to_s,
      user: options[:user],
      created_at: 5.minutes.ago..Time.current
    ).exists?
  end

  def broadcast_notification(notification)
    # Broadcast to admin dashboard using Turbo Streams with Redis error handling
    broadcast_with_redis_fallback do
      Turbo::StreamsChannel.broadcast_prepend_to(
        "admin_notifications",
        target: "notifications-list",
        partial: "admin/notifications/notification",
        locals: { notification: notification }
      )

      # Update notification counter
      unread_count = AdminNotification.unread.count
      Turbo::StreamsChannel.broadcast_update_to(
        "admin_notifications",
        target: "notification-counter",
        html: unread_count > 0 ? unread_count.to_s : ""
      )
    end
  end

  def broadcast_with_redis_fallback
    yield
  rescue Redis::CannotConnectError, Redis::ConnectionError, Redis::TimeoutError => e
    handle_redis_broadcast_error(e)
  rescue StandardError => e
    # Catch any other Redis-related errors that might not be explicitly Redis exceptions
    if redis_related_error?(e)
      handle_redis_broadcast_error(e)
    else
      raise e
    end
  end

  def handle_redis_broadcast_error(error)
    Rails.logger.warn "Redis unavailable for admin notification broadcast: #{error.message}"
    Rails.logger.info "Admin notification created successfully, but real-time broadcast skipped due to Redis connectivity"
    
    # Log additional context for debugging
    Rails.logger.debug "Redis URL: #{ENV['REDIS_URL']&.gsub(/:[^:@]*@/, ':***@')}"
    
    # Send to error tracking service if available, but don't re-raise
    if defined?(Sentry)
      Sentry.capture_exception(error, extra: {
        context: 'admin_notification_broadcast',
        service: self.class.name,
        event_type: @event_type,
        user_id: @options[:user]&.id
      })
    end
  end

  def redis_related_error?(error)
    # Check if the error message contains Redis-related keywords
    error.message.downcase.include?('redis') ||
    error.message.downcase.include?('connection') ||
    error.class.name.include?('Redis')
  end
end
</file>

<file path="services/application_service.rb">
# frozen_string_literal: true

# Base service class for all business logic services in this application
class ApplicationService
  include ActiveModel::Model
  include ActiveModel::Attributes
  include ActiveModel::Validations
  
  attr_reader :result, :errors, :context
  
  def initialize(attributes = {})
    @context = {}
    @errors = ActiveModel::Errors.new(self)
    @result = nil
    
    super(attributes)
    
    setup_service if respond_to?(:setup_service, true)
  end
  
  # Main execution method - to be overridden by subclasses
  def call
    raise NotImplementedError, "Subclasses must implement the call method"
  end
  
  # Class method for convenient service execution
  def self.call(*args)
    service = new(*args)
    service.call
    service
  end
  
  # Check if service execution was successful
  def success?
    @errors.empty?
  end
  
  # Check if service execution failed
  def failure?
    !success?
  end
  
  # Add error to the service
  def add_error(attribute, message)
    @errors.add(attribute, message)
  end
  
  # Set the service result
  def set_result(result)
    @result = result
  end
  
  # Get context value
  def get_context(key)
    @context[key]
  end
  
  # Set context value
  def set_context(key, value)
    @context[key] = value
  end
  
  # Update context with hash
  def update_context(new_context)
    @context.merge!(new_context)
  end
  
  # Execute with error handling and logging
  def execute_safely
    Rails.logger.info "Executing service #{self.class.name}"
    
    begin
      validate_service_inputs if respond_to?(:validate_service_inputs, true)
      
      if valid?
        call
        log_success if success?
      else
        log_validation_errors
      end
    rescue StandardError => e
      handle_service_error(e)
    end
    
    self
  end
  
  # Execute another service from within this service
  def execute_service(service_class, *args)
    Rails.logger.debug "#{self.class.name} executing #{service_class.name}"
    
    service = service_class.call(*args)
    
    if service.failure?
      service.errors.each do |error|
        add_error(:service_execution, "#{service_class.name}: #{error.full_message}")
      end
    end
    
    service
  end
  
  # Execute with database transaction
  def execute_in_transaction
    ActiveRecord::Base.transaction do
      execute_safely
      
      if failure?
        Rails.logger.error "Service #{self.class.name} failed, rolling back transaction"
        raise ActiveRecord::Rollback
      end
    end
    
    self
  end
  
  # Format service response
  def response
    {
      success: success?,
      result: @result,
      errors: @errors.full_messages,
      service: self.class.name,
      timestamp: Time.current.iso8601
    }
  end
  
  # Get service status
  def status
    {
      service: self.class.name,
      success: success?,
      errors_count: @errors.count,
      has_result: !@result.nil?,
      context_keys: @context.keys
    }
  end
  
  protected
  
  # Handle service execution errors
  def handle_service_error(error)
    Rails.logger.error "Service #{self.class.name} failed: #{error.message}"
    Rails.logger.error error.backtrace.join("\n") if Rails.env.development?
    
    # Track error in Sentry if available
    if defined?(Sentry)
      Sentry.capture_exception(error, extra: {
        service: self.class.name,
        context: @context,
        attributes: attributes
      })
    end
    
    add_error(:execution, "Service execution failed: #{error.message}")
  end
  
  # Log successful execution
  def log_success
    Rails.logger.info "Service #{self.class.name} completed successfully"
  end
  
  # Log validation errors
  def log_validation_errors
    Rails.logger.warn "Service #{self.class.name} validation failed: #{@errors.full_messages.join(', ')}"
  end
  
  # Validate required attributes
  def validate_required_attributes(*required_attrs)
    required_attrs.each do |attr|
      if send(attr).blank?
        add_error(attr, "is required")
      end
    end
  end
  
  # Safe database operation
  def safe_db_operation
    ActiveRecord::Base.transaction do
      yield
    end
  rescue ActiveRecord::RecordInvalid => e
    add_error(:database, "Validation error: #{e.message}")
    nil
  rescue ActiveRecord::RecordNotFound => e
    add_error(:database, "Record not found: #{e.message}")
    nil
  rescue StandardError => e
    add_error(:database, "Database error: #{e.message}")
    nil
  end
  
  # Find record safely
  def find_record(model_class, id, error_attribute = :base)
    record = model_class.find_by(id: id)
    
    unless record
      add_error(error_attribute, "#{model_class.name} not found with id: #{id}")
    end
    
    record
  end
  
  # Check authorization
  def authorize_user(user, action, resource = nil)
    return true unless user # Skip if no user context
    
    # Basic authorization - extend with Pundit if needed
    case action.to_s
    when 'read'
      true
    when 'write', 'update', 'delete'
      user.role != 'user' || user_owns_resource?(user, resource)
    else
      false
    end
  end
  
  # Check if user owns resource
  def user_owns_resource?(user, resource)
    return false unless resource
    
    if resource.respond_to?(:user_id)
      resource.user_id == user.id
    elsif resource.respond_to?(:user)
      resource.user == user
    else
      false
    end
  end
  
  # Format error response
  def error_response(message, type = 'service_error')
    {
      success: false,
      error: true,
      error_message: message,
      error_type: type,
      service: self.class.name,
      timestamp: Time.current.iso8601
    }
  end
  
  # Format success response
  def success_response(data = {})
    {
      success: true,
      service: self.class.name,
      timestamp: Time.current.iso8601,
      data: data
    }
  end
end
</file>

<file path="services/discount_code_service.rb">
# frozen_string_literal: true

# Service for handling discount code validation, application, and usage tracking
class DiscountCodeService < ApplicationService
  attribute :user
  attribute :code, :string
  attribute :original_amount, :integer
  attribute :subscription_id, :string

  # Validate a discount code for a user
  def validate_code
    validate_required_attributes(:user, :code)
    return self if failure?

    discount_code = find_discount_code
    return self if failure?

    validate_code_availability(discount_code)
    return self if failure?

    validate_user_eligibility
    return self if failure?

    set_result(discount_code: discount_code)
    self
  end

  # Calculate discount for display purposes (doesn't validate user eligibility)
  def calculate_discount(discount_code, amount)
    unless discount_code.is_a?(DiscountCode)
      return {
        original_amount: amount,
        discount_amount: 0,
        final_amount: amount,
        discount_percentage: 0
      }
    end

    unless amount.is_a?(Integer) && amount > 0
      return {
        original_amount: amount,
        discount_amount: 0,
        final_amount: amount,
        discount_percentage: 0
      }
    end

    discount_amount = calculate_discount_amount(discount_code, amount)
    final_amount = [amount - discount_amount, 0].max

    {
      original_amount: amount,
      discount_amount: discount_amount,
      final_amount: final_amount,
      discount_percentage: discount_code.discount_percentage
    }
  end

  # Apply discount calculation to an amount
  def apply_discount(discount_code, amount)
    validate_required_attributes(:user)
    return self if failure?

    unless discount_code.is_a?(DiscountCode)
      add_error(:discount_code, 'must be a DiscountCode instance')
      return self
    end

    unless amount.is_a?(Integer) && amount > 0
      add_error(:original_amount, 'must be a positive integer (amount in cents)')
      return self
    end

    discount_amount = calculate_discount_amount(discount_code, amount)
    final_amount = [amount - discount_amount, 0].max

    discount_details = {
      original_amount: amount,
      discount_amount: discount_amount,
      final_amount: final_amount,
      discount_percentage: discount_code.discount_percentage,
      savings_percentage: amount > 0 ? (discount_amount.to_f / amount * 100).round(1) : 0
    }

    set_result(discount_details)
    self
  end

  # Record usage of a discount code after successful subscription
  def record_usage(discount_code, subscription_details)
    validate_required_attributes(:user)
    return self if failure?

    unless discount_code.is_a?(DiscountCode)
      add_error(:discount_code, 'must be a DiscountCode instance')
      return self
    end

    validate_subscription_details(subscription_details)
    return self if failure?

    # Double-check user eligibility before recording
    validate_user_eligibility
    return self if failure?

    usage_record = nil
    
    safe_db_operation do
      # Use database transaction with retry logic for concurrent access
      ActiveRecord::Base.transaction do
        # Re-check discount code availability within transaction
        discount_code.reload
        unless discount_code.available?
          if discount_code.usage_limit_reached?
            add_error(:discount_code, 'This discount code has reached its usage limit')
          elsif !discount_code.active?
            add_error(:discount_code, 'This discount code is no longer active')
          elsif discount_code.expired?
            add_error(:discount_code, 'This discount code has expired')
          end
          raise ActiveRecord::Rollback
        end

        # Re-check user eligibility within transaction
        user.reload
        unless user.eligible_for_discount?
          add_error(:user, 'You are no longer eligible for discount codes')
          raise ActiveRecord::Rollback
        end

        usage_record = create_usage_record(discount_code, subscription_details)
        update_discount_code_usage(discount_code)
        mark_user_as_used_discount
        deactivate_code_if_exhausted(discount_code)
      end
    end

    return self if failure?

    set_result(usage_record: usage_record)
    self
  rescue ActiveRecord::RecordNotUnique, ActiveRecord::StatementInvalid => e
    # Handle concurrent access conflicts
    if e.message.include?('duplicate key') || e.message.include?('unique constraint')
      add_error(:concurrency, 'This discount code was just used by another user. Please try a different code.')
    else
      add_error(:database, "Database error: #{e.message}")
    end
    self
  end

  # Check if a discount code is valid and available
  def check_availability(code_string)
    self.code = code_string
    validate_required_attributes(:code)
    return self if failure?

    discount_code = find_discount_code
    return self if failure?

    availability_status = {
      code: discount_code.code,
      valid: true,
      active: discount_code.active?,
      expired: discount_code.expired?,
      usage_limit_reached: discount_code.usage_limit_reached?,
      available: discount_code.available?,
      discount_percentage: discount_code.discount_percentage,
      remaining_uses: discount_code.remaining_uses,
      expires_at: discount_code.expires_at
    }

    set_result(availability_status)
    self
  end

  # Check user eligibility for discount codes with detailed feedback
  def check_user_eligibility
    validate_required_attributes(:user)
    return self if failure?

    eligibility_status = {
      eligible: user.eligible_for_discount?,
      reasons: []
    }

    unless user.eligible_for_discount?
      if user.discount_code_used?
        eligibility_status[:reasons] << 'User has already used a discount code'
      end
      
      if user.suspended?
        eligibility_status[:reasons] << 'User account is suspended'
      end
      
      if user.subscription_tier == 'premium'
        eligibility_status[:reasons] << 'User already has a premium subscription'
      end
    end

    set_result(eligibility_status)
    self
  end

  # Get usage statistics for a discount code
  def get_usage_statistics(discount_code)
    unless discount_code.is_a?(DiscountCode)
      add_error(:discount_code, 'must be a DiscountCode instance')
      return self
    end

    stats = {
      code: discount_code.code,
      total_uses: discount_code.current_usage_count,
      max_uses: discount_code.max_usage_count,
      remaining_uses: discount_code.remaining_uses,
      usage_percentage: discount_code.usage_percentage,
      revenue_impact: discount_code.revenue_impact,
      active: discount_code.active?,
      expired: discount_code.expired?,
      created_at: discount_code.created_at,
      expires_at: discount_code.expires_at,
      recent_usages: discount_code.discount_code_usages.recent.limit(10).includes(:user)
    }

    set_result(stats)
    self
  end

  # Deactivate expired or exhausted codes (for background job)
  def deactivate_expired_codes
    deactivated_count = 0

    safe_db_operation do
      # Deactivate expired codes
      expired_count = DiscountCode.active.expired.update_all(active: false, updated_at: Time.current)
      deactivated_count += expired_count

      # Deactivate exhausted codes
      exhausted_codes = DiscountCode.active.where.not(max_usage_count: nil)
                                   .where('current_usage_count >= max_usage_count')
      exhausted_count = exhausted_codes.update_all(active: false, updated_at: Time.current)
      deactivated_count += exhausted_count
    end

    return self if failure?

    set_result(deactivated_count: deactivated_count)
    self
  end

  private

  def find_discount_code
    normalized_code = code&.upcase&.strip
    
    if normalized_code.blank?
      add_error(:code, 'cannot be blank')
      return nil
    end

    begin
      discount_code = DiscountCode.find_by(code: normalized_code)
    rescue StandardError => e
      add_error(:database, "Database error: #{e.message}")
      return nil
    end
    
    unless discount_code
      add_error(:code, 'Invalid discount code')
      return nil
    end

    discount_code
  end

  def validate_code_availability(discount_code)
    unless discount_code.active?
      add_error(:code, 'This discount code is no longer active')
      return false
    end

    if discount_code.expired?
      add_error(:code, 'This discount code has expired')
      return false
    end

    if discount_code.usage_limit_reached?
      add_error(:code, 'This discount code has reached its usage limit')
      return false
    end

    true
  end

  def validate_user_eligibility
    unless user.eligible_for_discount?
      if user.discount_code_used?
        add_error(:user, 'You have already used a discount code. Each account can only use one discount code.')
      elsif user.suspended?
        add_error(:user, 'Your account is suspended and cannot use discount codes. Please contact support.')
      elsif user.subscription_tier == 'premium'
        add_error(:user, 'Premium users cannot use discount codes on additional subscriptions.')
      else
        add_error(:user, 'You are not eligible for discount codes at this time.')
      end
      return false
    end

    true
  end

  def calculate_discount_amount(discount_code, amount)
    (amount * discount_code.discount_percentage / 100.0).round
  end

  def validate_subscription_details(details)
    required_fields = [:subscription_id, :original_amount, :discount_amount, :final_amount]
    
    required_fields.each do |field|
      unless details.key?(field) && details[field].present?
        add_error(:subscription_details, "#{field} is required")
      end
    end

    return if failure?

    # Validate amounts are positive integers
    [:original_amount, :discount_amount, :final_amount].each do |field|
      amount = details[field]
      unless amount.is_a?(Integer) && amount >= 0
        add_error(:subscription_details, "#{field} must be a non-negative integer")
      end
    end

    return if failure?

    # Validate calculation is correct
    expected_final = details[:original_amount] - details[:discount_amount]
    unless details[:final_amount] == expected_final
      add_error(:subscription_details, 'Final amount calculation is incorrect')
    end
  end

  def create_usage_record(discount_code, subscription_details)
    DiscountCodeUsage.create!(
      discount_code: discount_code,
      user: user,
      subscription_id: subscription_details[:subscription_id],
      original_amount: subscription_details[:original_amount],
      discount_amount: subscription_details[:discount_amount],
      final_amount: subscription_details[:final_amount],
      used_at: Time.current
    )
  end

  def update_discount_code_usage(discount_code)
    discount_code.increment!(:current_usage_count)
  end

  def mark_user_as_used_discount
    user.mark_discount_code_as_used!
  end

  def deactivate_code_if_exhausted(discount_code)
    if discount_code.reload.usage_limit_reached?
      discount_code.update!(active: false)
      Rails.logger.info "Discount code #{discount_code.code} deactivated due to usage limit reached"
    end
  end
end
</file>

<file path="services/form_publish_validation_service.rb">
# frozen_string_literal: true

class FormPublishValidationService < ApplicationService
  include PaymentAnalyticsTrackable
  
  attribute :form, default: nil
  attribute :track_analytics, default: true

  def call
    validate_service_inputs
    return self if failure?

    validate_payment_readiness
    track_validation_events if track_analytics
    self
  end

  private

  def validate_service_inputs
    validate_required_attributes(:form)
    
    unless form.is_a?(Form)
      add_error(:form, 'must be a Form instance')
    end
  end

  def validate_payment_readiness
    validation_results = {
      can_publish: true,
      validation_errors: [],
      required_actions: [],
      form_id: form.id,
      validated_at: Time.current
    }

    # Check if form has payment questions
    if form.has_payment_questions?
      validate_payment_questions_configuration(validation_results)
      validate_user_payment_setup(validation_results)
    end

    # Use PaymentReadinessChecker for comprehensive validation
    readiness_check = PaymentReadinessChecker.new(form: form).call
    
    if readiness_check.failure?
      validation_results[:can_publish] = false
      validation_results[:validation_errors].concat(readiness_check.result[:errors] || [])
      validation_results[:required_actions].concat(readiness_check.result[:actions] || [])
    end

    # Generate publish guidance if validation fails
    if validation_results[:validation_errors].any?
      generate_publish_guidance(validation_results)
    end

    # Set overall publish status
    validation_results[:can_publish] = validation_results[:validation_errors].empty?

    set_result(validation_results)
    set_context(:payment_questions_count, form.payment_questions.count)
    set_context(:validation_errors_count, validation_results[:validation_errors].length)
  end

  def validate_payment_questions_configuration(validation_results)
    payment_questions = form.payment_questions

    payment_questions.each do |question|
      # Validate question configuration
      unless question.question_config.present?
        validation_results[:validation_errors] << {
          type: 'payment_question_configuration',
          question_id: question.id,
          title: 'Payment Question Configuration Missing',
          description: "Payment question '#{question.title}' is not properly configured",
          details: ['Payment configuration is required for payment questions'],
          priority: 'high'
        }
      end

      # Validate required payment fields
      if question.question_config.present?
        validate_payment_question_fields(question, validation_results)
      end
    end
  end

  def validate_payment_question_fields(question, validation_results)
    config = question.question_config
    missing_fields = []

    # Check for required payment configuration fields
    missing_fields << 'amount' unless config['amount'].present?
    missing_fields << 'currency' unless config['currency'].present?
    missing_fields << 'description' unless config['description'].present?

    if missing_fields.any?
      validation_results[:validation_errors] << {
        type: 'payment_question_fields',
        question_id: question.id,
        title: 'Payment Question Fields Missing',
        description: "Payment question '#{question.title}' is missing required fields",
        details: missing_fields.map { |field| "Missing #{field}" },
        priority: 'high'
      }
    end
  end

  def validate_user_payment_setup(validation_results)
    user = form.user

    # Check Stripe configuration
    unless user.stripe_configured?
      validation_results[:validation_errors] << {
        type: 'stripe_not_configured',
        title: 'Stripe Configuration Required',
        description: 'Configure Stripe to accept payments before publishing forms with payment questions',
        details: ['Stripe keys not configured', 'Payment processing unavailable'],
        priority: 'high'
      }
    end

    # Check Premium subscription
    unless user.premium?
      validation_results[:validation_errors] << {
        type: 'premium_subscription_required',
        title: 'Premium Subscription Required',
        description: 'Upgrade to Premium to publish forms with payment questions',
        details: [
          "Current tier: #{user.subscription_tier}",
          'Premium subscription required for payment features'
        ],
        priority: 'high'
      }
    end

    # Check if user can accept payments (combined check)
    unless user.can_accept_payments?
      validation_results[:validation_errors] << {
        type: 'payment_acceptance_disabled',
        title: 'Payment Acceptance Not Available',
        description: 'Complete payment setup to publish forms with payment questions',
        details: ['Both Stripe configuration and Premium subscription are required'],
        priority: 'high'
      }
    end
  end

  def generate_publish_guidance(validation_results)
    validation_results[:validation_errors].each do |error|
      action = case error[:type]
               when 'stripe_not_configured'
                 generate_stripe_setup_action
               when 'premium_subscription_required'
                 generate_subscription_upgrade_action
               when 'payment_question_configuration'
                 generate_question_configuration_action(error)
               when 'payment_question_fields'
                 generate_question_fields_action(error)
               when 'payment_acceptance_disabled'
                 generate_complete_setup_action
               end
      
      validation_results[:required_actions] << action if action
    end

    # Remove duplicate actions
    validation_results[:required_actions].uniq! { |action| action[:type] }
  end

  def generate_stripe_setup_action
    {
      type: 'stripe_setup',
      title: 'Configure Stripe Payments',
      description: 'Set up your Stripe account to accept payments',
      action_url: '/stripe_settings',
      action_text: 'Configure Stripe',
      estimated_time: '5-10 minutes',
      priority: 'high',
      icon: 'credit-card'
    }
  end

  def generate_subscription_upgrade_action
    {
      type: 'subscription_upgrade',
      title: 'Upgrade to Premium',
      description: 'Unlock payment features with a Premium subscription',
      action_url: '/subscription_management',
      action_text: 'Upgrade Now',
      estimated_time: '2-3 minutes',
      priority: 'high',
      icon: 'star'
    }
  end

  def generate_question_configuration_action(error)
    {
      type: 'configure_payment_question',
      title: 'Configure Payment Question',
      description: 'Complete the configuration for your payment question',
      action_url: "/forms/#{form.id}/questions/#{error[:question_id]}/edit",
      action_text: 'Configure Question',
      estimated_time: '2-3 minutes',
      priority: 'high',
      icon: 'settings'
    }
  end

  def generate_question_fields_action(error)
    {
      type: 'complete_payment_fields',
      title: 'Complete Payment Fields',
      description: 'Add required fields to your payment question',
      action_url: "/forms/#{form.id}/questions/#{error[:question_id]}/edit",
      action_text: 'Complete Fields',
      estimated_time: '1-2 minutes',
      priority: 'high',
      icon: 'edit'
    }
  end

  def generate_complete_setup_action
    {
      type: 'complete_payment_setup',
      title: 'Complete Payment Setup',
      description: 'Finish setting up both Stripe and Premium subscription',
      action_url: '/payment_setup_guide',
      action_text: 'Complete Setup',
      estimated_time: '10-15 minutes',
      priority: 'high',
      icon: 'check-circle'
    }
  end

  def track_validation_events
    validation_result = result
    
    if validation_result[:can_publish]
      track_payment_event(
        'payment_form_published',
        user: form.user,
        context: {
          form_id: form.id,
          form_title: form.title,
          payment_questions_count: form.payment_questions.count,
          published_at: Time.current
        }
      )
    elsif validation_result[:validation_errors].any?
      validation_result[:validation_errors].each do |error|
        track_payment_event(
          'payment_validation_errors',
          user: form.user,
          context: {
            form_id: form.id,
            error_type: error[:type],
            error_title: error[:title],
            resolution_path: validation_result[:required_actions].find { |action| 
              action[:type].to_s.include?(error[:type].to_s.split('_').first) 
            }&.dig(:type),
            priority: error[:priority]
          }
        )
      end
    end
  end
end
</file>

<file path="services/lead_scoring_calculator.rb">
# frozen_string_literal: true

class LeadScoringCalculator
  class << self
    def calculate_technical_score(response_data)
      answers = response_data[:answers]
      technical_score = 0
      
      # Technical maturity indicators
      tech_maturity = answers['technical_maturity_score']&.to_i || 5
      ai_experience = answers['ai_experience']&.downcase || 'none'
      current_infrastructure = answers['current_infrastructure']&.downcase || 'basic'
      
      # Scoring based on technical readiness
      technical_score += (tech_maturity * 2)  # 0-20 points
      
      case ai_experience
      when 'experto', 'advanced'
        technical_score += 20
      when 'intermedio', 'intermediate'
        technical_score += 15
      when 'bsico', 'basic'
        technical_score += 10
      else
        technical_score += 5
      end
      
      case current_infrastructure
      when 'cloud-native', 'modern'
        technical_score += 15
      when 'hybrid', 'moderate'
        technical_score += 10
      when 'legacy', 'basic'
        technical_score += 5
      else
        technical_score += 8
      end
      
      [[technical_score, 0].max, 50].min
    end

    def calculate_business_impact_score(analysis, response_data)
      answers = response_data[:answers]
      impact_score = 0
      
      # Business impact indicators
      use_case_clarity = answers['ai_use_cases']&.length || 0
      strategic_alignment = answers['strategic_alignment']&.downcase || 'neutral'
      pain_points = answers['main_challenge']&.length || 0
      
      # Scoring based on business impact potential
      impact_score += [use_case_clarity * 2, 20].min  # 0-20 points
      impact_score += [pain_points / 10, 15].min      # 0-15 points
      
      case strategic_alignment
      when 'high', 'critical'
        impact_score += 20
      when 'medium', 'important'
        impact_score += 15
      when 'low', 'nice_to_have'
        impact_score += 10
      else
        impact_score += 12
      end
      
      # Bonus for specific business impact indicators
      business_impact_keywords = ['revenue', 'cost', 'efficiency', 'competitive', 'growth']
      challenge_text = answers['main_challenge']&.downcase || ''
      business_impact_keywords.each { |kw| impact_score += 3 if challenge_text.include?(kw) }
      
      [[impact_score, 0].max, 55].min
    end

    def calculate_financial_score(response_data)
      answers = response_data[:answers]
      financial_score = 0
      
      # Financial capacity indicators
      budget_amount = extract_budget_numeric(answers['budget_amount'])
      company_size = response_data[:enriched_data]&.[](:company_size) || 0
      
      # Budget-based scoring
      if budget_amount
        case budget_amount
        when 100000..Float::INFINITY
          financial_score += 25
        when 50000..99999
          financial_score += 20
        when 20000..49999
          financial_score += 15
        when 5000..19999
          financial_score += 10
        else
          financial_score += 5
        end
      end
      
      # Company size-based scoring
      case company_size
      when 1000..Float::INFINITY
        financial_score += 20
      when 100..999
        financial_score += 15
      when 50..99
        financial_score += 10
      when 10..49
        financial_score += 8
      else
        financial_score += 5
      end
      
      [[financial_score, 0].max, 45].min
    end

    def calculate_urgency_score(analysis, response_data)
      answers = response_data[:answers]
      urgency_score = 0
      
      # Timeline-based urgency
      timeline = answers['timeline']&.downcase || 'long_term'
      case timeline
      when 'immediately', '1-3 meses'
        urgency_score += 25
      when '3-6 meses', 'short_term'
        urgency_score += 20
      when '6-12 meses', 'medium_term'
        urgency_score += 15
      when '12+ meses', 'long_term'
        urgency_score += 10
      else
        urgency_score += 12
      end
      
      # Sentiment-based urgency
      sentiment_score = analysis.dig('sentiment_analysis', 'sentiment_score') || 0
      urgency_score += 15 if sentiment_score < -0.3  # Negative sentiment = urgency
      
      # Keyword-based urgency
      urgent_keywords = ['urgente', 'crisis', 'competencia', 'perdiendo', 'inmediato']
      challenge_text = answers['main_challenge']&.downcase || ''
      urgent_keywords.each { |kw| urgency_score += 5 if challenge_text.include?(kw) }
      
      [[urgency_score, 0].max, 40].min
    end

    def calculate_authority_score(response_data)
      answers = response_data[:answers]
      authority_score = 0
      
      # Role-based authority
      role = answers['role']&.downcase || 'unknown'
      case role
      when 'ceo', 'cto', 'founder', 'director', 'vp'
        authority_score += 25
      when 'manager', 'head', 'lead'
        authority_score += 20
      when 'senior', 'specialist'
        authority_score += 15
      else
        authority_score += 10
      end
      
      # Decision authority
      decision_authority = answers['decision_authority']&.downcase || 'unknown'
      case decision_authority
      when 'tengo autoridad completa', 'complete authority'
        authority_score += 20
      when 'tengo influencia significativa', 'significant influence'
        authority_score += 15
      when 'tengo influencia limitada', 'limited influence'
        authority_score += 10
      else
        authority_score += 5
      end
      
      [[authority_score, 0].max, 45].min
    end

    def calculate_complexity_score(response_data)
      answers = response_data[:answers]
      complexity_score = 0
      
      # Implementation complexity indicators
      integration_needs = answers['integration_needs']&.downcase || 'simple'
      compliance_needs = answers['compliance_needs']&.downcase || 'none'
      change_management = answers['change_management']&.downcase || 'minimal'
      
      # Complexity scoring (lower complexity = higher score)
      case integration_needs
      when 'simple', 'standalone'
        complexity_score += 20
      when 'moderate', 'some_integration'
        complexity_score += 15
      when 'complex', 'heavy_integration'
        complexity_score += 10
      else
        complexity_score += 12
      end
      
      case compliance_needs
      when 'none'
        complexity_score += 15
      when 'basic', 'standard'
        complexity_score += 10
      when 'strict', 'regulated'
        complexity_score += 5
      else
        complexity_score += 10
      end
      
      case change_management
      when 'minimal'
        complexity_score += 15
      when 'moderate'
        complexity_score += 10
      when 'significant'
        complexity_score += 5
      else
        complexity_score += 10
      end
      
      [[complexity_score, 0].max, 50].min
    end

    def get_industry_weights(industry)
      return default_weights unless industry
      
      industry_weights = {
        'technology' => {
          technical_readiness: 1.2,
          business_impact: 1.1,
          financial_capacity: 1.0,
          urgency_factor: 1.0,
          decision_authority: 1.0,
          implementation_complexity: 0.9
        },
        'healthcare' => {
          technical_readiness: 0.8,
          business_impact: 1.3,
          financial_capacity: 1.1,
          urgency_factor: 1.2,
          decision_authority: 0.9,
          implementation_complexity: 1.3
        },
        'financial_services' => {
          technical_readiness: 1.1,
          business_impact: 1.2,
          financial_capacity: 1.2,
          urgency_factor: 1.1,
          decision_authority: 1.1,
          implementation_complexity: 1.2
        },
        'manufacturing' => {
          technical_readiness: 0.9,
          business_impact: 1.1,
          financial_capacity: 1.0,
          urgency_factor: 0.9,
          decision_authority: 1.0,
          implementation_complexity: 1.1
        },
        'retail' => {
          technical_readiness: 1.0,
          business_impact: 1.2,
          financial_capacity: 0.9,
          urgency_factor: 1.1,
          decision_authority: 1.0,
          implementation_complexity: 1.0
        }
      }
      
      industry_weights[industry.downcase] || industry_weights[industry] || default_weights
    end

    private

    def default_weights
      {
        technical_readiness: 1.0,
        business_impact: 1.0,
        financial_capacity: 1.0,
        urgency_factor: 1.0,
        decision_authority: 1.0,
        implementation_complexity: 1.0
      }
    end

    def extract_budget_numeric(budget_string)
      return nil unless budget_string
      
      # Extract numeric value from budget string
      budget_string.scan(/[\d,]+/).first&.gsub(',', '')&.to_i
    end
  end
end
</file>

<file path="services/payment_analytics_service.rb">
# frozen_string_literal: true

class PaymentAnalyticsService
  PAYMENT_EVENTS = %w[
    template_payment_interaction
    payment_setup_started
    payment_setup_completed
    payment_setup_abandoned
    payment_form_published
    payment_validation_errors
  ].freeze

  def track_event(event_type, user:, context: {})
    return { success: false, error: 'Invalid event type' } unless PAYMENT_EVENTS.include?(event_type.to_s)

    analytics_data = build_analytics_data(event_type, user, context)
    
    # Store in database for dashboard metrics
    PaymentAnalytic.create!(analytics_data)
    
    # Send to external analytics if configured
    send_to_external_analytics(event_type, analytics_data) if external_analytics_enabled?
    
    { success: true, data: analytics_data }
  rescue StandardError => e
    Rails.logger.error "PaymentAnalyticsService error: #{e.message}"
    { success: false, error: "Failed to track event: #{e.message}" }
  end

  def get_dashboard_metrics(date_range: 30.days.ago..Time.current)
    {
      setup_completion_rate: calculate_setup_completion_rate(date_range),
      common_failure_points: identify_common_failure_points(date_range),
      template_interaction_stats: calculate_template_interaction_stats(date_range),
      job_performance_metrics: calculate_job_performance_metrics(date_range),
      error_resolution_paths: analyze_error_resolution_paths(date_range)
    }
  end

  private

  def build_analytics_data(event_type, user, context)
    {
      event_type: event_type,
      user_id: user.id,
      user_subscription_tier: user.subscription_tier,
      timestamp: Time.current,
      context: sanitize_context(context) || {},
      session_id: context[:session_id],
      user_agent: context[:user_agent],
      ip_address: context[:ip_address]&.then { |ip| anonymize_ip(ip) }
    }
  end

  def sanitize_context(context)
    return {} if context.blank?
    
    # Remove sensitive information and limit context size
    sanitized = context.except(:password, :token, :api_key, :secret)
    json_string = sanitized.to_json.truncate(1000) # Limit context size
    JSON.parse(json_string) # Ensure valid JSON
  rescue JSON::ParserError, StandardError
    { error: 'Invalid context data' }
  end

  def anonymize_ip(ip_address)
    # Anonymize IP for privacy compliance
    IPAddr.new(ip_address).mask(24).to_s
  rescue IPAddr::InvalidAddressError
    'unknown'
  end

  def calculate_setup_completion_rate(date_range)
    started_count = PaymentAnalytic.where(
      event_type: 'payment_setup_started',
      timestamp: date_range
    ).count

    completed_count = PaymentAnalytic.where(
      event_type: 'payment_setup_completed',
      timestamp: date_range
    ).count

    return 0 if started_count.zero?
    
    (completed_count.to_f / started_count * 100).round(2)
  end

  def identify_common_failure_points(date_range)
    PaymentAnalytic.where(
      event_type: 'payment_validation_errors',
      timestamp: date_range
    ).group("context->>'error_type'")
     .count
     .sort_by { |_, count| -count }
     .first(5)
     .to_h
  end

  def calculate_template_interaction_stats(date_range)
    interactions = PaymentAnalytic.where(
      event_type: 'template_payment_interaction',
      timestamp: date_range
    )

    {
      total_interactions: interactions.count,
      unique_users: interactions.distinct.count(:user_id),
      templates_by_popularity: interactions.group("context->>'template_id'").count.sort_by { |_, count| -count }.first(10).to_h
    }
  end

  def calculate_job_performance_metrics(date_range)
    # This would integrate with Sidekiq metrics if available
    # For now, return placeholder structure
    {
      average_processing_time: 0,
      error_rate: 0,
      queue_depth: 0,
      retry_rate: 0
    }
  end

  def analyze_error_resolution_paths(date_range)
    error_events = PaymentAnalytic.where(
      event_type: 'payment_validation_errors',
      timestamp: date_range
    )

    resolution_stats = {}
    
    error_events.find_each do |error_event|
      error_type = error_event.context['error_type']
      resolution_path = error_event.context['resolution_path']
      
      resolution_stats[error_type] ||= {}
      resolution_stats[error_type][resolution_path] ||= 0
      resolution_stats[error_type][resolution_path] += 1
    end

    resolution_stats
  end

  def send_to_external_analytics(event_type, data)
    # Integration point for external analytics services
    # Could integrate with Google Analytics, Mixpanel, etc.
    Rails.logger.info "External analytics: #{event_type} - #{data}"
  end

  def external_analytics_enabled?
    Rails.application.credentials.dig(:analytics, :enabled) || false
  end
end
</file>

<file path="services/payment_configuration_service.rb">
# frozen_string_literal: true

# PaymentConfigurationService manages payment setup status for users
# 
# This service provides comprehensive tracking and management of user payment
# configuration status, including Stripe setup and Premium subscription status.
# It includes caching for performance and integrates with existing payment services.
#
# Usage:
#   service = PaymentConfigurationService.new(user: user)
#   service.call
#   status = service.result
#
# Class methods:
#   PaymentConfigurationService.get_setup_status(user) - Get cached or fresh status
#   PaymentConfigurationService.calculate_progress(user) - Get progress percentage
#   PaymentConfigurationService.setup_complete?(user) - Check if setup is complete
#   PaymentConfigurationService.invalidate_cache(user) - Clear cached status
#
class PaymentConfigurationService < ApplicationService
  attribute :user, default: nil
  attribute :force_refresh, default: false

  CACHE_EXPIRY = 5.minutes
  SETUP_STEPS = %w[stripe_configuration premium_subscription].freeze

  def call
    validate_service_inputs
    return self if failure?

    update_user_status
    self
  end

  # Update user's payment setup status
  def update_user_status
    status_data = calculate_setup_status
    
    # Cache the status for performance (always cache the result)
    cache_setup_status(status_data)
    
    # Update user's cached setup completion if it has changed
    update_user_completion_cache(status_data)
    
    set_result(status_data)
    set_context(:status_updated_at, Time.current)
    set_context(:cache_used, get_context(:cache_hit) || false)
  end

  # Get cached setup status or calculate fresh
  def self.get_setup_status(user, force_refresh: false)
    service = new(user: user, force_refresh: force_refresh)
    service.call
    service.success? ? service.result : nil
  end

  # Calculate setup progress percentage
  def self.calculate_progress(user)
    return 0 unless user.is_a?(User)
    
    completed_steps = 0
    completed_steps += 1 if user.stripe_configured?
    completed_steps += 1 if user.premium?
    
    (completed_steps.to_f / SETUP_STEPS.length * 100).round
  end

  # Get next required setup step
  def self.next_required_step(user)
    return nil unless user.is_a?(User)
    
    return 'stripe_configuration' unless user.stripe_configured?
    return 'premium_subscription' unless user.premium?
    
    nil # All steps completed
  end

  # Get all missing setup steps
  def self.missing_steps(user)
    return SETUP_STEPS.dup unless user.is_a?(User)
    
    missing = []
    missing << 'stripe_configuration' unless user.stripe_configured?
    missing << 'premium_subscription' unless user.premium?
    
    missing
  end

  # Check if setup is complete
  def self.setup_complete?(user)
    return false unless user.is_a?(User)
    
    user.stripe_configured? && user.premium?
  end

  # Get setup requirements with actions
  def self.setup_requirements(user)
    return [] unless user.is_a?(User)
    
    requirements = []
    
    unless user.stripe_configured?
      requirements << stripe_configuration_requirement
    end
    
    unless user.premium?
      requirements << premium_subscription_requirement
    end
    
    requirements
  end

  # Invalidate cached setup status
  def self.invalidate_cache(user)
    return unless user.is_a?(User)
    
    Rails.cache.delete(cache_key(user.id))
    Rails.logger.debug "Invalidated payment setup cache for user #{user.id}"
  end

  # Bulk update setup status for multiple users
  def self.bulk_update_status(user_ids)
    return { updated: 0, errors: [] } if user_ids.blank?
    
    updated_count = 0
    errors = []
    
    User.where(id: user_ids).find_each do |user|
      begin
        service = new(user: user, force_refresh: true)
        service.call
        
        if service.success?
          updated_count += 1
        else
          errors << { user_id: user.id, errors: service.errors.full_messages }
        end
      rescue StandardError => e
        errors << { user_id: user.id, error: e.message }
      end
    end
    
    {
      updated: updated_count,
      errors: errors,
      total_processed: user_ids.length
    }
  end

  # Update status when Stripe configuration changes
  def self.handle_stripe_configuration_change(user)
    return unless user.is_a?(User)
    
    invalidate_cache(user)
    
    # Update status in background to avoid blocking the request
    PaymentSetupValidationJob.perform_async(user.id) if defined?(PaymentSetupValidationJob)
    
    Rails.logger.info "Payment configuration status update triggered for user #{user.id}"
  end

  # Update status when subscription changes
  def self.handle_subscription_change(user)
    return unless user.is_a?(User)
    
    invalidate_cache(user)
    
    # Update status immediately for subscription changes as they affect access
    service = new(user: user, force_refresh: true)
    service.call
    
    Rails.logger.info "Subscription status updated for user #{user.id}: #{service.success? ? 'success' : 'failed'}"
    
    service.result
  end

  # Get setup status with detailed breakdown for admin/debugging
  def self.detailed_status(user)
    return nil unless user.is_a?(User)
    
    service = new(user: user, force_refresh: true)
    service.call
    
    return nil unless service.success?
    
    status = service.result.dup
    
    # Add additional debugging information
    status[:debug_info] = {
      service_version: '1.0.0',
      calculated_by: service.class.name,
      user_methods: {
        stripe_configured: user.stripe_configured?,
        premium: user.premium?,
        can_accept_payments: user.can_accept_payments?
      },
      cache_info: {
        cache_key: cache_key(user.id),
        cache_hit: service.get_context(:cache_hit),
        cached_until: service.get_context(:cached_until)
      }
    }
    
    status
  end

  private

  def validate_service_inputs
    validate_required_attributes(:user)
    
    unless user.is_a?(User)
      add_error(:user, 'must be a User instance')
    end
  end

  def calculate_setup_status
    # Check cache first unless force refresh
    if !force_refresh && (cached_status = get_cached_status)
      set_context(:cache_hit, true)
      return cached_status
    end
    
    set_context(:cache_hit, false)
    
    # Calculate fresh status
    status = {
      user_id: user.id,
      setup_complete: false,
      progress_percentage: 0,
      completed_steps: [],
      missing_steps: [],
      next_step: nil,
      requirements: [],
      stripe_status: {},
      subscription_status: {},
      calculated_at: Time.current,
      expires_at: CACHE_EXPIRY.from_now
    }
    
    # Check Stripe configuration
    check_stripe_configuration(status)
    
    # Check subscription status
    check_subscription_status(status)
    
    # Calculate overall progress
    calculate_overall_progress(status)
    
    # Determine next steps
    determine_next_steps(status)
    
    # Generate requirements
    generate_requirements(status)
    
    status
  end

  def check_stripe_configuration(status)
    begin
      stripe_configured = user.stripe_configured?
      
      status[:stripe_status] = {
        configured: stripe_configured,
        has_publishable_key: user.stripe_publishable_key.present?,
        has_secret_key: user.stripe_secret_key.present?,
        has_webhook_secret: user.stripe_webhook_secret.present?,
        can_accept_payments: user.can_accept_payments?
      }
      
      if stripe_configured
        status[:completed_steps] << 'stripe_configuration'
        
        # Get detailed Stripe status
        begin
          stripe_details = StripeConfigurationChecker.configuration_status(user)
          status[:stripe_status].merge!(stripe_details)
        rescue StandardError => e
          Rails.logger.warn "Failed to get detailed Stripe status: #{e.message}"
          # Continue with basic status
        end
      else
        status[:missing_steps] << 'stripe_configuration'
      end
    rescue StandardError => e
      add_error(:stripe_configuration, "Failed to check Stripe configuration: #{e.message}")
      status[:stripe_status] = { configured: false, error: e.message }
      status[:missing_steps] << 'stripe_configuration'
    end
  end

  def check_subscription_status(status)
    begin
      is_premium = user.premium?
      
      status[:subscription_status] = {
        is_premium: is_premium,
        subscription_tier: user.subscription_tier,
        subscription_active: user.subscription_active?,
        subscription_expires_at: user.subscription_expires_at,
        trial_active: user.trial_active?,
        trial_expired: user.trial_expired?
      }
      
      if is_premium
        status[:completed_steps] << 'premium_subscription'
      else
        status[:missing_steps] << 'premium_subscription'
      end
    rescue StandardError => e
      add_error(:subscription_status, "Failed to check subscription status: #{e.message}")
      status[:subscription_status] = { is_premium: false, error: e.message }
      status[:missing_steps] << 'premium_subscription'
    end
  end

  def calculate_overall_progress(status)
    completed_count = status[:completed_steps].length
    total_steps = SETUP_STEPS.length
    
    status[:progress_percentage] = (completed_count.to_f / total_steps * 100).round
    status[:setup_complete] = status[:missing_steps].empty?
  end

  def determine_next_steps(status)
    if status[:missing_steps].any?
      # Prioritize Stripe configuration first, then subscription
      if status[:missing_steps].include?('stripe_configuration')
        status[:next_step] = 'stripe_configuration'
      elsif status[:missing_steps].include?('premium_subscription')
        status[:next_step] = 'premium_subscription'
      end
    end
  end

  def generate_requirements(status)
    requirements = []
    
    status[:missing_steps].each do |step|
      case step
      when 'stripe_configuration'
        requirements << self.class.stripe_configuration_requirement
      when 'premium_subscription'
        requirements << self.class.premium_subscription_requirement
      end
    end
    
    status[:requirements] = requirements
  end

  def get_cached_status
    Rails.cache.read(self.class.cache_key(user.id))
  end

  def cache_setup_status(status_data)
    Rails.cache.write(
      self.class.cache_key(user.id),
      status_data,
      expires_in: CACHE_EXPIRY
    )
    
    set_context(:cached_until, status_data[:expires_at])
  end

  def update_user_completion_cache(status_data)
    begin
      current_percentage = user.calculate_setup_completion
      new_percentage = status_data[:progress_percentage]
      
      # Only update if percentage has changed to avoid unnecessary DB writes
      if current_percentage != new_percentage
        # We could add a cached_setup_completion field to users table in the future
        # For now, we rely on the calculate_setup_completion method
        set_context(:completion_changed, true)
        set_context(:old_completion, current_percentage)
        set_context(:new_completion, new_percentage)
      end
    rescue StandardError => e
      Rails.logger.warn "Failed to update user completion cache: #{e.message}"
      # Don't fail the service for cache update issues
    end
  end

  def self.cache_key(user_id)
    "payment_setup_status:#{user_id}"
  end

  def self.stripe_configuration_requirement
    {
      type: 'stripe_configuration',
      title: 'Configure Stripe Payments',
      description: 'Set up your Stripe account to accept payments from your forms',
      action_url: '/stripe_settings',
      action_text: 'Configure Stripe',
      priority: 'high',
      estimated_time: '5-10 minutes',
      benefits: [
        'Accept credit card payments',
        'Secure payment processing',
        'Automatic payment notifications'
      ]
    }
  end

  def self.premium_subscription_requirement
    {
      type: 'premium_subscription',
      title: 'Upgrade to Premium',
      description: 'Unlock payment features and advanced form capabilities',
      action_url: '/subscription_management',
      action_text: 'Upgrade to Premium',
      priority: 'high',
      estimated_time: '2-3 minutes',
      benefits: [
        'Payment question types',
        'Advanced analytics',
        'Custom branding',
        'Priority support'
      ]
    }
  end
end
</file>

<file path="services/payment_error_recovery_service.rb">
# frozen_string_literal: true

# Service for guiding users through payment error recovery workflows
# Provides step-by-step guidance to resolve payment setup issues
class PaymentErrorRecoveryService < ApplicationService
  def initialize(error:, user:, context: {})
    @error = error
    @user = user
    @context = context
    @recovery_steps = []
    @current_step = 0
  end

  def call
    Rails.logger.info "Starting payment error recovery for error type: #{@error.error_type}"
    
    begin
      generate_recovery_workflow
      track_recovery_initiation
      
      success(
        recovery_workflow: {
          error_type: @error.error_type,
          total_steps: @recovery_steps.length,
          current_step: @current_step,
          steps: @recovery_steps,
          estimated_time: calculate_estimated_time,
          completion_url: generate_completion_url
        }
      )
    rescue StandardError => e
      Rails.logger.error "Error recovery workflow generation failed: #{e.message}"
      error(message: 'Could not generate recovery workflow', details: e.message)
    end
  end

  def self.get_next_step(error_type:, user:, completed_steps: [])
    service = new(
      error: PaymentValidationErrors.find_error_definition(error_type) || { error_type: error_type },
      user: user
    )
    service.send(:generate_recovery_workflow)
    
    # Find the next incomplete step
    next_step = service.instance_variable_get(:@recovery_steps).find do |step|
      !completed_steps.include?(step[:id])
    end
    
    next_step
  end

  def self.mark_step_completed(error_type:, user:, step_id:)
    # Track step completion
    Rails.logger.info "Marking step #{step_id} as completed for user #{user.id}"
    
    # You could store this in Redis, database, or user session
    # For now, we'll just log it
    if defined?(Rails.cache)
      cache_key = "payment_recovery:#{user.id}:#{error_type}"
      completed_steps = Rails.cache.read(cache_key) || []
      completed_steps << step_id unless completed_steps.include?(step_id)
      Rails.cache.write(cache_key, completed_steps, expires_in: 1.hour)
    end
    
    true
  end

  private

  attr_reader :error, :user, :context, :recovery_steps, :current_step

  def generate_recovery_workflow
    case @error.error_type || @error[:error_type]
    when 'stripe_not_configured'
      generate_stripe_setup_workflow
    when 'premium_subscription_required'
      generate_subscription_upgrade_workflow
    when 'multiple_requirements_missing'
      generate_multiple_requirements_workflow
    when 'invalid_payment_configuration'
      generate_configuration_fix_workflow
    else
      generate_generic_recovery_workflow
    end
  end

  def generate_stripe_setup_workflow
    @recovery_steps = [
      {
        id: 'stripe_account_creation',
        title: 'Create or Connect Stripe Account',
        description: 'Set up your Stripe account to process payments securely',
        action_url: '/stripe_settings',
        action_text: 'Go to Stripe Settings',
        estimated_minutes: 3,
        requirements: [],
        validation_endpoint: '/api/v1/payment_setup/validate_stripe_account',
        help_content: {
          overview: 'Stripe is a secure payment processor that handles all payment transactions for your forms.',
          steps: [
            'Click "Go to Stripe Settings" below',
            'Choose to create a new Stripe account or connect an existing one',
            'Follow the Stripe onboarding process',
            'Complete your business information and bank account details'
          ],
          common_issues: [
            'Make sure to use the same email address for consistency',
            'Have your business tax ID and bank account information ready',
            'Stripe may require additional verification for some business types'
          ]
        }
      },
      {
        id: 'stripe_webhook_configuration',
        title: 'Configure Webhooks',
        description: 'Set up webhooks so your forms can receive payment notifications',
        action_url: '/stripe_settings/webhooks',
        action_text: 'Configure Webhooks',
        estimated_minutes: 2,
        requirements: ['stripe_account_creation'],
        validation_endpoint: '/api/v1/payment_setup/validate_webhooks',
        help_content: {
          overview: 'Webhooks allow your forms to automatically update when payments are processed.',
          steps: [
            'Go to webhook configuration',
            'Copy the provided webhook URL',
            'Add the webhook URL to your Stripe dashboard',
            'Select the required webhook events'
          ],
          common_issues: [
            'Webhook URL must be exactly as provided',
            'Make sure to select all required webhook events',
            'Test the webhook connection before proceeding'
          ]
        }
      },
      {
        id: 'stripe_test_payment',
        title: 'Test Payment Processing',
        description: 'Verify that payments are working correctly with a test transaction',
        action_url: '/stripe_settings/test',
        action_text: 'Run Test Payment',
        estimated_minutes: 2,
        requirements: ['stripe_account_creation', 'stripe_webhook_configuration'],
        validation_endpoint: '/api/v1/payment_setup/test_payment',
        help_content: {
          overview: 'Testing ensures your payment setup is working correctly before going live.',
          steps: [
            'Click "Run Test Payment"',
            'Use the provided test card numbers',
            'Verify the test payment completes successfully',
            'Check that webhook notifications are received'
          ],
          common_issues: [
            'Use only test card numbers provided by Stripe',
            'Make sure you\'re in test mode, not live mode',
            'Check webhook logs if test payments fail'
          ]
        }
      }
    ]
  end

  def generate_subscription_upgrade_workflow
    @recovery_steps = [
      {
        id: 'review_premium_features',
        title: 'Review Premium Features',
        description: 'Learn about the payment features included in Premium plans',
        action_url: '/subscription_management',
        action_text: 'View Premium Plans',
        estimated_minutes: 2,
        requirements: [],
        validation_endpoint: nil,
        help_content: {
          overview: 'Premium plans unlock payment functionality and other advanced features.',
          steps: [
            'Review the available Premium plan options',
            'Compare features and pricing',
            'Consider your expected form volume and needs',
            'Choose the plan that best fits your requirements'
          ],
          features: [
            'Unlimited payment forms and transactions',
            'Advanced analytics and reporting',
            'Custom branding and white-label options',
            'Priority support and onboarding assistance',
            'API access and integrations'
          ]
        }
      },
      {
        id: 'select_premium_plan',
        title: 'Select and Purchase Premium Plan',
        description: 'Choose your Premium plan and complete the upgrade process',
        action_url: '/subscription_management/upgrade',
        action_text: 'Upgrade Now',
        estimated_minutes: 3,
        requirements: ['review_premium_features'],
        validation_endpoint: '/api/v1/subscription/validate_premium_status',
        help_content: {
          overview: 'Upgrading to Premium immediately unlocks payment features for your account.',
          steps: [
            'Select your preferred Premium plan',
            'Enter your payment information',
            'Review and confirm your subscription',
            'Wait for confirmation of successful upgrade'
          ],
          common_issues: [
            'Make sure your payment method is valid and has sufficient funds',
            'Check that your billing information is accurate',
            'Contact support if the upgrade doesn\'t process immediately'
          ]
        }
      },
      {
        id: 'verify_premium_access',
        title: 'Verify Premium Access',
        description: 'Confirm that your Premium features are active and accessible',
        action_url: '/profile',
        action_text: 'Check Account Status',
        estimated_minutes: 1,
        requirements: ['select_premium_plan'],
        validation_endpoint: '/api/v1/subscription/validate_premium_access',
        help_content: {
          overview: 'Verification ensures your Premium features are properly activated.',
          steps: [
            'Go to your account profile',
            'Verify your subscription status shows as Premium',
            'Check that payment features are now available',
            'Test creating a form with payment questions'
          ],
          common_issues: [
            'Premium activation may take a few minutes',
            'Refresh your browser if features don\'t appear immediately',
            'Contact support if Premium features aren\'t available after 10 minutes'
          ]
        }
      }
    ]
  end

  def generate_multiple_requirements_workflow
    # Combine steps from multiple workflows based on missing requirements
    missing_requirements = @error.user_guidance&.dig(:missing_requirements) || []
    
    @recovery_steps = []
    
    if missing_requirements.include?('stripe_configuration') || missing_requirements.include?('stripe_config')
      generate_stripe_setup_workflow
      stripe_steps = @recovery_steps.dup
      @recovery_steps = []
    end
    
    if missing_requirements.include?('premium_subscription') || missing_requirements.include?('premium')
      generate_subscription_upgrade_workflow
      premium_steps = @recovery_steps.dup
      @recovery_steps = []
    end
    
    # Merge and sequence the steps appropriately
    @recovery_steps = []
    @recovery_steps.concat(premium_steps) if defined?(premium_steps)
    @recovery_steps.concat(stripe_steps) if defined?(stripe_steps)
    
    # Add a final verification step
    @recovery_steps << {
      id: 'final_verification',
      title: 'Final Setup Verification',
      description: 'Verify that all payment requirements are now satisfied',
      action_url: @context[:return_url] || '/forms',
      action_text: 'Return to Form',
      estimated_minutes: 1,
      requirements: @recovery_steps.map { |step| step[:id] },
      validation_endpoint: '/api/v1/payment_setup/validate_complete_setup',
      help_content: {
        overview: 'Final verification ensures all payment setup requirements are met.',
        steps: [
          'Return to your form',
          'Verify that payment questions are working',
          'Test the complete form flow',
          'Publish your form when ready'
        ]
      }
    }
  end

  def generate_configuration_fix_workflow
    @recovery_steps = [
      {
        id: 'review_payment_questions',
        title: 'Review Payment Question Configuration',
        description: 'Check and fix configuration issues with your payment questions',
        action_url: @context[:form_edit_url] || '/forms',
        action_text: 'Edit Form',
        estimated_minutes: 5,
        requirements: [],
        validation_endpoint: '/api/v1/forms/validate_payment_questions',
        help_content: {
          overview: 'Payment questions need proper configuration to work correctly.',
          steps: [
            'Go to your form editor',
            'Review each payment question',
            'Check that amounts and currencies are set',
            'Verify that all required fields are completed'
          ],
          common_issues: [
            'Missing payment amounts or currency settings',
            'Invalid currency codes (use ISO 4217 codes like USD, EUR)',
            'Subscription plans without proper interval settings',
            'Donation questions without suggested amounts'
          ]
        }
      },
      {
        id: 'test_payment_questions',
        title: 'Test Payment Questions',
        description: 'Preview and test your payment questions to ensure they work correctly',
        action_url: @context[:form_preview_url] || '/forms',
        action_text: 'Preview Form',
        estimated_minutes: 3,
        requirements: ['review_payment_questions'],
        validation_endpoint: '/api/v1/forms/test_payment_flow',
        help_content: {
          overview: 'Testing helps identify any remaining configuration issues.',
          steps: [
            'Use the form preview feature',
            'Go through the complete form flow',
            'Test each payment question type',
            'Verify that payment processing works correctly'
          ]
        }
      }
    ]
  end

  def generate_generic_recovery_workflow
    @recovery_steps = [
      {
        id: 'contact_support',
        title: 'Contact Support for Assistance',
        description: 'Get help from our support team to resolve this payment setup issue',
        action_url: '/support',
        action_text: 'Contact Support',
        estimated_minutes: 1,
        requirements: [],
        validation_endpoint: nil,
        help_content: {
          overview: 'Our support team can help resolve complex payment setup issues.',
          steps: [
            'Click "Contact Support" below',
            'Describe your payment setup issue',
            'Include your error type and any relevant details',
            'Wait for a response from our support team'
          ]
        }
      }
    ]
  end

  def calculate_estimated_time
    @recovery_steps.sum { |step| step[:estimated_minutes] || 0 }
  end

  def generate_completion_url
    @context[:return_url] || '/forms'
  end

  def track_recovery_initiation
    if defined?(Rails.cache)
      Rails.cache.write(
        "payment_recovery_started:#{@user.id}:#{@error.error_type}",
        {
          started_at: Time.current,
          error_type: @error.error_type,
          total_steps: @recovery_steps.length
        },
        expires_in: 1.hour
      )
    end

    if window_analytics_available?
      # This would be called from the frontend
      Rails.logger.info "Payment error recovery initiated for user #{@user.id}, error: #{@error.error_type}"
    end
  end

  def window_analytics_available?
    # This is a placeholder - in reality, analytics tracking would happen on the frontend
    false
  end
end
</file>

<file path="services/payment_fallback_validation_service.rb">
# frozen_string_literal: true

# Service for fallback payment validation when background jobs fail
# Provides synchronous validation as a backup to async job processing
class PaymentFallbackValidationService < ApplicationService
  def initialize(form:, user: nil)
    @form = form
    @user = user || form.user
    @validation_errors = []
    @required_actions = []
  end

  def call
    Rails.logger.info "Starting fallback payment validation for form #{@form.id}"
    
    begin
      validate_form_payment_requirements
      validate_user_payment_setup
      validate_payment_question_configuration
      
      if @validation_errors.any?
        create_validation_error
      else
        success_result
      end
    rescue StandardError => e
      Rails.logger.error "Fallback validation failed: #{e.message}"
      Rails.logger.error e.backtrace.join("\n")
      
      # Return a generic error if fallback validation itself fails
      error_result(
        message: 'Payment validation could not be completed',
        errors: ['validation_system_error'],
        actions: [{ type: 'contact_support', url: '/support', text: 'Contact Support' }]
      )
    end
  end

  private

  attr_reader :form, :user, :validation_errors, :required_actions

  def validate_form_payment_requirements
    return unless form_has_payment_questions?

    Rails.logger.debug "Form has payment questions, validating requirements"
    
    # Check if form is properly configured for payments
    unless form.payment_enabled?
      add_validation_error(
        type: 'payment_not_enabled',
        title: 'Payment functionality not enabled',
        description: 'Form contains payment questions but payment functionality is not enabled'
      )
    end

    # Validate payment question configuration
    validate_payment_questions_structure
  end

  def validate_user_payment_setup
    return unless form_has_payment_questions?

    Rails.logger.debug "Validating user payment setup"
    
    # Check Stripe configuration
    unless user_has_stripe_configured?
      add_validation_error(
        type: 'stripe_not_configured',
        title: 'Stripe configuration required',
        description: 'Stripe must be configured to process payments'
      )
      add_required_action('configure_stripe', '/stripe_settings', 'Configure Stripe')
    end

    # Check Premium subscription
    unless user_has_premium_access?
      add_validation_error(
        type: 'premium_subscription_required',
        title: 'Premium subscription required',
        description: 'Payment features require a Premium subscription'
      )
      add_required_action('upgrade_subscription', '/subscription_management', 'Upgrade to Premium')
    end
  end

  def validate_payment_question_configuration
    return unless form_has_payment_questions?

    Rails.logger.debug "Validating payment question configuration"
    
    payment_questions = form.form_questions.where(question_type: payment_question_types)
    
    payment_questions.each do |question|
      validate_individual_payment_question(question)
    end
  end

  def validate_individual_payment_question(question)
    question_config = question.configuration || {}
    
    # Validate required payment fields
    case question.question_type
    when 'payment'
      validate_payment_question_config(question, question_config)
    when 'subscription'
      validate_subscription_question_config(question, question_config)
    when 'donation'
      validate_donation_question_config(question, question_config)
    end
  end

  def validate_payment_question_config(question, config)
    if config['amount'].blank? && config['allow_custom_amount'] != true
      add_validation_error(
        type: 'payment_question_configuration',
        title: 'Payment amount not configured',
        description: "Payment question '#{question.title}' must have an amount or allow custom amounts"
      )
    end

    if config['currency'].blank?
      add_validation_error(
        type: 'payment_question_configuration',
        title: 'Payment currency not configured',
        description: "Payment question '#{question.title}' must specify a currency"
      )
    end
  end

  def validate_subscription_question_config(question, config)
    if config['plans'].blank? || !config['plans'].is_a?(Array) || config['plans'].empty?
      add_validation_error(
        type: 'payment_question_configuration',
        title: 'Subscription plans not configured',
        description: "Subscription question '#{question.title}' must have at least one plan configured"
      )
    end

    config['plans']&.each_with_index do |plan, index|
      if plan['amount'].blank? || plan['interval'].blank?
        add_validation_error(
          type: 'payment_question_configuration',
          title: 'Incomplete subscription plan',
          description: "Plan #{index + 1} in '#{question.title}' is missing amount or interval"
        )
      end
    end
  end

  def validate_donation_question_config(question, config)
    if config['suggested_amounts'].blank? && config['allow_custom_amount'] != true
      add_validation_error(
        type: 'payment_question_configuration',
        title: 'Donation amounts not configured',
        description: "Donation question '#{question.title}' must have suggested amounts or allow custom amounts"
      )
    end
  end

  def form_has_payment_questions?
    @form_has_payment_questions ||= form.form_questions.where(question_type: payment_question_types).exists?
  end

  def payment_question_types
    %w[payment subscription donation]
  end

  def user_has_stripe_configured?
    return false unless user.stripe_account_id.present?
    return false unless user.stripe_publishable_key.present?
    
    # Additional checks could be added here for webhook configuration, etc.
    true
  end

  def user_has_premium_access?
    user.premium? || user.subscription_tier == 'premium' || user.subscription_tier == 'pro'
  end

  def add_validation_error(type:, title:, description:)
    @validation_errors << {
      type: type,
      title: title,
      description: description
    }
  end

  def add_required_action(action_type, url, text)
    @required_actions << {
      type: action_type,
      url: url,
      text: text
    }
  end

  def create_validation_error
    primary_error = @validation_errors.first
    error_type = primary_error[:type]

    case error_type
    when 'stripe_not_configured'
      raise PaymentValidationErrors.stripe_not_configured(
        additional_actions: @required_actions.map { |a| a[:type] }
      )
    when 'premium_subscription_required'
      raise PaymentValidationErrors.premium_required(
        additional_actions: @required_actions.map { |a| a[:type] }
      )
    when 'payment_question_configuration'
      raise PaymentValidationErrors.invalid_payment_configuration(
        details: @validation_errors.map { |e| e[:description] },
        additional_actions: @required_actions.map { |a| a[:type] }
      )
    else
      # Multiple errors or unknown error type
      missing_requirements = @validation_errors.map { |e| e[:type] }.uniq
      raise PaymentValidationErrors.multiple_requirements(
        missing_requirements,
        additional_actions: @required_actions.map { |a| a[:type] }
      )
    end
  end

  def success_result
    success(
      message: 'Payment validation completed successfully',
      validation_status: 'passed',
      errors: [],
      actions: []
    )
  end

  def error_result(message:, errors:, actions:)
    error(
      message: message,
      validation_status: 'failed',
      errors: errors,
      actions: actions
    )
  end

  # Class method for quick validation check
  def self.validate_form_payment_setup(form)
    new(form: form).call
  end

  # Class method for validating multiple forms
  def self.validate_multiple_forms(forms)
    results = {}
    
    forms.each do |form|
      begin
        results[form.id] = validate_form_payment_setup(form)
      rescue PaymentValidationError => e
        results[form.id] = {
          success: false,
          error: e.to_hash,
          form_id: form.id
        }
      rescue StandardError => e
        Rails.logger.error "Unexpected error validating form #{form.id}: #{e.message}"
        results[form.id] = {
          success: false,
          error: {
            error_type: 'validation_system_error',
            message: 'Validation system error',
            required_actions: ['contact_support']
          },
          form_id: form.id
        }
      end
    end
    
    results
  end
end
</file>

<file path="services/payment_readiness_checker.rb">
# frozen_string_literal: true

class PaymentReadinessChecker < ApplicationService
  attribute :form, default: nil
  attribute :user, default: nil

  def call
    validate_service_inputs
    return self if failure?

    perform_comprehensive_readiness_check
    self
  end

  private

  def validate_service_inputs
    # Form is required, user can be derived from form
    validate_required_attributes(:form)
    
    unless form.is_a?(Form)
      add_error(:form, 'must be a Form instance')
      return
    end

    # Set user from form if not provided
    self.user = form.user if user.nil?
    
    unless user.is_a?(User)
      add_error(:user, 'must be a User instance')
    end
  end

  def perform_comprehensive_readiness_check
    readiness_results = {
      ready: true,
      errors: [],
      actions: [],
      checks_performed: [],
      form_id: form.id,
      user_id: user.id,
      checked_at: Time.current
    }

    # Perform all readiness checks
    check_payment_questions_presence(readiness_results)
    check_user_subscription_status(readiness_results)
    check_stripe_configuration(readiness_results)
    check_payment_questions_configuration(readiness_results)
    check_webhook_configuration(readiness_results)
    check_form_publish_eligibility(readiness_results)

    # Set overall readiness status
    readiness_results[:ready] = readiness_results[:errors].empty?

    # Generate recovery actions if not ready
    if readiness_results[:errors].any?
      generate_recovery_actions(readiness_results)
    end

    set_result(readiness_results)
    set_context(:checks_count, readiness_results[:checks_performed].length)
    set_context(:errors_count, readiness_results[:errors].length)
  end

  def check_payment_questions_presence(results)
    results[:checks_performed] << 'payment_questions_presence'

    return unless form.has_payment_questions?

    payment_questions_count = form.payment_questions.count
    
    if payment_questions_count.zero?
      # This shouldn't happen if has_payment_questions? is true, but defensive check
      results[:errors] << {
        type: 'no_payment_questions',
        severity: 'info',
        message: 'No payment questions detected in form'
      }
    else
      set_context(:payment_questions_count, payment_questions_count)
    end
  end

  def check_user_subscription_status(results)
    results[:checks_performed] << 'user_subscription_status'

    return unless form.has_payment_questions?

    unless user.premium?
      results[:errors] << {
        type: 'premium_subscription_required',
        severity: 'high',
        message: 'Premium subscription required for payment features',
        current_tier: user.subscription_tier,
        required_tier: 'premium'
      }
    end
  end

  def check_stripe_configuration(results)
    results[:checks_performed] << 'stripe_configuration'

    return unless form.has_payment_questions?

    stripe_status = StripeConfigurationChecker.configuration_status(user)
    
    unless stripe_status[:configured]
      results[:errors] << {
        type: 'stripe_not_configured',
        severity: 'high',
        message: 'Stripe configuration incomplete',
        missing_elements: stripe_status[:missing_elements] || [],
        configuration_url: '/stripe_settings'
      }
    end
  end

  def check_payment_questions_configuration(results)
    results[:checks_performed] << 'payment_questions_configuration'

    return unless form.has_payment_questions?

    form.payment_questions.each do |question|
      question_errors = validate_payment_question_configuration(question)
      
      question_errors.each do |error|
        results[:errors] << {
          type: 'payment_question_invalid',
          severity: 'high',
          message: "Payment question '#{question.title}' has configuration issues",
          question_id: question.id,
          question_title: question.title,
          validation_error: error
        }
      end
    end
  end

  def check_webhook_configuration(results)
    results[:checks_performed] << 'webhook_configuration'

    return unless form.has_payment_questions?

    # Check if webhooks are properly configured for payment processing
    webhook_status = check_stripe_webhooks

    unless webhook_status[:configured]
      results[:errors] << {
        type: 'webhook_configuration_incomplete',
        severity: 'medium',
        message: 'Webhook configuration incomplete for payment processing',
        issues: webhook_status[:issues] || [],
        setup_url: '/stripe_settings/webhooks'
      }
    end
  end

  def check_form_publish_eligibility(results)
    results[:checks_performed] << 'form_publish_eligibility'

    # Check if form meets basic publishing requirements
    if form.name.blank?
      results[:errors] << {
        type: 'form_name_missing',
        severity: 'high',
        message: 'Form name is required for publishing'
      }
    end

    if form.form_questions.empty?
      results[:errors] << {
        type: 'no_questions',
        severity: 'high',
        message: 'Form must have at least one question to be published'
      }
    end

    # Check if form is already published
    if form.published?
      results[:errors] << {
        type: 'already_published',
        severity: 'info',
        message: 'Form is already published'
      }
    end
  end

  def validate_payment_question_configuration(question)
    errors = []
    config = question.question_config || {}

    # Required fields for payment questions
    required_fields = %w[amount currency description]
    
    required_fields.each do |field|
      if config[field].blank?
        errors << "Missing required field: #{field}"
      end
    end

    # Validate amount format
    if config['amount'].present?
      begin
        amount = Float(config['amount'])
        if amount <= 0
          errors << "Amount must be greater than 0"
        end
      rescue ArgumentError
        errors << "Amount must be a valid number"
      end
    end

    # Validate currency format
    if config['currency'].present?
      unless config['currency'].match?(/\A[A-Z]{3}\z/)
        errors << "Currency must be a valid 3-letter ISO code (e.g., USD, EUR)"
      end
    end

    # Validate description length
    if config['description'].present? && config['description'].length > 500
      errors << "Description must be 500 characters or less"
    end

    errors
  end

  def check_stripe_webhooks
    # Basic webhook configuration check
    # This would be expanded with actual Stripe webhook validation
    {
      configured: user.stripe_webhook_secret.present?,
      issues: user.stripe_webhook_secret.present? ? [] : ['Webhook secret not configured']
    }
  end

  def generate_recovery_actions(results)
    # Group errors by type and generate appropriate actions
    error_types = results[:errors].map { |error| error[:type] }.uniq

    error_types.each do |error_type|
      action = case error_type
               when 'premium_subscription_required'
                 {
                   type: 'upgrade_subscription',
                   title: 'Upgrade to Premium',
                   description: 'Unlock payment features',
                   url: '/subscription_management',
                   priority: 'high'
                 }
               when 'stripe_not_configured'
                 {
                   type: 'configure_stripe',
                   title: 'Configure Stripe',
                   description: 'Set up payment processing',
                   url: '/stripe_settings',
                   priority: 'high'
                 }
               when 'payment_question_invalid'
                 {
                   type: 'fix_payment_questions',
                   title: 'Fix Payment Questions',
                   description: 'Complete payment question configuration',
                   url: "/forms/#{form.id}/edit",
                   priority: 'high'
                 }
               when 'webhook_configuration_incomplete'
                 {
                   type: 'configure_webhooks',
                   title: 'Configure Webhooks',
                   description: 'Set up payment notifications',
                   url: '/stripe_settings/webhooks',
                   priority: 'medium'
                 }
               when 'form_name_missing'
                 {
                   type: 'add_form_name',
                   title: 'Add Form Name',
                   description: 'Give your form a name',
                   url: "/forms/#{form.id}/edit",
                   priority: 'high'
                 }
               when 'no_questions'
                 {
                   type: 'add_questions',
                   title: 'Add Questions',
                   description: 'Add questions to your form',
                   url: "/forms/#{form.id}/edit",
                   priority: 'high'
                 }
               end

      results[:actions] << action if action
    end

    # Remove duplicate actions
    results[:actions].uniq! { |action| action[:type] }
  end
end
</file>

<file path="services/payment_requirement_detector.rb">
class PaymentRequirementDetector
  PAYMENT_QUESTION_TYPES = %w[payment subscription donation].freeze
  
  def self.detect_in_template(template)
    return false unless template.respond_to?(:questions_config)
    
    template.questions_config.any? { |question| payment_question?(question) }
  end
  
  def self.payment_question?(question_config)
    return false unless question_config.is_a?(Hash)
    
    question_type = question_config['question_type'] || question_config[:question_type]
    PAYMENT_QUESTION_TYPES.include?(question_type)
  end
  
  def self.required_features_for_questions(questions)
    features = Set.new
    
    questions.each do |question|
      question_features = required_features_for_question_type(question['question_type'])
      features.merge(question_features)
    end
    
    features.to_a
  end
  
  def self.required_features_for_question_type(question_type)
    case question_type
    when 'payment'
      ['stripe_payments', 'premium_subscription']
    when 'subscription'
      ['stripe_payments', 'premium_subscription', 'recurring_payments']
    when 'donation'
      ['stripe_payments', 'donation_processing']
    else
      []
    end
  end
end
</file>

<file path="services/payment_setup_validation_service.rb">
# frozen_string_literal: true

class PaymentSetupValidationService < ApplicationService
  include PaymentAnalyticsTrackable
  
  attribute :user, default: nil
  attribute :required_features, default: -> { [] }
  attribute :track_analytics, default: true

  def call
    validate_service_inputs
    return self if failure?

    validate_user_requirements
    track_setup_events if track_analytics
    self
  end

  private

  def validate_service_inputs
    validate_required_attributes(:user)
    
    unless user.is_a?(User)
      add_error(:user, 'must be a User instance')
    end

    unless required_features.is_a?(Array)
      add_error(:required_features, 'must be an array')
    end
  end

  def validate_user_requirements
    validation_results = {
      valid: true,
      missing_requirements: [],
      setup_actions: [],
      user_id: user.id,
      validated_at: Time.current
    }

    # Check each required feature
    required_features.each do |feature|
      case feature
      when 'stripe_payments'
        validate_stripe_configuration(validation_results)
      when 'premium_subscription'
        validate_subscription_level(validation_results)
      when 'subscription_management'
        validate_subscription_management(validation_results)
      when 'webhook_configuration'
        validate_webhook_configuration(validation_results)
      end
    end

    # Generate setup actions for missing requirements
    generate_setup_actions(validation_results)

    # Set overall validity
    validation_results[:valid] = validation_results[:missing_requirements].empty?

    set_result(validation_results)
    set_context(:features_validated, required_features.length)
    set_context(:requirements_missing, validation_results[:missing_requirements].length)
  end

  def validate_stripe_configuration(validation_results)
    unless user.stripe_configured?
      validation_results[:missing_requirements] << {
        type: 'stripe_configuration',
        title: 'Stripe Configuration Required',
        description: 'Configure Stripe to accept payments',
        details: ['Stripe keys not configured'],
        priority: 'high'
      }
    end
  end

  def validate_subscription_level(validation_results)
    unless user.premium?
      validation_results[:missing_requirements] << {
        type: 'premium_subscription',
        title: 'Premium Subscription Required',
        description: 'Upgrade to Premium to use payment features',
        current_tier: user.subscription_tier,
        required_tier: 'premium',
        priority: 'high'
      }
    end
  end

  def validate_subscription_management(validation_results)
    # Check if user has subscription management capabilities
    unless user.premium? && user.stripe_configured?
      validation_results[:missing_requirements] << {
        type: 'subscription_management',
        title: 'Subscription Management Setup',
        description: 'Configure recurring payment and subscription settings',
        dependencies: ['premium_subscription', 'stripe_configuration'],
        priority: 'medium'
      }
    end
  end

  def validate_webhook_configuration(validation_results)
    # Check webhook configuration - required regardless of current Stripe status
    webhook_status = check_webhook_configuration
    
    unless webhook_status[:configured]
      validation_results[:missing_requirements] << {
        type: 'webhook_configuration',
        title: 'Webhook Configuration',
        description: 'Configure webhooks for payment status updates',
        details: webhook_status[:issues],
        priority: 'medium'
      }
    end
  end

  def generate_setup_actions(validation_results)
    validation_results[:missing_requirements].each do |requirement|
      action = case requirement[:type]
               when 'stripe_configuration'
                 generate_stripe_setup_action
               when 'premium_subscription'
                 generate_subscription_upgrade_action
               when 'subscription_management'
                 generate_subscription_management_action
               when 'webhook_configuration'
                 generate_webhook_setup_action
               end
      
      validation_results[:setup_actions] << action if action
    end
  end

  def generate_stripe_setup_action
    {
      type: 'stripe_setup',
      title: 'Configure Stripe Payments',
      description: 'Set up your Stripe account to accept payments',
      action_url: '/stripe_settings',
      action_text: 'Configure Stripe',
      estimated_time: '5-10 minutes',
      priority: 'high'
    }
  end

  def generate_subscription_upgrade_action
    {
      type: 'subscription_upgrade',
      title: 'Upgrade to Premium',
      description: 'Unlock payment features with a Premium subscription',
      action_url: '/subscription_management',
      action_text: 'Upgrade Now',
      estimated_time: '2-3 minutes',
      priority: 'high'
    }
  end

  def generate_subscription_management_action
    {
      type: 'subscription_management_setup',
      title: 'Configure Subscription Management',
      description: 'Set up recurring payment and subscription options',
      action_url: '/subscription_management/setup',
      action_text: 'Configure Subscriptions',
      estimated_time: '3-5 minutes',
      priority: 'medium',
      dependencies: ['stripe_setup', 'subscription_upgrade']
    }
  end

  def generate_webhook_setup_action
    {
      type: 'webhook_setup',
      title: 'Configure Payment Webhooks',
      description: 'Set up webhooks for real-time payment notifications',
      action_url: '/stripe_settings/webhooks',
      action_text: 'Configure Webhooks',
      estimated_time: '2-3 minutes',
      priority: 'medium'
    }
  end

  def check_webhook_configuration
    # Basic webhook configuration check
    # This would be expanded with actual Stripe webhook validation
    {
      configured: user.stripe_webhook_secret.present?,
      issues: user.stripe_webhook_secret.present? ? [] : ['Webhook secret not configured']
    }
  end

  def track_setup_events
    validation_result = result
    
    if validation_result[:valid]
      track_payment_event(
        'payment_setup_completed',
        user: user,
        context: {
          required_features: required_features,
          setup_completion_time: Time.current,
          features_validated: required_features.length
        }
      )
    elsif validation_result[:missing_requirements].any?
      track_payment_event(
        'payment_setup_started',
        user: user,
        context: {
          required_features: required_features,
          missing_requirements: validation_result[:missing_requirements].map { |req| req[:type] },
          setup_actions_count: validation_result[:setup_actions].length
        }
      )
    end
  end
end
</file>

<file path="services/redis_error_logger.rb">
# frozen_string_literal: true

# RedisErrorLogger - Centralized Redis error logging service
# Provides comprehensive error logging for all Redis operations across the application
# Includes context information, masked connection details, and Sentry integration
class RedisErrorLogger
  include ActiveSupport::Configurable
  
  # Error severity levels
  SEVERITY_LEVELS = {
    debug: 0,
    info: 1,
    warn: 2,
    error: 3,
    fatal: 4
  }.freeze
  
  # Redis error types for categorization
  REDIS_ERROR_TYPES = {
    connection: [
      'Redis::CannotConnectError',
      'Redis::ConnectionError',
      'Redis::TimeoutError',
      'Redis::ReadOnlyError'
    ].freeze,
    command: [
      'Redis::CommandError',
      'Redis::WrongTypeError',
      'Redis::OutOfMemoryError'
    ].freeze,
    protocol: [
      'Redis::ProtocolError',
      'Redis::ParserError'
    ].freeze,
    client: [
      'Redis::ClientError',
      'Redis::InheritedError'
    ].freeze
  }.freeze
  
  class << self
    # Main entry point for logging Redis errors
    # @param exception [Exception] The Redis-related exception
    # @param context [Hash] Additional context information
    # @param severity [Symbol] Log severity level (:debug, :info, :warn, :error, :fatal)
    def log_redis_error(exception, context = {}, severity: :error)
      return unless should_log?(exception, severity)
      
      error_data = build_error_data(exception, context)
      log_to_rails_logger(error_data, severity)
      send_to_sentry(exception, error_data) if should_send_to_sentry?(severity)
      track_error_metrics(error_data)
      
      error_data
    end
    
    # Log Redis connection errors specifically
    def log_connection_error(exception, context = {})
      enhanced_context = context.merge({
        error_category: 'connection',
        redis_url_masked: mask_redis_url(current_redis_url),
        ssl_enabled: ssl_enabled?,
        environment: Rails.env,
        timestamp: Time.current.iso8601
      })
      
      log_redis_error(exception, enhanced_context, severity: :error)
    end
    
    # Log Redis command errors
    def log_command_error(exception, context = {})
      enhanced_context = context.merge({
        error_category: 'command',
        redis_url_masked: mask_redis_url(current_redis_url),
        timestamp: Time.current.iso8601
      })
      
      log_redis_error(exception, enhanced_context, severity: :warn)
    end
    
    # Log Redis operation warnings (non-critical issues)
    def log_redis_warning(message, context = {})
      warning_data = {
        message: message,
        context: context,
        redis_url_masked: mask_redis_url(current_redis_url),
        ssl_enabled: ssl_enabled?,
        environment: Rails.env,
        timestamp: Time.current.iso8601,
        severity: 'warning'
      }
      
      Rails.logger.warn format_log_message(warning_data)
      track_warning_metrics(warning_data)
    end
    
    # Log Redis operation info (successful operations, monitoring)
    def log_redis_info(message, context = {})
      info_data = {
        message: message,
        context: context,
        redis_url_masked: mask_redis_url(current_redis_url),
        timestamp: Time.current.iso8601,
        severity: 'info'
      }
      
      Rails.logger.info format_log_message(info_data)
    end
    
    # Log Redis connection recovery
    def log_connection_recovery(context = {})
      recovery_data = {
        message: 'Redis connection recovered successfully',
        context: context,
        redis_url_masked: mask_redis_url(current_redis_url),
        ssl_enabled: ssl_enabled?,
        environment: Rails.env,
        timestamp: Time.current.iso8601,
        event_type: 'connection_recovery'
      }
      
      Rails.logger.info format_log_message(recovery_data)
      
      if defined?(Sentry)
        Sentry.capture_message(
          'Redis connection recovered',
          level: :info,
          extra: recovery_data
        )
      end
    end
    
    # Test Redis connection and log results
    def test_and_log_connection(component: 'unknown')
      start_time = Time.current
      
      begin
        # Test basic Redis connectivity using proper SSL configuration
        case component
        when 'sidekiq'
          if defined?(Sidekiq)
            Sidekiq.redis(&:ping)
          else
            Redis.new(RedisConfig.sidekiq_config).ping
          end
        when 'cache'
          if Rails.cache.respond_to?(:redis)
            Rails.cache.redis.ping
          else
            Redis.new(RedisConfig.cache_config).ping
          end
        when 'actioncable'
          Redis.new(RedisConfig.cable_config).ping
        else
          # Generic Redis test using RedisConfig
          Redis.new(RedisConfig.connection_config).ping
        end
        
        duration = Time.current - start_time
        
        log_redis_info("Redis connection test successful for #{component}", {
          component: component,
          duration_ms: (duration * 1000).round(2),
          test_type: 'connectivity'
        })
        
        true
      rescue => e
        duration = Time.current - start_time
        
        log_connection_error(e, {
          component: component,
          duration_ms: (duration * 1000).round(2),
          test_type: 'connectivity',
          operation: 'connection_test'
        })
        
        false
      end
    end
    
    # Get Redis connection diagnostics
    def get_connection_diagnostics
      diagnostics = {
        redis_url_masked: mask_redis_url(current_redis_url),
        ssl_enabled: ssl_enabled?,
        environment: Rails.env,
        timestamp: Time.current.iso8601
      }
      
      begin
        # Try to get Redis info
        redis_info = get_redis_info
        diagnostics.merge!(redis_info)
      rescue => e
        diagnostics[:connection_error] = e.message
        diagnostics[:connection_status] = 'failed'
      end
      
      diagnostics
    end
    
    private
    
    # Build comprehensive error data structure
    def build_error_data(exception, context)
      {
        error_class: exception.class.name,
        error_message: exception.message,
        error_category: categorize_error(exception),
        context: context,
        redis_url_masked: mask_redis_url(current_redis_url),
        ssl_enabled: ssl_enabled?,
        environment: Rails.env,
        timestamp: Time.current.iso8601,
        backtrace: format_backtrace(exception),
        redis_diagnostics: get_safe_redis_diagnostics
      }
    end
    
    # Determine if error should be logged based on severity and configuration
    def should_log?(exception, severity)
      # In test environment, check if Redis error logging is explicitly enabled
      if Rails.env.test?
        return false unless Rails.application.config.respond_to?(:log_redis_errors_in_test) &&
                           Rails.application.config.log_redis_errors_in_test
      end
      
      # Always log errors and fatal
      return true if [:error, :fatal].include?(severity)
      
      # Log warnings in production and development, or in test when enabled
      return true if severity == :warn && (
        !Rails.env.test? || 
        (Rails.application.config.respond_to?(:log_redis_errors_in_test) && 
         Rails.application.config.log_redis_errors_in_test)
      )
      
      # Log info and debug only in development or when explicitly enabled
      [:info, :debug].include?(severity) && 
        (Rails.env.development? || 
         (Rails.application.config.respond_to?(:verbose_redis_logging) && 
          Rails.application.config.verbose_redis_logging))
    end
    
    # Determine if error should be sent to Sentry
    def should_send_to_sentry?(severity)
      defined?(Sentry) && [:error, :fatal].include?(severity)
    end
    
    # Categorize Redis errors by type
    def categorize_error(exception)
      error_class = exception.class.name
      
      REDIS_ERROR_TYPES.each do |category, error_classes|
        return category.to_s if error_classes.include?(error_class)
      end
      
      'unknown'
    end
    
    # Format error message for Rails logger
    def format_log_message(data)
      severity_text = case data[:severity]
                     when 'info'
                       'INFO'
                     when 'warning'
                       'WARNING'
                     when 'debug'
                       'DEBUG'
                     when 'fatal'
                       'FATAL'
                     else
                       'ERROR'
                     end
      
      message_parts = [
        "Redis #{severity_text}:",
        data[:error_message] || data[:message]
      ]
      
      if data[:context] && !data[:context].empty?
        message_parts << "Context: #{data[:context].inspect}"
      end
      
      if data[:redis_url_masked]
        message_parts << "Redis URL: #{data[:redis_url_masked]}"
      end
      
      if data[:error_category]
        message_parts << "Category: #{data[:error_category]}"
      end
      
      message_parts.join(' | ')
    end
    
    # Log to Rails logger with appropriate severity
    def log_to_rails_logger(error_data, severity)
      formatted_message = format_log_message(error_data)
      
      case severity
      when :debug
        Rails.logger.debug formatted_message
      when :info
        Rails.logger.info formatted_message
      when :warn
        Rails.logger.warn formatted_message
      when :error
        Rails.logger.error formatted_message
      when :fatal
        Rails.logger.fatal formatted_message
      end
      
      # Log additional context in debug mode
      if Rails.env.development? || Rails.logger.level <= Logger::DEBUG
        Rails.logger.debug "Redis Error Details: #{error_data.except(:backtrace).to_json}"
        
        if error_data[:backtrace]
          Rails.logger.debug "Redis Error Backtrace:\n#{error_data[:backtrace]}"
        end
      end
    end
    
    # Send error to Sentry with enhanced context
    def send_to_sentry(exception, error_data)
      Sentry.capture_exception(exception, extra: error_data.except(:backtrace))
    end
    
    # Track error metrics for monitoring
    def track_error_metrics(error_data)
      # This could be extended to send metrics to monitoring services
      # For now, we'll just increment Rails cache-based counters
      
      begin
        cache_key = "redis_errors:#{Date.current}:#{error_data[:error_category]}"
        current_count = Rails.cache.read(cache_key) || 0
        Rails.cache.write(cache_key, current_count + 1, expires_in: 7.days)
        
        total_cache_key = "redis_errors:#{Date.current}:total"
        total_count = Rails.cache.read(total_cache_key) || 0
        Rails.cache.write(total_cache_key, total_count + 1, expires_in: 7.days)
      rescue
        # Ignore cache errors when tracking Redis errors to avoid recursion
      end
    end
    
    # Track warning metrics
    def track_warning_metrics(warning_data)
      begin
        cache_key = "redis_warnings:#{Date.current}"
        current_count = Rails.cache.read(cache_key) || 0
        Rails.cache.write(cache_key, current_count + 1, expires_in: 7.days)
      rescue
        # Ignore cache errors
      end
    end
    
    # Get current Redis URL from configuration
    def current_redis_url
      ENV.fetch('REDIS_URL', 'redis://localhost:6379/0')
    end
    
    # Check if SSL is enabled
    def ssl_enabled?
      current_redis_url.start_with?('rediss://')
    end
    
    # Mask sensitive information in Redis URL
    def mask_redis_url(url)
      return url unless url&.include?('@')
      
      # Replace password with asterisks
      url.gsub(/:[^:@]*@/, ':***@')
    end
    
    # Format exception backtrace for logging
    def format_backtrace(exception)
      return nil unless exception.backtrace
      
      # Limit backtrace to first 10 lines to avoid log spam
      exception.backtrace.first(10).join("\n")
    end
    
    # Get Redis server information safely
    def get_redis_info
      info = {}
      
      begin
        # Try different Redis connection methods
        redis_client = if defined?(Sidekiq)
          Sidekiq.redis { |conn| conn }
        elsif Rails.cache.respond_to?(:redis)
          Rails.cache.redis
        else
          Redis.new(url: current_redis_url)
        end
        
        server_info = redis_client.info
        
        info.merge!({
          redis_version: server_info['redis_version'],
          connected_clients: server_info['connected_clients'],
          used_memory_human: server_info['used_memory_human'],
          uptime_in_seconds: server_info['uptime_in_seconds'],
          connection_status: 'connected'
        })
      rescue => e
        info.merge!({
          connection_status: 'failed',
          connection_error: e.message
        })
      end
      
      info
    end
    
    # Get Redis diagnostics safely (won't raise exceptions)
    def get_safe_redis_diagnostics
      begin
        get_redis_info
      rescue
        {
          connection_status: 'unknown',
          diagnostic_error: 'Unable to retrieve Redis diagnostics'
        }
      end
    end
  end
end
</file>

<file path="services/service_object.rb">
# frozen_string_literal: true

# Base module for service objects
module ServiceObject
  extend ActiveSupport::Concern

  included do
    def self.call(*args, **kwargs)
      new(*args, **kwargs).call
    end
  end

  class_methods do
    def call(*args, **kwargs)
      new(*args, **kwargs).call
    end
  end
end

# Service result object for consistent return values
class ServiceResult
  attr_reader :result, :errors

  def initialize(success:, result: nil, errors: [])
    @success = success
    @result = result
    @errors = Array(errors)
  end

  def success?
    @success
  end

  def failure?
    !@success
  end

  def self.success(result = nil)
    new(success: true, result: result)
  end

  def self.failure(errors)
    new(success: false, errors: errors)
  end
end
</file>

<file path="services/stripe_configuration_checker.rb">
# frozen_string_literal: true

class StripeConfigurationChecker
  # Check if user has complete Stripe configuration
  def self.configured?(user)
    return false unless user.is_a?(User)
    
    user.stripe_configured?
  end

  # Get detailed configuration status
  def self.configuration_status(user)
    return default_unconfigured_status unless user.is_a?(User)

    status = {
      configured: false,
      user_id: user.id,
      checked_at: Time.current,
      configuration_steps: {},
      missing_steps: [],
      overall_completion: 0
    }

    check_stripe_keys(user, status)
    check_stripe_account_status(user, status)
    check_webhook_configuration(user, status)
    check_payment_methods(user, status)

    calculate_completion_percentage(status)
    determine_overall_status(status)

    status
  end

  # Get specific missing configuration elements
  def self.missing_configuration_steps(user)
    return ['All Stripe configuration missing'] unless user.is_a?(User)

    status = configuration_status(user)
    status[:missing_steps]
  end

  # Check if user can accept live payments
  def self.can_accept_live_payments?(user)
    return false unless configured?(user)

    status = configuration_status(user)
    status[:configuration_steps][:stripe_keys] == 'complete' &&
      status[:configuration_steps][:account_status] == 'complete'
  end

  # Get configuration requirements for user
  def self.configuration_requirements(user)
    status = configuration_status(user)
    
    requirements = []
    
    status[:missing_steps].each do |step|
      requirement = case step
                   when 'stripe_keys'
                     stripe_keys_requirement
                   when 'account_verification'
                     account_verification_requirement
                   when 'webhook_setup'
                     webhook_setup_requirement
                   when 'payment_methods'
                     payment_methods_requirement
                   end
      
      requirements << requirement if requirement
    end

    requirements
  end

  # Validate Stripe API keys format
  def self.validate_stripe_keys(publishable_key, secret_key)
    errors = []

    if publishable_key.blank?
      errors << 'Publishable key is required'
    elsif !publishable_key.start_with?('pk_')
      errors << 'Publishable key must start with pk_'
    end

    if secret_key.blank?
      errors << 'Secret key is required'
    elsif !secret_key.start_with?('sk_')
      errors << 'Secret key must start with sk_'
    end

    # Check if keys are test or live
    test_mode = publishable_key&.include?('test') || secret_key&.include?('test')
    
    {
      valid: errors.empty?,
      errors: errors,
      test_mode: test_mode,
      live_mode: !test_mode && errors.empty?
    }
  end

  # Test Stripe connection
  def self.test_stripe_connection(user)
    return { success: false, error: 'User not configured for Stripe' } unless configured?(user)

    begin
      stripe_client = user.stripe_client
      return { success: false, error: 'Stripe client not available' } unless stripe_client

      # Test connection by retrieving account information
      account = stripe_client.accounts.retrieve
      
      {
        success: true,
        account_id: account.id,
        account_type: account.type,
        country: account.country,
        default_currency: account.default_currency,
        charges_enabled: account.charges_enabled,
        payouts_enabled: account.payouts_enabled,
        details_submitted: account.details_submitted
      }
    rescue Stripe::AuthenticationError => e
      { success: false, error: 'Invalid Stripe API keys', details: e.message }
    rescue Stripe::StripeError => e
      { success: false, error: 'Stripe API error', details: e.message }
    rescue StandardError => e
      { success: false, error: 'Connection test failed', details: e.message }
    end
  end

  private

  def self.default_unconfigured_status
    {
      configured: false,
      user_id: nil,
      checked_at: Time.current,
      configuration_steps: {},
      missing_steps: ['All configuration missing'],
      overall_completion: 0
    }
  end

  def self.check_stripe_keys(user, status)
    if user.stripe_publishable_key.present? && user.stripe_secret_key.present?
      # Validate key format
      validation = validate_stripe_keys(user.stripe_publishable_key, user.decrypt_stripe_secret_key)
      
      if validation[:valid]
        status[:configuration_steps][:stripe_keys] = 'complete'
      else
        status[:configuration_steps][:stripe_keys] = 'invalid'
        status[:missing_steps] << 'stripe_keys'
      end
    else
      status[:configuration_steps][:stripe_keys] = 'missing'
      status[:missing_steps] << 'stripe_keys'
    end
  end

  def self.check_stripe_account_status(user, status)
    if user.stripe_configured?
      connection_test = test_stripe_connection(user)
      
      if connection_test[:success]
        if connection_test[:charges_enabled] && connection_test[:details_submitted]
          status[:configuration_steps][:account_status] = 'complete'
        else
          status[:configuration_steps][:account_status] = 'incomplete'
          status[:missing_steps] << 'account_verification'
        end
      else
        status[:configuration_steps][:account_status] = 'error'
        status[:missing_steps] << 'account_verification'
      end
    else
      status[:configuration_steps][:account_status] = 'not_configured'
      status[:missing_steps] << 'account_verification'
    end
  end

  def self.check_webhook_configuration(user, status)
    if user.stripe_webhook_secret.present?
      status[:configuration_steps][:webhook_setup] = 'complete'
    else
      status[:configuration_steps][:webhook_setup] = 'missing'
      status[:missing_steps] << 'webhook_setup'
    end
  end

  def self.check_payment_methods(user, status)
    # For now, assume payment methods are configured if Stripe is set up
    # This could be expanded to check actual Stripe payment method configuration
    if user.stripe_configured?
      status[:configuration_steps][:payment_methods] = 'complete'
    else
      status[:configuration_steps][:payment_methods] = 'not_configured'
      status[:missing_steps] << 'payment_methods'
    end
  end

  def self.calculate_completion_percentage(status)
    total_steps = 4 # stripe_keys, account_status, webhook_setup, payment_methods
    completed_steps = status[:configuration_steps].count { |_, step_status| step_status == 'complete' }
    
    status[:overall_completion] = (completed_steps.to_f / total_steps * 100).round
  end

  def self.determine_overall_status(status)
    status[:configured] = status[:missing_steps].empty?
  end

  def self.stripe_keys_requirement
    {
      type: 'stripe_keys',
      title: 'Stripe API Keys',
      description: 'Configure your Stripe publishable and secret keys',
      action_url: '/stripe_settings',
      priority: 'high',
      estimated_time: '2-3 minutes'
    }
  end

  def self.account_verification_requirement
    {
      type: 'account_verification',
      title: 'Stripe Account Verification',
      description: 'Complete your Stripe account verification to accept payments',
      action_url: 'https://dashboard.stripe.com/account',
      external: true,
      priority: 'high',
      estimated_time: '10-15 minutes'
    }
  end

  def self.webhook_setup_requirement
    {
      type: 'webhook_setup',
      title: 'Webhook Configuration',
      description: 'Set up webhooks for payment status notifications',
      action_url: '/stripe_settings/webhooks',
      priority: 'medium',
      estimated_time: '3-5 minutes'
    }
  end

  def self.payment_methods_requirement
    {
      type: 'payment_methods',
      title: 'Payment Methods',
      description: 'Configure accepted payment methods in Stripe',
      action_url: 'https://dashboard.stripe.com/settings/payment_methods',
      external: true,
      priority: 'medium',
      estimated_time: '2-3 minutes'
    }
  end
end
</file>

<file path="services/stripe_payment_service.rb">
class StripePaymentService < ApplicationService

  def initialize(user:, form:, form_response:, payment_data:)
    @user = user
    @form = form
    @form_response = form_response
    @payment_data = payment_data
    @stripe_client = user.stripe_client
  end

  def call
    return failure('User does not have Stripe configured') unless @user.stripe_configured?
    return failure('User cannot accept payments') unless @user.can_accept_payments?
    return failure('Invalid payment data') unless valid_payment_data?

    begin
      create_payment_intent
    rescue Stripe::StripeError => e
      failure("Stripe error: #{e.message}")
    rescue StandardError => e
      failure("Payment processing error: #{e.message}")
    end
  end

  private

  def valid_payment_data?
    @payment_data[:amount].present? && 
    @payment_data[:amount].to_f > 0 &&
    @payment_data[:currency].present? &&
    @payment_data[:payment_method].present?
  end

  def create_payment_intent
    # Create payment intent with user's Stripe account
    payment_intent = @stripe_client.payment_intents.create(
      amount: amount_in_cents,
      currency: @payment_data[:currency].downcase,
      payment_method_types: [stripe_payment_method_type],
      metadata: payment_metadata,
      description: payment_description,
      receipt_email: @form_response.email_address,
      setup_future_usage: 'off_session' # For future payments if needed
    )

    # Create our payment transaction record
    transaction = create_payment_transaction(payment_intent)

    success(
      payment_intent: payment_intent,
      transaction: transaction,
      client_secret: payment_intent.client_secret
    )
  end

  def create_payment_transaction(payment_intent)
    PaymentTransaction.create!(
      user: @user,
      form: @form,
      form_response: @form_response,
      stripe_payment_intent_id: payment_intent.id,
      amount: @payment_data[:amount].to_f,
      currency: @payment_data[:currency].upcase,
      status: payment_intent.status,
      payment_method: @payment_data[:payment_method],
      metadata: {
        form_name: @form.name,
        form_response_id: @form_response.id,
        created_via: 'form_submission',
        stripe_payment_intent_id: payment_intent.id
      }
    )
  end

  def amount_in_cents
    (@payment_data[:amount].to_f * 100).to_i
  end

  def stripe_payment_method_type
    case @payment_data[:payment_method]
    when 'credit_card'
      'card'
    when 'apple_pay'
      'card' # Apple Pay uses card payment method type
    when 'google_pay'
      'card' # Google Pay uses card payment method type
    else
      'card'
    end
  end

  def payment_metadata
    {
      form_id: @form.id,
      form_name: @form.name,
      form_response_id: @form_response.id,
      user_id: @user.id,
      payment_source: 'agentform'
    }
  end

  def payment_description
    "Payment for #{@form.name} - AgentForm"
  end
end
</file>

<file path="services/subscription_management_service.rb">
require 'ostruct'

class SubscriptionManagementService
  include ActiveModel::Model
  include ActiveModel::Attributes

  attribute :user
  attribute :plan_type, :string, default: 'premium'

  PLANS = {
    'premium' => {
      name: 'Premium',
      price_monthly: 2900, # $29.00 in cents
      price_yearly: 29000, # $290.00 in cents (2 months free)
      features: [
        'Unlimited forms and responses',
        'Payment processing via Stripe',
        'Advanced AI features',
        'Priority support',
        'Custom branding removal',
        'Advanced analytics'
      ]
    }
  }.freeze

  def self.plans
    PLANS
  end

  def initialize(attributes = {})
    super
    @stripe_client = Stripe::StripeClient.new
  end

  # Create a new subscription
  def create_subscription(billing_cycle: 'monthly', discount_code: nil, success_url:, cancel_url:)
    return failure('User is required') unless user.present?
    return failure('User already has active subscription') if user_has_active_subscription?

    begin
      # Validate and process discount code if provided
      discount_data = nil
      if discount_code.present?
        discount_result = validate_and_prepare_discount(discount_code, billing_cycle)
        return discount_result unless discount_result.success?
        discount_data = discount_result.data
      end

      # Create or retrieve Stripe customer
      customer = find_or_create_stripe_customer

      # Get the appropriate price ID
      price_id = get_price_id(billing_cycle)
      return failure('Invalid billing cycle') unless price_id

      # Create checkout session
      session = create_checkout_session(
        customer: customer,
        price_id: price_id,
        discount_data: discount_data,
        success_url: success_url,
        cancel_url: cancel_url
      )

      success(checkout_url: session.url, session_id: session.id, discount_applied: discount_data.present?)
    rescue Stripe::StripeError => e
      failure("Stripe error: #{e.message}")
    rescue StandardError => e
      failure("Unexpected error: #{e.message}")
    end
  end

  # Cancel subscription
  def cancel_subscription(at_period_end: true)
    return failure('User has no active subscription') unless user_has_active_subscription?

    begin
      subscription = get_user_stripe_subscription
      return failure('No Stripe subscription found') unless subscription

      if at_period_end
        # Cancel at period end (user keeps access until billing period ends)
        updated_subscription = @stripe_client.subscriptions.update(
          subscription.id,
          { cancel_at_period_end: true }
        )
        
        user.update!(
          subscription_status: 'canceling',
          subscription_expires_at: Time.at(updated_subscription.current_period_end)
        )
        
        success(message: 'Subscription will be canceled at the end of the billing period')
      else
        # Cancel immediately
        @stripe_client.subscriptions.cancel(subscription.id)
        
        user.update!(
          subscription_status: 'canceled',
          subscription_tier: 'basic',
          subscription_expires_at: Time.current
        )
        
        success(message: 'Subscription canceled immediately')
      end
    rescue Stripe::StripeError => e
      failure("Stripe error: #{e.message}")
    end
  end

  # Reactivate a canceled subscription
  def reactivate_subscription
    return failure('User has no subscription to reactivate') unless user.stripe_customer_id.present?

    begin
      subscription = get_user_stripe_subscription
      return failure('No subscription found') unless subscription

      if subscription.cancel_at_period_end
        # Remove the cancellation
        updated_subscription = @stripe_client.subscriptions.update(
          subscription.id,
          { cancel_at_period_end: false }
        )
        
        user.update!(
          subscription_status: 'active',
          subscription_expires_at: nil
        )
        
        success(message: 'Subscription reactivated successfully')
      else
        failure('Subscription is not scheduled for cancellation')
      end
    rescue Stripe::StripeError => e
      failure("Stripe error: #{e.message}")
    end
  end

  # Update payment method
  def update_payment_method(success_url:, cancel_url:)
    return failure('User has no active subscription') unless user_has_active_subscription?

    begin
      customer = @stripe_client.customers.retrieve(user.stripe_customer_id)
      
      session = @stripe_client.checkout.sessions.create({
        customer: customer.id,
        payment_method_types: ['card'],
        mode: 'setup',
        success_url: success_url,
        cancel_url: cancel_url,
      })

      success(checkout_url: session.url, session_id: session.id)
    rescue Stripe::StripeError => e
      failure("Stripe error: #{e.message}")
    end
  end

  # Get subscription details
  def subscription_details
    # If user doesn't have a Stripe customer ID, they might be a manually upgraded user
    unless user.stripe_customer_id.present?
      return user.premium? ? manual_subscription_details : {}
    end

    begin
      subscription = get_user_stripe_subscription
      return user.premium? ? manual_subscription_details : {} unless subscription

      {
        status: subscription.status,
        current_period_start: Time.at(subscription.current_period_start),
        current_period_end: Time.at(subscription.current_period_end),
        cancel_at_period_end: subscription.cancel_at_period_end,
        canceled_at: subscription.canceled_at ? Time.at(subscription.canceled_at) : nil,
        plan_name: subscription.items.data.first&.price&.nickname || 'Premium',
        amount: subscription.items.data.first&.price&.unit_amount,
        currency: subscription.items.data.first&.price&.currency&.upcase,
        interval: subscription.items.data.first&.price&.recurring&.interval,
        source: 'stripe'
      }
    rescue Stripe::StripeError => e
      Rails.logger.error "Failed to get subscription details: #{e.message}"
      user.premium? ? manual_subscription_details : {}
    end
  end

  # Check if user has active subscription
  def user_has_active_subscription?
    # Simply check if user is premium - this covers both Stripe subscriptions and manual upgrades
    user.present? && user.premium?
  end

  private

  def manual_subscription_details
    {
      status: 'active',
      plan_name: 'Premium (Complimentary)',
      amount: 0,
      currency: 'USD',
      interval: 'month',
      source: 'manual'
    }
  end

  def find_or_create_stripe_customer
    if user.stripe_customer_id.present?
      @stripe_client.customers.retrieve(user.stripe_customer_id)
    else
      customer = @stripe_client.customers.create({
        email: user.email,
        name: user.full_name,
        metadata: {
          user_id: user.id,
          app: 'AgentForm'
        }
      })
      
      user.update!(stripe_customer_id: customer.id)
      customer
    end
  end

  def get_price_id(billing_cycle)
    case billing_cycle
    when 'monthly'
      Rails.application.credentials.stripe[:premium_monthly_price_id]
    when 'yearly'
      Rails.application.credentials.stripe[:premium_yearly_price_id]
    else
      nil
    end
  end

  def validate_and_prepare_discount(discount_code, billing_cycle)
    # Use DiscountCodeService to validate the code
    discount_service = DiscountCodeService.new(user: user, code: discount_code)
    discount_service.validate_code
    
    unless discount_service.success?
      return failure(discount_service.errors.full_messages.first || 'Invalid discount code')
    end
    
    discount_code_obj = discount_service.result[:discount_code]
    
    # Calculate discount for the billing cycle
    original_amount = get_plan_amount(billing_cycle)
    discount_calculation = discount_service.calculate_discount(discount_code_obj, original_amount)
    
    success({
      discount_code: discount_code_obj,
      calculation: discount_calculation
    })
  end

  def get_plan_amount(billing_cycle)
    case billing_cycle
    when 'yearly'
      PLANS['premium'][:price_yearly]
    else
      PLANS['premium'][:price_monthly]
    end
  end

  def create_checkout_session(customer:, price_id:, discount_data: nil, success_url:, cancel_url:)
    session_params = {
      customer: customer.id,
      payment_method_types: ['card'],
      line_items: [{
        price: price_id,
        quantity: 1,
      }],
      mode: 'subscription',
      success_url: success_url,
      cancel_url: cancel_url,
      allow_promotion_codes: true,
      billing_address_collection: 'required',
      metadata: {
        user_id: user.id,
        plan_type: plan_type
      }
    }
    
    # Add discount information to metadata if present
    if discount_data
      session_params[:metadata][:discount_code] = discount_data[:discount_code].code
      session_params[:metadata][:discount_percentage] = discount_data[:discount_code].discount_percentage
      session_params[:metadata][:original_amount] = discount_data[:calculation][:original_amount]
      session_params[:metadata][:discount_amount] = discount_data[:calculation][:discount_amount]
      session_params[:metadata][:final_amount] = discount_data[:calculation][:final_amount]
      
      # Apply discount as a Stripe coupon (we'll create this dynamically)
      coupon_id = create_or_get_stripe_coupon(discount_data[:discount_code])
      if coupon_id
        session_params[:discounts] = [{ coupon: coupon_id }]
      end
    end
    
    @stripe_client.checkout.sessions.create(session_params)
  end

  def create_or_get_stripe_coupon(discount_code)
    # Create a unique coupon ID based on the discount code
    coupon_id = "discount_#{discount_code.code.downcase}_#{discount_code.discount_percentage}pct"
    
    begin
      # Try to retrieve existing coupon
      @stripe_client.coupons.retrieve(coupon_id)
      coupon_id
    rescue Stripe::InvalidRequestError
      # Coupon doesn't exist, create it
      begin
        @stripe_client.coupons.create({
          id: coupon_id,
          percent_off: discount_code.discount_percentage,
          duration: 'once', # Apply only to first payment
          name: "#{discount_code.discount_percentage}% off (#{discount_code.code})",
          metadata: {
            discount_code_id: discount_code.id,
            created_by: 'agentform_system'
          }
        })
        coupon_id
      rescue Stripe::StripeError => e
        Rails.logger.error "Failed to create Stripe coupon: #{e.message}"
        nil
      end
    end
  end

  def get_user_stripe_subscription
    return nil unless user.stripe_customer_id.present?

    subscriptions = @stripe_client.subscriptions.list({
      customer: user.stripe_customer_id,
      status: 'all',
      limit: 1
    })

    subscriptions.data.first
  end

  def success(data = {})
    OpenStruct.new(success?: true, data: data, error: nil)
  end

  def failure(error_message)
    OpenStruct.new(success?: false, data: {}, error: error_message)
  end
end
</file>

<file path="services/template_analysis_service.rb">
# frozen_string_literal: true

class TemplateAnalysisService < ApplicationService
  include PaymentAnalyticsTrackable
  
  attribute :template, default: nil
  attribute :user, default: nil

  def call
    validate_service_inputs
    return self if failure?

    analyze_template_requirements
    track_template_interaction if user.present?
    self
  end
  
  def analyze_payment_requirements(template, user: nil)
    @template = template
    @user = user
    validate_service_inputs
    return {} if failure?

    analyze_template_requirements
    track_template_interaction if user.present?
    result
  end

  private

  def validate_service_inputs
    validate_required_attributes(:template)
    
    unless template.is_a?(FormTemplate)
      add_error(:template, 'must be a FormTemplate instance')
    end
  end

  def analyze_template_requirements
    payment_questions = detect_payment_questions
    required_features = determine_required_features(payment_questions)
    setup_complexity = calculate_setup_complexity(required_features)

    set_result({
      has_payment_questions: payment_questions.any?,
      payment_questions: payment_questions,
      required_features: required_features,
      setup_complexity: setup_complexity,
      template_id: template.id,
      template_name: template.name
    })

    set_context(:analysis_completed_at, Time.current)
    set_context(:questions_analyzed, template.questions_config.length)
  end

  def detect_payment_questions
    return [] unless template.questions_config.present?

    payment_questions = []
    
    template.questions_config.each_with_index do |question_config, index|
      if PaymentRequirementDetector.payment_question?(question_config)
        payment_questions << {
          position: index + 1,
          title: question_config['title'],
          question_type: question_config['question_type'],
          required: question_config['required'] || false,
          configuration: question_config['configuration'] || {}
        }
      end
    end

    payment_questions
  end

  def determine_required_features(payment_questions)
    return [] if payment_questions.empty?

    features = Set.new

    payment_questions.each do |question|
      question_features = PaymentRequirementDetector.required_features_for_question_type(
        question[:question_type]
      )
      features.merge(question_features)
    end

    features.to_a
  end

  def calculate_setup_complexity(required_features)
    return 'simple' if required_features.empty?

    complexity_score = 0
    
    # Base complexity for having payment features
    complexity_score += 1

    # Add complexity based on specific features
    feature_complexity = {
      'stripe_payments' => 1,
      'premium_subscription' => 1,
      'webhook_configuration' => 1,
      'tax_calculation' => 1,
      'subscription_management' => 2
    }

    required_features.each do |feature|
      complexity_score += feature_complexity[feature] || 1
    end

    case complexity_score
    when 0..2
      'simple'
    when 3..5
      'moderate'
    when 6..8
      'complex'
    else
      'very_complex'
    end
  end

  def track_template_interaction
    return unless template&.has_payment_questions?

    track_payment_event(
      'template_payment_interaction',
      user: user,
      context: {
        template_id: template.id,
        template_name: template.name,
        payment_questions_count: result[:payment_questions]&.length || 0,
        required_features: result[:required_features] || [],
        setup_complexity: result[:setup_complexity]
      }
    )
  end
end
</file>

<file path="services/user_management_service.rb">
# frozen_string_literal: true

# Service for managing user operations in the admin interface
class UserManagementService < ApplicationService
  attribute :current_user
  attribute :filters, default: -> { {} }
  attribute :user_id
  attribute :user_params, default: -> { {} }
  attribute :suspension_reason
  attribute :transfer_data, default: false

  validates :current_user, presence: true
  validate :current_user_is_superadmin

  # List users with search, filters, and pagination
  def list_users
    return self unless valid?

    # Use optimized includes to avoid N+1 queries
    users = User.includes(
      :discount_code_usage, 
      forms: :form_responses,
      payment_transactions: []
    )
    
    # Apply search filter with optimized query
    if filters[:search].present?
      search_term = "%#{filters[:search].strip}%"
      users = users.where(
        'email ILIKE ? OR first_name ILIKE ? OR last_name ILIKE ?',
        search_term, search_term, search_term
      )
    end
    
    # Apply role filter
    if filters[:role].present? && %w[user admin superadmin].include?(filters[:role])
      users = users.where(role: filters[:role])
    end
    
    # Apply subscription tier filter
    if filters[:tier].present? && %w[basic premium].include?(filters[:tier])
      users = users.where(subscription_tier: filters[:tier])
    end
    
    # Apply status filter
    case filters[:status]
    when 'active'
      users = users.where(suspended_at: nil)
    when 'suspended'
      users = users.where.not(suspended_at: nil)
    end
    
    # Apply date range filter
    if filters[:created_after].present?
      users = users.where('created_at >= ?', filters[:created_after])
    end
    
    if filters[:created_before].present?
      users = users.where('created_at <= ?', filters[:created_before])
    end
    
    # Order by creation date (newest first) by default
    users = users.order(created_at: :desc)
    
    # Apply pagination with optimized count query
    page = filters[:page] || 1
    per_page = filters[:per_page] || 25
    
    # Use limit/offset instead of Kaminari for better performance with large datasets
    total_count = users.count
    offset = (page.to_i - 1) * per_page.to_i
    paginated_users = users.limit(per_page).offset(offset)
    
    set_result({
      users: paginated_users,
      total_count: total_count,
      current_page: page.to_i,
      per_page: per_page.to_i,
      total_pages: (total_count.to_f / per_page.to_f).ceil
    })
    
    self
  end

  # Get detailed user information
  def get_user_details
    return self unless valid?
    
    unless user_id.present?
      errors.add(:user_id, 'is required')
      return self
    end

    user = find_record(User, user_id, :user)
    return self unless user

    subscription_details = get_subscription_details(user)
    usage_stats = get_usage_stats(user)
    recent_activity = get_recent_activity(user)
    discount_info = get_discount_info(user)

    set_result({
      user: user,
      subscription_details: subscription_details,
      usage_stats: usage_stats,
      recent_activity: recent_activity,
      discount_info: discount_info
    })

    self
  end

  # Create a new user
  def create_user
    return self unless valid?
    
    unless user_params.present?
      errors.add(:user_params, 'are required')
      return self
    end

    # Generate temporary password
    temp_password = SecureRandom.hex(8)
    
    user_attributes = user_params.merge(
      password: temp_password,
      password_confirmation: temp_password
    )
    
    user = User.new(user_attributes)
    
    if user.save
      # Send invitation email asynchronously
      UserInvitationJob.perform_later(user.id, temp_password)
      
      # Log the action
      Rails.logger.info "User #{user.email} created by admin #{current_user.email}"
      
      set_result({
        user: user,
        temporary_password: temp_password,
        message: 'User created successfully. Invitation email sent.'
      })
    else
      user.errors.each do |error|
        add_error(:user_creation, error.full_message)
      end
    end

    self
  end

  # Update user information
  def update_user
    return self unless valid?
    
    unless user_id.present?
      errors.add(:user_id, 'is required')
      return self
    end
    
    unless user_params.present?
      errors.add(:user_params, 'are required')
      return self
    end

    user = find_record(User, user_id, :user)
    return self unless user

    # Prevent self-demotion for superadmins
    if user == current_user && user_params[:role] && user_params[:role] != 'superadmin'
      add_error(:role, 'Cannot change your own role')
      return self
    end

    if user.update(user_params)
      # Log the action
      Rails.logger.info "User #{user.email} updated by admin #{current_user.email}"
      
      set_result({
        user: user,
        message: 'User updated successfully'
      })
    else
      user.errors.each do |error|
        add_error(:user_update, error.full_message)
      end
    end

    self
  end

  # Suspend a user
  def suspend_user
    return self unless valid?
    
    unless user_id.present?
      errors.add(:user_id, 'is required')
      return self
    end
    
    unless suspension_reason.present?
      errors.add(:suspension_reason, 'is required')
      return self
    end

    user = find_record(User, user_id, :user)
    return self unless user

    # Prevent self-suspension
    if user == current_user
      add_error(:suspension, 'Cannot suspend your own account')
      return self
    end

    # Prevent suspending other superadmins
    if user.superadmin?
      add_error(:suspension, 'Cannot suspend other superadmin accounts')
      return self
    end

    begin
      user.suspend!(suspension_reason)
      
      # Send suspension notification email
      UserSuspensionJob.perform_later(user.id, suspension_reason)
      
      # Log the action
      Rails.logger.info "User #{user.email} suspended by admin #{current_user.email}. Reason: #{suspension_reason}"
      
      set_result({
        user: user,
        message: 'User suspended successfully'
      })
    rescue StandardError => e
      add_error(:suspension, "Failed to suspend user: #{e.message}")
    end

    self
  end

  # Reactivate a suspended user
  def reactivate_user
    return self unless valid?
    
    unless user_id.present?
      errors.add(:user_id, 'is required')
      return self
    end

    user = find_record(User, user_id, :user)
    return self unless user

    unless user.suspended?
      add_error(:reactivation, 'User is not suspended')
      return self
    end

    begin
      user.reactivate!
      
      # Send reactivation notification email
      UserReactivationJob.perform_later(user.id)
      
      # Log the action
      Rails.logger.info "User #{user.email} reactivated by admin #{current_user.email}"
      
      set_result({
        user: user,
        message: 'User reactivated successfully'
      })
    rescue StandardError => e
      add_error(:reactivation, "Failed to reactivate user: #{e.message}")
    end

    self
  end

  # Delete a user
  def delete_user
    return self unless valid?
    
    unless user_id.present?
      errors.add(:user_id, 'is required')
      return self
    end

    user = find_record(User, user_id, :user)
    return self unless user

    # Prevent self-deletion
    if user == current_user
      add_error(:deletion, 'Cannot delete your own account')
      return self
    end

    # Prevent deleting other superadmins
    if user.superadmin?
      add_error(:deletion, 'Cannot delete other superadmin accounts')
      return self
    end

    begin
      user_email = user.email
      
      # Handle data transfer if requested
      if transfer_data && user.forms.exists?
        # Mark forms as archived but keep user association
        # In a real implementation, you might transfer to another user
        user.forms.update_all(status: 'archived')
      end
      
      if user.destroy
        # Log the action
        Rails.logger.info "User #{user_email} deleted by admin #{current_user.email}"
        
        set_result({
          message: 'User deleted successfully',
          deleted_user_email: user_email
        })
      else
        user.errors.each do |error|
          add_error(:deletion, error.full_message)
        end
      end
    rescue StandardError => e
      add_error(:deletion, "Failed to delete user: #{e.message}")
    end

    self
  end

  # Send password reset email to user
  def send_password_reset
    return self unless valid?
    
    unless user_id.present?
      errors.add(:user_id, 'is required')
      return self
    end

    user = find_record(User, user_id, :user)
    return self unless user

    begin
      # Generate password reset token using Devise
      token = user.send_reset_password_instructions
      
      # Log the action
      Rails.logger.info "Password reset sent to #{user.email} by admin #{current_user.email}"
      
      set_result({
        user: user,
        message: 'Password reset email sent successfully'
      })
    rescue StandardError => e
      add_error(:password_reset, "Failed to send password reset: #{e.message}")
    end

    self
  end

  # Get user statistics for dashboard
  def get_user_statistics
    return self unless valid?

    stats = {
      total_users: User.count,
      active_users: User.where(suspended_at: nil).count,
      suspended_users: User.where.not(suspended_at: nil).count,
      premium_users: User.where(subscription_tier: 'premium').count,
      admin_users: User.where(role: ['admin', 'superadmin']).count,
      users_this_month: User.where(created_at: 1.month.ago..Time.current).count,
      users_this_week: User.where(created_at: 1.week.ago..Time.current).count
    }

    set_result(stats)
    self
  end

  private

  def current_user_is_superadmin
    return unless current_user
    
    unless current_user.superadmin?
      errors.add(:authorization, 'Only superadmins can perform user management operations')
    end
  end

  def get_subscription_details(user)
    {
      tier: user.subscription_tier,
      status: user.subscription_status,
      expires_at: user.subscription_expires_at,
      stripe_customer_id: user.stripe_customer_id,
      subscription_id: user.respond_to?(:stripe_subscription_id) ? user.stripe_subscription_id : nil,
      payment_method: user.respond_to?(:payment_method_type) ? user.payment_method_type : nil,
      last_payment: user.payment_transactions.successful.order(:created_at).last,
      total_payments: user.payment_transactions.successful.sum(:amount)
    }
  end

  def get_usage_stats(user)
    {
      total_forms: user.forms.count,
      published_forms: user.forms.published.count,
      total_responses: user.form_responses.count,
      ai_credits_used: user.ai_credits_used,
      ai_credits_limit: user.monthly_ai_limit,
      last_form_created: user.forms.order(:created_at).last&.created_at,
      last_response_received: user.form_responses.order(:created_at).last&.created_at
    }
  end

  def get_recent_activity(user)
    activities = []
    
    # Recent forms
    user.forms.order(created_at: :desc).limit(5).each do |form|
      activities << {
        type: 'form_created',
        description: "Created form: #{form.name}",
        timestamp: form.created_at,
        resource: form
      }
    end
    
    # Recent responses
    user.form_responses.includes(:form).order(created_at: :desc).limit(5).each do |response|
      activities << {
        type: 'response_received',
        description: "Received response for: #{response.form.name}",
        timestamp: response.created_at,
        resource: response
      }
    end
    
    # Recent payments
    user.payment_transactions.successful.order(created_at: :desc).limit(3).each do |payment|
      activities << {
        type: 'payment_made',
        description: "Payment of $#{payment.amount_cents / 100.0}",
        timestamp: payment.created_at,
        resource: payment
      }
    end
    
    # Sort by timestamp and return latest 10
    activities.sort_by { |a| a[:timestamp] }.reverse.first(10)
  end

  def get_discount_info(user)
    {
      has_used_discount: user.discount_code_used?,
      discount_usage: user.discount_code_usage,
      eligible_for_discount: user.eligible_for_discount?
    }
  end
end
</file>

<file path="views/admin/dashboard/index.html.erb">
<% content_for :title, "Admin Dashboard" %>

<% content_for :page_header do %>
  <div class="flex items-center justify-between">
    <div>
      <h1 class="text-2xl font-bold text-gray-900">Admin Dashboard</h1>
      <p class="mt-1 text-sm text-gray-600">
        Welcome back, <%= current_user.full_name %>. Here's what's happening with AgentForm.
      </p>
    </div>
    <div class="flex items-center space-x-3">
      <span class="text-sm text-gray-500">Last updated: <%= Time.current.strftime("%B %d, %Y at %I:%M %p") %></span>
      <button onclick="location.reload()" class="text-indigo-600 hover:text-indigo-500 text-sm font-medium">
        Refresh
      </button>
    </div>
  </div>
<% end %>

<!-- User Statistics Grid -->
<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
  <!-- Total Users Card -->
  <div class="<%= admin_card_classes %> hover:shadow-lg transition-shadow duration-200">
    <div class="p-6">
      <div class="flex items-center">
        <div class="flex-shrink-0">
          <div class="w-10 h-10 bg-blue-100 rounded-lg flex items-center justify-center">
            <svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197m13.5-9a2.5 2.5 0 11-5 0 2.5 2.5 0 015 0z"></path>
            </svg>
          </div>
        </div>
        <div class="ml-4 flex-1">
          <div class="text-3xl font-bold text-gray-900"><%= number_with_delimiter(@dashboard_stats[:user_stats][:total]) %></div>
          <div class="text-sm font-medium text-gray-500">Total Users</div>
          <div class="text-xs text-green-600 mt-1">
            +<%= @dashboard_stats[:user_stats][:new_this_month] %> this month
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Active Users Card -->
  <div class="<%= admin_card_classes %> hover:shadow-lg transition-shadow duration-200">
    <div class="p-6">
      <div class="flex items-center">
        <div class="flex-shrink-0">
          <div class="w-10 h-10 bg-green-100 rounded-lg flex items-center justify-center">
            <svg class="w-6 h-6 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </div>
        </div>
        <div class="ml-4 flex-1">
          <div class="text-3xl font-bold text-gray-900"><%= number_with_delimiter(@dashboard_stats[:user_stats][:active]) %></div>
          <div class="text-sm font-medium text-gray-500">Active Users</div>
          <div class="text-xs text-gray-600 mt-1">
            <%= @dashboard_stats[:user_stats][:suspended] %> suspended
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Premium Subscriptions Card -->
  <div class="<%= admin_card_classes %> hover:shadow-lg transition-shadow duration-200">
    <div class="p-6">
      <div class="flex items-center">
        <div class="flex-shrink-0">
          <div class="w-10 h-10 bg-indigo-100 rounded-lg flex items-center justify-center">
            <svg class="w-6 h-6 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
            </svg>
          </div>
        </div>
        <div class="ml-4 flex-1">
          <div class="text-3xl font-bold text-gray-900"><%= number_with_delimiter(@dashboard_stats[:subscription_stats][:active]) %></div>
          <div class="text-sm font-medium text-gray-500">Premium Users</div>
          <div class="text-xs text-purple-600 mt-1">
            <%= @dashboard_stats[:user_stats][:premium_percentage] %>% conversion rate
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Monthly Revenue Card -->
  <div class="<%= admin_card_classes %> hover:shadow-lg transition-shadow duration-200">
    <div class="p-6">
      <div class="flex items-center">
        <div class="flex-shrink-0">
          <div class="w-10 h-10 bg-emerald-100 rounded-lg flex items-center justify-center">
            <svg class="w-6 h-6 text-emerald-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1"></path>
            </svg>
          </div>
        </div>
        <div class="ml-4 flex-1">
          <div class="text-3xl font-bold text-gray-900">$<%= number_with_delimiter(@dashboard_stats[:subscription_stats][:mrr]) %></div>
          <div class="text-sm font-medium text-gray-500">Monthly Revenue</div>
          <div class="text-xs text-green-600 mt-1">
            +<%= @dashboard_stats[:subscription_stats][:new_this_month] %> new subs
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Discount Code Statistics -->
<div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
  <!-- Active Discount Codes -->
  <div class="<%= admin_card_classes %> hover:shadow-lg transition-shadow duration-200">
    <div class="p-6">
      <div class="flex items-center">
        <div class="flex-shrink-0">
          <div class="w-10 h-10 bg-purple-100 rounded-lg flex items-center justify-center">
            <svg class="w-6 h-6 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z"></path>
            </svg>
          </div>
        </div>
        <div class="ml-4 flex-1">
          <div class="text-2xl font-bold text-gray-900"><%= @dashboard_stats[:discount_code_stats][:active_codes] %></div>
          <div class="text-sm font-medium text-gray-500">Active Codes</div>
          <div class="text-xs text-gray-600 mt-1">
            <%= @dashboard_stats[:discount_code_stats][:total_codes] %> total codes
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Total Usage -->
  <div class="<%= admin_card_classes %> hover:shadow-lg transition-shadow duration-200">
    <div class="p-6">
      <div class="flex items-center">
        <div class="flex-shrink-0">
          <div class="w-10 h-10 bg-amber-100 rounded-lg flex items-center justify-center">
            <svg class="w-6 h-6 text-amber-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
            </svg>
          </div>
        </div>
        <div class="ml-4 flex-1">
          <div class="text-2xl font-bold text-gray-900"><%= @dashboard_stats[:discount_code_stats][:total_usage] %></div>
          <div class="text-sm font-medium text-gray-500">Total Usage</div>
          <% if @dashboard_stats[:discount_code_stats][:most_popular_code] %>
            <div class="text-xs text-amber-600 mt-1">
              Most popular: <%= @dashboard_stats[:discount_code_stats][:most_popular_code] %>
            </div>
          <% end %>
        </div>
      </div>
    </div>
  </div>

  <!-- Revenue Impact -->
  <div class="<%= admin_card_classes %> hover:shadow-lg transition-shadow duration-200">
    <div class="p-6">
      <div class="flex items-center">
        <div class="flex-shrink-0">
          <div class="w-10 h-10 bg-red-100 rounded-lg flex items-center justify-center">
            <svg class="w-6 h-6 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 17h8m0 0V9m0 8l-8-8-4 4-6-6"></path>
            </svg>
          </div>
        </div>
        <div class="ml-4 flex-1">
          <div class="text-2xl font-bold text-gray-900">$<%= number_with_delimiter((@dashboard_stats[:discount_code_stats][:total_discount_amount] / 100.0).round(2)) %></div>
          <div class="text-sm font-medium text-gray-500">Total Discounts</div>
          <div class="text-xs text-red-600 mt-1">
            Avg: $<%= (@dashboard_stats[:discount_code_stats][:average_discount_per_use] / 100.0).round(2) %> per use
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Main Content Grid -->
<div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
  <!-- Recent Activity -->
  <div class="<%= admin_card_classes %>">
    <div class="px-6 py-4 border-b border-gray-200">
      <h3 class="text-lg font-semibold text-gray-900">Recent Activity</h3>
      <p class="text-sm text-gray-600">Latest system events and user actions</p>
    </div>
    <div class="p-6">
      <% if @dashboard_stats[:recent_activity].any? %>
        <div class="space-y-4">
          <% @dashboard_stats[:recent_activity].each do |activity| %>
            <div class="flex items-start space-x-3 p-3 rounded-lg hover:bg-gray-50 transition-colors duration-150">
              <div class="flex-shrink-0 mt-1">
                <% case activity[:icon] %>
                <% when 'user-plus' %>
                  <div class="w-8 h-8 bg-green-100 rounded-full flex items-center justify-center">
                    <svg class="w-4 h-4 <%= activity[:color] %>" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18 9v3m0 0v3m0-3h3m-3 0h-3m-2-5a4 4 0 11-8 0 4 4 0 018 0zM3 20a6 6 0 0112 0v1H3v-1z"></path>
                    </svg>
                  </div>
                <% when 'tag' %>
                  <div class="w-8 h-8 bg-purple-100 rounded-full flex items-center justify-center">
                    <svg class="w-4 h-4 <%= activity[:color] %>" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z"></path>
                    </svg>
                  </div>
                <% when 'user-x' %>
                  <div class="w-8 h-8 bg-red-100 rounded-full flex items-center justify-center">
                    <svg class="w-4 h-4 <%= activity[:color] %>" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7a4 4 0 11-8 0 4 4 0 018 0zM9 14a6 6 0 00-6 6v1h12v-1a6 6 0 00-6-6zM21 12h-6"></path>
                    </svg>
                  </div>
                <% end %>
              </div>
              <div class="flex-1 min-w-0">
                <p class="text-sm text-gray-900 font-medium"><%= activity[:message] %></p>
                <p class="text-xs text-gray-500 mt-1">
                  <%= time_ago_in_words(activity[:timestamp]) %> ago
                </p>
              </div>
            </div>
          <% end %>
        </div>
      <% else %>
        <div class="text-center py-8">
          <svg class="w-12 h-12 text-gray-400 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path>
          </svg>
          <p class="text-gray-500">No recent activity</p>
        </div>
      <% end %>
    </div>
  </div>

  <!-- Quick Actions -->
  <div class="<%= admin_card_classes %>">
    <div class="px-6 py-4 border-b border-gray-200">
      <h3 class="text-lg font-semibold text-gray-900">Quick Actions</h3>
      <p class="text-sm text-gray-600">Common administrative tasks</p>
    </div>
    <div class="p-6">
      <div class="grid grid-cols-1 gap-4">
        <% @dashboard_stats[:quick_actions].each do |action| %>
          <%= link_to action[:url], class: "group flex items-center p-4 rounded-lg border-2 border-gray-200 hover:border-indigo-300 hover:bg-indigo-50 transition-all duration-200" do %>
            <div class="flex-shrink-0">
              <div class="w-10 h-10 <%= action[:color] %> rounded-lg flex items-center justify-center group-hover:scale-110 transition-transform duration-200">
                <% case action[:icon] %>
                <% when 'plus-circle' %>
                  <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v3m0 0v3m0-3h3m-3 0H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                  </svg>
                <% when 'users' %>
                  <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197m13.5-9a2.5 2.5 0 11-5 0 2.5 2.5 0 015 0z"></path>
                  </svg>
                <% when 'tag' %>
                  <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z"></path>
                  </svg>
                <% when 'download' %>
                  <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                  </svg>
                <% end %>
              </div>
            </div>
            <div class="ml-4 flex-1">
              <h4 class="text-sm font-semibold text-gray-900 group-hover:text-indigo-900"><%= action[:title] %></h4>
              <p class="text-xs text-gray-600 group-hover:text-indigo-700"><%= action[:description] %></p>
            </div>
            <div class="flex-shrink-0">
              <svg class="w-5 h-5 text-gray-400 group-hover:text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
              </svg>
            </div>
          <% end %>
        <% end %>
      </div>
    </div>
  </div>
</div>
</file>

<file path="views/admin/discount_codes/edit.html.erb">
<% content_for :title, "Edit Discount Code" %>

<div class="admin-content">
  <div class="admin-header">
    <div class="admin-header-content">
      <h1 class="admin-title">Edit Discount Code</h1>
      <p class="admin-subtitle">Modify discount code: <strong><%= @discount_code.code %></strong></p>
    </div>
    <div class="admin-header-actions">
      <%= link_to "View Code", admin_discount_code_path(@discount_code), 
                  class: "btn btn-ghost" %>
      <%= link_to "Back to Codes", admin_discount_codes_path, 
                  class: "btn btn-secondary" %>
    </div>
  </div>

  <div class="admin-form-container">
    <%= form_with model: [:admin, @discount_code], local: true, class: "admin-form" do |form| %>
      <% if @discount_code.errors.any? %>
        <div class="alert alert-danger">
          <h4><%= pluralize(@discount_code.errors.count, "error") %> prohibited this discount code from being saved:</h4>
          <ul>
            <% @discount_code.errors.full_messages.each do |message| %>
              <li><%= message %></li>
            <% end %>
          </ul>
        </div>
      <% end %>

      <div class="form-section">
        <h3 class="form-section-title">Basic Information</h3>
        
        <div class="form-group">
          <%= form.label :code, class: "form-label" %>
          <div class="form-input-readonly">
            <%= @discount_code.code %>
          </div>
          <p class="form-help">
            Code cannot be changed after creation.
          </p>
        </div>

        <div class="form-group">
          <%= form.label :discount_percentage, "Discount Percentage", class: "form-label" %>
          <div class="input-group">
            <%= form.number_field :discount_percentage, 
                                 class: "form-input",
                                 min: 1,
                                 max: 99,
                                 required: true %>
            <span class="input-group-text">%</span>
          </div>
          <p class="form-help">
            Enter a value between 1% and 99%.
          </p>
        </div>
      </div>

      <div class="form-section">
        <h3 class="form-section-title">Usage Limits</h3>
        
        <div class="form-group">
          <%= form.label :max_usage_count, "Maximum Uses", class: "form-label" %>
          <%= form.number_field :max_usage_count, 
                               class: "form-input",
                               min: [@discount_code.current_usage_count, 1].max,
                               placeholder: "Leave blank for unlimited" %>
          <p class="form-help">
            <% if @discount_code.current_usage_count > 0 %>
              This code has been used <%= @discount_code.current_usage_count %> times. 
              Maximum uses cannot be set below current usage.
            <% else %>
              Limit how many times this code can be used. Leave blank for unlimited uses.
            <% end %>
          </p>
        </div>

        <div class="form-group">
          <%= form.label :expires_at, "Expiration Date", class: "form-label" %>
          <%= form.datetime_local_field :expires_at, 
                                       class: "form-input",
                                       min: Date.current.strftime("%Y-%m-%dT%H:%M") %>
          <p class="form-help">
            Leave blank if the code should never expire.
          </p>
        </div>
      </div>

      <div class="form-section">
        <h3 class="form-section-title">Status</h3>
        
        <div class="form-group">
          <div class="checkbox-group">
            <%= form.check_box :active, class: "form-checkbox" %>
            <%= form.label :active, "Active", class: "form-label checkbox-label" %>
          </div>
          <p class="form-help">
            Only active codes can be used by customers.
          </p>
        </div>
      </div>

      <div class="form-actions">
        <%= form.submit "Update Discount Code", class: "btn btn-primary" %>
        <%= link_to "Cancel", admin_discount_code_path(@discount_code), class: "btn btn-secondary" %>
      </div>
    <% end %>
  </div>
</div>
</file>

<file path="views/admin/discount_codes/index.html.erb">
<% content_for :title, "Discount Codes" %>

<div class="admin-content">
  <div class="admin-header">
    <div class="admin-header-content">
      <h1 class="admin-title">Discount Codes</h1>
      <p class="admin-subtitle">Manage promotional discount codes for new subscribers</p>
    </div>
    <div class="admin-header-actions">
      <%= link_to "Create New Code", new_admin_discount_code_path, 
                  class: "btn btn-primary" %>
    </div>
  </div>

  <!-- Analytics Overview -->
  <div class="analytics-overview mb-8">
    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
      <div class="admin-card">
        <div class="admin-card-body">
          <div class="stat-item">
            <div class="stat-value"><%= @analytics[:total_codes] %></div>
            <div class="stat-label">Total Codes</div>
          </div>
        </div>
      </div>
      
      <div class="admin-card">
        <div class="admin-card-body">
          <div class="stat-item">
            <div class="stat-value text-green-600"><%= @analytics[:active_codes] %></div>
            <div class="stat-label">Active Codes</div>
          </div>
        </div>
      </div>
      
      <div class="admin-card">
        <div class="admin-card-body">
          <div class="stat-item">
            <div class="stat-value"><%= @analytics[:total_usage] %></div>
            <div class="stat-label">Total Uses</div>
          </div>
        </div>
      </div>
      
      <div class="admin-card">
        <div class="admin-card-body">
          <div class="stat-item">
            <div class="stat-value text-red-600">
              <%= number_to_currency(@analytics[:total_revenue_impact] / 100.0) %>
            </div>
            <div class="stat-label">Total Discounts Given</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Filters -->
  <div class="admin-filters">
    <%= form_with url: admin_discount_codes_path, method: :get, local: true, class: "filter-form" do |form| %>
      <div class="filter-group">
        <%= form.text_field :search, 
                           placeholder: "Search by code...", 
                           value: params[:search],
                           class: "form-input" %>
      </div>
      
      <div class="filter-group">
        <%= form.select :status, 
                       options_for_select([
                         ['All Codes', ''],
                         ['Active', 'active'],
                         ['Inactive', 'inactive']
                       ], params[:status]),
                       {},
                       { class: "form-select" } %>
      </div>
      
      <div class="filter-actions">
        <%= form.submit "Filter", class: "btn btn-secondary" %>
        <%= link_to "Clear", admin_discount_codes_path, class: "btn btn-ghost" %>
      </div>
    <% end %>
  </div>

  <!-- Discount Codes Table -->
  <div class="admin-table-container">
    <% if @discount_codes.any? %>
      <table class="min-w-full divide-y divide-gray-200">
        <thead class="bg-gray-50">
          <tr>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Code</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Discount</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Usage</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Expires</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Created</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Actions</th>
          </tr>
        </thead>
        <tbody class="bg-white divide-y divide-gray-200">
          <% @discount_codes.each do |code| %>
            <tr class="hover:bg-gray-50 <%= 'opacity-60' unless code.active? %>">
              <td class="px-6 py-4 whitespace-nowrap">
                <div class="flex flex-col space-y-1">
                  <span class="font-mono font-semibold text-gray-900 text-lg"><%= code.code %></span>
                  <% unless code.available? %>
                    <div class="flex space-x-2">
                      <% if code.expired? %>
                        <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800">Expired</span>
                      <% elsif code.usage_limit_reached? %>
                        <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800">Exhausted</span>
                      <% elsif !code.active? %>
                        <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800">Inactive</span>
                      <% end %>
                    </div>
                  <% end %>
                </div>
              </td>
              
              <td class="px-6 py-4 whitespace-nowrap">
                <span class="text-lg font-semibold text-green-600"><%= code.discount_percentage %>%</span>
              </td>
              
              <td class="px-6 py-4 whitespace-nowrap">
                <div class="flex flex-col space-y-2">
                  <span class="text-sm font-medium text-gray-900">
                    <%= code.current_usage_count %>
                    <% if code.max_usage_count %>
                      / <%= code.max_usage_count %>
                    <% else %>
                      / 
                    <% end %>
                  </span>
                  <% if code.max_usage_count %>
                    <div class="w-full bg-gray-200 rounded-full h-2">
                      <div class="bg-blue-600 h-2 rounded-full transition-all duration-300" 
                           style="width: <%= code.usage_percentage %>%"></div>
                    </div>
                    <span class="text-xs text-gray-500"><%= code.usage_percentage %>% used</span>
                  <% end %>
                </div>
              </td>
              
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                <% if code.expires_at %>
                  <span class="<%= 'text-red-600 font-medium' if code.expired? %>">
                    <%= code.expires_at.strftime("%b %d, %Y") %>
                  </span>
                <% else %>
                  <span class="text-gray-500">Never</span>
                <% end %>
              </td>
              
              <td class="px-6 py-4 whitespace-nowrap">
                <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium <%= code.active? ? 'bg-green-100 text-green-800' : 'bg-gray-100 text-gray-800' %>">
                  <%= code.active? ? 'Active' : 'Inactive' %>
                </span>
              </td>
              
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                <%= code.created_at.strftime("%b %d, %Y") %>
              </td>
              
              <td>
                <div class="action-buttons">
                  <%= link_to "View", admin_discount_code_path(code), 
                             class: "btn btn-sm btn-ghost" %>
                  <%= link_to "Edit", edit_admin_discount_code_path(code), 
                             class: "btn btn-sm btn-secondary" %>
                  <%= link_to code.active? ? "Deactivate" : "Activate", 
                             toggle_status_admin_discount_code_path(code),
                             method: :patch,
                             class: "btn btn-sm #{code.active? ? 'btn-warning' : 'btn-success'}",
                             data: { 
                               confirm: "Are you sure you want to #{code.active? ? 'deactivate' : 'activate'} this code?" 
                             } %>
                  <% unless code.discount_code_usages.exists? %>
                    <%= link_to "Delete", admin_discount_code_path(code), 
                               method: :delete,
                               class: "btn btn-sm btn-danger",
                               data: { 
                                 confirm: "Are you sure? This action cannot be undone." 
                               } %>
                  <% end %>
                </div>
              </td>
            </tr>
          <% end %>
        </tbody>
      </table>
      
      <!-- Pagination -->
      <div class="admin-pagination">
        <%= paginate @discount_codes if respond_to?(:paginate) %>
      </div>
    <% else %>
      <div class="empty-state">
        <div class="empty-state-icon">
          <svg class="w-12 h-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                  d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z"></path>
          </svg>
        </div>
        <h3 class="empty-state-title">No discount codes found</h3>
        <p class="empty-state-description">
          <% if params[:search].present? || params[:status].present? %>
            Try adjusting your filters or search terms.
          <% else %>
            Get started by creating your first discount code.
          <% end %>
        </p>
        <% unless params[:search].present? || params[:status].present? %>
          <%= link_to "Create First Code", new_admin_discount_code_path, 
                     class: "btn btn-primary" %>
        <% end %>
      </div>
    <% end %>
  </div>
</div>
</file>

<file path="views/admin/discount_codes/new.html.erb">
<% content_for :title, "Create Discount Code" %>

<div class="admin-content">
  <div class="admin-header">
    <div class="admin-header-content">
      <h1 class="admin-title">Create Discount Code</h1>
      <p class="admin-subtitle">Create a new promotional discount code for subscribers</p>
    </div>
    <div class="admin-header-actions">
      <%= link_to "Back to Codes", admin_discount_codes_path, 
                  class: "btn btn-secondary" %>
    </div>
  </div>

  <div class="admin-form-container">
    <%= form_with model: [:admin, @discount_code], local: true, class: "admin-form" do |form| %>
      <% if @discount_code.errors.any? %>
        <div class="alert alert-danger">
          <h4><%= pluralize(@discount_code.errors.count, "error") %> prohibited this discount code from being saved:</h4>
          <ul>
            <% @discount_code.errors.full_messages.each do |message| %>
              <li><%= message %></li>
            <% end %>
          </ul>
        </div>
      <% end %>

      <div class="form-section">
        <h3 class="form-section-title">Basic Information</h3>
        
        <div class="form-group">
          <%= form.label :code, class: "form-label" %>
          <%= form.text_field :code, 
                             class: "form-input",
                             placeholder: "e.g., WELCOME20, SAVE50",
                             maxlength: 50,
                             required: true %>
          <p class="form-help">
            Use uppercase letters and numbers only. Must be unique.
          </p>
        </div>

        <div class="form-group">
          <%= form.label :discount_percentage, "Discount Percentage", class: "form-label" %>
          <div class="input-group">
            <%= form.number_field :discount_percentage, 
                                 class: "form-input",
                                 min: 1,
                                 max: 99,
                                 required: true %>
            <span class="input-group-text">%</span>
          </div>
          <p class="form-help">
            Enter a value between 1% and 99%.
          </p>
        </div>
      </div>

      <div class="form-section">
        <h3 class="form-section-title">Usage Limits</h3>
        
        <div class="form-group">
          <%= form.label :max_usage_count, "Maximum Uses", class: "form-label" %>
          <%= form.number_field :max_usage_count, 
                               class: "form-input",
                               min: 1,
                               placeholder: "Leave blank for unlimited" %>
          <p class="form-help">
            Limit how many times this code can be used. Leave blank for unlimited uses.
          </p>
        </div>

        <div class="form-group">
          <%= form.label :expires_at, "Expiration Date", class: "form-label" %>
          <%= form.datetime_local_field :expires_at, 
                                       class: "form-input",
                                       min: Date.current.strftime("%Y-%m-%dT%H:%M") %>
          <p class="form-help">
            Leave blank if the code should never expire.
          </p>
        </div>
      </div>

      <div class="form-section">
        <h3 class="form-section-title">Status</h3>
        
        <div class="form-group">
          <div class="checkbox-group">
            <%= form.check_box :active, class: "form-checkbox", checked: true %>
            <%= form.label :active, "Active", class: "form-label checkbox-label" %>
          </div>
          <p class="form-help">
            Only active codes can be used by customers.
          </p>
        </div>
      </div>

      <div class="form-actions">
        <%= form.submit "Create Discount Code", class: "btn btn-primary" %>
        <%= link_to "Cancel", admin_discount_codes_path, class: "btn btn-secondary" %>
      </div>
    <% end %>
  </div>
</div>
</file>

<file path="views/admin/discount_codes/show.html.erb">
<% content_for :title, "Discount Code: #{@discount_code.code}" %>

<div class="admin-content">
  <div class="admin-header">
    <div class="admin-header-content">
      <h1 class="admin-title">
        Discount Code: <span class="code-highlight"><%= @discount_code.code %></span>
      </h1>
      <div class="admin-subtitle">
        <span class="status-indicator <%= @discount_code.active? ? 'active' : 'inactive' %>">
          <%= @discount_code.active? ? 'Active' : 'Inactive' %>
        </span>
        <% unless @discount_code.available? %>
          <% if @discount_code.expired? %>
            <span class="badge badge-warning">Expired</span>
          <% elsif @discount_code.usage_limit_reached? %>
            <span class="badge badge-danger">Exhausted</span>
          <% end %>
        <% end %>
      </div>
    </div>
    <div class="admin-header-actions">
      <%= link_to "Edit Code", edit_admin_discount_code_path(@discount_code), 
                  class: "btn btn-primary" %>
      <%= link_to @discount_code.active? ? "Deactivate" : "Activate", 
                 toggle_status_admin_discount_code_path(@discount_code),
                 method: :patch,
                 class: "btn #{@discount_code.active? ? 'btn-warning' : 'btn-success'}",
                 data: { 
                   confirm: "Are you sure you want to #{@discount_code.active? ? 'deactivate' : 'activate'} this code?" 
                 } %>
      <%= link_to "Back to Codes", admin_discount_codes_path, 
                  class: "btn btn-secondary" %>
    </div>
  </div>

  <div class="admin-grid">
    <!-- Code Details -->
    <div class="admin-card">
      <h3 class="card-title">Code Details</h3>
      <div class="detail-grid">
        <div class="detail-item">
          <span class="detail-label">Discount Percentage</span>
          <span class="detail-value discount-percentage">
            <%= @discount_code.discount_percentage %>%
          </span>
        </div>
        
        <div class="detail-item">
          <span class="detail-label">Created By</span>
          <span class="detail-value">
            <%= @discount_code.created_by.email %>
          </span>
        </div>
        
        <div class="detail-item">
          <span class="detail-label">Created Date</span>
          <span class="detail-value">
            <%= @discount_code.created_at.strftime("%B %d, %Y at %I:%M %p") %>
          </span>
        </div>
        
        <div class="detail-item">
          <span class="detail-label">Expiration</span>
          <span class="detail-value">
            <% if @discount_code.expires_at %>
              <span class="<%= 'text-danger' if @discount_code.expired? %>">
                <%= @discount_code.expires_at.strftime("%B %d, %Y at %I:%M %p") %>
              </span>
            <% else %>
              <span class="text-muted">Never expires</span>
            <% end %>
          </span>
        </div>
      </div>
    </div>

    <!-- Usage Statistics -->
    <div class="admin-card">
      <h3 class="card-title">Usage Statistics</h3>
      <% if @usage_stats.success? %>
        <% stats = @usage_stats.result %>
        <div class="stats-grid">
          <div class="stat-item">
            <div class="stat-value"><%= stats[:total_uses] %></div>
            <div class="stat-label">Total Uses</div>
          </div>
          
          <div class="stat-item">
            <div class="stat-value">
              <% if stats[:max_uses] %>
                <%= stats[:remaining_uses] %>
              <% else %>
                
              <% end %>
            </div>
            <div class="stat-label">Remaining Uses</div>
          </div>
          
          <div class="stat-item">
            <div class="stat-value">
              <%= number_to_currency(stats[:revenue_impact] / 100.0) %>
            </div>
            <div class="stat-label">Total Discount Given</div>
          </div>
          
          <div class="stat-item">
            <div class="stat-value">
              <%= stats[:usage_percentage].round(1) %>%
            </div>
            <div class="stat-label">Usage Rate</div>
          </div>
        </div>
        
        <% if stats[:max_uses] %>
          <div class="usage-progress-container">
            <div class="usage-progress-bar">
              <div class="usage-progress-fill" 
                   style="width: <%= stats[:usage_percentage] %>%"></div>
            </div>
            <div class="usage-progress-text">
              <%= stats[:total_uses] %> of <%= stats[:max_uses] %> uses
            </div>
          </div>
        <% end %>
      <% else %>
        <div class="alert alert-warning">
          Unable to load usage statistics.
        </div>
      <% end %>
    </div>
  </div>

  <!-- Recent Usage -->
  <% if @recent_usages.any? %>
    <div class="admin-card">
      <h3 class="card-title">Recent Usage</h3>
      <div class="usage-table-container">
        <table class="usage-table">
          <thead>
            <tr>
              <th>User</th>
              <th>Original Amount</th>
              <th>Discount Amount</th>
              <th>Final Amount</th>
              <th>Savings</th>
              <th>Used At</th>
            </tr>
          </thead>
          <tbody>
            <% @recent_usages.each do |usage| %>
              <tr>
                <td>
                  <div class="user-info">
                    <span class="user-email"><%= usage.user.email %></span>
                    <span class="user-name text-muted">
                      <%= usage.user.first_name %> <%= usage.user.last_name %>
                    </span>
                  </div>
                </td>
                <td>
                  <span class="amount">
                    <%= usage.formatted_original_amount %>
                  </span>
                </td>
                <td>
                  <span class="discount-amount">
                    -<%= usage.formatted_discount_amount %>
                  </span>
                </td>
                <td>
                  <span class="final-amount">
                    <%= usage.formatted_final_amount %>
                  </span>
                </td>
                <td>
                  <span class="savings-percentage">
                    <%= usage.savings_percentage %>%
                  </span>
                </td>
                <td>
                  <span class="usage-date">
                    <%= usage.used_at.strftime("%b %d, %Y") %>
                  </span>
                </td>
              </tr>
            <% end %>
          </tbody>
        </table>
      </div>
      
      <% if @discount_code.discount_code_usages.count > 10 %>
        <div class="table-footer">
          <p class="text-muted">
            Showing 10 most recent uses. 
            Total: <%= @discount_code.discount_code_usages.count %> uses.
          </p>
        </div>
      <% end %>
    </div>
  <% else %>
    <div class="admin-card">
      <div class="empty-state">
        <div class="empty-state-icon">
          <svg class="w-12 h-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                  d="M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path>
          </svg>
        </div>
        <h3 class="empty-state-title">No usage yet</h3>
        <p class="empty-state-description">
          This discount code hasn't been used by any customers yet.
        </p>
      </div>
    </div>
  <% end %>
</div>
</file>

<file path="views/admin/notifications/_notification.html.erb">
<div id="notification_<%= notification.id %>" class="px-6 py-4 hover:bg-gray-50 transition-colors duration-150 <%= 'bg-blue-50' if notification.unread? %>">
  <div class="flex items-start space-x-4">
    <!-- Event Icon -->
    <div class="flex-shrink-0">
      <div class="w-10 h-10 rounded-full bg-gray-100 flex items-center justify-center text-lg">
        <%= notification.event_icon %>
      </div>
    </div>

    <!-- Notification Content -->
    <div class="flex-1 min-w-0">
      <div class="flex items-center justify-between">
        <div class="flex items-center space-x-2">
          <h4 class="text-sm font-medium text-gray-900 <%= 'font-semibold' if notification.unread? %>">
            <%= notification.title %>
          </h4>
          
          <!-- Priority Badge -->
          <span class="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium <%= notification.priority_color %>">
            <%= notification.priority_icon %> <%= notification.priority.humanize %>
          </span>
          
          <!-- Unread Indicator -->
          <% if notification.unread? %>
            <span class="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800">
              New
            </span>
          <% end %>
        </div>

        <!-- Actions -->
        <div class="flex items-center space-x-2">
          <% if notification.unread? %>
            <%= button_to mark_as_read_admin_notification_path(notification), 
                method: :patch,
                class: "text-sm text-indigo-600 hover:text-indigo-900",
                data: { turbo_method: :patch } do %>
              Mark Read
            <% end %>
          <% end %>
          
          <%= button_to admin_notification_path(notification), 
              method: :delete,
              class: "text-sm text-red-600 hover:text-red-900",
              data: { 
                turbo_method: :delete,
                confirm: "Are you sure you want to delete this notification?"
              } do %>
            Delete
          <% end %>
        </div>
      </div>

      <!-- Message -->
      <p class="mt-1 text-sm text-gray-600">
        <%= notification.message %>
      </p>

      <!-- Metadata -->
      <div class="mt-2 flex items-center justify-between">
        <div class="flex items-center space-x-4 text-xs text-gray-500">
          <span>
            <svg class="inline w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
            <%= time_ago_in_words(notification.created_at) %> ago
          </span>
          
          <% if notification.user %>
            <span>
              <svg class="inline w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
              </svg>
              <%= notification.user.email %>
            </span>
          <% end %>
          
          <span>
            <svg class="inline w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z"></path>
            </svg>
            <%= notification.event_type.humanize %>
          </span>
        </div>

        <!-- Read Status -->
        <% if notification.read? %>
          <span class="text-xs text-gray-400">
            Read <%= time_ago_in_words(notification.read_at) %> ago
          </span>
        <% end %>
      </div>

      <!-- Additional Metadata -->
      <% if notification.metadata.present? && notification.metadata.any? %>
        <div class="mt-3 p-3 bg-gray-50 rounded-md">
          <details class="text-xs">
            <summary class="cursor-pointer text-gray-600 hover:text-gray-800">
              View Details
            </summary>
            <div class="mt-2 space-y-1">
              <% notification.metadata.each do |key, value| %>
                <div class="flex justify-between">
                  <span class="font-medium text-gray-700"><%= key.humanize %>:</span>
                  <span class="text-gray-600"><%= value %></span>
                </div>
              <% end %>
            </div>
          </details>
        </div>
      <% end %>
    </div>
  </div>
</div>
</file>

<file path="views/admin/notifications/_notifications_list.html.erb">
<div class="divide-y divide-gray-200">
  <% if notifications.any? %>
    <% notifications.each do |notification| %>
      <%= render "notification", notification: notification %>
    <% end %>
    
    <% if notifications.respond_to?(:current_page) %>
      <div class="px-6 py-4 bg-gray-50">
        <%= paginate notifications, theme: 'twitter_bootstrap_4' %>
      </div>
    <% end %>
  <% else %>
    <div class="px-6 py-12 text-center">
      <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-5 5v-5zM11 19H6a2 2 0 01-2-2V7a2 2 0 012-2h5m5 0v5"></path>
      </svg>
      <h3 class="mt-2 text-sm font-medium text-gray-900">No notifications</h3>
      <p class="mt-1 text-sm text-gray-500">
        No notifications match your current filters.
      </p>
    </div>
  <% end %>
</div>
</file>

<file path="views/admin/notifications/index.html.erb">
<% content_for :title, "Admin Notifications" %>

<div class="min-h-screen bg-gray-50" data-controller="admin-notifications" data-turbo-permanent>
  <!-- Header -->
  <div class="bg-white shadow-sm border-b border-gray-200">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
      <div class="flex justify-between items-center py-6">
        <div>
          <h1 class="text-2xl font-bold text-gray-900">Admin Notifications</h1>
          <p class="mt-1 text-sm text-gray-500">
            Monitor user activities and system events
          </p>
        </div>
        
        <div class="flex items-center space-x-3">
          <% if @stats[:unread] > 0 %>
            <%= button_to mark_all_as_read_admin_notifications_path, 
                method: :patch,
                class: "inline-flex items-center px-3 py-2 border border-transparent text-sm leading-4 font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500",
                data: { turbo_method: :patch } do %>
              <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
              </svg>
              Mark All Read
            <% end %>
          <% end %>
          
          <div class="relative">
            <span id="notification-counter" class="absolute -top-2 -right-2 inline-flex items-center justify-center px-2 py-1 text-xs font-bold leading-none text-white transform translate-x-1/2 -translate-y-1/2 bg-red-600 rounded-full">
              <%= @stats[:unread] > 0 ? @stats[:unread] : "" %>
            </span>
            <svg class="w-6 h-6 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-5 5v-5zM11 19H6a2 2 0 01-2-2V7a2 2 0 012-2h5m5 0v5"></path>
            </svg>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
    <div class="grid grid-cols-1 lg:grid-cols-4 gap-8">
      
      <!-- Stats Cards -->
      <div class="lg:col-span-4">
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4 mb-8">
          <div class="bg-white overflow-hidden shadow rounded-lg">
            <div class="p-5">
              <div class="flex items-center">
                <div class="flex-shrink-0">
                  <div class="w-8 h-8 bg-blue-500 rounded-md flex items-center justify-center">
                    <span class="text-white text-sm font-medium"></span>
                  </div>
                </div>
                <div class="ml-5 w-0 flex-1">
                  <dl>
                    <dt class="text-sm font-medium text-gray-500 truncate">Total</dt>
                    <dd class="text-lg font-medium text-gray-900"><%= @stats[:total] %></dd>
                  </dl>
                </div>
              </div>
            </div>
          </div>

          <div class="bg-white overflow-hidden shadow rounded-lg">
            <div class="p-5">
              <div class="flex items-center">
                <div class="flex-shrink-0">
                  <div class="w-8 h-8 bg-red-500 rounded-md flex items-center justify-center">
                    <span class="text-white text-sm font-medium"></span>
                  </div>
                </div>
                <div class="ml-5 w-0 flex-1">
                  <dl>
                    <dt class="text-sm font-medium text-gray-500 truncate">Unread</dt>
                    <dd class="text-lg font-medium text-gray-900"><%= @stats[:unread] %></dd>
                  </dl>
                </div>
              </div>
            </div>
          </div>

          <div class="bg-white overflow-hidden shadow rounded-lg">
            <div class="p-5">
              <div class="flex items-center">
                <div class="flex-shrink-0">
                  <div class="w-8 h-8 bg-green-500 rounded-md flex items-center justify-center">
                    <span class="text-white text-sm font-medium"></span>
                  </div>
                </div>
                <div class="ml-5 w-0 flex-1">
                  <dl>
                    <dt class="text-sm font-medium text-gray-500 truncate">Today</dt>
                    <dd class="text-lg font-medium text-gray-900"><%= @stats[:today] %></dd>
                  </dl>
                </div>
              </div>
            </div>
          </div>

          <div class="bg-white overflow-hidden shadow rounded-lg">
            <div class="p-5">
              <div class="flex items-center">
                <div class="flex-shrink-0">
                  <div class="w-8 h-8 bg-purple-500 rounded-md flex items-center justify-center">
                    <span class="text-white text-sm font-medium"></span>
                  </div>
                </div>
                <div class="ml-5 w-0 flex-1">
                  <dl>
                    <dt class="text-sm font-medium text-gray-500 truncate">This Week</dt>
                    <dd class="text-lg font-medium text-gray-900"><%= @stats[:this_week] %></dd>
                  </dl>
                </div>
              </div>
            </div>
          </div>

          <div class="bg-white overflow-hidden shadow rounded-lg">
            <div class="p-5">
              <div class="flex items-center">
                <div class="flex-shrink-0">
                  <div class="w-8 h-8 bg-red-600 rounded-md flex items-center justify-center">
                    <span class="text-white text-sm font-medium"></span>
                  </div>
                </div>
                <div class="ml-5 w-0 flex-1">
                  <dl>
                    <dt class="text-sm font-medium text-gray-500 truncate">Critical</dt>
                    <dd class="text-lg font-medium text-gray-900"><%= @stats[:critical] %></dd>
                  </dl>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Filters Sidebar -->
      <div class="lg:col-span-1">
        <div class="bg-white shadow rounded-lg p-6">
          <h3 class="text-lg font-medium text-gray-900 mb-4">Filters</h3>
          
          <%= form_with url: admin_notifications_path, method: :get, local: true, class: "space-y-4" do |form| %>
            
            <!-- Status Filter -->
            <div>
              <label class="block text-sm font-medium text-gray-700 mb-2">Status</label>
              <%= form.select :status, 
                  options_for_select([
                    ['All', ''],
                    ['Unread', 'unread'],
                    ['Read', 'read']
                  ], params[:status]),
                  {},
                  { class: "block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" } %>
            </div>

            <!-- Event Type Filter -->
            <div>
              <label class="block text-sm font-medium text-gray-700 mb-2">Event Type</label>
              <%= form.select :event_type,
                  options_for_select([['All Types', '']] + 
                    AdminNotification::EVENT_TYPES.map { |k, v| [k.humanize, v] }, 
                    params[:event_type]),
                  {},
                  { class: "block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" } %>
            </div>

            <!-- Priority Filter -->
            <div>
              <label class="block text-sm font-medium text-gray-700 mb-2">Priority</label>
              <%= form.select :priority,
                  options_for_select([['All Priorities', '']] + 
                    AdminNotification::PRIORITIES.map { |k, v| [k.humanize, v] }, 
                    params[:priority]),
                  {},
                  { class: "block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" } %>
            </div>

            <div class="pt-4">
              <%= form.submit "Apply Filters", 
                  class: "w-full bg-indigo-600 text-white py-2 px-4 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2" %>
            </div>
          <% end %>

          <div class="mt-6 pt-6 border-t border-gray-200">
            <%= link_to "Clear Filters", admin_notifications_path, 
                class: "w-full block text-center text-sm text-gray-500 hover:text-gray-700" %>
          </div>
        </div>
      </div>

      <!-- Notifications List -->
      <div class="lg:col-span-3">
        <div class="bg-white shadow rounded-lg">
          <div class="px-6 py-4 border-b border-gray-200">
            <h3 class="text-lg font-medium text-gray-900">Recent Notifications</h3>
          </div>
          
          <div id="notifications-list" data-turbo-permanent>
            <%= render "notifications_list", notifications: @notifications %>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<%= turbo_stream_from "admin_notifications" %>
</file>

<file path="views/admin/payment_analytics/index.html.erb">
<div class="min-h-screen bg-gray-50 py-8">
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
    <!-- Header -->
    <div class="mb-8">
      <h1 class="text-3xl font-bold text-gray-900">Payment Analytics Dashboard</h1>
      <p class="mt-2 text-gray-600">Monitor payment template usage and setup completion rates</p>
    </div>

    <!-- Date Range Filter -->
    <div class="bg-white rounded-lg shadow p-6 mb-8">
      <%= form_with url: admin_payment_analytics_path, method: :get, local: true, class: "flex items-end space-x-4" do |form| %>
        <div>
          <%= form.label :start_date, "Start Date", class: "block text-sm font-medium text-gray-700" %>
          <%= form.date_field :start_date, value: params[:start_date] || 30.days.ago.to_date, class: "mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500" %>
        </div>
        <div>
          <%= form.label :end_date, "End Date", class: "block text-sm font-medium text-gray-700" %>
          <%= form.date_field :end_date, value: params[:end_date] || Date.current, class: "mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500" %>
        </div>
        <div>
          <%= form.submit "Update", class: "bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500" %>
        </div>
      <% end %>
    </div>

    <!-- Key Metrics -->
    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
      <!-- Setup Completion Rate -->
      <div class="bg-white rounded-lg shadow p-6">
        <div class="flex items-center">
          <div class="flex-shrink-0">
            <div class="w-8 h-8 bg-green-100 rounded-full flex items-center justify-center">
              <svg class="w-5 h-5 text-green-600" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
              </svg>
            </div>
          </div>
          <div class="ml-4">
            <p class="text-sm font-medium text-gray-500">Setup Completion Rate</p>
            <p class="text-2xl font-semibold text-gray-900"><%= @metrics[:setup_completion_rate] %>%</p>
          </div>
        </div>
      </div>

      <!-- Template Interactions -->
      <div class="bg-white rounded-lg shadow p-6">
        <div class="flex items-center">
          <div class="flex-shrink-0">
            <div class="w-8 h-8 bg-blue-100 rounded-full flex items-center justify-center">
              <svg class="w-5 h-5 text-blue-600" fill="currentColor" viewBox="0 0 20 20">
                <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
              </svg>
            </div>
          </div>
          <div class="ml-4">
            <p class="text-sm font-medium text-gray-500">Template Interactions</p>
            <p class="text-2xl font-semibold text-gray-900"><%= @metrics[:template_interaction_stats][:total_interactions] %></p>
          </div>
        </div>
      </div>

      <!-- Unique Users -->
      <div class="bg-white rounded-lg shadow p-6">
        <div class="flex items-center">
          <div class="flex-shrink-0">
            <div class="w-8 h-8 bg-purple-100 rounded-full flex items-center justify-center">
              <svg class="w-5 h-5 text-purple-600" fill="currentColor" viewBox="0 0 20 20">
                <path d="M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 00-8 0v3h8v-3z"></path>
              </svg>
            </div>
          </div>
          <div class="ml-4">
            <p class="text-sm font-medium text-gray-500">Unique Users</p>
            <p class="text-2xl font-semibold text-gray-900"><%= @metrics[:template_interaction_stats][:unique_users] %></p>
          </div>
        </div>
      </div>

      <!-- Job Performance -->
      <div class="bg-white rounded-lg shadow p-6">
        <div class="flex items-center">
          <div class="flex-shrink-0">
            <div class="w-8 h-8 bg-yellow-100 rounded-full flex items-center justify-center">
              <svg class="w-5 h-5 text-yellow-600" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd"></path>
              </svg>
            </div>
          </div>
          <div class="ml-4">
            <p class="text-sm font-medium text-gray-500">Avg Processing Time</p>
            <p class="text-2xl font-semibold text-gray-900"><%= @metrics[:job_performance_metrics][:average_processing_time] %>ms</p>
          </div>
        </div>
      </div>
    </div>

    <!-- Common Failure Points -->
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
      <div class="bg-white rounded-lg shadow">
        <div class="px-6 py-4 border-b border-gray-200">
          <h3 class="text-lg font-medium text-gray-900">Common Failure Points</h3>
        </div>
        <div class="p-6">
          <% if @metrics[:common_failure_points].any? %>
            <div class="space-y-4">
              <% @metrics[:common_failure_points].each do |error_type, count| %>
                <div class="flex justify-between items-center">
                  <span class="text-sm text-gray-600"><%= error_type&.humanize || 'Unknown' %></span>
                  <span class="text-sm font-medium text-gray-900"><%= count %></span>
                </div>
              <% end %>
            </div>
          <% else %>
            <p class="text-gray-500 text-sm">No failure points recorded in this period.</p>
          <% end %>
        </div>
      </div>

      <!-- Popular Templates -->
      <div class="bg-white rounded-lg shadow">
        <div class="px-6 py-4 border-b border-gray-200">
          <h3 class="text-lg font-medium text-gray-900">Popular Payment Templates</h3>
        </div>
        <div class="p-6">
          <% if @metrics[:template_interaction_stats][:templates_by_popularity].any? %>
            <div class="space-y-4">
              <% @metrics[:template_interaction_stats][:templates_by_popularity].each do |template_id, count| %>
                <div class="flex justify-between items-center">
                  <span class="text-sm text-gray-600">Template <%= template_id %></span>
                  <span class="text-sm font-medium text-gray-900"><%= count %></span>
                </div>
              <% end %>
            </div>
          <% else %>
            <p class="text-gray-500 text-sm">No template interactions recorded in this period.</p>
          <% end %>
        </div>
      </div>
    </div>

    <!-- Recent Events -->
    <div class="bg-white rounded-lg shadow">
      <div class="px-6 py-4 border-b border-gray-200 flex justify-between items-center">
        <h3 class="text-lg font-medium text-gray-900">Recent Payment Events</h3>
        <div class="flex space-x-2">
          <%= link_to "Export CSV", admin_payment_analytics_path(format: :csv, start_date: params[:start_date], end_date: params[:end_date]), 
                      class: "text-sm bg-gray-100 hover:bg-gray-200 px-3 py-1 rounded-md" %>
          <%= link_to "Export JSON", admin_payment_analytics_path(format: :json, start_date: params[:start_date], end_date: params[:end_date]), 
                      class: "text-sm bg-gray-100 hover:bg-gray-200 px-3 py-1 rounded-md" %>
        </div>
      </div>
      <div class="overflow-x-auto">
        <table class="min-w-full divide-y divide-gray-200">
          <thead class="bg-gray-50">
            <tr>
              <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Event Type</th>
              <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">User</th>
              <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Tier</th>
              <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Timestamp</th>
              <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Context</th>
            </tr>
          </thead>
          <tbody class="bg-white divide-y divide-gray-200">
            <% @recent_events.each do |event| %>
              <tr>
                <td class="px-6 py-4 whitespace-nowrap">
                  <span class="inline-flex px-2 py-1 text-xs font-semibold rounded-full 
                    <%= case event.event_type
                        when 'payment_setup_completed' then 'bg-green-100 text-green-800'
                        when 'payment_validation_errors' then 'bg-red-100 text-red-800'
                        when 'payment_setup_started' then 'bg-blue-100 text-blue-800'
                        when 'payment_setup_abandoned' then 'bg-yellow-100 text-yellow-800'
                        else 'bg-gray-100 text-gray-800'
                        end %>">
                    <%= event.event_type.humanize %>
                  </span>
                </td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                  <%= event.user.email %>
                </td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                  <%= event.user_subscription_tier&.humanize || 'Free' %>
                </td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                  <%= time_ago_in_words(event.timestamp) %> ago
                </td>
                <td class="px-6 py-4 text-sm text-gray-500 max-w-xs truncate">
                  <%= event.context.except('user_agent', 'ip_address').to_json %>
                </td>
              </tr>
            <% end %>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</div>
</file>

<file path="views/admin/security/index.html.erb">
<% content_for :title, "Security Dashboard" %>

<div class="space-y-6">
  <!-- Header -->
  <div class="flex justify-between items-center">
    <div>
      <h1 class="text-2xl font-bold text-gray-900">Security Dashboard</h1>
      <p class="text-gray-600">Monitor security events and admin activities</p>
    </div>
    
    <div class="flex space-x-3">
      <%= link_to "Audit Logs", admin_security_audit_logs_path, 
          class: "btn btn-secondary" %>
      <%= link_to "Security Report", admin_security_security_report_path, 
          class: "btn btn-secondary" %>
      <%= link_to "User Activity", admin_security_user_activity_path, 
          class: "btn btn-secondary" %>
    </div>
  </div>

  <!-- Security Alerts -->
  <% if @alerts.any? %>
    <div class="bg-red-50 border border-red-200 rounded-lg p-4">
      <div class="flex items-center mb-3">
        <svg class="w-5 h-5 text-red-600 mr-2" fill="currentColor" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path>
        </svg>
        <h3 class="text-lg font-semibold text-red-800">Security Alerts (<%= @alerts.count %>)</h3>
      </div>
      
      <div class="space-y-2">
        <% @alerts.each do |alert| %>
          <div class="flex items-center justify-between p-3 bg-white rounded border border-red-200">
            <div class="flex-1">
              <div class="flex items-center space-x-2">
                <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium
                  <%= alert[:severity] == 'high' ? 'bg-red-100 text-red-800' : 
                      alert[:severity] == 'medium' ? 'bg-yellow-100 text-yellow-800' : 
                      'bg-blue-100 text-blue-800' %>">
                  <%= alert[:severity].upcase %>
                </span>
                <span class="text-sm font-medium text-gray-900"><%= alert[:type].humanize %></span>
              </div>
              <p class="text-sm text-gray-600 mt-1"><%= alert[:message] %></p>
            </div>
            
            <div class="flex items-center space-x-2">
              <% if alert[:ip_address] %>
                <%= form_with url: admin_security_block_ip_path, method: :post, local: true, class: "inline" do |f| %>
                  <%= f.hidden_field :ip_address, value: alert[:ip_address] %>
                  <%= f.hidden_field :reason, value: "Security alert: #{alert[:type]}" %>
                  <%= f.submit "Block IP", class: "btn btn-sm btn-danger", 
                      confirm: "Are you sure you want to block IP #{alert[:ip_address]}?" %>
                <% end %>
              <% end %>
              <span class="text-xs text-gray-500">
                <%= time_ago_in_words(alert[:created_at]) %> ago
              </span>
            </div>
          </div>
        <% end %>
      </div>
    </div>
  <% end %>

  <!-- Security Metrics -->
  <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
    <div class="bg-white rounded-lg shadow p-6">
      <div class="flex items-center">
        <div class="flex-shrink-0">
          <div class="w-8 h-8 bg-red-100 rounded-md flex items-center justify-center">
            <svg class="w-5 h-5 text-red-600" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path>
            </svg>
          </div>
        </div>
        <div class="ml-4">
          <p class="text-sm font-medium text-gray-500">Security Alerts Today</p>
          <p class="text-2xl font-semibold text-gray-900"><%= @dashboard_data[:security_alerts_today] %></p>
        </div>
      </div>
    </div>

    <div class="bg-white rounded-lg shadow p-6">
      <div class="flex items-center">
        <div class="flex-shrink-0">
          <div class="w-8 h-8 bg-yellow-100 rounded-md flex items-center justify-center">
            <svg class="w-5 h-5 text-yellow-600" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M3 6a3 3 0 013-3h10a1 1 0 01.8 1.6L14.25 8l2.55 3.4A1 1 0 0116 13H6a1 1 0 00-1 1v3a1 1 0 11-2 0V6z" clip-rule="evenodd"></path>
            </svg>
          </div>
        </div>
        <div class="ml-4">
          <p class="text-sm font-medium text-gray-500">Failed Attempts (1h)</p>
          <p class="text-2xl font-semibold text-gray-900"><%= @dashboard_data[:failed_attempts_last_hour] %></p>
        </div>
      </div>
    </div>

    <div class="bg-white rounded-lg shadow p-6">
      <div class="flex items-center">
        <div class="flex-shrink-0">
          <div class="w-8 h-8 bg-blue-100 rounded-md flex items-center justify-center">
            <svg class="w-5 h-5 text-blue-600" fill="currentColor" viewBox="0 0 20 20">
              <path d="M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 00-8 0v3h8v-3z"></path>
            </svg>
          </div>
        </div>
        <div class="ml-4">
          <p class="text-sm font-medium text-gray-500">Active Admins (24h)</p>
          <p class="text-2xl font-semibold text-gray-900"><%= @dashboard_data[:admin_activity_summary].count %></p>
        </div>
      </div>
    </div>

    <div class="bg-white rounded-lg shadow p-6">
      <div class="flex items-center">
        <div class="flex-shrink-0">
          <div class="w-8 h-8 bg-green-100 rounded-md flex items-center justify-center">
            <svg class="w-5 h-5 text-green-600" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M6.267 3.455a3.066 3.066 0 001.745-.723 3.066 3.066 0 013.976 0 3.066 3.066 0 001.745.723 3.066 3.066 0 012.812 2.812c.051.643.304 1.254.723 1.745a3.066 3.066 0 010 3.976 3.066 3.066 0 00-.723 1.745 3.066 3.066 0 01-2.812 2.812 3.066 3.066 0 00-1.745.723 3.066 3.066 0 01-3.976 0 3.066 3.066 0 00-1.745-.723 3.066 3.066 0 01-2.812-2.812 3.066 3.066 0 00-.723-1.745 3.066 3.066 0 010-3.976 3.066 3.066 0 00.723-1.745 3.066 3.066 0 012.812-2.812zm7.44 5.252a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
            </svg>
          </div>
        </div>
        <div class="ml-4">
          <p class="text-sm font-medium text-gray-500">System Status</p>
          <p class="text-2xl font-semibold text-green-600">Secure</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Top Suspicious IPs -->
  <div class="bg-white rounded-lg shadow">
    <div class="px-6 py-4 border-b border-gray-200">
      <h3 class="text-lg font-medium text-gray-900">Top Suspicious IPs (24h)</h3>
    </div>
    <div class="p-6">
      <% if @dashboard_data[:top_suspicious_ips].any? %>
        <div class="space-y-3">
          <% @dashboard_data[:top_suspicious_ips].each do |ip, count| %>
            <div class="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
              <div class="flex items-center space-x-3">
                <code class="text-sm font-mono bg-gray-200 px-2 py-1 rounded"><%= ip %></code>
                <span class="text-sm text-gray-600"><%= count %> failed attempts</span>
              </div>
              
              <%= form_with url: admin_security_block_ip_path, method: :post, local: true, class: "inline" do |f| %>
                <%= f.hidden_field :ip_address, value: ip %>
                <%= f.hidden_field :reason, value: "Suspicious activity: #{count} failed attempts" %>
                <%= f.submit "Block IP", class: "btn btn-sm btn-danger", 
                    confirm: "Are you sure you want to block IP #{ip}?" %>
              <% end %>
            </div>
          <% end %>
        </div>
      <% else %>
        <p class="text-gray-500 text-center py-8">No suspicious IPs detected in the last 24 hours</p>
      <% end %>
    </div>
  </div>

  <!-- Recent Security Events -->
  <div class="bg-white rounded-lg shadow">
    <div class="px-6 py-4 border-b border-gray-200">
      <div class="flex justify-between items-center">
        <h3 class="text-lg font-medium text-gray-900">Recent Security Events</h3>
        <%= link_to "View All", admin_security_audit_logs_path, class: "text-indigo-600 hover:text-indigo-500" %>
      </div>
    </div>
    <div class="p-6">
      <% if @dashboard_data[:recent_security_events].any? %>
        <div class="space-y-3">
          <% @dashboard_data[:recent_security_events].each do |event| %>
            <div class="flex items-center justify-between p-3 border border-gray-200 rounded-lg">
              <div class="flex-1">
                <div class="flex items-center space-x-2">
                  <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800">
                    <%= event[:event_type].humanize %>
                  </span>
                  <% if event[:user_email] %>
                    <span class="text-sm text-gray-600">by <%= event[:user_email] %></span>
                  <% end %>
                  <% if event[:ip_address] %>
                    <code class="text-xs font-mono bg-gray-100 px-1 py-0.5 rounded"><%= event[:ip_address] %></code>
                  <% end %>
                </div>
                <% if event[:details].present? %>
                  <p class="text-sm text-gray-500 mt-1">
                    <%= truncate(event[:details].to_s, length: 100) %>
                  </p>
                <% end %>
              </div>
              <span class="text-xs text-gray-500">
                <%= time_ago_in_words(event[:created_at]) %> ago
              </span>
            </div>
          <% end %>
        </div>
      <% else %>
        <p class="text-gray-500 text-center py-8">No recent security events</p>
      <% end %>
    </div>
  </div>
</div>
</file>

<file path="views/admin/users/edit.html.erb">
<% content_for :title, "Edit User - #{@user.full_name}" %>

<div class="min-h-screen bg-gray-50">
  <div class="max-w-3xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
    <!-- Header -->
    <div class="mb-8">
      <div class="flex items-center space-x-4">
        <%= link_to admin_user_path(@user), 
            class: "text-gray-400 hover:text-gray-600" do %>
          <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
          </svg>
        <% end %>
        <div>
          <h1 class="text-2xl font-bold text-gray-900">Edit User</h1>
          <p class="mt-1 text-sm text-gray-500">
            Update <%= @user.full_name %>'s information
          </p>
        </div>
      </div>
    </div>

    <!-- Form -->
    <div class="bg-white shadow rounded-lg">
      <div class="px-6 py-4 border-b border-gray-200">
        <h3 class="text-lg font-medium text-gray-900">User Information</h3>
        <p class="mt-1 text-sm text-gray-500">
          Update the user's profile and access settings.
        </p>
      </div>
      
      <div class="px-6 py-6">
        <%= form_with model: [:admin, @user], local: true, class: "space-y-6" do |form| %>
          <% if @user.errors.any? %>
            <div class="rounded-md bg-red-50 p-4">
              <div class="flex">
                <div class="flex-shrink-0">
                  <svg class="h-5 w-5 text-red-400" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
                  </svg>
                </div>
                <div class="ml-3">
                  <h3 class="text-sm font-medium text-red-800">
                    There were <%= pluralize(@user.errors.count, "error") %> with your submission:
                  </h3>
                  <div class="mt-2 text-sm text-red-700">
                    <ul class="list-disc pl-5 space-y-1">
                      <% @user.errors.full_messages.each do |message| %>
                        <li><%= message %></li>
                      <% end %>
                    </ul>
                  </div>
                </div>
              </div>
            </div>
          <% end %>

          <div class="grid grid-cols-1 gap-6 sm:grid-cols-2">
            <!-- First Name -->
            <div>
              <%= form.label :first_name, class: "block text-sm font-medium text-gray-700" %>
              <%= form.text_field :first_name, 
                  class: "mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm",
                  required: true %>
            </div>

            <!-- Last Name -->
            <div>
              <%= form.label :last_name, class: "block text-sm font-medium text-gray-700" %>
              <%= form.text_field :last_name, 
                  class: "mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm",
                  required: true %>
            </div>
          </div>

          <!-- Email -->
          <div>
            <%= form.label :email, class: "block text-sm font-medium text-gray-700" %>
            <%= form.email_field :email, 
                class: "mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm",
                required: true %>
            <p class="mt-1 text-sm text-gray-500">
              Changing the email will require the user to verify the new address.
            </p>
          </div>

          <div class="grid grid-cols-1 gap-6 sm:grid-cols-2">
            <!-- Role -->
            <div>
              <%= form.label :role, class: "block text-sm font-medium text-gray-700" %>
              <% if @user == current_user %>
                <%= form.select :role, 
                    options_for_select([
                      ['User', 'user'],
                      ['Admin', 'admin'],
                      ['Superadmin', 'superadmin']
                    ], @user.role),
                    {},
                    { class: "mt-1 block w-full rounded-md border-gray-300 bg-gray-100 shadow-sm sm:text-sm", disabled: true } %>
                <p class="mt-1 text-sm text-yellow-600">
                  You cannot change your own role.
                </p>
              <% else %>
                <%= form.select :role, 
                    options_for_select([
                      ['User', 'user'],
                      ['Admin', 'admin'],
                      ['Superadmin', 'superadmin']
                    ], @user.role),
                    {},
                    { class: "mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" } %>
                <p class="mt-1 text-sm text-gray-500">
                  Determines the user's access level in the system.
                </p>
              <% end %>
            </div>

            <!-- Subscription Tier -->
            <div>
              <%= form.label :subscription_tier, class: "block text-sm font-medium text-gray-700" %>
              <%= form.select :subscription_tier, 
                  options_for_select([
                    ['Basic', 'basic'],
                    ['Premium', 'premium']
                  ], @user.subscription_tier),
                  {},
                  { class: "mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" } %>
              <p class="mt-1 text-sm text-gray-500">
                Sets the user's subscription level and feature access.
              </p>
            </div>
          </div>

          <!-- Account Status -->
          <% if @user.suspended? %>
            <div class="border border-red-200 rounded-md p-4 bg-red-50">
              <div class="flex">
                <div class="flex-shrink-0">
                  <svg class="h-5 w-5 text-red-400" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                  </svg>
                </div>
                <div class="ml-3">
                  <h3 class="text-sm font-medium text-red-800">
                    Account Suspended
                  </h3>
                  <div class="mt-2 text-sm text-red-700">
                    <p>
                      This account was suspended on <%= @user.suspended_at.strftime("%B %d, %Y at %I:%M %p") %>.
                    </p>
                    <% if @user.suspended_reason.present? %>
                      <p class="mt-1">
                        <strong>Reason:</strong> <%= @user.suspended_reason %>
                      </p>
                    <% end %>
                  </div>
                  <div class="mt-4">
                    <%= link_to reactivate_admin_user_path(@user), 
                        method: :post,
                        data: { confirm: "Are you sure you want to reactivate this user?" },
                        class: "inline-flex items-center px-3 py-2 border border-transparent text-sm leading-4 font-medium rounded-md text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500" do %>
                      <svg class="-ml-0.5 mr-2 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                      </svg>
                      Reactivate Account
                    <% end %>
                  </div>
                </div>
              </div>
            </div>
          <% end %>

          <!-- Password Reset Section -->
          <div class="border-t border-gray-200 pt-6">
            <h4 class="text-lg font-medium text-gray-900 mb-4">Password Management</h4>
            
            <div class="bg-blue-50 border border-blue-200 rounded-md p-4">
              <div class="flex">
                <div class="flex-shrink-0">
                  <svg class="h-5 w-5 text-blue-400" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                  </svg>
                </div>
                <div class="ml-3">
                  <h3 class="text-sm font-medium text-blue-800">
                    Password Reset
                  </h3>
                  <div class="mt-2 text-sm text-blue-700">
                    <p>
                      To reset the user's password, use the "Send Password Reset" button. 
                      This will send a secure password reset link to their email address.
                    </p>
                  </div>
                  <div class="mt-4">
                    <button type="button" 
                            onclick="sendPasswordReset('<%= @user.id %>')"
                            class="inline-flex items-center px-3 py-2 border border-blue-300 text-sm leading-4 font-medium rounded-md text-blue-700 bg-blue-100 hover:bg-blue-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                      <svg class="-ml-0.5 mr-2 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 8l7.89 4.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
                      </svg>
                      Send Password Reset
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Form Actions -->
          <div class="flex justify-end space-x-3 pt-6 border-t border-gray-200">
            <%= link_to admin_user_path(@user), 
                class: "inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" do %>
              Cancel
            <% end %>
            <%= form.submit "Update User", 
                class: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" %>
          </div>
        <% end %>
      </div>
    </div>
  </div>
</div>

<script>
function sendPasswordReset(userId) {
  if (confirm('Are you sure you want to send a password reset email to this user?')) {
    fetch(`/admin/users/${userId}/send_password_reset`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').getAttribute('content')
      }
    })
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        alert('Password reset email sent successfully!');
      } else {
        alert('Error sending password reset email: ' + data.error);
      }
    })
    .catch(error => {
      console.error('Error:', error);
      alert('An error occurred while sending the password reset email.');
    });
  }
}
</script>
</file>

<file path="views/admin/users/index.html.erb">
<% content_for :title, "User Management" %>

<div class="min-h-screen bg-gray-50">
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
    <!-- Header -->
    <div class="mb-8">
      <div class="flex justify-between items-center">
        <div>
          <h1 class="text-2xl font-bold text-gray-900">User Management</h1>
          <p class="mt-1 text-sm text-gray-500">
            Manage all users in the system
          </p>
        </div>
        <%= link_to new_admin_user_path, 
            class: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" do %>
          <svg class="-ml-1 mr-2 h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
          </svg>
          New User
        <% end %>
      </div>
    </div>

    <!-- Filters -->
    <div class="bg-white shadow rounded-lg mb-6">
      <div class="px-6 py-4 border-b border-gray-200">
        <h3 class="text-lg font-medium text-gray-900">Filters</h3>
      </div>
      <div class="p-6">
        <%= form_with url: admin_users_path, method: :get, local: true, class: "space-y-4" do |form| %>
          <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
            <!-- Search -->
            <div>
              <%= form.label :search, "Search", class: "block text-sm font-medium text-gray-700 mb-1" %>
              <%= form.text_field :search, 
                  value: params[:search],
                  placeholder: "Email, name...",
                  class: "block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" %>
            </div>

            <!-- Role Filter -->
            <div>
              <%= form.label :role, "Role", class: "block text-sm font-medium text-gray-700 mb-1" %>
              <%= form.select :role, 
                  options_for_select([
                    ['All Roles', ''],
                    ['User', 'user'],
                    ['Admin', 'admin'],
                    ['Superadmin', 'superadmin']
                  ], params[:role]),
                  {},
                  { class: "block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" } %>
            </div>

            <!-- Tier Filter -->
            <div>
              <%= form.label :tier, "Subscription Tier", class: "block text-sm font-medium text-gray-700 mb-1" %>
              <%= form.select :tier, 
                  options_for_select([
                    ['All Tiers', ''],
                    ['Basic', 'basic'],
                    ['Premium', 'premium']
                  ], params[:tier]),
                  {},
                  { class: "block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" } %>
            </div>

            <!-- Status Filter -->
            <div>
              <%= form.label :status, "Status", class: "block text-sm font-medium text-gray-700 mb-1" %>
              <%= form.select :status, 
                  options_for_select([
                    ['All Statuses', ''],
                    ['Active', 'active'],
                    ['Suspended', 'suspended']
                  ], params[:status]),
                  {},
                  { class: "block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" } %>
            </div>
          </div>

          <div class="flex justify-between items-center">
            <div class="flex space-x-3">
              <%= form.submit "Apply Filters", 
                  class: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" %>
              <%= link_to "Clear Filters", admin_users_path, 
                  class: "inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" %>
            </div>
            <div class="text-sm text-gray-500">
              Showing <%= @users.count %> of <%= @total_count %> users
            </div>
          </div>
        <% end %>
      </div>
    </div>

    <!-- Users Table -->
    <div class="bg-white shadow rounded-lg overflow-hidden">
      <div class="px-6 py-4 border-b border-gray-200">
        <h3 class="text-lg font-medium text-gray-900">Users</h3>
      </div>
      
      <% if @users.any? %>
        <div class="overflow-x-auto">
          <table class="min-w-full divide-y divide-gray-200">
            <thead class="bg-gray-50">
              <tr>
                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  User
                </th>
                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Role
                </th>
                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Subscription
                </th>
                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Status
                </th>
                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Joined
                </th>
                <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Actions
                </th>
              </tr>
            </thead>
            <tbody class="bg-white divide-y divide-gray-200">
              <% @users.each do |user| %>
                <tr class="hover:bg-gray-50">
                  <td class="px-6 py-4 whitespace-nowrap">
                    <div class="flex items-center">
                      <div class="flex-shrink-0 h-10 w-10">
                        <div class="h-10 w-10 rounded-full bg-indigo-100 flex items-center justify-center">
                          <span class="text-sm font-medium text-indigo-700">
                            <%= user.first_name&.first&.upcase %><%= user.last_name&.first&.upcase %>
                          </span>
                        </div>
                      </div>
                      <div class="ml-4">
                        <div class="text-sm font-medium text-gray-900">
                          <%= user.full_name %>
                        </div>
                        <div class="text-sm text-gray-500">
                          <%= user.email %>
                        </div>
                      </div>
                    </div>
                  </td>
                  <td class="px-6 py-4 whitespace-nowrap">
                    <span class="inline-flex px-2 py-1 text-xs font-semibold rounded-full <%= user.role == 'superadmin' ? 'bg-purple-100 text-purple-800' : user.role == 'admin' ? 'bg-blue-100 text-blue-800' : 'bg-gray-100 text-gray-800' %>">
                      <%= user.role.humanize %>
                    </span>
                  </td>
                  <td class="px-6 py-4 whitespace-nowrap">
                    <span class="inline-flex px-2 py-1 text-xs font-semibold rounded-full <%= user.subscription_tier == 'premium' ? 'bg-green-100 text-green-800' : user.subscription_tier == 'basic' ? 'bg-yellow-100 text-yellow-800' : 'bg-gray-100 text-gray-800' %>">
                      <%= user.subscription_tier.humanize %>
                    </span>
                  </td>
                  <td class="px-6 py-4 whitespace-nowrap">
                    <% if user.suspended? %>
                      <span class="inline-flex px-2 py-1 text-xs font-semibold rounded-full bg-red-100 text-red-800">
                        Suspended
                      </span>
                    <% else %>
                      <span class="inline-flex px-2 py-1 text-xs font-semibold rounded-full bg-green-100 text-green-800">
                        Active
                      </span>
                    <% end %>
                  </td>
                  <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                    <%= user.created_at.strftime("%b %d, %Y") %>
                  </td>
                  <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                    <div class="flex justify-end space-x-2">
                      <%= link_to admin_user_path(user), 
                          class: "text-indigo-600 hover:text-indigo-900" do %>
                        View
                      <% end %>
                      <%= link_to edit_admin_user_path(user), 
                          class: "text-indigo-600 hover:text-indigo-900" do %>
                        Edit
                      <% end %>
                      <% unless user == current_user %>
                        <% if user.suspended? %>
                          <%= link_to reactivate_admin_user_path(user), 
                              method: :post,
                              data: { confirm: "Are you sure you want to reactivate this user?" },
                              class: "text-green-600 hover:text-green-900" do %>
                            Reactivate
                          <% end %>
                        <% else %>
                          <button type="button" 
                                  onclick="openSuspensionModal('<%= user.id %>', '<%= user.full_name %>')"
                                  class="text-yellow-600 hover:text-yellow-900">
                            Suspend
                          </button>
                        <% end %>
                        <% unless user.superadmin? %>
                          <button type="button" 
                                  onclick="openDeletionModal('<%= user.id %>', '<%= user.full_name %>')"
                                  class="text-red-600 hover:text-red-900">
                            Delete
                          </button>
                        <% end %>
                      <% end %>
                    </div>
                  </td>
                </tr>
              <% end %>
            </tbody>
          </table>
        </div>

        <!-- Pagination -->
        <% if @total_pages > 1 %>
          <div class="bg-white px-4 py-3 flex items-center justify-between border-t border-gray-200 sm:px-6">
            <div class="flex-1 flex justify-between sm:hidden">
              <% if @current_page > 1 %>
                <%= link_to admin_users_path(params.permit!.merge(page: @current_page - 1)), 
                    class: "relative inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50" do %>
                  Previous
                <% end %>
              <% end %>
              <% if @current_page < @total_pages %>
                <%= link_to admin_users_path(params.permit!.merge(page: @current_page + 1)), 
                    class: "ml-3 relative inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50" do %>
                  Next
                <% end %>
              <% end %>
            </div>
            <div class="hidden sm:flex-1 sm:flex sm:items-center sm:justify-between">
              <div>
                <p class="text-sm text-gray-700">
                  Showing
                  <span class="font-medium"><%= (@current_page - 1) * @per_page + 1 %></span>
                  to
                  <span class="font-medium"><%= [@current_page * @per_page, @total_count].min %></span>
                  of
                  <span class="font-medium"><%= @total_count %></span>
                  results
                </p>
              </div>
              <div>
                <nav class="relative z-0 inline-flex rounded-md shadow-sm -space-x-px" aria-label="Pagination">
                  <% if @current_page > 1 %>
                    <%= link_to admin_users_path(params.permit!.merge(page: @current_page - 1)), 
                        class: "relative inline-flex items-center px-2 py-2 rounded-l-md border border-gray-300 bg-white text-sm font-medium text-gray-500 hover:bg-gray-50" do %>
                      <span class="sr-only">Previous</span>
                      <svg class="h-5 w-5" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd" />
                      </svg>
                    <% end %>
                  <% end %>
                  
                  <% (1..@total_pages).each do |page| %>
                    <% if page == @current_page %>
                      <span class="relative inline-flex items-center px-4 py-2 border border-gray-300 bg-indigo-50 text-sm font-medium text-indigo-600">
                        <%= page %>
                      </span>
                    <% else %>
                      <%= link_to admin_users_path(params.permit!.merge(page: page)), 
                          class: "relative inline-flex items-center px-4 py-2 border border-gray-300 bg-white text-sm font-medium text-gray-700 hover:bg-gray-50" do %>
                        <%= page %>
                      <% end %>
                    <% end %>
                  <% end %>
                  
                  <% if @current_page < @total_pages %>
                    <%= link_to admin_users_path(params.permit!.merge(page: @current_page + 1)), 
                        class: "relative inline-flex items-center px-2 py-2 rounded-r-md border border-gray-300 bg-white text-sm font-medium text-gray-500 hover:bg-gray-50" do %>
                      <span class="sr-only">Next</span>
                      <svg class="h-5 w-5" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd" />
                      </svg>
                    <% end %>
                  <% end %>
                </nav>
              </div>
            </div>
          </div>
        <% end %>
      <% else %>
        <div class="text-center py-12">
          <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197m13.5-9a2.5 2.5 0 11-5 0 2.5 2.5 0 015 0z" />
          </svg>
          <h3 class="mt-2 text-sm font-medium text-gray-900">No users found</h3>
          <p class="mt-1 text-sm text-gray-500">
            Try adjusting your search or filter criteria.
          </p>
        </div>
      <% end %>
    </div>
  </div>
</div>

<!-- Suspension Modal -->
<div id="suspensionModal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full hidden">
  <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
    <div class="mt-3 text-center">
      <div class="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-yellow-100">
        <svg class="h-6 w-6 text-yellow-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" />
        </svg>
      </div>
      <h3 class="text-lg font-medium text-gray-900 mt-2">Suspend User</h3>
      <div class="mt-2 px-7 py-3">
        <p class="text-sm text-gray-500">
          Are you sure you want to suspend <span id="suspensionUserName" class="font-medium"></span>?
        </p>
        <%= form_with url: "", method: :post, id: "suspensionForm", class: "mt-4" do |form| %>
          <%= form.text_area :suspension_reason, 
              placeholder: "Reason for suspension...",
              required: true,
              class: "block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" %>
        <% end %>
      </div>
      <div class="items-center px-4 py-3">
        <button id="suspendButton" 
                class="px-4 py-2 bg-yellow-500 text-white text-base font-medium rounded-md w-full shadow-sm hover:bg-yellow-600 focus:outline-none focus:ring-2 focus:ring-yellow-300">
          Suspend User
        </button>
        <button onclick="closeSuspensionModal()" 
                class="mt-3 px-4 py-2 bg-gray-300 text-gray-800 text-base font-medium rounded-md w-full shadow-sm hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-300">
          Cancel
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Deletion Modal -->
<div id="deletionModal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full hidden">
  <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
    <div class="mt-3 text-center">
      <div class="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-red-100">
        <svg class="h-6 w-6 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
        </svg>
      </div>
      <h3 class="text-lg font-medium text-gray-900 mt-2">Delete User</h3>
      <div class="mt-2 px-7 py-3">
        <p class="text-sm text-gray-500">
          Are you sure you want to delete <span id="deletionUserName" class="font-medium"></span>? This action cannot be undone.
        </p>
        <%= form_with url: "", method: :delete, id: "deletionForm", class: "mt-4", local: true do |form| %>
          <%= form.hidden_field :authenticity_token, value: form_authenticity_token %>
          <div class="flex items-center">
            <%= form.check_box :transfer_data, class: "h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded" %>
            <%= form.label :transfer_data, "Archive user's forms instead of deleting them", class: "ml-2 block text-sm text-gray-900" %>
          </div>
        <% end %>
      </div>
      <div class="items-center px-4 py-3">
        <button id="deleteButton" 
                class="px-4 py-2 bg-red-500 text-white text-base font-medium rounded-md w-full shadow-sm hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-300">
          Delete User
        </button>
        <button onclick="closeDeletionModal()" 
                class="mt-3 px-4 py-2 bg-gray-300 text-gray-800 text-base font-medium rounded-md w-full shadow-sm hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-300">
          Cancel
        </button>
      </div>
    </div>
  </div>
</div>

<script>
function openSuspensionModal(userId, userName) {
  document.getElementById('suspensionUserName').textContent = userName;
  document.getElementById('suspensionForm').action = `/admin/users/${userId}/suspend`;
  document.getElementById('suspensionModal').classList.remove('hidden');
}

function closeSuspensionModal() {
  document.getElementById('suspensionModal').classList.add('hidden');
}

function openDeletionModal(userId, userName) {
  document.getElementById('deletionUserName').textContent = userName;
  document.getElementById('deletionForm').action = `/admin/users/${userId}`;
  document.getElementById('deletionModal').classList.remove('hidden');
}

function closeDeletionModal() {
  document.getElementById('deletionModal').classList.add('hidden');
}

document.getElementById('suspendButton').addEventListener('click', function() {
  document.getElementById('suspensionForm').submit();
});

document.getElementById('deleteButton').addEventListener('click', function() {
  const form = document.getElementById('deletionForm');
  
  // Ensure CSRF token is present
  const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');
  let csrfInput = form.querySelector('input[name="authenticity_token"]');
  
  if (!csrfInput) {
    csrfInput = document.createElement('input');
    csrfInput.type = 'hidden';
    csrfInput.name = 'authenticity_token';
    form.appendChild(csrfInput);
  }
  
  csrfInput.value = csrfToken;
  
  form.submit();
});
</script>
</file>

<file path="views/admin/users/new.html.erb">
<% content_for :title, "Create New User" %>

<div class="min-h-screen bg-gray-50">
  <div class="max-w-3xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
    <!-- Header -->
    <div class="mb-8">
      <div class="flex items-center space-x-4">
        <%= link_to admin_users_path, 
            class: "text-gray-400 hover:text-gray-600" do %>
          <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
          </svg>
        <% end %>
        <div>
          <h1 class="text-2xl font-bold text-gray-900">Create New User</h1>
          <p class="mt-1 text-sm text-gray-500">
            Add a new user to the system
          </p>
        </div>
      </div>
    </div>

    <!-- Form -->
    <div class="bg-white shadow rounded-lg">
      <div class="px-6 py-4 border-b border-gray-200">
        <h3 class="text-lg font-medium text-gray-900">User Information</h3>
        <p class="mt-1 text-sm text-gray-500">
          The user will receive an invitation email with a temporary password.
        </p>
      </div>
      
      <div class="px-6 py-6">
        <%= form_with model: [:admin, @user], local: true, class: "space-y-6" do |form| %>
          <% if @user.errors.any? %>
            <div class="rounded-md bg-red-50 p-4">
              <div class="flex">
                <div class="flex-shrink-0">
                  <svg class="h-5 w-5 text-red-400" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
                  </svg>
                </div>
                <div class="ml-3">
                  <h3 class="text-sm font-medium text-red-800">
                    There were <%= pluralize(@user.errors.count, "error") %> with your submission:
                  </h3>
                  <div class="mt-2 text-sm text-red-700">
                    <ul class="list-disc pl-5 space-y-1">
                      <% @user.errors.full_messages.each do |message| %>
                        <li><%= message %></li>
                      <% end %>
                    </ul>
                  </div>
                </div>
              </div>
            </div>
          <% end %>

          <div class="grid grid-cols-1 gap-6 sm:grid-cols-2">
            <!-- First Name -->
            <div>
              <%= form.label :first_name, class: "block text-sm font-medium text-gray-700" %>
              <%= form.text_field :first_name, 
                  class: "mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm",
                  required: true %>
            </div>

            <!-- Last Name -->
            <div>
              <%= form.label :last_name, class: "block text-sm font-medium text-gray-700" %>
              <%= form.text_field :last_name, 
                  class: "mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm",
                  required: true %>
            </div>
          </div>

          <!-- Email -->
          <div>
            <%= form.label :email, class: "block text-sm font-medium text-gray-700" %>
            <%= form.email_field :email, 
                class: "mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm",
                required: true %>
            <p class="mt-1 text-sm text-gray-500">
              The user will use this email to log in to the system.
            </p>
          </div>

          <div class="grid grid-cols-1 gap-6 sm:grid-cols-2">
            <!-- Role -->
            <div>
              <%= form.label :role, class: "block text-sm font-medium text-gray-700" %>
              <%= form.select :role, 
                  options_for_select([
                    ['User', 'user'],
                    ['Admin', 'admin'],
                    ['Superadmin', 'superadmin']
                  ], @user.role),
                  {},
                  { class: "mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" } %>
              <p class="mt-1 text-sm text-gray-500">
                Determines the user's access level in the system.
              </p>
            </div>

            <!-- Subscription Tier -->
            <div>
              <%= form.label :subscription_tier, class: "block text-sm font-medium text-gray-700" %>
              <%= form.select :subscription_tier, 
                  options_for_select([
                    ['Basic', 'basic'],
                    ['Premium', 'premium']
                  ], @user.subscription_tier || 'basic'),
                  {},
                  { class: "mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" } %>
              <p class="mt-1 text-sm text-gray-500">
                Sets the user's subscription level and feature access.
              </p>
            </div>
          </div>

          <!-- Password Section -->
          <div class="border-t border-gray-200 pt-6">
            <h4 class="text-lg font-medium text-gray-900 mb-4">Password Settings</h4>
            <p class="text-sm text-gray-500 mb-4">
              A temporary password will be automatically generated and sent to the user via email. 
              They will be prompted to change it on first login.
            </p>
            
            <div class="bg-blue-50 border border-blue-200 rounded-md p-4">
              <div class="flex">
                <div class="flex-shrink-0">
                  <svg class="h-5 w-5 text-blue-400" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                  </svg>
                </div>
                <div class="ml-3">
                  <h3 class="text-sm font-medium text-blue-800">
                    Automatic Password Generation
                  </h3>
                  <div class="mt-2 text-sm text-blue-700">
                    <p>
                      The system will generate a secure temporary password and send it to the user's email address. 
                      The user will be required to change this password when they first log in.
                    </p>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Form Actions -->
          <div class="flex justify-end space-x-3 pt-6 border-t border-gray-200">
            <%= link_to admin_users_path, 
                class: "inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" do %>
              Cancel
            <% end %>
            <%= form.submit "Create User", 
                class: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" %>
          </div>
        <% end %>
      </div>
    </div>
  </div>
</div>
</file>

<file path="views/admin/users/show.html.erb">
<% content_for :title, "User Details - #{@user.full_name}" %>

<div class="min-h-screen bg-gray-50">
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
    <!-- Header -->
    <div class="mb-8">
      <div class="flex justify-between items-center">
        <div class="flex items-center space-x-4">
          <%= link_to admin_users_path, 
              class: "text-gray-400 hover:text-gray-600" do %>
            <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
            </svg>
          <% end %>
          <div>
            <h1 class="text-2xl font-bold text-gray-900"><%= @user.full_name %></h1>
            <p class="mt-1 text-sm text-gray-500">
              User details and management
            </p>
          </div>
        </div>
        <div class="flex space-x-3">
          <%= link_to edit_admin_user_path(@user), 
              class: "inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" do %>
            <svg class="-ml-1 mr-2 h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
            </svg>
            Edit User
          <% end %>
          <% unless @user == current_user %>
            <% if @user.suspended? %>
              <%= link_to reactivate_admin_user_path(@user), 
                  method: :post,
                  data: { confirm: "Are you sure you want to reactivate this user?" },
                  class: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500" do %>
                <svg class="-ml-1 mr-2 h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                Reactivate
              <% end %>
            <% else %>
              <button type="button" 
                      onclick="openSuspensionModal('<%= @user.id %>', '<%= @user.full_name %>')"
                      class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-yellow-600 hover:bg-yellow-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-yellow-500">
                <svg class="-ml-1 mr-2 h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728L5.636 5.636m12.728 12.728L18.364 5.636M5.636 18.364l12.728-12.728" />
                </svg>
                Suspend
              </button>
            <% end %>
          <% end %>
        </div>
      </div>
    </div>    <!--
 User Overview Cards -->
    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
      <!-- Basic Info Card -->
      <div class="bg-white overflow-hidden shadow rounded-lg">
        <div class="p-5">
          <div class="flex items-center">
            <div class="flex-shrink-0">
              <div class="h-8 w-8 rounded-full bg-indigo-100 flex items-center justify-center">
                <svg class="h-5 w-5 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                </svg>
              </div>
            </div>
            <div class="ml-5 w-0 flex-1">
              <dl>
                <dt class="text-sm font-medium text-gray-500 truncate">Role</dt>
                <dd class="text-lg font-medium text-gray-900">
                  <span class="inline-flex px-2 py-1 text-xs font-semibold rounded-full <%= @user.role == 'superadmin' ? 'bg-purple-100 text-purple-800' : @user.role == 'admin' ? 'bg-blue-100 text-blue-800' : 'bg-gray-100 text-gray-800' %>">
                    <%= @user.role.humanize %>
                  </span>
                </dd>
              </dl>
            </div>
          </div>
        </div>
      </div>

      <!-- Subscription Card -->
      <div class="bg-white overflow-hidden shadow rounded-lg">
        <div class="p-5">
          <div class="flex items-center">
            <div class="flex-shrink-0">
              <div class="h-8 w-8 rounded-full bg-green-100 flex items-center justify-center">
                <svg class="h-5 w-5 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1" />
                </svg>
              </div>
            </div>
            <div class="ml-5 w-0 flex-1">
              <dl>
                <dt class="text-sm font-medium text-gray-500 truncate">Subscription</dt>
                <dd class="text-lg font-medium text-gray-900">
                  <span class="inline-flex px-2 py-1 text-xs font-semibold rounded-full <%= @user.subscription_tier == 'premium' ? 'bg-green-100 text-green-800' : @user.subscription_tier == 'basic' ? 'bg-yellow-100 text-yellow-800' : 'bg-gray-100 text-gray-800' %>">
                    <%= @user.subscription_tier.humanize %>
                  </span>
                </dd>
              </dl>
            </div>
          </div>
        </div>
      </div>

      <!-- Status Card -->
      <div class="bg-white overflow-hidden shadow rounded-lg">
        <div class="p-5">
          <div class="flex items-center">
            <div class="flex-shrink-0">
              <div class="h-8 w-8 rounded-full <%= @user.suspended? ? 'bg-red-100' : 'bg-green-100' %> flex items-center justify-center">
                <% if @user.suspended? %>
                  <svg class="h-5 w-5 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728L5.636 5.636m12.728 12.728L18.364 5.636M5.636 18.364l12.728-12.728" />
                  </svg>
                <% else %>
                  <svg class="h-5 w-5 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                  </svg>
                <% end %>
              </div>
            </div>
            <div class="ml-5 w-0 flex-1">
              <dl>
                <dt class="text-sm font-medium text-gray-500 truncate">Status</dt>
                <dd class="text-lg font-medium text-gray-900">
                  <% if @user.suspended? %>
                    <span class="inline-flex px-2 py-1 text-xs font-semibold rounded-full bg-red-100 text-red-800">
                      Suspended
                    </span>
                  <% else %>
                    <span class="inline-flex px-2 py-1 text-xs font-semibold rounded-full bg-green-100 text-green-800">
                      Active
                    </span>
                  <% end %>
                </dd>
              </dl>
            </div>
          </div>
        </div>
      </div>

      <!-- Join Date Card -->
      <div class="bg-white overflow-hidden shadow rounded-lg">
        <div class="p-5">
          <div class="flex items-center">
            <div class="flex-shrink-0">
              <div class="h-8 w-8 rounded-full bg-blue-100 flex items-center justify-center">
                <svg class="h-5 w-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
                </svg>
              </div>
            </div>
            <div class="ml-5 w-0 flex-1">
              <dl>
                <dt class="text-sm font-medium text-gray-500 truncate">Joined</dt>
                <dd class="text-lg font-medium text-gray-900">
                  <%= @user.created_at.strftime("%b %d, %Y") %>
                </dd>
              </dl>
            </div>
          </div>
        </div>
      </div>
    </div>    <!--
 Main Content Grid -->
    <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
      <!-- Left Column - User Details -->
      <div class="lg:col-span-2 space-y-6">
        <!-- Personal Information -->
        <div class="bg-white shadow rounded-lg">
          <div class="px-6 py-4 border-b border-gray-200">
            <h3 class="text-lg font-medium text-gray-900">Personal Information</h3>
          </div>
          <div class="px-6 py-4">
            <dl class="grid grid-cols-1 gap-x-4 gap-y-6 sm:grid-cols-2">
              <div>
                <dt class="text-sm font-medium text-gray-500">Full Name</dt>
                <dd class="mt-1 text-sm text-gray-900"><%= @user.full_name %></dd>
              </div>
              <div>
                <dt class="text-sm font-medium text-gray-500">Email</dt>
                <dd class="mt-1 text-sm text-gray-900"><%= @user.email %></dd>
              </div>
              <div>
                <dt class="text-sm font-medium text-gray-500">Role</dt>
                <dd class="mt-1 text-sm text-gray-900"><%= @user.role.humanize %></dd>
              </div>
              <div>
                <dt class="text-sm font-medium text-gray-500">Subscription Tier</dt>
                <dd class="mt-1 text-sm text-gray-900"><%= @user.subscription_tier.humanize %></dd>
              </div>
              <div>
                <dt class="text-sm font-medium text-gray-500">Member Since</dt>
                <dd class="mt-1 text-sm text-gray-900"><%= @user.created_at.strftime("%B %d, %Y") %></dd>
              </div>
              <div>
                <dt class="text-sm font-medium text-gray-500">Last Activity</dt>
                <dd class="mt-1 text-sm text-gray-900">
                  <% if @user.last_activity_at %>
                    <%= time_ago_in_words(@user.last_activity_at) %> ago
                  <% else %>
                    Never
                  <% end %>
                </dd>
              </div>
            </dl>
          </div>
        </div>

        <!-- Subscription Details -->
        <% if @user_details[:subscription_details] %>
          <div class="bg-white shadow rounded-lg">
            <div class="px-6 py-4 border-b border-gray-200">
              <h3 class="text-lg font-medium text-gray-900">Subscription Details</h3>
            </div>
            <div class="px-6 py-4">
              <dl class="grid grid-cols-1 gap-x-4 gap-y-6 sm:grid-cols-2">
                <div>
                  <dt class="text-sm font-medium text-gray-500">Status</dt>
                  <dd class="mt-1 text-sm text-gray-900">
                    <span class="inline-flex px-2 py-1 text-xs font-semibold rounded-full <%= @user_details[:subscription_details][:status] == 'active' ? 'bg-green-100 text-green-800' : 'bg-gray-100 text-gray-800' %>">
                      <%= @user_details[:subscription_details][:status]&.humanize || 'Free' %>
                    </span>
                  </dd>
                </div>
                <div>
                  <dt class="text-sm font-medium text-gray-500">Expires At</dt>
                  <dd class="mt-1 text-sm text-gray-900">
                    <% if @user_details[:subscription_details][:expires_at] %>
                      <%= @user_details[:subscription_details][:expires_at].strftime("%B %d, %Y") %>
                    <% else %>
                      N/A
                    <% end %>
                  </dd>
                </div>
                <div>
                  <dt class="text-sm font-medium text-gray-500">Stripe Customer ID</dt>
                  <dd class="mt-1 text-sm text-gray-900 font-mono">
                    <%= @user_details[:subscription_details][:stripe_customer_id] || 'N/A' %>
                  </dd>
                </div>
                <div>
                  <dt class="text-sm font-medium text-gray-500">Total Payments</dt>
                  <dd class="mt-1 text-sm text-gray-900">
                    $<%= number_with_precision(@user_details[:subscription_details][:total_payments] || 0, precision: 2) %>
                  </dd>
                </div>
              </dl>
            </div>
          </div>
        <% end %>

        <!-- Usage Statistics -->
        <% if @user_details[:usage_stats] %>
          <div class="bg-white shadow rounded-lg">
            <div class="px-6 py-4 border-b border-gray-200">
              <h3 class="text-lg font-medium text-gray-900">Usage Statistics</h3>
            </div>
            <div class="px-6 py-4">
              <dl class="grid grid-cols-1 gap-x-4 gap-y-6 sm:grid-cols-2">
                <div>
                  <dt class="text-sm font-medium text-gray-500">Total Forms</dt>
                  <dd class="mt-1 text-sm text-gray-900"><%= @user_details[:usage_stats][:total_forms] %></dd>
                </div>
                <div>
                  <dt class="text-sm font-medium text-gray-500">Published Forms</dt>
                  <dd class="mt-1 text-sm text-gray-900"><%= @user_details[:usage_stats][:published_forms] %></dd>
                </div>
                <div>
                  <dt class="text-sm font-medium text-gray-500">Total Responses</dt>
                  <dd class="mt-1 text-sm text-gray-900"><%= @user_details[:usage_stats][:total_responses] %></dd>
                </div>
                <div>
                  <dt class="text-sm font-medium text-gray-500">AI Credits Used</dt>
                  <dd class="mt-1 text-sm text-gray-900">
                    <%= number_with_precision(@user_details[:usage_stats][:ai_credits_used] || 0, precision: 1) %> / 
                    <%= number_with_precision(@user_details[:usage_stats][:ai_credits_limit] || 0, precision: 1) %>
                  </dd>
                </div>
              </dl>
            </div>
          </div>
        <% end %>
</file>

<file path="views/billings/index.html.erb">
<div class="min-h-screen bg-slate-50 flex flex-col items-center justify-center py-12 px-6">
  <div class="max-w-4xl w-full text-center">
    <div class="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4 rounded-md mb-8">
      <p class="font-bold">Your free trial has ended</p>
      <p>Please choose a plan to continue using AgentForm and access your forms.</p>
    </div>

    <h1 class="text-4xl font-extrabold text-slate-900">Elige tu Plan</h1>
    <p class="mt-4 text-lg text-slate-600">Continue creating smart forms.</p>

    <!-- Plans Section (similar to landing page) -->
    <div class="mt-12 grid lg:grid-cols-2 gap-8 items-center">
      <!-- Plan Basic -->
      <div class="bg-white p-8 rounded-xl shadow-lg border h-full">
        <h3 class="text-2xl font-bold text-gray-900">Basic</h3>
        <p class="mt-2 text-gray-500">Ideal for individual projects.</p>
        <p class="mt-6"><span class="text-4xl font-bold">$5</span><span class="text-gray-500"> / mes</span></p>
        <%= form_with url: billing_path, method: :post, data: { turbo: false } do |f| %>
          <%= f.hidden_field :plan, value: 'basic' %>
          <%= f.submit "Choose Basic", class: "w-full mt-6 py-3 bg-slate-100 text-slate-700 font-semibold rounded-lg cursor-pointer hover:bg-slate-200" %>
        <% end %>
        <ul class="mt-8 space-y-4 text-gray-600 text-sm flex-1">
          <li class="flex items-start"><svg class="w-5 h-5 text-indigo-500 mr-2 shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/></svg><span><strong>Unlimited</strong> Forms & Responses</span></li>
          <li class="flex items-start"><svg class="w-5 h-5 text-indigo-500 mr-2 shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/></svg><span>Basic Conditional Logic</span></li>
          <li class="flex items-start"><svg class="w-5 h-5 text-indigo-500 mr-2 shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/></svg><span>File Uploads (100 MB storage)</span></li>
          <li class="flex items-start"><svg class="w-5 h-5 text-indigo-500 mr-2 shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/></svg><span>Integrations: Sheets, Slack, Webhooks</span></li>
          <li class="flex items-start"><svg class="w-5 h-5 text-indigo-500 mr-2 shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/></svg><span><strong>1,000</strong> AI Credits / month</span></li>
        </ul>
      </div>

      <!-- Plan Professional -->
      <div class="bg-white p-8 rounded-xl shadow-2xl border-2 border-indigo-600 h-full relative">
        <div class="absolute top-0 -translate-y-1/2 left-1/2 -translate-x-1/2 px-4 py-1 bg-indigo-600 text-white text-xs font-semibold rounded-full uppercase">Most Popular</div>
        <h3 class="text-2xl font-bold text-gray-900">Professional</h3>
        <p class="mt-2 text-gray-500">For teams and professionals.</p>
        <p class="mt-6"><span class="text-4xl font-bold">$29</span><span class="text-gray-500"> / mes</span></p>
        <%= form_with url: billing_path, method: :post, data: { turbo: false } do |f| %>
          <%= f.hidden_field :plan, value: 'professional' %>
          <%= f.submit "Choose Professional", class: "w-full mt-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg cursor-pointer hover:bg-indigo-700" %>
        <% end %>
        <ul class="mt-8 space-y-4 text-gray-600 text-sm flex-1">
          <li class="font-semibold text-indigo-700">Everything in Basic, plus:</li>
          <li class="flex items-start"><svg class="w-5 h-5 text-indigo-500 mr-2 shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/></svg><span><strong>Remove "Powered by AgentForm"</strong> branding</span></li>
          <li class="flex items-start"><svg class="w-5 h-5 text-indigo-500 mr-2 shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/></svg><span><strong>Unlimited File Uploads</strong> (10 GB storage)</span></li>
          <li class="flex items-start"><svg class="w-5 h-5 text-indigo-500 mr-2 shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/></svg><span><strong>Advanced Integrations</strong> (Stripe, Salesforce, HubSpot)</span></li>
          <li class="flex items-start"><svg class="w-5 h-5 text-indigo-500 mr-2 shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/></svg><span>Advanced Analytics with <strong>Drop-off Analysis</strong></span></li>
          <li class="flex items-start"><svg class="w-5 h-5 text-indigo-500 mr-2 shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/></svg><span>Team Collaboration (up to 5 users)</span></li>
          <li class="flex items-start"><svg class="w-5 h-5 text-indigo-500 mr-2 shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/></svg><span><strong>25,000</strong> AI Credits / month</span></li>
          <li class="flex items-start"><svg class="w-5 h-5 text-indigo-500 mr-2 shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/></svg><span><strong>AI Qualification Agents</strong> & App Builder</span></li>
          <li class="flex items-start"><svg class="w-5 h-5 text-indigo-500 mr-2 shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/></svg><span>Full <strong>API Access</strong></span></li>
        </ul>
      </div>
    </div>
    
    <div class="mt-8">
        <%= button_to "Sign Out", destroy_user_session_path, method: :delete, class: "text-slate-500 hover:text-slate-700" %>
    </div>
  </div>
</div>
</file>

<file path="views/blogs/index.html.erb">
<div class="bg-gray-50 min-h-full">
  <!-- Hero Section -->
  <div class="bg-gradient-to-r from-indigo-600 to-purple-600 text-white">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
      <div class="text-center">
        <h1 class="text-4xl font-bold tracking-tight sm:text-5xl md:text-6xl">
          Resource Center
        </h1>
        <p class="mt-6 max-w-2xl mx-auto text-xl text-indigo-200">
          Learn to create effective forms that generate results. Guides, best practices, and expert tips.
        </p>
      </div>
    </div>
  </div>

  <!-- Search and Filter -->
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
    <div class="mb-8">
      <div class="flex flex-col sm:flex-row gap-4 items-center justify-between">
        <div class="flex items-center space-x-4"
             data-controller="dropdown">
          <button type="button"
                  class="inline-flex items-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50"
                  data-action="click->dropdown#toggle">
            <span>Categories</span>
            <svg class="ml-2 -mr-1 h-5 w-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
            </svg>
          </button>
          
          <div class="hidden absolute z-10 mt-2 w-56 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5"
               data-dropdown-target="menu">
            <div class="py-1">
              <%= link_to "All categories", blogs_path, class: "block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" %>
              <%= link_to "Marketing", blogs_path(category: "marketing"), class: "block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" %>
              <%= link_to "Research", blogs_path(category: "investigacion"), class: "block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" %>
              <%= link_to "Best Practices", blogs_path(category: "practicas"), class: "block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" %>
              <%= link_to "Feedback", blogs_path(category: "feedback"), class: "block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" %>
            </div>
          </div>
        </div>
        
        <div class="relative">
          <input type="text"
                 placeholder="Search articles..."
                 class="w-full sm:w-64 px-4 py-2 border border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500"
                 data-controller="search"
                 data-action="input->search#filter">
        </div>
      </div>
    </div>

    <!-- Articles Grid -->
    <div class="grid gap-8 md:grid-cols-2 lg:grid-cols-3">
      <% @articles.each do |article| %>
        <article class="bg-white rounded-lg shadow-md overflow-hidden hover:shadow-lg transition-shadow duration-300"
                 data-search-item="true"
                 data-category="<%= article[:category].downcase %>">
          <div class="p-6">
            <div class="flex items-center justify-between mb-2">
              <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-indigo-100 text-indigo-800">
                <%= article[:category] %>
              </span>
              <span class="text-sm text-gray-500"><%= article[:read_time] %></span>
            </div>
            
            <h2 class="text-xl font-semibold text-gray-900 mb-2">
              <%= link_to article[:title], blog_path(article[:slug]), class: "hover:text-indigo-600" %>
            </h2>
            
            <p class="text-gray-600 mb-4">
              <%= article[:description] %>
            </p>
            
            <div class="flex items-center justify-between text-sm text-gray-500">
              <span>Por <%= article[:author] %></span>
              <span><%= l(article[:date], format: :short) %></span>
            </div>
            
            <div class="mt-4"
                 data-controller="tooltip"
                 data-tooltip-content="Read full article">
              <%= link_to "Read more", blog_path(article[:slug]), 
                  class: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-indigo-600 bg-indigo-100 hover:bg-indigo-200" %>
            </div>
          </div>
        </article>
      <% end %>
    </div>

    <!-- Newsletter CTA -->
    <div class="mt-12 bg-white rounded-lg shadow-md p-8 text-center">
      <svg class="mx-auto h-12 w-12 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
      </svg>
      <h3 class="mt-4 text-xl font-semibold text-gray-900">
        Stay updated with best practices
      </h3>
      <p class="mt-2 text-gray-600">
        Get weekly tips on how to create more effective forms.
      </p>
      <div class="mt-6 max-w-md mx-auto">
        <%= form_with url: "#", local: true, class: "flex gap-2" do |form| %>
          <%= email_field_tag :email, nil, 
              class: "flex-1 px-4 py-2 border border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500",
              placeholder: "your@email.com",
              required: true %>
          <%= submit_tag "Subscribe", class: "px-6 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700" %>
        <% end %>
      </div>
    </div>
  </div>
</div>
</file>

<file path="views/blogs/show.html.erb">
<div class="bg-gray-50 min-h-full">
  <!-- Article Header -->
  <div class="bg-white border-b">
    <div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
      <!-- Breadcrumb -->
      <nav class="mb-8" aria-label="Breadcrumb">
        <ol class="flex items-center space-x-2 text-sm text-gray-500">
          <li><%= link_to "Resource Center", blogs_path, class: "hover:text-gray-700" %></li>
          <li class="text-gray-400"><svg class="h-4 w-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd" /></svg></li>
          <li class="text-gray-900 font-medium"><%= @article[:title] %></li>
        </ol>
      </nav>

      <div class="text-center">
        <div class="flex items-center justify-center space-x-4 text-sm text-gray-500 mb-4">
          <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-indigo-100 text-indigo-800">
            <%= @article[:category] %>
          </span>
          <span><%= @article[:read_time] %> read</span>
          <span>By <%= @article[:author] %></span>
          <span><%= l(@article[:date], format: :long) %></span>
        </div>
        
        <h1 class="text-4xl font-bold text-gray-900 mb-4">
          <%= @article[:title] %>
        </h1>
        
        <p class="text-xl text-gray-600 max-w-3xl mx-auto">
          <%= @article[:description] %>
        </p>
      </div>
    </div>
  </div>

  <!-- Article Content -->
  <div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
    <div class="prose prose-lg max-w-none">
      <!-- Introduction -->
      <div class="bg-indigo-50 border-l-4 border-indigo-400 p-6 mb-8">
        <p class="text-indigo-800 font-medium">
          <%= @article[:content][:introduction] %>
        </p>
      </div>

      <!-- Main Content -->
      <% if @article[:content][:sections] %>
        <% @article[:content][:sections].each do |section| %>
          <section class="mb-8">
            <h2 class="text-2xl font-bold text-gray-900 mb-4">
              <%= section[:title] %>
            </h2>
            <p class="text-gray-700 leading-relaxed">
              <%= section[:content] %>
            </p>
          </section>
        <% end %>
      <% end %>

      <% if @article[:content][:elements] %>
        <section class="mb-8">
          <h2 class="text-2xl font-bold text-gray-900 mb-4">Essential Elements</h2>
          <div class="space-y-4">
            <% @article[:content][:elements].each do |element| %>
              <div class="border-l-4 border-indigo-500 pl-4">
                <h3 class="text-lg font-semibold text-gray-900"><%= element[:name] %></h3>
                <p class="text-gray-700"><%= element[:description] %></p>
              </div>
            <% end %>
          </div>
        </section>
      <% end %>

      <% if @article[:content][:questions] %>
        <section class="mb-8">
          <h2 class="text-2xl font-bold text-gray-900 mb-4">Key Questions</h2>
          <div class="bg-gray-50 rounded-lg p-6">
            <ul class="space-y-2">
              <% @article[:content][:questions].each do |question| %>
                <li class="flex items-start">
                  <svg class="w-6 h-6 text-indigo-600 mr-2 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                  </svg>
                  <span><%= question %></span>
                </li>
              <% end %>
            </ul>
          </div>
        </section>
      <% end %>

      <% if @article[:content][:tips] %>
        <section class="mb-8">
          <h2 class="text-2xl font-bold text-gray-900 mb-4">Quick Tips</h2>
          <div class="grid md:grid-cols-2 gap-4">
            <% @article[:content][:tips].each do |tip| %>
              <div class="bg-green-50 border border-green-200 rounded-lg p-4">
                <p class="text-green-800">
                  <svg class="inline w-4 h-4 mr-1 text-green-600" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
                  </svg>
                  <%= tip %>
                </p>
              </div>
            <% end %>
          </div>
        </section>
      <% end %>
    </div>

    <!-- Related Articles -->
    <div class="mt-12 bg-white rounded-lg shadow-md p-6">
      <h3 class="text-xl font-semibold text-gray-900 mb-4">Related Articles</h3>
      <div class="grid md:grid-cols-2 gap-4"
           data-controller="related-articles">
        <% [
          { title: "Formularios para Marketing", slug: "formularios-marketing-conversion" },
          { title: "Investigacin de Mercados", slug: "investigacion-mercados-formularios" },
          { title: "Elementos de Formulario Exitoso", slug: "elementos-formulario-exitoso" },
          { title: "Feedback y Satisfaccin", slug: "formularios-feedback-satisfaccion" }
        ].each do |related| %>
          <div class="border border-gray-200 rounded-lg p-4 hover:border-indigo-300 transition-colors"
               data-related-article="<%= related[:slug] %>">
            <h4 class="font-medium text-gray-900 mb-1"><%= link_to related[:title], blog_path(related[:slug]), class: "hover:text-indigo-600" %></h4>
            <p class="text-sm text-gray-600">Practical tips to improve your forms</p>
          </div>
        <% end %>
      </div>
    </div>

    <!-- CTA Section -->
    <div class="mt-12 bg-indigo-600 rounded-lg shadow-md p-8 text-center">
      <svg class="mx-auto h-12 w-12 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
      </svg>
      <h3 class="mt-4 text-2xl font-bold text-white">
        Ready to create your first form?
      </h3>
      <p class="mt-2 text-indigo-200">
        Apply these tips and create more effective forms today.
      </p>
      <div class="mt-6">
        <% if user_signed_in? %>
          <%= link_to "Create Form", new_form_path, class: "inline-flex items-center px-6 py-3 bg-white text-indigo-600 font-medium rounded-md hover:bg-gray-50" %>
        <% else %>
          <%= link_to "Sign Up Free", new_user_registration_path, class: "inline-flex items-center px-6 py-3 bg-white text-indigo-600 font-medium rounded-md hover:bg-gray-50 mr-4" %>
          <%= link_to "Explore Forms", forms_path, class: "inline-flex items-center px-6 py-3 border border-white text-white font-medium rounded-md hover:bg-indigo-700" %>
        <% end %>
      </div>
    </div>
  </div>
</div>

<!-- JavaScript for related articles -->
<script>
document.addEventListener('DOMContentLoaded', function() {
  // Simple related articles functionality
  const currentSlug = window.location.pathname.split('/').pop();
  const relatedArticles = document.querySelectorAll('[data-related-article]');
  
  relatedArticles.forEach(article => {
    if (article.dataset.relatedArticle === currentSlug) {
      article.style.display = 'none';
    }
  });
});
</script>
</file>

<file path="views/devise/confirmations/new.html.erb">
<h2>Resend confirmation instructions</h2>

<%= form_for(resource, as: resource_name, url: confirmation_path(resource_name), html: { method: :post }) do |f| %>
  <%= render "devise/shared/error_messages", resource: resource %>

  <div class="field">
    <%= f.label :email %><br />
    <%= f.email_field :email, autofocus: true, autocomplete: "email", value: (resource.pending_reconfirmation? ? resource.unconfirmed_email : resource.email) %>
  </div>

  <div class="actions">
    <%= f.submit "Resend confirmation instructions" %>
  </div>
<% end %>

<%= render "devise/shared/links" %>
</file>

<file path="views/devise/mailer/confirmation_instructions.html.erb">
<p>Welcome <%= @email %>!</p>

<p>You can confirm your account email through the link below:</p>

<p><%= link_to 'Confirm my account', confirmation_url(@resource, confirmation_token: @token) %></p>
</file>

<file path="views/devise/mailer/email_changed.html.erb">
<p>Hello <%= @email %>!</p>

<% if @resource.try(:unconfirmed_email?) %>
  <p>We're contacting you to notify you that your email is being changed to <%= @resource.unconfirmed_email %>.</p>
<% else %>
  <p>We're contacting you to notify you that your email has been changed to <%= @resource.email %>.</p>
<% end %>
</file>

<file path="views/devise/mailer/password_change.html.erb">
<p>Hello <%= @resource.email %>!</p>

<p>We're contacting you to notify you that your password has been changed.</p>
</file>

<file path="views/devise/mailer/reset_password_instructions.html.erb">
<p>Hello <%= @resource.email %>!</p>

<p>Someone has requested a link to change your password. You can do this through the link below.</p>

<p><%= link_to 'Change my password', edit_password_url(@resource, reset_password_token: @token) %></p>

<p>If you didn't request this, please ignore this email.</p>
<p>Your password won't change until you access the link above and create a new one.</p>
</file>

<file path="views/devise/mailer/unlock_instructions.html.erb">
<p>Hello <%= @resource.email %>!</p>

<p>Your account has been locked due to an excessive number of unsuccessful sign in attempts.</p>

<p>Click the link below to unlock your account:</p>

<p><%= link_to 'Unlock my account', unlock_url(@resource, unlock_token: @token) %></p>
</file>

<file path="views/devise/passwords/edit.html.erb">
<h2>Change your password</h2>

<%= form_for(resource, as: resource_name, url: password_path(resource_name), html: { method: :put }) do |f| %>
  <%= render "devise/shared/error_messages", resource: resource %>
  <%= f.hidden_field :reset_password_token %>

  <div class="field">
    <%= f.label :password, "New password" %><br />
    <% if @minimum_password_length %>
      <em>(<%= @minimum_password_length %> characters minimum)</em><br />
    <% end %>
    <%= f.password_field :password, autofocus: true, autocomplete: "new-password" %>
  </div>

  <div class="field">
    <%= f.label :password_confirmation, "Confirm new password" %><br />
    <%= f.password_field :password_confirmation, autocomplete: "new-password" %>
  </div>

  <div class="actions">
    <%= f.submit "Change my password" %>
  </div>
<% end %>

<%= render "devise/shared/links" %>
</file>

<file path="views/devise/passwords/new.html.erb">
<h2>Forgot your password?</h2>

<%= form_for(resource, as: resource_name, url: password_path(resource_name), html: { method: :post }) do |f| %>
  <%= render "devise/shared/error_messages", resource: resource %>

  <div class="field">
    <%= f.label :email %><br />
    <%= f.email_field :email, autofocus: true, autocomplete: "email" %>
  </div>

  <div class="actions">
    <%= f.submit "Send me reset password instructions" %>
  </div>
<% end %>

<%= render "devise/shared/links" %>
</file>

<file path="views/devise/registrations/edit.html.erb">
<h2>Edit <%= resource_name.to_s.humanize %></h2>

<%= form_for(resource, as: resource_name, url: registration_path(resource_name), html: { method: :put }) do |f| %>
  <%= render "devise/shared/error_messages", resource: resource %>

  <div class="field">
    <%= f.label :email %><br />
    <%= f.email_field :email, autofocus: true, autocomplete: "email" %>
  </div>

  <% if devise_mapping.confirmable? && resource.pending_reconfirmation? %>
    <div>Currently waiting confirmation for: <%= resource.unconfirmed_email %></div>
  <% end %>

  <div class="field">
    <%= f.label :password %> <i>(leave blank if you don't want to change it)</i><br />
    <%= f.password_field :password, autocomplete: "new-password" %>
    <% if @minimum_password_length %>
      <br />
      <em><%= @minimum_password_length %> characters minimum</em>
    <% end %>
  </div>

  <div class="field">
    <%= f.label :password_confirmation %><br />
    <%= f.password_field :password_confirmation, autocomplete: "new-password" %>
  </div>

  <div class="field">
    <%= f.label :current_password %> <i>(we need your current password to confirm your changes)</i><br />
    <%= f.password_field :current_password, autocomplete: "current-password" %>
  </div>

  <div class="actions">
    <%= f.submit "Update" %>
  </div>
<% end %>

<h3>Cancel my account</h3>

<div>Unhappy? <%= button_to "Cancel my account", registration_path(resource_name), data: { confirm: "Are you sure?", turbo_confirm: "Are you sure?" }, method: :delete %></div>

<%= link_to "Back", :back %>
</file>

<file path="views/devise/registrations/new.html.erb">
<h2>Sign up</h2>

<%= form_for(resource, as: resource_name, url: registration_path(resource_name)) do |f| %>
  <%= render "devise/shared/error_messages", resource: resource %>

  <div class="field">
    <%= f.label :email %><br />
    <%= f.email_field :email, autofocus: true, autocomplete: "email" %>
  </div>

  <div class="field">
    <%= f.label :password %>
    <% if @minimum_password_length %>
    <em>(<%= @minimum_password_length %> characters minimum)</em>
    <% end %><br />
    <%= f.password_field :password, autocomplete: "new-password" %>
  </div>

  <div class="field">
    <%= f.label :password_confirmation %><br />
    <%= f.password_field :password_confirmation, autocomplete: "new-password" %>
  </div>

  <div class="actions">
    <%= f.submit "Sign up" %>
  </div>
<% end %>

<%= render "devise/shared/links" %>
</file>

<file path="views/devise/sessions/new.html.erb">
<div class="flex items-center justify-center min-h-screen bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
  <div class="max-w-md w-full space-y-8">
    <div>
      <h2 class="mt-6 text-center text-3xl font-extrabold text-gray-900">
        Sign in to your account
      </h2>
      <p class="mt-2 text-center text-sm text-gray-600">
        Welcome back to AgentForm
      </p>
    </div>
     
    <div class="bg-white py-8 px-4 shadow-lg rounded-lg sm:px-10">
      <%= form_with(model: resource, 
                    as: resource_name, 
                    url: session_path(resource_name), 
                    local: true, 
                    html: { class: "space-y-6" }) do |f| %>
        
        <div>
          <%= f.label :email, class: "block text-sm font-medium text-gray-700" %>
          <div class="mt-1">
            <%= f.email_field :email,
                  autofocus: true,
                  autocomplete: "email",
                  required: true,
                  class: "block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" %>
          </div>
        </div>
        
        <div>
          <%= f.label :password, class: "block text-sm font-medium text-gray-700" %>
          <div class="mt-1">
            <%= f.password_field :password,
                  autocomplete: "current-password",
                  required: true,
                  class: "block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" %>
          </div>
        </div>
        
        <% if devise_mapping.rememberable? %>
          <div class="flex items-center">
            <%= f.check_box :remember_me, class: "h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded" %>
            <%= f.label :remember_me, class: "ml-2 block text-sm text-gray-900" %>
          </div>
        <% end %>
        
        <div>
          <%= f.submit "Sign in", class: "w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" %>
        </div>
      <% end %>
      
      <div class="mt-6">
        <%= render "devise/shared/links" %>
      </div>
    </div>
  </div>
</div>
</file>

<file path="views/devise/shared/_error_messages.html.erb">
<% if resource.errors.any? %>
  <div id="error_explanation" data-turbo-cache="false">
    <h2>
      <%= I18n.t("errors.messages.not_saved",
                 count: resource.errors.count,
                 resource: resource.class.model_name.human.downcase)
       %>
    </h2>
    <ul>
      <% resource.errors.full_messages.each do |message| %>
        <li><%= message %></li>
      <% end %>
    </ul>
  </div>
<% end %>
</file>

<file path="views/devise/shared/_links.html.erb">
<div class="space-y-4">
  <%- if controller_name != 'sessions' %>
    <%= link_to "Log in", new_session_path(resource_name), class: "w-full flex justify-center py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50" %>
  <% end %>

  <%- if devise_mapping.registerable? && controller_name != 'registrations' %>
    <%= link_to "Sign up", new_registration_path(resource_name), class: "w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-green-600 hover:bg-green-700" %>
  <% end %>

  <%- if devise_mapping.recoverable? && controller_name != 'passwords' && controller_name != 'registrations' %>
    <div class="text-center">
      <%= link_to "Forgot your password?", new_password_path(resource_name), class: "text-sm text-indigo-600 hover:text-indigo-500" %>
    </div>
  <% end %>

  <%- if devise_mapping.confirmable? && controller_name != 'confirmations' %>
    <div class="text-center">
      <%= link_to "Didn't receive confirmation instructions?", new_confirmation_path(resource_name), class: "text-sm text-indigo-600 hover:text-indigo-500" %>
    </div>
  <% end %>

  <%- if devise_mapping.lockable? && resource_class.unlock_strategy_enabled?(:email) && controller_name != 'unlocks' %>
    <div class="text-center">
      <%= link_to "Didn't receive unlock instructions?", new_unlock_path(resource_name), class: "text-sm text-indigo-600 hover:text-indigo-500" %>
    </div>
  <% end %>

  <%- if devise_mapping.omniauthable? %>
    <div class="space-y-2">
      <%- resource_class.omniauth_providers.each do |provider| %>
        <%= button_to "Sign in with #{OmniAuth::Utils.camelize(provider)}", 
              omniauth_authorize_path(resource_name, provider), 
              data: { turbo: false }, 
              class: "w-full flex justify-center py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50" %>
      <% end %>
    </div>
  <% end %>
</div>
</file>

<file path="views/devise/unlocks/new.html.erb">
<h2>Resend unlock instructions</h2>

<%= form_for(resource, as: resource_name, url: unlock_path(resource_name), html: { method: :post }) do |f| %>
  <%= render "devise/shared/error_messages", resource: resource %>

  <div class="field">
    <%= f.label :email %><br />
    <%= f.email_field :email, autofocus: true, autocomplete: "email" %>
  </div>

  <div class="actions">
    <%= f.submit "Resend unlock instructions" %>
  </div>
<% end %>

<%= render "devise/shared/links" %>
</file>

<file path="views/errors/404.html.erb">
<div class="text-center">
  <div class="mb-8">
    <div class="text-6xl font-bold text-gray-300 mb-4">404</div>
    <h1 class="text-2xl font-bold text-gray-900 mb-2">Page Not Found</h1>
    <p class="text-gray-600">
      Sorry, we couldn't find the page you're looking for.
    </p>
  </div>
  
  <div class="bg-white rounded-lg shadow-sm border p-6">
    <div class="flex items-center justify-center w-12 h-12 mx-auto mb-4 bg-red-100 rounded-full">
      <svg class="w-6 h-6 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
      </svg>
    </div>
    <p class="text-sm text-gray-500">
      The page you requested might have been moved, deleted, or you might have mistyped the URL.
    </p>
  </div>
</div>
</file>

<file path="views/errors/form_error.html.erb">
<% content_for :title, "Error" %>

<div class="text-center py-12">
  <!-- Error icon -->
  <div class="mx-auto flex items-center justify-center h-16 w-16 rounded-full bg-red-100 mb-6">
    <svg class="h-8 w-8 text-red-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" />
    </svg>
  </div>
  
  <!-- Error message -->
  <h1 class="text-2xl font-bold text-gray-900 mb-4">
    <% case status %>
    <% when :not_found %>
      Form Not Found
    <% when :gone %>
      Form No Longer Available
    <% else %>
      Something Went Wrong
    <% end %>
  </h1>
  
  <div class="max-w-md mx-auto">
    <p class="text-lg text-gray-600 mb-8">
      <%= message %>
    </p>
    
    <% case status %>
    <% when :not_found %>
      <p class="text-sm text-gray-500 mb-6">
        The form you're looking for might have been moved, deleted, or the link might be incorrect.
      </p>
    <% when :gone %>
      <p class="text-sm text-gray-500 mb-6">
        This form has expired or is no longer accepting responses.
      </p>
    <% else %>
      <p class="text-sm text-gray-500 mb-6">
        Please try again in a few moments. If the problem persists, contact the form owner.
      </p>
    <% end %>
    
    <!-- Action buttons -->
    <div class="space-y-3">
      <button onclick="window.history.back()" 
              class="w-full inline-flex justify-center items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
        Go Back
      </button>
      
      <a href="https://agentform.com" 
         class="w-full inline-flex justify-center items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
        Visit AgentForm
      </a>
    </div>
  </div>
</div>
</file>

<file path="views/form_questions/analytics.html.erb">
<div class="container mx-auto px-4 py-8">
  <div class="flex justify-between items-center mb-6">
    <h1 class="text-2xl font-bold text-gray-900">Question Analytics</h1>
    <%= link_to "Back to Question", form_form_question_path(@form, @question), 
        class: "text-gray-600 hover:text-gray-900" %>
  </div>

  <!-- Question Info -->
  <div class="bg-white shadow rounded-lg p-6 mb-6">
    <h2 class="text-lg font-medium text-gray-900 mb-2"><%= @question.title %></h2>
    <p class="text-sm text-gray-500">
      Position <%= @question.position %>  <%= @question.question_type.humanize %>
      <% if @question.required? %>
         Required
      <% end %>
    </p>
  </div>

  <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
    <!-- Key Metrics -->
    <div class="lg:col-span-2">
      <div class="bg-white shadow rounded-lg p-6 mb-6">
        <h3 class="text-lg font-medium text-gray-900 mb-4">Performance Metrics</h3>
        
        <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
          <div class="text-center">
            <div class="text-2xl font-bold text-indigo-600">
              <%= @performance_metrics[:completion_rate] || 0 %>%
            </div>
            <div class="text-sm text-gray-500">Completion Rate</div>
          </div>
          
          <div class="text-center">
            <div class="text-2xl font-bold text-green-600">
              <%= @performance_metrics[:average_response_time] || 0 %>s
            </div>
            <div class="text-sm text-gray-500">Avg Response Time</div>
          </div>
          
          <div class="text-center">
            <div class="text-2xl font-bold text-yellow-600">
              <%= @performance_metrics[:skip_rate] || 0 %>%
            </div>
            <div class="text-sm text-gray-500">Skip Rate</div>
          </div>
          
          <div class="text-center">
            <div class="text-2xl font-bold text-purple-600">
              <%= @performance_metrics[:engagement_score] || 0 %>
            </div>
            <div class="text-sm text-gray-500">Engagement Score</div>
          </div>
        </div>
      </div>

      <!-- Response Distribution -->
      <div class="bg-white shadow rounded-lg p-6">
        <h3 class="text-lg font-medium text-gray-900 mb-4">Response Distribution</h3>
        
        <% if @response_distribution.any? %>
          <div class="space-y-3">
            <% @response_distribution.each do |response, percentage| %>
              <div class="flex items-center justify-between">
                <div class="flex-1">
                  <div class="text-sm font-medium text-gray-900 truncate">
                    <%= response %>
                  </div>
                  <div class="w-full bg-gray-200 rounded-full h-2 mt-1">
                    <div class="bg-indigo-600 h-2 rounded-full" 
                         style="width: <%= percentage %>%"></div>
                  </div>
                </div>
                <div class="ml-4 text-sm font-medium text-gray-900">
                  <%= percentage %>%
                </div>
              </div>
            <% end %>
          </div>
        <% else %>
          <p class="text-gray-500">No response data available yet.</p>
        <% end %>
      </div>
    </div>

    <!-- Analytics Summary -->
    <div class="lg:col-span-1">
      <div class="bg-white shadow rounded-lg p-6 mb-6">
        <h3 class="text-lg font-medium text-gray-900 mb-4">Summary</h3>
        
        <div class="space-y-4">
          <div>
            <dt class="text-sm font-medium text-gray-500">Total Responses</dt>
            <dd class="mt-1 text-lg font-semibold text-gray-900">
              <%= @question_analytics[:total_responses] || 0 %>
            </dd>
          </div>
          
          <div>
            <dt class="text-sm font-medium text-gray-500">Quality Score</dt>
            <dd class="mt-1 text-lg font-semibold text-gray-900">
              <%= @performance_metrics[:quality_score] || 0 %>/100
            </dd>
          </div>
          
          <div>
            <dt class="text-sm font-medium text-gray-500">Period</dt>
            <dd class="mt-1 text-sm text-gray-900">
              Last <%= (@analytics_period / 1.day).to_i %> days
            </dd>
          </div>
        </div>
      </div>

      <!-- Quick Actions -->
      <div class="bg-white shadow rounded-lg p-6">
        <h3 class="text-lg font-medium text-gray-900 mb-4">Quick Actions</h3>
        
        <div class="space-y-3">
          <%= link_to "Edit Question", edit_form_form_question_path(@form, @question), 
              class: "w-full bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 text-center block" %>
          
          <%= link_to "Preview Question", preview_form_form_question_path(@form, @question), 
              class: "w-full bg-gray-600 text-white px-4 py-2 rounded-md hover:bg-gray-700 text-center block" %>
          
          <% if @form.ai_enhanced? %>
            <%= link_to "AI Enhance", ai_enhance_form_form_question_path(@form, @question), 
                method: :post,
                class: "w-full bg-purple-600 text-white px-4 py-2 rounded-md hover:bg-purple-700 text-center block" %>
          <% end %>
        </div>
      </div>
    </div>
  </div>
</div>
</file>

<file path="views/form_questions/edit.html.erb">
<div class="container mx-auto px-4 py-8">
  <div class="max-w-2xl mx-auto">
    <div class="flex justify-between items-center mb-6">
      <h1 class="text-2xl font-bold text-gray-900">Edit Question</h1>
      <%= link_to "Back to Form", edit_form_path(@form), 
          class: "text-gray-600 hover:text-gray-900" %>
    </div>

    <div class="bg-white shadow rounded-lg p-6">
      <%= form_with model: [@form, @question], local: true, class: "space-y-6" do |form| %>
        <% if @question.errors.any? %>
          <div class="bg-red-50 border border-red-200 rounded-md p-4">
            <h3 class="text-sm font-medium text-red-800">
              <%= pluralize(@question.errors.count, "error") %> prohibited this question from being saved:
            </h3>
            <ul class="mt-2 text-sm text-red-700 list-disc list-inside">
              <% @question.errors.full_messages.each do |message| %>
                <li><%= message %></li>
              <% end %>
            </ul>
          </div>
        <% end %>

        <div>
          <%= form.label :title, class: "block text-sm font-medium text-gray-700" %>
          <%= form.text_field :title, 
              class: "mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500",
              placeholder: "Enter your question..." %>
        </div>

        <div>
          <%= form.label :description, class: "block text-sm font-medium text-gray-700" %>
          <%= form.text_area :description, 
              rows: 3,
              class: "mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500",
              placeholder: "Optional description or help text..." %>
        </div>

        <div>
          <%= form.label :question_type, class: "block text-sm font-medium text-gray-700" %>
          <%= form.select :question_type, 
              options_for_select(@question_types.map { |type| [type.humanize, type] }, @question.question_type),
              {},
              { class: "mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500" } %>
          
          <!-- Payment Feature Notice -->
          <% unless current_user.can_accept_payments? %>
            <div id="payment-premium-notice" class="mt-2 p-3 bg-amber-50 border border-amber-200 rounded-md <%= 'hidden' unless @question.question_type == 'payment' %>">
              <div class="flex items-start">
                <svg class="w-5 h-5 text-amber-600 mt-0.5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.5 0L4.232 15.5c-.77.833.192 2.5 1.732 2.5z"></path>
                </svg>
                <div class="flex-1">
                  <% if current_user.premium? %>
                    <h4 class="text-sm font-medium text-amber-800">Stripe Configuration Required</h4>
                    <p class="mt-1 text-sm text-amber-700">
                      To accept payments, you need to configure your Stripe account. 
                      <a href="<%= stripe_settings_path %>" class="font-medium underline hover:text-amber-600">Configure Stripe</a> 
                      to start accepting payments through your forms.
                    </p>
                  <% else %>
                    <h4 class="text-sm font-medium text-amber-800">Premium Feature</h4>
                    <p class="mt-1 text-sm text-amber-700">
                      Payment questions are only available for Premium users. 
                      <a href="#" class="font-medium underline hover:text-amber-600">Upgrade your account</a> 
                      to accept payments directly through your forms.
                    </p>
                  <% end %>
                </div>
              </div>
            </div>
          <% end %>
        </div>

        <div>
          <%= form.label :position, class: "block text-sm font-medium text-gray-700" %>
          <%= form.number_field :position, 
              class: "mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500" %>
        </div>

        <!-- Multiple Choice Configuration -->
        <div id="choice-configuration" class="space-y-4" style="display: none;">
          <h3 class="text-lg font-medium text-gray-900">Choice Options</h3>
          
          <div id="options-container" class="space-y-3">
            <% current_options = @question.question_config&.dig('options') || [] %>
            <% current_options.each_with_index do |option, index| %>
              <div class="flex items-center space-x-2 option-item">
                <%= text_field_tag "form_question[question_config][options][]", option,
                    class: "block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500",
                    placeholder: "Option #{index + 1}" %>
                <button type="button" class="remove-option text-red-600 hover:text-red-800">
                  <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                  </svg>
                </button>
              </div>
            <% end %>
          </div>
          
          <button type="button" id="add-option" class="inline-flex items-center px-3 py-1.5 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50">
            Add Option
          </button>
        </div>

        <!-- Rating Configuration -->
        <div id="rating-configuration" class="space-y-4" style="display: none;">
          <h3 class="text-lg font-medium text-gray-900">Rating Configuration</h3>
          
          <div class="grid grid-cols-2 gap-4">
            <div>
              <%= label_tag "form_question[question_config][min_value]", "Minimum Value", class: "block text-sm font-medium text-gray-700" %>
              <%= number_field_tag "form_question[question_config][min_value]", 
                  @question.question_config&.dig('min_value') || 1,
                  class: "mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500" %>
            </div>
            <div>
              <%= label_tag "form_question[question_config][max_value]", "Maximum Value", class: "block text-sm font-medium text-gray-700" %>
              <%= number_field_tag "form_question[question_config][max_value]", 
                  @question.question_config&.dig('max_value') || 5,
                  class: "mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500" %>
            </div>
          </div>
        </div>

        <!-- Drag and Drop Configuration -->
        <div id="drag-drop-configuration" class="space-y-4" style="display: none;">
          <h3 class="text-lg font-medium text-gray-900">Drag and Drop Configuration</h3>
          
          <div class="space-y-4">
            <div>
              <%= label_tag "form_question[question_config][items][]", "Items to Drag", class: "block text-sm font-medium text-gray-700" %>
              <div id="items-container" class="space-y-2">
                <% current_items = @question.question_config&.dig('items') || [] %>
                <% current_items.each_with_index do |item, index| %>
                  <div class="flex items-center space-x-2 item-item">
                    <%= text_field_tag "form_question[question_config][items][]", item,
                        class: "block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500",
                        placeholder: "Item #{index + 1}" %>
                    <button type="button" class="remove-item text-red-600 hover:text-red-800">
                      <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                      </svg>
                    </button>
                  </div>
                <% end %>
              </div>
              <button type="button" id="add-item" class="inline-flex items-center px-3 py-1.5 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50">
                Add Item
              </button>
            </div>

            <div>
              <%= label_tag "form_question[question_config][categories][]", "Drop Categories", class: "block text-sm font-medium text-gray-700" %>
              <div id="categories-container" class="space-y-2">
                <% current_categories = @question.question_config&.dig('categories') || [] %>
                <% current_categories.each_with_index do |category, index| %>
                  <div class="flex items-center space-x-2 category-item">
                    <%= text_field_tag "form_question[question_config][categories][]", category,
                        class: "block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500",
                        placeholder: "Category #{index + 1}" %>
                    <button type="button" class="remove-category text-red-600 hover:text-red-800">
                      <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                      </svg>
                    </button>
                  </div>
                <% end %>
              </div>
              <button type="button" id="add-category" class="inline-flex items-center px-3 py-1.5 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50">
                Add Category
              </button>
            </div>
          </div>
        </div>

        <!-- Matrix Configuration -->
        <div id="matrix-configuration" class="space-y-4" style="display: none;">
          <h3 class="text-lg font-medium text-gray-900">Matrix Configuration</h3>
          
          <div class="space-y-4">
            <div>
              <%= label_tag "form_question[question_config][rows][]", "Matrix Rows", class: "block text-sm font-medium text-gray-700" %>
              <div id="matrix-rows-container" class="space-y-2">
                <% current_rows = @question.question_config&.dig('rows') || [] %>
                <% current_rows.each_with_index do |row, index| %>
                  <div class="flex items-center space-x-2 matrix-row-item">
                    <%= text_field_tag "form_question[question_config][rows][]", row,
                        class: "block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500",
                        placeholder: "Row #{index + 1}" %>
                    <button type="button" class="remove-matrix-row text-red-600 hover:text-red-800">
                      <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                      </svg>
                    </button>
                  </div>
                <% end %>
              </div>
              <button type="button" id="add-matrix-row" class="inline-flex items-center px-3 py-1.5 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50">
                Add Row
              </button>
            </div>

            <div>
              <%= label_tag "form_question[question_config][columns][]", "Matrix Columns", class: "block text-sm font-medium text-gray-700" %>
              <div id="matrix-columns-container" class="space-y-2">
                <% current_columns = @question.question_config&.dig('columns') || [] %>
                <% current_columns.each_with_index do |column, index| %>
                  <div class="flex items-center space-x-2 matrix-column-item">
                    <%= text_field_tag "form_question[question_config][columns][]", column,
                        class: "block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500",
                        placeholder: "Column #{index + 1}" %>
                    <button type="button" class="remove-matrix-column text-red-600 hover:text-red-800">
                      <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                      </svg>
                    </button>
                  </div>
                <% end %>
              </div>
              <button type="button" id="add-matrix-column" class="inline-flex items-center px-3 py-1.5 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50">
                Add Column
              </button>
            </div>
          </div>
        </div>

        <!-- Conditional Logic Configuration -->
        <div id="conditional-configuration" class="space-y-4" style="display: none;">
          <h3 class="text-lg font-medium text-gray-900">Conditional Logic Rules</h3>
          
          <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
            <div class="flex items-start">
              <div class="flex-shrink-0">
                <svg class="h-5 w-5 text-blue-400" fill="currentColor" viewBox="0 0 20 20">
                  <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"/>
                </svg>
              </div>
              <div class="ml-3">
                <h4 class="text-sm font-medium text-blue-800">How conditional logic works</h4>
                <p class="text-sm text-blue-700 mt-1">
                  This question will only be shown if ALL the conditions below are met. 
                  The conditions are checked against answers from previous questions.
                </p>
              </div>
            </div>
          </div>
          
          <div class="bg-gray-50 p-4 rounded-lg">
            <div id="conditional-rules-container" class="space-y-4">
              <% current_rules = @question.conditional_logic&.dig('rules') || [] %>
              <% current_rules.each_with_index do |rule, index| %>
                <div class="conditional-rule border border-gray-200 rounded-lg p-4 bg-white relative" data-rule-index="<%= index %>">
                  <!-- Rule Number Badge -->
                  <div class="absolute -top-2 -left-2 bg-indigo-500 text-white text-xs rounded-full w-6 h-6 flex items-center justify-center font-semibold">
                    <%= index + 1 %>
                  </div>
                  
                  <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <!-- Question Selection -->
                    <div>
                      <%= label_tag "form_question[conditional_logic][rules][][question_id]", "Previous Question", class: "block text-sm font-medium text-gray-700" %>
                      <% 
                        question_options = @conditional_questions.map do |q|
                          # Include question type and sample options for better UX
                          label = "#{q.title}"
                          if q.question_type == 'single_choice' && q.choice_options.any?
                            sample_options = q.choice_options.first(2).join(', ')
                            sample_options += '...' if q.choice_options.length > 2
                            label += " (Options: #{sample_options})"
                          elsif q.question_type == 'yes_no'
                            label += " (Yes/No)"
                          end
                          [label, q.reference_id || q.id, { 'data-question-type' => q.question_type, 'data-options' => q.choice_options&.to_json }]
                        end
                      %>
                      <%= select_tag "form_question[conditional_logic][rules][][question_id]", 
                          options_for_select(question_options.map { |opt| [opt[0], opt[1], opt[2]] }, rule['question_id']),
                          { prompt: "Select a previous question...", 
                            class: "question-select mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500" } %>
                      
                      <!-- Dynamic help text based on selected question -->
                      <div class="question-help-text mt-1 text-xs text-gray-500" style="display: none;">
                        <span class="available-options"></span>
                      </div>
                    </div>
                    
                    <!-- Operator Selection -->
                    <div>
                      <%= label_tag "form_question[conditional_logic][rules][][operator]", "Condition", class: "block text-sm font-medium text-gray-700" %>
                      <%= select_tag "form_question[conditional_logic][rules][][operator]",
                          options_for_select([
                            ['is exactly', 'equals'],
                            ['is not', 'not_equals'],
                            ['contains', 'contains'],
                            ['does not contain', 'not_contains'],
                            ['starts with', 'starts_with'],
                            ['ends with', 'ends_with'],
                            ['is greater than', 'greater_than'],
                            ['is less than', 'less_than'],
                            ['is empty (no answer)', 'is_empty'],
                            ['has any answer', 'is_not_empty']
                          ], rule['operator']),
                          { prompt: "Select condition...",
                            class: "operator-select mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500" } %>
                    </div>
                    
                    <!-- Value Selection -->
                    <div class="value-field">
                      <%= label_tag "form_question[conditional_logic][rules][][value]", "Expected Value", class: "block text-sm font-medium text-gray-700" %>
                      <div class="value-input-container">
                        <%= text_field_tag "form_question[conditional_logic][rules][][value]", rule['value'],
                            class: "value-input mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500",
                            placeholder: "Enter the expected value..." %>
                      </div>
                      
                      <!-- Dynamic value suggestions -->
                      <div class="value-suggestions mt-2" style="display: none;">
                        <div class="text-xs text-gray-600 mb-1">Quick select:</div>
                        <div class="flex flex-wrap gap-1"></div>
                      </div>
                    </div>
                  </div>
                  
                  <!-- Rule Preview -->
                  <div class="mt-3 p-2 bg-gray-50 rounded text-sm text-gray-600 rule-preview">
                    <strong>Rule preview:</strong> <span class="preview-text">Configure the rule above to see preview</span>
                  </div>
                  
                  <div class="mt-4 flex justify-end">
                    <button type="button" class="remove-rule text-red-600 hover:text-red-800 inline-flex items-center">
                      <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                      </svg>
                      Remove Rule
                    </button>
                  </div>
                </div>
              <% end %>
            </div>
            
            <div class="mt-4 flex items-center justify-between">
              <button type="button" id="add-conditional-rule" class="inline-flex items-center px-3 py-1.5 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50">
                <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"/>
                </svg>
                Add Another Rule
              </button>
              
              <!-- Logic Operator for Multiple Rules -->
              <div class="logic-operator-section" style="display: none;">
                <label class="text-sm font-medium text-gray-700 mr-2">Multiple rules logic:</label>
                <%= select_tag "form_question[conditional_logic][operator]",
                    options_for_select([
                      ['ALL rules must be true (AND)', 'and'],
                      ['ANY rule can be true (OR)', 'or']
                    ], @question.conditional_logic&.dig('operator') || 'and'),
                    { class: "text-sm border-gray-300 rounded shadow-sm focus:ring-indigo-500 focus:border-indigo-500" } %>
              </div>
            </div>
            
            <!-- Test Section -->
            <div class="mt-4 p-3 border-t border-gray-200">
              <button type="button" id="test-conditional-logic" class="text-sm text-indigo-600 hover:text-indigo-800">
                 Test this logic with sample data
              </button>
              <div id="test-results" class="mt-2" style="display: none;">
                <!-- Test results will be populated here -->
              </div>
            </div>
          </div>
        </div>

        <div class="flex items-center space-x-6">
          <div class="flex items-center">
            <%= form.check_box :required, class: "h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded" %>
            <%= form.label :required, "Required", class: "ml-2 block text-sm text-gray-900" %>
          </div>

          <div class="flex items-center">
            <%= form.check_box :ai_enhanced, class: "h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded" %>
            <%= form.label :ai_enhanced, "AI Enhanced", class: "ml-2 block text-sm text-gray-900" %>
          </div>

          <div class="flex items-center">
            <%= form.check_box :conditional_enabled, class: "h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded" %>
            <%= form.label :conditional_enabled, "Conditional Logic", class: "ml-2 block text-sm text-gray-900" %>
          </div>
        </div>

        <div class="flex justify-end space-x-3">
          <%= link_to "Cancel", edit_form_path(@form), 
              class: "bg-white py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" %>
          <%= form.submit "Update Question", 
              class: "bg-indigo-600 py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" %>
        </div>
      <% end %>
    </div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const questionTypeSelect = document.getElementById('form_question_question_type');
  const choiceConfig = document.getElementById('choice-configuration');
  const ratingConfig = document.getElementById('rating-configuration');
  const dragDropConfig = document.getElementById('drag-drop-configuration');
  const optionsContainer = document.getElementById('options-container');
  const addOptionBtn = document.getElementById('add-option');
  const itemsContainer = document.getElementById('items-container');
  const addItemBtn = document.getElementById('add-item');
  const categoriesContainer = document.getElementById('categories-container');
  const addCategoryBtn = document.getElementById('add-category');
  const matrixConfig = document.getElementById('matrix-configuration');
  const matrixRowsContainer = document.getElementById('matrix-rows-container');
  const addMatrixRowBtn = document.getElementById('add-matrix-row');
  const matrixColumnsContainer = document.getElementById('matrix-columns-container');
  const addMatrixColumnBtn = document.getElementById('add-matrix-column');
  
  // Conditional Logic Elements
  const conditionalEnabled = document.getElementById('form_question_conditional_enabled');
  const conditionalConfig = document.getElementById('conditional-configuration');
  const conditionalRulesContainer = document.getElementById('conditional-rules-container');
  const addConditionalRuleBtn = document.getElementById('add-conditional-rule');

    // Enhanced Conditional Logic Management
  function initializeConditionalLogic() {
    updateLogicOperatorVisibility();
    updateAllRulePreviews();
    attachConditionalEventListeners();
  }

  function attachConditionalEventListeners() {
    // Question selection change
    document.addEventListener('change', function(e) {
      if (e.target.classList.contains('question-select')) {
        handleQuestionSelectionChange(e.target);
      }
    });

    // Operator selection change
    document.addEventListener('change', function(e) {
      if (e.target.classList.contains('operator-select')) {
        handleOperatorChange(e.target);
      }
    });

    // Value input change
    document.addEventListener('input', function(e) {
      if (e.target.classList.contains('value-input')) {
        handleValueChange(e.target);
      }
    });

    // Test logic button
    const testButton = document.getElementById('test-conditional-logic');
    if (testButton) {
      testButton.addEventListener('click', testConditionalLogic);
    }
  }

  function handleQuestionSelectionChange(questionSelect) {
    const ruleDiv = questionSelect.closest('.conditional-rule');
    const selectedOption = questionSelect.options[questionSelect.selectedIndex];
    const questionType = selectedOption.getAttribute('data-question-type');
    const questionOptions = selectedOption.getAttribute('data-options');
    
    // Update help text
    updateQuestionHelpText(ruleDiv, questionType, questionOptions);
    
    // Update operator options based on question type
    updateOperatorOptions(ruleDiv, questionType);
    
    // Update value field based on question type
    updateValueField(ruleDiv, questionType, questionOptions);
    
    // Update rule preview
    updateRulePreview(ruleDiv);
  }

  function updateQuestionHelpText(ruleDiv, questionType, questionOptions) {
    const helpText = ruleDiv.querySelector('.question-help-text');
    const availableOptions = helpText.querySelector('.available-options');
    
    if (questionType && questionOptions) {
      try {
        const options = JSON.parse(questionOptions);
        if (options && options.length > 0) {
          availableOptions.textContent = `Available options: ${options.join(', ')}`;
          helpText.style.display = 'block';
        } else {
          helpText.style.display = 'none';
        }
      } catch (e) {
        helpText.style.display = 'none';
      }
    } else if (questionType === 'yes_no') {
      availableOptions.textContent = 'Available options: Yes, No';
      helpText.style.display = 'block';
    } else {
      helpText.style.display = 'none';
    }
  }

  function updateOperatorOptions(ruleDiv, questionType) {
    const operatorSelect = ruleDiv.querySelector('.operator-select');
    const currentValue = operatorSelect.value;
    
    // Define operators for each question type
    const operatorsByType = {
      'single_choice': [
        ['is exactly', 'equals'],
        ['is not', 'not_equals'],
        ['is any of', 'in_list'],
        ['is none of', 'not_in_list']
      ],
      'multiple_choice': [
        ['contains', 'contains'],
        ['does not contain', 'not_contains'],
        ['is any of', 'in_list'],
        ['is none of', 'not_in_list']
      ],
      'yes_no': [
        ['is', 'equals']
      ],
      'text_short': [
        ['is exactly', 'equals'],
        ['contains', 'contains'],
        ['does not contain', 'not_contains'],
        ['starts with', 'starts_with'],
        ['ends with', 'ends_with'],
        ['is empty', 'is_empty'],
        ['has any answer', 'is_not_empty']
      ],
      'text_long': [
        ['contains', 'contains'],
        ['does not contain', 'not_contains'],
        ['is empty', 'is_empty'],
        ['has any answer', 'is_not_empty']
      ],
      'rating': [
        ['is exactly', 'equals'],
        ['is greater than', 'greater_than'],
        ['is less than', 'less_than'],
        ['is greater than or equal', 'greater_than_or_equal'],
        ['is less than or equal', 'less_than_or_equal']
      ]
    };

    const operators = operatorsByType[questionType] || operatorsByType['text_short'];
    
    // Clear and repopulate options
    operatorSelect.innerHTML = '<option value="">Select condition...</option>';
    operators.forEach(([label, value]) => {
      const option = document.createElement('option');
      option.value = value;
      option.textContent = label;
      if (value === currentValue) {
        option.selected = true;
      }
      operatorSelect.appendChild(option);
    });
  }

  function updateValueField(ruleDiv, questionType, questionOptions) {
    const valueContainer = ruleDiv.querySelector('.value-input-container');
    const suggestionsDiv = ruleDiv.querySelector('.value-suggestions');
    const operatorSelect = ruleDiv.querySelector('.operator-select');
    const currentValue = ruleDiv.querySelector('.value-input')?.value || '';
    
    // Operators that don't need a value
    const noValueOperators = ['is_empty', 'is_not_empty'];
    if (noValueOperators.includes(operatorSelect.value)) {
      valueContainer.style.display = 'none';
      suggestionsDiv.style.display = 'none';
      return;
    } else {
      valueContainer.style.display = 'block';
    }

    if (questionType === 'yes_no') {
      // Create yes/no select
      valueContainer.innerHTML = `
        <select name="form_question[conditional_logic][rules][][value]" 
                class="value-input mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
          <option value="">Select value...</option>
          <option value="yes" ${currentValue.toLowerCase() === 'yes' ? 'selected' : ''}>Yes</option>
          <option value="no" ${currentValue.toLowerCase() === 'no' ? 'selected' : ''}>No</option>
        </select>
      `;
      suggestionsDiv.style.display = 'none';
    } else if (questionType === 'single_choice' || questionType === 'multiple_choice') {
      // Create text input with suggestions
      valueContainer.innerHTML = `
        <input type="text" name="form_question[conditional_logic][rules][][value]" 
               class="value-input mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
               placeholder="Type or click a suggestion below..."
               value="${currentValue}">
      `;
      
      // Show suggestions
      if (questionOptions) {
        try {
          const options = JSON.parse(questionOptions);
          if (options && options.length > 0) {
            const suggestionsContainer = suggestionsDiv.querySelector('.flex');
            suggestionsContainer.innerHTML = '';
            
            options.forEach(option => {
              const button = document.createElement('button');
              button.type = 'button';
              button.className = 'text-xs px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded border text-gray-700';
              button.textContent = option;
              button.addEventListener('click', function() {
                const valueInput = ruleDiv.querySelector('.value-input');
                valueInput.value = option;
                updateRulePreview(ruleDiv);
              });
              suggestionsContainer.appendChild(button);
            });
            
            suggestionsDiv.style.display = 'block';
          } else {
            suggestionsDiv.style.display = 'none';
          }
        } catch (e) {
          suggestionsDiv.style.display = 'none';
        }
      }
    } else {
      // Standard text input
      valueContainer.innerHTML = `
        <input type="text" name="form_question[conditional_logic][rules][][value]" 
               class="value-input mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
               placeholder="Enter the expected value..."
               value="${currentValue}">
      `;
      suggestionsDiv.style.display = 'none';
    }
  }

  function handleOperatorChange(operatorSelect) {
    const ruleDiv = operatorSelect.closest('.conditional-rule');
    const questionSelect = ruleDiv.querySelector('.question-select');
    const selectedOption = questionSelect.options[questionSelect.selectedIndex];
    const questionType = selectedOption.getAttribute('data-question-type');
    const questionOptions = selectedOption.getAttribute('data-options');
    
    updateValueField(ruleDiv, questionType, questionOptions);
    updateRulePreview(ruleDiv);
  }

  function handleValueChange(valueInput) {
    const ruleDiv = valueInput.closest('.conditional-rule');
    updateRulePreview(ruleDiv);
  }

  function updateRulePreview(ruleDiv) {
    const questionSelect = ruleDiv.querySelector('.question-select');
    const operatorSelect = ruleDiv.querySelector('.operator-select');
    const valueInput = ruleDiv.querySelector('.value-input');
    const previewSpan = ruleDiv.querySelector('.preview-text');
    
    const questionText = questionSelect.options[questionSelect.selectedIndex]?.text || 'Select a question';
    const operatorText = operatorSelect.options[operatorSelect.selectedIndex]?.text || 'select condition';
    const valueText = valueInput?.value || 'enter value';
    
    // Clean question text (remove the options part)
    const cleanQuestionText = questionText.replace(/\s*\(.*\)$/, '');
    
    if (questionSelect.value && operatorSelect.value) {
      if (['is_empty', 'is_not_empty'].includes(operatorSelect.value)) {
        previewSpan.innerHTML = `Show this question when "<strong>${cleanQuestionText}</strong>" <strong>${operatorText}</strong>`;
      } else if (valueInput?.value) {
        previewSpan.innerHTML = `Show this question when "<strong>${cleanQuestionText}</strong>" <strong>${operatorText}</strong> "<strong>${valueText}</strong>"`;
      } else {
        previewSpan.innerHTML = `Show this question when "<strong>${cleanQuestionText}</strong>" <strong>${operatorText}</strong> <em>(enter value)</em>`;
      }
    } else {
      previewSpan.textContent = 'Configure the rule above to see preview';
    }
  }

  function updateAllRulePreviews() {
    document.querySelectorAll('.conditional-rule').forEach(ruleDiv => {
      updateRulePreview(ruleDiv);
    });
  }

  function updateLogicOperatorVisibility() {
    const rulesContainer = document.getElementById('conditional-rules-container');
    const logicOperatorSection = document.querySelector('.logic-operator-section');
    
    if (rulesContainer && logicOperatorSection) {
      const ruleCount = rulesContainer.children.length;
      logicOperatorSection.style.display = ruleCount > 1 ? 'block' : 'none';
    }
  }

  function testConditionalLogic() {
    const rulesContainer = document.getElementById('conditional-rules-container');
    const testResults = document.getElementById('test-results');
    const rules = [];
    
    // Collect all rules
    rulesContainer.querySelectorAll('.conditional-rule').forEach(ruleDiv => {
      const questionSelect = ruleDiv.querySelector('.question-select');
      const operatorSelect = ruleDiv.querySelector('.operator-select');
      const valueInput = ruleDiv.querySelector('.value-input');
      
      if (questionSelect.value && operatorSelect.value) {
        rules.push({
          questionText: questionSelect.options[questionSelect.selectedIndex].text.replace(/\s*\(.*\)$/, ''),
          operator: operatorSelect.value,
          operatorText: operatorSelect.options[operatorSelect.selectedIndex].text,
          value: valueInput?.value || ''
        });
      }
    });
    
    if (rules.length === 0) {
      testResults.innerHTML = '<div class="text-sm text-red-600">Please configure at least one rule to test.</div>';
      testResults.style.display = 'block';
      return;
    }
    
    // Generate test scenarios
    let testHTML = '<div class="text-sm space-y-2">';
    testHTML += '<div class="font-medium text-gray-900">Test scenarios:</div>';
    
    rules.forEach((rule, index) => {
      testHTML += `<div class="pl-4 border-l-2 border-gray-200">`;
      testHTML += `<div class="font-medium">Rule ${index + 1}:</div>`;
      testHTML += `<div class="text-gray-600">When "${rule.questionText}" ${rule.operatorText}`;
      if (rule.value && !['is_empty', 'is_not_empty'].includes(rule.operator)) {
        testHTML += ` "${rule.value}"`;
      }
      testHTML += `  This question will be shown</div>`;
      testHTML += `</div>`;
    });
    
    const logicOperator = document.querySelector('select[name*="[operator]"]')?.value || 'and';
    if (rules.length > 1) {
      testHTML += `<div class="mt-2 p-2 bg-yellow-50 border border-yellow-200 rounded">`;
      testHTML += `<strong>Multiple rules logic:</strong> ${logicOperator === 'and' ? 'ALL' : 'ANY'} of the above rules must be true`;
      testHTML += `</div>`;
    }
    
    testHTML += '</div>';
    
    testResults.innerHTML = testHTML;
    testResults.style.display = 'block';
  }

  // Enhanced add rule function
  const originalAddConditionalRule = addConditionalRuleBtn.onclick;
  addConditionalRuleBtn.onclick = function() {
    // Call original function or create new rule
    const ruleCount = conditionalRulesContainer.children.length;
    const newRule = document.createElement('div');
    newRule.className = 'conditional-rule border border-gray-200 rounded-lg p-4 bg-white relative';
    newRule.setAttribute('data-rule-index', ruleCount);
    
    newRule.innerHTML = `
      <div class="absolute -top-2 -left-2 bg-indigo-500 text-white text-xs rounded-full w-6 h-6 flex items-center justify-center font-semibold">
        ${ruleCount + 1}
      </div>
      
      <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
        <div>
          <label class="block text-sm font-medium text-gray-700">Previous Question</label>
          <select name="form_question[conditional_logic][rules][][question_id]" 
                  class="question-select mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
            <option value="">Select a previous question...</option>
            <% @conditional_questions.each do |q| %>
              <% 
                label = q.title
                if q.question_type == 'single_choice' && q.choice_options.any?
                  sample_options = q.choice_options.first(2).join(', ')
                  sample_options += '...' if q.choice_options.length > 2
                  label += " (Options: #{sample_options})"
                elsif q.question_type == 'yes_no'
                  label += " (Yes/No)"
                end
              %>
              <option value="<%= q.reference_id || q.id %>" 
                      data-question-type="<%= q.question_type %>"
                      data-options="<%= q.choice_options&.to_json %>"><%= label %></option>
            <% end %>
          </select>
          <div class="question-help-text mt-1 text-xs text-gray-500" style="display: none;">
            <span class="available-options"></span>
          </div>
        </div>
        
        <div>
          <label class="block text-sm font-medium text-gray-700">Condition</label>
          <select name="form_question[conditional_logic][rules][][operator]"
                  class="operator-select mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
            <option value="">Select condition...</option>
          </select>
        </div>
        
        <div class="value-field">
          <label class="block text-sm font-medium text-gray-700">Expected Value</label>
          <div class="value-input-container">
            <input type="text" name="form_question[conditional_logic][rules][][value]" 
                   class="value-input mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
                   placeholder="Enter the expected value...">
          </div>
          <div class="value-suggestions mt-2" style="display: none;">
            <div class="text-xs text-gray-600 mb-1">Quick select:</div>
            <div class="flex flex-wrap gap-1"></div>
          </div>
        </div>
      </div>
      
      <div class="mt-3 p-2 bg-gray-50 rounded text-sm text-gray-600 rule-preview">
        <strong>Rule preview:</strong> <span class="preview-text">Configure the rule above to see preview</span>
      </div>
      
      <div class="mt-4 flex justify-end">
        <button type="button" class="remove-rule text-red-600 hover:text-red-800 inline-flex items-center">
          <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
          </svg>
          Remove Rule
        </button>
      </div>
    `;
    
    conditionalRulesContainer.appendChild(newRule);
    
    // Add event listeners to the new rule
    newRule.querySelector('.remove-rule').addEventListener('click', function() {
      newRule.remove();
      updateLogicOperatorVisibility();
      // Renumber rules
      document.querySelectorAll('.conditional-rule').forEach((rule, index) => {
        rule.querySelector('.absolute').textContent = index + 1;
      });
    });
    
    updateLogicOperatorVisibility();
  };

  // Initialize enhanced conditional logic
  if (conditionalEnabled) {
    initializeConditionalLogic();
  }

  function showConfiguration() {
    const selectedType = questionTypeSelect.value;
    const paymentNotice = document.getElementById('payment-premium-notice');
    
    // Hide all configurations
    choiceConfig.style.display = 'none';
    ratingConfig.style.display = 'none';
    dragDropConfig.style.display = 'none';
    matrixConfig.style.display = 'none';
    
    // Show/hide premium notice for payment questions
    if (paymentNotice) {
      if (selectedType === 'payment') {
        paymentNotice.classList.remove('hidden');
      } else {
        paymentNotice.classList.add('hidden');
      }
    }
    
    // Show appropriate configuration
    if (['multiple_choice', 'single_choice', 'checkbox'].includes(selectedType)) {
      choiceConfig.style.display = 'block';
    } else if (['rating', 'scale', 'nps_score'].includes(selectedType)) {
      ratingConfig.style.display = 'block';
    } else if (['drag_drop'].includes(selectedType)) {
      dragDropConfig.style.display = 'block';
    } else if (['matrix'].includes(selectedType)) {
      matrixConfig.style.display = 'block';
    }
  }

  function showConditionalConfiguration() {
    conditionalConfig.style.display = conditionalEnabled.checked ? 'block' : 'none';
  }

  function updateConditionalRuleOptions() {
    const ruleDivs = conditionalRulesContainer.querySelectorAll('.conditional-rule');
    ruleDivs.forEach((ruleDiv, index) => {
      const questionSelect = ruleDiv.querySelector('select[name*="[question_id]"]');
      const operatorSelect = ruleDiv.querySelector('select[name*="[operator]"]');
      const valueInput = ruleDiv.querySelector('input[name*="[value]"]');
      
      // Update operator options based on question type
      if (questionSelect.value) {
        const selectedOption = questionSelect.options[questionSelect.selectedIndex];
        const questionType = selectedOption.getAttribute('data-question-type') || 'text';
        
        // For yes/no questions, provide yes/no value options
        if (questionType === 'yes_no') {
          if (!valueInput.getAttribute('data-initialized')) {
            valueInput.outerHTML = `
              <select name="form_question[conditional_logic][rules][][value]" 
                      class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
                      data-initialized="true">
                <option value="">Select value...</option>
                <option value="yes">Yes</option>
                <option value="no">No</option>
              </select>
            `;
          }
        } else {
          // For other question types, use text input
          if (valueInput.tagName === 'SELECT') {
            valueInput.outerHTML = `
              <input type="text" name="form_question[conditional_logic][rules][][value]" 
                     class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
                     placeholder="Enter value..."
                     data-initialized="true">
            `;
          }
        }
      }
    });
  }

  // Initial setup
  showConfiguration();
  showConditionalConfiguration();
  updateConditionalRuleOptions();

  // Handle question type change
  questionTypeSelect.addEventListener('change', showConfiguration);

  // Handle conditional logic toggle
  conditionalEnabled.addEventListener('change', function() {
    showConditionalConfiguration();
    if (this.checked) {
      updateConditionalRuleOptions();
    }
  });

  // Handle adding new conditional rules
  addConditionalRuleBtn.addEventListener('click', function() {
    const ruleCount = conditionalRulesContainer.children.length;
    const newRule = document.createElement('div');
    newRule.className = 'conditional-rule border border-gray-200 rounded-lg p-4 bg-white';
    newRule.setAttribute('data-rule-index', ruleCount);
    newRule.innerHTML = `
      <div class="grid grid-cols-3 gap-4">
        <div>
          <label class="block text-sm font-medium text-gray-700">Question</label>
          <select name="form_question[conditional_logic][rules][][question_id]" 
                  class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
            <option value="">Select a question...</option>
            <% @conditional_questions.each do |q| %>
              <option value="<%= q.reference_id || q.id %>"><%= q.title %></option>
            <% end %>
          </select>
        </div>
        
        <div>
          <label class="block text-sm font-medium text-gray-700">Condition</label>
          <select name="form_question[conditional_logic][rules][][operator]"
                  class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
            <option value="">Select condition...</option>
            <option value="equals">Equals (Case Insensitive)</option>
            <option value="equals_ignore_case">Equals (Exact)</option>
            <option value="not_equals">Not Equals (Case Insensitive)</option>
            <option value="not_equals_ignore_case">Not Equals (Exact)</option>
            <option value="contains">Contains (Case Insensitive)</option>
            <option value="contains_ignore_case">Contains (Exact)</option>
            <option value="starts_with">Starts With (Case Insensitive)</option>
            <option value="starts_with_ignore_case">Starts With (Exact)</option>
            <option value="ends_with">Ends With (Case Insensitive)</option>
            <option value="ends_with_ignore_case">Ends With (Exact)</option>
            <option value="greater_than">Greater Than</option>
            <option value="greater_than_or_equal">Greater Than or Equal</option>
            <option value="less_than">Less Than</option>
            <option value="less_than_or_equal">Less Than or Equal</option>
            <option value="is_empty">Is Empty</option>
            <option value="is_not_empty">Is Not Empty</option>
            <option value="matches_pattern">Matches Pattern (Regex)</option>
          </select>
        </div>
        
        <div class="value-field">
          <label class="block text-sm font-medium text-gray-700">Value</label>
          <input type="text" name="form_question[conditional_logic][rules][][value]" 
                 class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
                 placeholder="Enter value...">
        </div>
      </div>
      
      <div class="mt-4 flex justify-end">
        <button type="button" class="remove-rule text-red-600 hover:text-red-800 inline-flex items-center">
          <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
          </svg>
          Remove Rule
        </button>
      </div>
    `;
    conditionalRulesContainer.appendChild(newRule);
    
    // Add event listeners to the new rule
    newRule.querySelector('.remove-rule').addEventListener('click', removeConditionalRule);
    newRule.querySelector('select[name*="[question_id]"]').addEventListener('change', updateConditionalRuleOptions);
    newRule.querySelector('select[name*="[operator]"]').addEventListener('change', function() {
      updateValueFieldVisibility(newRule);
    });
    
    // Initialize value field visibility for the new rule
    updateValueFieldVisibility(newRule);
  });

  // Handle removing conditional rules
  function removeConditionalRule(event) {
    const ruleItem = event.target.closest('.conditional-rule');
    if (ruleItem) {
      ruleItem.remove();
    }
  }

  // Handle dynamic value field visibility based on operator
  function updateValueFieldVisibility(ruleDiv) {
    const operatorSelect = ruleDiv.querySelector('select[name*="[operator]"]');
    const valueField = ruleDiv.querySelector('.value-field');
    const valueInput = valueField.querySelector('input, select');
    
    if (!operatorSelect || !valueField) return;
    
    const operatorsThatNeedValue = [
      'equals', 'equals_ignore_case', 'not_equals', 'not_equals_ignore_case',
      'contains', 'contains_ignore_case', 'starts_with', 'starts_with_ignore_case',
      'ends_with', 'ends_with_ignore_case', 'greater_than', 'greater_than_or_equal',
      'less_than', 'less_than_or_equal', 'matches_pattern'
    ];
    
    const operatorsThatNeedNoValue = [
      'is_empty', 'is_not_empty'
    ];
    
    const selectedOperator = operatorSelect.value;
    
    if (operatorsThatNeedNoValue.includes(selectedOperator)) {
      valueField.style.display = 'none';
      if (valueInput) valueInput.removeAttribute('required');
    } else if (operatorsThatNeedValue.includes(selectedOperator)) {
      valueField.style.display = 'block';
      if (valueInput) valueInput.setAttribute('required', 'required');
    } else {
      valueField.style.display = 'block';
      if (valueInput) valueInput.setAttribute('required', 'required');
    }
  }

  // Update value field visibility for all existing rules
  function updateAllValueFields() {
    document.querySelectorAll('.conditional-rule').forEach(ruleDiv => {
      updateValueFieldVisibility(ruleDiv);
    });
  }

  // Add event listeners to existing conditional rules
  document.querySelectorAll('.conditional-rule select[name*="[question_id]"]').forEach(select => {
    select.addEventListener('change', updateConditionalRuleOptions);
  });

  document.querySelectorAll('.conditional-rule .remove-rule').forEach(button => {
    button.addEventListener('click', removeConditionalRule);
  });

  // Handle adding new options
  addOptionBtn.addEventListener('click', function() {
    const optionCount = optionsContainer.children.length;
    const newOption = document.createElement('div');
    newOption.className = 'flex items-center space-x-2 option-item';
    newOption.innerHTML = `
      <input type="text" name="form_question[question_config][options][]" 
             class="block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
             placeholder="Option ${optionCount + 1}" />
      <button type="button" class="remove-option text-red-600 hover:text-red-800">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
        </svg>
      </button>
    `;
    optionsContainer.appendChild(newOption);

    // Add remove handler to new button
    newOption.querySelector('.remove-option').addEventListener('click', removeOption);
  });

  // Handle removing options
  function removeOption(event) {
    const optionItem = event.target.closest('.option-item');
    if (optionItem) {
      optionItem.remove();
    }
  }

  // Handle adding new items for drag-drop
  addItemBtn.addEventListener('click', function() {
    const itemCount = itemsContainer.children.length;
    const newItem = document.createElement('div');
    newItem.className = 'flex items-center space-x-2 item-item';
    newItem.innerHTML = `
      <input type="text" name="form_question[question_config][items][]" 
             class="block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
             placeholder="Item ${itemCount + 1}" />
      <button type="button" class="remove-item text-red-600 hover:text-red-800">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
        </svg>
      </button>
    `;
    itemsContainer.appendChild(newItem);
    newItem.querySelector('.remove-item').addEventListener('click', removeItem);
  });

  // Handle adding new categories for drag-drop
  addCategoryBtn.addEventListener('click', function() {
    const categoryCount = categoriesContainer.children.length;
    const newCategory = document.createElement('div');
    newCategory.className = 'flex items-center space-x-2 category-item';
    newCategory.innerHTML = `
      <input type="text" name="form_question[question_config][categories][]" 
             class="block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
             placeholder="Category ${categoryCount + 1}" />
      <button type="button" class="remove-category text-red-600 hover:text-red-800">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
        </svg>
      </button>
    `;
    categoriesContainer.appendChild(newCategory);
    newCategory.querySelector('.remove-category').addEventListener('click', removeCategory);
  });

  // Handle removing items
  function removeItem(event) {
    const itemItem = event.target.closest('.item-item');
    if (itemItem) {
      itemItem.remove();
    }
  }

  // Handle removing categories
  function removeCategory(event) {
    const categoryItem = event.target.closest('.category-item');
    if (categoryItem) {
      categoryItem.remove();
    }
  }

  // Handle adding matrix rows
  addMatrixRowBtn.addEventListener('click', function() {
    const rowCount = matrixRowsContainer.children.length;
    const newRow = document.createElement('div');
    newRow.className = 'flex items-center space-x-2 matrix-row-item';
    newRow.innerHTML = `
      <input type="text" name="form_question[question_config][rows][]" 
             class="block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
             placeholder="Row ${rowCount + 1}" />
      <button type="button" class="remove-matrix-row text-red-600 hover:text-red-800">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
        </svg>
      </button>
    `;
    matrixRowsContainer.appendChild(newRow);
    newRow.querySelector('.remove-matrix-row').addEventListener('click', removeMatrixRow);
  });

  // Handle adding matrix columns
  addMatrixColumnBtn.addEventListener('click', function() {
    const columnCount = matrixColumnsContainer.children.length;
    const newColumn = document.createElement('div');
    newColumn.className = 'flex items-center space-x-2 matrix-column-item';
    newColumn.innerHTML = `
      <input type="text" name="form_question[question_config][columns][]" 
             class="block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
             placeholder="Column ${columnCount + 1}" />
      <button type="button" class="remove-matrix-column text-red-600 hover:text-red-800">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
        </svg>
      </button>
    `;
    matrixColumnsContainer.appendChild(newColumn);
    newColumn.querySelector('.remove-matrix-column').addEventListener('click', removeMatrixColumn);
  });

  // Handle removing matrix rows
  function removeMatrixRow(event) {
    const rowItem = event.target.closest('.matrix-row-item');
    if (rowItem) {
      rowItem.remove();
    }
  }

  // Handle removing matrix columns
  function removeMatrixColumn(event) {
    const columnItem = event.target.closest('.matrix-column-item');
    if (columnItem) {
      columnItem.remove();
    }
  }

  // Add remove handlers to all existing elements
  document.querySelectorAll('.remove-option').forEach(button => {
    button.addEventListener('click', removeOption);
  });
  document.querySelectorAll('.remove-item').forEach(button => {
    button.addEventListener('click', removeItem);
  });
  document.querySelectorAll('.remove-category').forEach(button => {
    button.addEventListener('click', removeCategory);
  });
  document.querySelectorAll('.remove-matrix-row').forEach(button => {
    button.addEventListener('click', removeMatrixRow);
  });
  document.querySelectorAll('.remove-matrix-column').forEach(button => {
    button.addEventListener('click', removeMatrixColumn);
  });

  // Add operator change event listeners for conditional rules
  document.querySelectorAll('.conditional-rule select[name*="[operator]"]').forEach(select => {
    select.addEventListener('change', function() {
      updateValueFieldVisibility(this.closest('.conditional-rule'));
    });
  });

  // Initialize value field visibility for existing rules
  updateAllValueFields();
});
</script>
</file>

<file path="views/form_questions/index.html.erb">
<div class="container mx-auto px-4 py-8">
  <div class="flex justify-between items-center mb-6">
    <h1 class="text-2xl font-bold text-gray-900">Form Questions</h1>
    <%= link_to "Add Question", new_form_form_question_path(@form), 
        class: "bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700" %>
  </div>

  <div class="bg-white shadow rounded-lg">
    <% if @questions.any? %>
      <div class="divide-y divide-gray-200">
        <% @questions.each do |question| %>
          <div class="p-6 hover:bg-gray-50">
            <div class="flex items-center justify-between">
              <div class="flex-1">
                <h3 class="text-lg font-medium text-gray-900">
                  <%= question.position %>. <%= question.title %>
                </h3>
                <p class="text-sm text-gray-500 mt-1">
                  Type: <%= question.question_type.humanize %>
                  <% if question.required? %>
                    <span class="text-red-600 font-medium"> Required</span>
                  <% end %>
                  <% if question.ai_enhanced? %>
                    <span class="text-purple-600 font-medium"> AI Enhanced</span>
                  <% end %>
                </p>
              </div>
              <div class="flex items-center space-x-2">
                <%= link_to "Edit", edit_form_form_question_path(@form, question), 
                    class: "text-indigo-600 hover:text-indigo-900" %>
                <%= link_to "Delete", form_form_question_path(@form, question), 
                    method: :delete, 
                    confirm: "Are you sure?",
                    class: "text-red-600 hover:text-red-900" %>
              </div>
            </div>
          </div>
        <% end %>
      </div>
    <% else %>
      <div class="p-6 text-center">
        <p class="text-gray-500">No questions added yet.</p>
        <%= link_to "Add your first question", new_form_form_question_path(@form), 
            class: "text-indigo-600 hover:text-indigo-900" %>
      </div>
    <% end %>
  </div>
</div>
</file>

<file path="views/form_questions/new.html.erb">
<div class="container mx-auto px-4 py-8">
  <div class="max-w-2xl mx-auto">
    <div class="flex justify-between items-center mb-6">
      <h1 class="text-2xl font-bold text-gray-900">Add New Question</h1>
      <%= link_to "Back to Form", edit_form_path(@form), 
          class: "text-gray-600 hover:text-gray-900" %>
    </div>

    <div class="bg-white shadow rounded-lg p-6">
      <%= form_with model: [@form, @question], local: true, class: "space-y-6" do |form| %>
        <% if @question.errors.any? %>
          <div class="bg-red-50 border border-red-200 rounded-md p-4">
            <h3 class="text-sm font-medium text-red-800">
              <%= pluralize(@question.errors.count, "error") %> prohibited this question from being saved:
            </h3>
            <ul class="mt-2 text-sm text-red-700 list-disc list-inside">
              <% @question.errors.full_messages.each do |message| %>
                <li><%= message %></li>
              <% end %>
            </ul>
          </div>
        <% end %>

        <div>
          <%= form.label :title, class: "block text-sm font-medium text-gray-700" %>
          <%= form.text_field :title, 
              class: "mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500",
              placeholder: "Enter your question..." %>
        </div>

        <div>
          <%= form.label :description, class: "block text-sm font-medium text-gray-700" %>
          <%= form.text_area :description, 
              rows: 3,
              class: "mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500",
              placeholder: "Optional description or help text..." %>
        </div>

        <div>
          <%= form.label :question_type, class: "block text-sm font-medium text-gray-700" %>
          <%= form.select :question_type, 
              options_for_select(@question_types.map { |type| [type.humanize, type] }, @question.question_type),
              { prompt: "Select question type..." },
              { class: "mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500" } %>
          
          <!-- Payment Feature Notice -->
          <% unless current_user.can_accept_payments? %>
            <div id="payment-premium-notice" class="mt-2 p-3 bg-amber-50 border border-amber-200 rounded-md hidden">
              <div class="flex items-start">
                <svg class="w-5 h-5 text-amber-600 mt-0.5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.5 0L4.232 15.5c-.77.833.192 2.5 1.732 2.5z"></path>
                </svg>
                <div class="flex-1">
                  <% if current_user.premium? %>
                    <h4 class="text-sm font-medium text-amber-800">Stripe Configuration Required</h4>
                    <p class="mt-1 text-sm text-amber-700">
                      To accept payments, you need to configure your Stripe account. 
                      <a href="<%= stripe_settings_path %>" class="font-medium underline hover:text-amber-600">Configure Stripe</a> 
                      to start accepting payments through your forms.
                    </p>
                  <% else %>
                    <h4 class="text-sm font-medium text-amber-800">Premium Feature</h4>
                    <p class="mt-1 text-sm text-amber-700">
                      Payment questions are only available for Premium users. 
                      <a href="#" class="font-medium underline hover:text-amber-600">Upgrade your account</a> 
                      to accept payments directly through your forms.
                    </p>
                  <% end %>
                </div>
              </div>
            </div>
          <% end %>
        </div>

        <!-- Multiple Choice Configuration -->
        <div id="choice-configuration" class="space-y-4" style="display: none;">
          <h3 class="text-lg font-medium text-gray-900">Choice Options</h3>
          
          <div id="options-container" class="space-y-3">
            <div class="flex items-center space-x-2 option-item">
              <%= text_field_tag "form_question[question_config][options][]", "",
                  class: "block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500",
                  placeholder: "Option 1" %>
              <button type="button" class="remove-option text-red-600 hover:text-red-800">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                </svg>
              </button>
            </div>
          </div>
          
          <button type="button" id="add-option" class="inline-flex items-center px-3 py-1.5 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50">
            Add Option
          </button>
        </div>

        <!-- Rating Configuration -->
        <div id="rating-configuration" class="space-y-4" style="display: none;">
          <h3 class="text-lg font-medium text-gray-900">Rating Configuration</h3>
          
          <div class="grid grid-cols-2 gap-4">
            <div>
              <%= label_tag "form_question[question_config][min_value]", "Minimum Value", class: "block text-sm font-medium text-gray-700" %>
              <%= number_field_tag "form_question[question_config][min_value]", 1,
                  class: "mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500" %>
            </div>
            <div>
              <%= label_tag "form_question[question_config][max_value]", "Maximum Value", class: "block text-sm font-medium text-gray-700" %>
              <%= number_field_tag "form_question[question_config][max_value]", 5,
                  class: "mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500" %>
            </div>
          </div>
        </div>

        <div class="flex items-center space-x-6">
          <div class="flex items-center">
            <%= form.check_box :required, class: "h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded" %>
            <%= form.label :required, "Required", class: "ml-2 block text-sm text-gray-900" %>
          </div>

          <div class="flex items-center">
            <%= form.check_box :ai_enhanced, class: "h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded" %>
            <%= form.label :ai_enhanced, "AI Enhanced", class: "ml-2 block text-sm text-gray-900" %>
          </div>
        </div>

        <div class="flex justify-end space-x-3">
          <%= link_to "Cancel", edit_form_path(@form), 
              class: "bg-white py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" %>
          <%= form.submit "Create Question", 
              class: "bg-indigo-600 py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" %>
        </div>

        <script>
        document.addEventListener('DOMContentLoaded', function() {
          const questionTypeSelect = document.getElementById('form_question_question_type');
          const choiceConfig = document.getElementById('choice-configuration');
          const ratingConfig = document.getElementById('rating-configuration');
          const optionsContainer = document.getElementById('options-container');
          const addOptionBtn = document.getElementById('add-option');
          const paymentNotice = document.getElementById('payment-premium-notice');

          function showConfiguration() {
            const selectedType = questionTypeSelect.value;
            
            // Hide all configurations
            choiceConfig.style.display = 'none';
            ratingConfig.style.display = 'none';
            
            // Show/hide premium notice for payment questions
            if (paymentNotice) {
              if (selectedType === 'payment') {
                paymentNotice.classList.remove('hidden');
              } else {
                paymentNotice.classList.add('hidden');
              }
            }
            
            // Show appropriate configuration
            if (['multiple_choice', 'single_choice', 'checkbox'].includes(selectedType)) {
              choiceConfig.style.display = 'block';
            } else if (['rating', 'scale', 'nps_score'].includes(selectedType)) {
              ratingConfig.style.display = 'block';
            }
          }

          // Initial setup
          showConfiguration();

          // Handle question type change
          questionTypeSelect.addEventListener('change', showConfiguration);

          // Handle adding new options
          addOptionBtn.addEventListener('click', function() {
            const optionCount = optionsContainer.children.length;
            const newOption = document.createElement('div');
            newOption.className = 'flex items-center space-x-2 option-item';
            newOption.innerHTML = `
              <input type="text" name="form_question[question_config][options][]" 
                     class="block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
                     placeholder="Option ${optionCount + 1}" />
              <button type="button" class="remove-option text-red-600 hover:text-red-800">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                </svg>
              </button>
            `;
            optionsContainer.appendChild(newOption);

            // Add remove handler to new button
            newOption.querySelector('.remove-option').addEventListener('click', removeOption);
          });

          // Handle removing options
          function removeOption(event) {
            const optionItem = event.target.closest('.option-item');
            if (optionItem) {
              optionItem.remove();
            }
          }

          // Add remove handlers to existing options
          document.querySelectorAll('.remove-option').forEach(button => {
            button.addEventListener('click', removeOption);
          });
        });
        </script>
      <% end %>
    </div>
  </div>
</div>
</file>

<file path="views/form_questions/preview.html.erb">
<div class="container mx-auto px-4 py-8">
  <div class="max-w-2xl mx-auto">
    <div class="flex justify-between items-center mb-6">
      <h1 class="text-2xl font-bold text-gray-900">Question Preview</h1>
      <%= link_to "Back to Edit", edit_form_form_question_path(@form, @question), 
          class: "text-gray-600 hover:text-gray-900" %>
    </div>

    <div class="bg-white shadow rounded-lg p-8">
      <div class="mb-4">
        <span class="text-sm text-gray-500">Question <%= @question.position %></span>
      </div>

      <div class="mb-6">
        <h2 class="text-xl font-medium text-gray-900 mb-2">
          <%= @question.title %>
          <% if @question.required? %>
            <span class="text-red-500">*</span>
          <% end %>
        </h2>
        
        <% if @question.description.present? %>
          <p class="text-gray-600 text-sm"><%= @question.description %></p>
        <% end %>
      </div>

      <!-- Question Preview Based on Type -->
      <div class="mb-6">
        <% case @question.question_type %>
        <% when 'text_short' %>
          <input type="text" 
                 class="w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
                 placeholder="<%= @sample_response %>"
                 disabled>
        
        <% when 'text_long' %>
          <textarea rows="4" 
                    class="w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
                    placeholder="<%= @sample_response %>"
                    disabled></textarea>
        
        <% when 'email' %>
          <input type="email" 
                 class="w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"
                 placeholder="<%= @sample_response %>"
                 disabled>
        
        <% when 'multiple_choice' %>
          <div class="space-y-2">
            <% (@question.choice_options.presence || ['Option 1', 'Option 2', 'Option 3']).each_with_index do |option, index| %>
              <label class="flex items-center">
                <input type="checkbox" 
                       class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded"
                       <%= 'checked' if index == 0 %>
                       disabled>
                <span class="ml-2 text-gray-900"><%= option %></span>
              </label>
            <% end %>
          </div>
        
        <% when 'single_choice' %>
          <div class="space-y-2">
            <% (@question.choice_options.presence || ['Option 1', 'Option 2', 'Option 3']).each_with_index do |option, index| %>
              <label class="flex items-center">
                <input type="radio" 
                       name="preview_radio"
                       class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300"
                       <%= 'checked' if index == 0 %>
                       disabled>
                <span class="ml-2 text-gray-900"><%= option %></span>
              </label>
            <% end %>
          </div>
        
        <% when 'rating' %>
          <div class="flex items-center space-x-2">
            <% config = @question.rating_config %>
            <% (config[:min]..config[:max]).each do |rating| %>
              <button class="w-8 h-8 rounded-full border-2 border-gray-300 text-sm font-medium
                           <%= rating <= @sample_response.to_i ? 'bg-indigo-600 text-white border-indigo-600' : 'text-gray-700' %>"
                      disabled>
                <%= rating %>
              </button>
            <% end %>
          </div>
        
        <% else %>
          <div class="p-4 bg-gray-50 rounded-md">
            <p class="text-gray-600 text-sm">
              Preview for <%= @question.question_type.humanize %> questions coming soon...
            </p>
          </div>
        <% end %>
      </div>

      <!-- AI Enhancement Indicator -->
      <% if @question.ai_enhanced? %>
        <div class="flex items-center space-x-2 text-sm text-purple-600 mb-4">
          <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
            <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
          </svg>
          <span>AI Enhanced Question</span>
        </div>
      <% end %>

      <!-- Question Metadata -->
      <div class="border-t pt-4 text-sm text-gray-500">
        <div class="grid grid-cols-2 gap-4">
          <div>
            <span class="font-medium">Type:</span> <%= @question.question_type.humanize %>
          </div>
          <div>
            <span class="font-medium">Required:</span> <%= @question.required? ? 'Yes' : 'No' %>
          </div>
        </div>
      </div>
    </div>

    <div class="mt-6 flex justify-center space-x-4">
      <%= link_to "Edit Question", edit_form_form_question_path(@form, @question), 
          class: "bg-indigo-600 text-white px-6 py-2 rounded-md hover:bg-indigo-700" %>
      <%= link_to "Back to Form", edit_form_path(@form), 
          class: "bg-gray-600 text-white px-6 py-2 rounded-md hover:bg-gray-700" %>
    </div>
  </div>
</div>
</file>

<file path="views/form_questions/show.html.erb">
<div class="container mx-auto px-4 py-8">
  <div class="flex justify-between items-center mb-6">
    <h1 class="text-2xl font-bold text-gray-900"><%= @question.title %></h1>
    <div class="flex space-x-2">
      <%= link_to "Edit", edit_form_form_question_path(@form, @question), 
          class: "bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700" %>
      <%= link_to "Back to Form", edit_form_path(@form), 
          class: "bg-gray-600 text-white px-4 py-2 rounded-md hover:bg-gray-700" %>
    </div>
  </div>

  <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
    <!-- Question Details -->
    <div class="lg:col-span-2">
      <div class="bg-white shadow rounded-lg p-6">
        <h2 class="text-lg font-medium text-gray-900 mb-4">Question Details</h2>
        
        <dl class="grid grid-cols-1 gap-4 sm:grid-cols-2">
          <div>
            <dt class="text-sm font-medium text-gray-500">Type</dt>
            <dd class="mt-1 text-sm text-gray-900"><%= @question.question_type.humanize %></dd>
          </div>
          <div>
            <dt class="text-sm font-medium text-gray-500">Position</dt>
            <dd class="mt-1 text-sm text-gray-900"><%= @question.position %></dd>
          </div>
          <div>
            <dt class="text-sm font-medium text-gray-500">Required</dt>
            <dd class="mt-1 text-sm text-gray-900">
              <%= @question.required? ? "Yes" : "No" %>
            </dd>
          </div>
          <div>
            <dt class="text-sm font-medium text-gray-500">AI Enhanced</dt>
            <dd class="mt-1 text-sm text-gray-900">
              <%= @question.ai_enhanced? ? "Yes" : "No" %>
            </dd>
          </div>
        </dl>

        <% if @question.description.present? %>
          <div class="mt-4">
            <dt class="text-sm font-medium text-gray-500">Description</dt>
            <dd class="mt-1 text-sm text-gray-900"><%= @question.description %></dd>
          </div>
        <% end %>
      </div>

      <!-- Recent Responses -->
      <div class="bg-white shadow rounded-lg p-6 mt-6">
        <h2 class="text-lg font-medium text-gray-900 mb-4">Recent Responses</h2>
        <% if @recent_responses.any? %>
          <div class="space-y-3">
            <% @recent_responses.each do |response| %>
              <div class="border-l-4 border-indigo-400 pl-4">
                <p class="text-sm text-gray-900"><%= response.answer_text %></p>
                <p class="text-xs text-gray-500 mt-1">
                  <%= time_ago_in_words(response.created_at) %> ago
                </p>
              </div>
            <% end %>
          </div>
        <% else %>
          <p class="text-gray-500">No responses yet.</p>
        <% end %>
      </div>
    </div>

    <!-- Analytics Sidebar -->
    <div class="lg:col-span-1">
      <div class="bg-white shadow rounded-lg p-6">
        <h2 class="text-lg font-medium text-gray-900 mb-4">Analytics</h2>
        
        <div class="space-y-4">
          <div>
            <dt class="text-sm font-medium text-gray-500">Completion Rate</dt>
            <dd class="mt-1 text-2xl font-semibold text-gray-900">
              <%= @question_analytics[:completion_rate] || 0 %>%
            </dd>
          </div>
          
          <div>
            <dt class="text-sm font-medium text-gray-500">Total Responses</dt>
            <dd class="mt-1 text-2xl font-semibold text-gray-900">
              <%= @question_analytics[:total_responses] || 0 %>
            </dd>
          </div>
          
          <div>
            <dt class="text-sm font-medium text-gray-500">Avg Response Time</dt>
            <dd class="mt-1 text-2xl font-semibold text-gray-900">
              <%= @question_analytics[:avg_response_time] || 0 %>s
            </dd>
          </div>
        </div>

        <%= link_to "View Full Analytics", analytics_form_form_question_path(@form, @question), 
            class: "mt-4 w-full bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 text-center block" %>
      </div>
    </div>
  </div>
</div>
</file>

<file path="views/forms/_configuration_panel.html.erb">
<%# Configuration Panel for Form Builder %>
<div class="p-4">
  <h3 class="text-lg font-semibold text-gray-900 mb-4">Form Configuration</h3>
  
  <!-- Basic Settings -->
  <div class="space-y-4">
    <div>
      <label class="block text-sm font-medium text-gray-700 mb-1">Form Name</label>
      <%= text_field_tag "form_name", @form.name, 
            class: "w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-purple-500",
            data: { action: "blur->form-builder#triggerAutoSave", "form-builder-target": "formName" } %>
    </div>
    
    <div>
      <label class="block text-sm font-medium text-gray-700 mb-1">Description</label>
      <%= text_area_tag "form_description", @form.description, 
            class: "w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-purple-500",
            rows: 3,
            data: { action: "blur->form-builder#triggerAutoSave" } %>
    </div>
    
    <div>
      <label class="block text-sm font-medium text-gray-700 mb-1">Category</label>
      <%= select_tag "form_category", 
            options_for_select(Form.categories.map { |key, value| [key.humanize, key] }, @form.category),
            class: "w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-purple-500",
            data: { action: "change->form-builder#triggerAutoSave" } %>
    </div>
  </div>
  
  <!-- AI Settings -->
  <div class="mt-6">
    <h4 class="text-md font-medium text-gray-900 mb-3">AI Enhancement</h4>
    <% if @can_use_ai %>
      <div class="space-y-2">
        <label class="flex items-center">
          <%= check_box_tag "ai_enabled", "1", @form.ai_enabled?, 
                class: "rounded border-gray-300 text-purple-600 focus:ring-purple-500",
                data: { action: "change->form-builder#triggerAutoSave" } %>
          <span class="ml-2 text-sm text-gray-700">Enable AI features</span>
        </label>
      </div>
      
      <% if @form.ai_enabled? %>
        <div class="mt-4 space-y-3 border-t pt-4">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">AI Features</label>
            <div class="space-y-2">
              <label class="flex items-center">
                <%= check_box_tag "ai_configuration[lead_scoring]", "1", @form.ai_configuration&.dig("lead_scoring") == "1", 
                      class: "rounded border-gray-300 text-purple-600 focus:ring-purple-500",
                      data: { action: "change->form-builder#triggerAutoSave" } %>
                <span class="ml-2 text-sm text-gray-700">Lead Qualification Agent</span>
              </label>
              
              <label class="flex items-center">
                <%= check_box_tag "ai_configuration[response_analysis]", "1", @form.ai_configuration&.dig("response_analysis") == "1", 
                      class: "rounded border-gray-300 text-purple-600 focus:ring-purple-500",
                      data: { action: "change->form-builder#triggerAutoSave" } %>
                <span class="ml-2 text-sm text-gray-700">Response Analysis</span>
              </label>
              
              <label class="flex items-center">
                <%= check_box_tag "ai_configuration[dynamic_questions]", "1", @form.ai_configuration&.dig("dynamic_questions") == "1", 
                      class: "rounded border-gray-300 text-purple-600 focus:ring-purple-500",
                      data: { action: "change->form-builder#triggerAutoSave" } %>
                <span class="ml-2 text-sm text-gray-700">Dynamic Questions</span>
              </label>
              
              <label class="flex items-center">
                <%= check_box_tag "ai_configuration[sentiment_analysis]", "1", @form.ai_configuration&.dig("sentiment_analysis") == "1", 
                      class: "rounded border-gray-300 text-purple-600 focus:ring-purple-500",
                      data: { action: "change->form-builder#triggerAutoSave" } %>
                <span class="ml-2 text-sm text-gray-700">Sentiment Analysis</span>
              </label>
            </div>
          </div>
          
          <% if @form.ai_configuration&.dig("lead_scoring") == "1" %>
            <div class="mt-3 p-3 bg-purple-50 rounded-md border border-purple-200">
              <h5 class="text-sm font-medium text-purple-900 mb-2"> Lead Qualification Agent</h5>
              <div class="space-y-3">
                <div>
                  <label class="block text-xs font-medium text-purple-700 mb-1">Qualification Framework</label>
                  <%= select_tag "ai_configuration[qualification_framework]", 
                        options_for_select([
                          ['BANT (Budget, Authority, Need, Timeline)', 'bant'], 
                          ['CHAMP (Challenges, Authority, Money, Prioritization)', 'champ'],
                          ['MEDDIC (Metrics, Economic Buyer, Decision Criteria)', 'meddic'],
                          ['ANUM (Authority, Need, Urgency, Money)', 'anum']
                        ], @form.ai_configuration&.dig("qualification_framework") || 'bant'),
                        class: "w-full mt-1 px-2 py-1 border border-purple-200 rounded text-xs",
                        data: { action: "change->form-builder#triggerAutoSave" } %>
                </div>
                
                <div class="grid grid-cols-3 gap-2">
                  <div>
                    <label class="block text-xs font-medium text-purple-700 mb-1">Hot Leads</label>
                    <%= number_field_tag "ai_configuration[hot_lead_threshold]", 
                          @form.ai_configuration&.dig("hot_lead_threshold") || 80, 
                          min: 0, max: 100, 
                          class: "w-full mt-1 px-2 py-1 border border-purple-200 rounded text-xs",
                          data: { action: "change->form-builder#triggerAutoSave" } %>
                  </div>
                  <div>
                    <label class="block text-xs font-medium text-purple-700 mb-1">Warm Leads</label>
                    <%= number_field_tag "ai_configuration[warm_lead_threshold]", 
                          @form.ai_configuration&.dig("warm_lead_threshold") || 60, 
                          min: 0, max: 100, 
                          class: "w-full mt-1 px-2 py-1 border border-purple-200 rounded text-xs",
                          data: { action: "change->form-builder#triggerAutoSave" } %>
                  </div>
                  <div>
                    <label class="block text-xs font-medium text-purple-700 mb-1">Cold Leads</label>
                    <%= number_field_tag "ai_configuration[cold_lead_threshold]", 
                          @form.ai_configuration&.dig("cold_lead_threshold") || 40, 
                          min: 0, max: 100, 
                          class: "w-full mt-1 px-2 py-1 border border-purple-200 rounded text-xs",
                          data: { action: "change->form-builder#triggerAutoSave" } %>
                  </div>
                </div>
                
                <div class="text-xs text-purple-600 bg-white p-2 rounded border">
                  <strong>Lead Tiers:</strong> Hot (80), Warm (60-79), Lukewarm (40-59), Cold (<40)
                </div>
              </div>
            </div>
          <% end %>
        </div>
      <% end %>
    <% else %>
      <div class="flex items-center p-3 bg-yellow-50 border border-yellow-200 rounded-md">
        <svg class="w-5 h-5 text-yellow-600 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
        </svg>
        <div>
          <p class="text-sm font-medium text-yellow-800">AI features require Premium plan</p>
          <p class="text-xs text-yellow-700">Upgrade to unlock response analysis, dynamic questions, and more.</p>
        </div>
      </div>
    <% end %>
  </div>
  
  <!-- Form Settings -->
  <div class="mt-6">
    <h4 class="text-md font-medium text-gray-900 mb-3">Form Settings</h4>
    <div class="space-y-2">
      <label class="flex items-center">
        <%= check_box_tag "accepts_responses", "1", @form.accepts_responses?, 
              class: "rounded border-gray-300 text-purple-600 focus:ring-purple-500",
              data: { action: "change->form-builder#triggerAutoSave" } %>
        <span class="ml-2 text-sm text-gray-700">Accept new responses</span>
      </label>
      
      <label class="flex items-center">
        <%= check_box_tag "public", "1", @form.public?, 
              class: "rounded border-gray-300 text-purple-600 focus:ring-purple-500",
              data: { action: "change->form-builder#triggerAutoSave" } %>
        <span class="ml-2 text-sm text-gray-700">Public form</span>
      </label>
    </div>
  </div>
  
  <!-- Integrations -->
  <div class="mt-6">
    <h4 class="text-md font-medium text-gray-900 mb-3">Integrations</h4>
    <%= render 'forms/google_sheets_integration', form: @form %>
  </div>
  
  <!-- Actions -->
  <div class="mt-6 pt-4 border-t border-gray-200">
    <div class="space-y-2">
      <%= link_to "Preview", 
            public_form_path(@form.share_token),
            target: "_blank",
            class: "w-full flex justify-center py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50" %>
      
      <%= link_to "View Analytics",
            analytics_form_path(@form),
            class: "w-full flex justify-center py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50" %>
    </div>
  </div>
</div>
</file>

<file path="views/forms/_configuration_tabs.html.erb">
<%
  # Configuration Tabs Component
  # Right sidebar with tabbed configuration panels for form settings
%>

<div class="w-80 bg-white border-l border-gray-200 flex flex-col" data-controller="tabs">
  
  <!-- Tab Navigation -->
  <div class="border-b border-gray-200 px-4 py-3">
    <nav class="flex space-x-1" role="tablist">
      <button data-action="click->tabs#switch" 
              data-tabs-target="tab"
              data-tab="settings"
              class="tab-button active px-3 py-2 text-sm font-medium rounded-lg transition-colors">
        Settings
      </button>
      <button data-action="click->tabs#switch" 
              data-tabs-target="tab"
              data-tab="design"
              class="tab-button px-3 py-2 text-sm font-medium rounded-lg transition-colors">
        Design
      </button>
      <button data-action="click->tabs#switch" 
              data-tabs-target="tab"
              data-tab="ai"
              class="tab-button px-3 py-2 text-sm font-medium rounded-lg transition-colors">
        AI
      </button>
      <button data-action="click->tabs#switch" 
              data-tabs-target="tab"
              data-tab="integrations"
              class="tab-button px-3 py-2 text-sm font-medium rounded-lg transition-colors">
        Integrations
      </button>
    </nav>
  </div>

  <!-- Tab Content -->
  <div class="flex-1 overflow-y-auto">
    
    <!-- Settings Tab -->
    <div data-tabs-target="panel" data-tab="settings" class="tab-panel p-4 space-y-6">
      <div>
        <h3 class="text-sm font-semibold text-gray-900 mb-3">Form Information</h3>
        
        <%= form_with model: @form, local: false, data: { controller: "auto-save" } do |form| %>
          <div class="space-y-4">
            <div>
              <%= form.label :name, "Form Title", class: "block text-sm font-medium text-gray-700 mb-1" %>
              <%= form.text_field :name, 
                  class: "w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent",
                  placeholder: "Enter form title..." %>
            </div>
            
            <div>
              <%= form.label :description, "Description", class: "block text-sm font-medium text-gray-700 mb-1" %>
              <%= form.text_area :description, 
                  rows: 3,
                  class: "w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent",
                  placeholder: "Describe your form..." %>
            </div>
            
            <div>
              <%= form.label :category, "Category", class: "block text-sm font-medium text-gray-700 mb-1" %>
              <%= form.select :category, 
                  options_for_select([
                    ['Lead Generation', 'lead_generation'],
                    ['Customer Feedback', 'customer_feedback'],
                    ['Event Registration', 'event_registration'],
                    ['Contact Form', 'contact_form'],
                    ['Survey', 'survey'],
                    ['Application', 'application'],
                    ['Other', 'other']
                  ], @form.category),
                  { prompt: "Select category..." },
                  { class: "w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent" } %>
            </div>
          </div>
        <% end %>
      </div>
      
      <!-- Form Behavior -->
      <div class="border-t pt-6">
        <h3 class="text-sm font-semibold text-gray-900 mb-3">Form Behavior</h3>
        <div class="space-y-3">
          <label class="flex items-center">
            <input type="checkbox" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded">
            <span class="ml-2 text-sm text-gray-700">Allow multiple submissions</span>
          </label>
          <label class="flex items-center">
            <input type="checkbox" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded">
            <span class="ml-2 text-sm text-gray-700">Show progress bar</span>
          </label>
          <label class="flex items-center">
            <input type="checkbox" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded">
            <span class="ml-2 text-sm text-gray-700">Auto-save responses</span>
          </label>
        </div>
      </div>
      
      <!-- Notifications -->
      <div class="border-t pt-6">
        <h3 class="text-sm font-semibold text-gray-900 mb-3">Notifications</h3>
        <div class="space-y-3">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">Email notifications to:</label>
            <input type="email" 
                   class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
                   placeholder="your@email.com">
          </div>
          <label class="flex items-center">
            <input type="checkbox" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded">
            <span class="ml-2 text-sm text-gray-700">Send confirmation email to respondents</span>
          </label>
        </div>
      </div>
    </div>

    <!-- Design Tab -->
    <div data-tabs-target="panel" data-tab="design" class="tab-panel hidden p-4 space-y-6">
      <div>
        <h3 class="text-sm font-semibold text-gray-900 mb-3">Theme</h3>
        <div class="grid grid-cols-2 gap-3">
          <button class="theme-option active p-3 border-2 border-indigo-500 rounded-lg bg-white">
            <div class="w-full h-8 bg-gradient-to-r from-indigo-500 to-purple-600 rounded mb-2"></div>
            <span class="text-xs font-medium">Default</span>
          </button>
          <button class="theme-option p-3 border-2 border-gray-200 rounded-lg bg-white hover:border-gray-300">
            <div class="w-full h-8 bg-gradient-to-r from-green-500 to-blue-600 rounded mb-2"></div>
            <span class="text-xs font-medium">Nature</span>
          </button>
          <button class="theme-option p-3 border-2 border-gray-200 rounded-lg bg-white hover:border-gray-300">
            <div class="w-full h-8 bg-gradient-to-r from-pink-500 to-red-600 rounded mb-2"></div>
            <span class="text-xs font-medium">Warm</span>
          </button>
          <button class="theme-option p-3 border-2 border-gray-200 rounded-lg bg-white hover:border-gray-300">
            <div class="w-full h-8 bg-gradient-to-r from-gray-700 to-gray-900 rounded mb-2"></div>
            <span class="text-xs font-medium">Dark</span>
          </button>
        </div>
      </div>
      
      <!-- Custom Colors -->
      <div class="border-t pt-6">
        <h3 class="text-sm font-semibold text-gray-900 mb-3">Custom Colors</h3>
        <div class="space-y-3">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">Primary Color</label>
            <div class="flex items-center space-x-2">
              <input type="color" value="#6366f1" class="w-8 h-8 border border-gray-300 rounded">
              <input type="text" value="#6366f1" class="flex-1 px-3 py-2 border border-gray-300 rounded-lg text-sm">
            </div>
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">Background Color</label>
            <div class="flex items-center space-x-2">
              <input type="color" value="#ffffff" class="w-8 h-8 border border-gray-300 rounded">
              <input type="text" value="#ffffff" class="flex-1 px-3 py-2 border border-gray-300 rounded-lg text-sm">
            </div>
          </div>
        </div>
      </div>
      
      <!-- Typography -->
      <div class="border-t pt-6">
        <h3 class="text-sm font-semibold text-gray-900 mb-3">Typography</h3>
        <div class="space-y-3">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">Font Family</label>
            <select class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm">
              <option>Inter (Default)</option>
              <option>Roboto</option>
              <option>Open Sans</option>
              <option>Lato</option>
            </select>
          </div>
        </div>
      </div>
    </div>

    <!-- AI Tab -->
    <div data-tabs-target="panel" data-tab="ai" class="tab-panel hidden p-4 space-y-6">
      <div>
        <h3 class="text-sm font-semibold text-gray-900 mb-3">AI Features</h3>
        
        <!-- AI Toggle -->
        <div class="flex items-center justify-between p-3 bg-purple-50 rounded-lg border border-purple-200">
          <div>
            <div class="font-medium text-purple-900">Enable AI Enhancement</div>
            <div class="text-sm text-purple-700">Unlock intelligent form features</div>
          </div>
          <label class="relative inline-flex items-center cursor-pointer">
            <input type="checkbox" class="sr-only peer" <%= 'checked' if @form.ai_enhanced? %>>
            <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-purple-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600"></div>
          </label>
        </div>
        
        <!-- AI Features List -->
        <div class="space-y-3 <%= 'opacity-50 pointer-events-none' unless @form.ai_enhanced? %>" id="ai-features-list">
          <label class="flex items-center">
            <input type="checkbox" class="h-4 w-4 text-purple-600 focus:ring-purple-500 border-gray-300 rounded">
            <span class="ml-2 text-sm text-gray-700">Smart question suggestions</span>
          </label>
          <label class="flex items-center">
            <input type="checkbox" class="h-4 w-4 text-purple-600 focus:ring-purple-500 border-gray-300 rounded">
            <span class="ml-2 text-sm text-gray-700">Dynamic follow-up questions</span>
          </label>
          <label class="flex items-center">
            <input type="checkbox" class="h-4 w-4 text-purple-600 focus:ring-purple-500 border-gray-300 rounded">
            <span class="ml-2 text-sm text-gray-700">Response analysis & insights</span>
          </label>
          <label class="flex items-center">
            <input type="checkbox" class="h-4 w-4 text-purple-600 focus:ring-purple-500 border-gray-300 rounded">
            <span class="ml-2 text-sm text-gray-700">Lead qualification (BANT)</span>
          </label>
          <label class="flex items-center">
            <input type="checkbox" class="h-4 w-4 text-purple-600 focus:ring-purple-500 border-gray-300 rounded">
            <span class="ml-2 text-sm text-gray-700">Sentiment analysis</span>
          </label>
        </div>
      </div>
      
      <!-- AI Model Settings -->
      <div class="border-t pt-6">
        <h3 class="text-sm font-semibold text-gray-900 mb-3">AI Model Settings</h3>
        <div class="space-y-3">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">Analysis Intensity</label>
            <select class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm">
              <option>Light (Fast, basic insights)</option>
              <option selected>Medium (Balanced performance)</option>
              <option>Deep (Comprehensive analysis)</option>
            </select>
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">Response Language</label>
            <select class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm">
              <option>Auto-detect</option>
              <option selected>English</option>
              <option>Spanish</option>
              <option>French</option>
              <option>German</option>
            </select>
          </div>
        </div>
      </div>
    </div>

    <!-- Integrations Tab -->
    <div data-tabs-target="panel" data-tab="integrations" class="tab-panel hidden p-4 space-y-6">
      <div>
        <h3 class="text-sm font-semibold text-gray-900 mb-3">Connected Integrations</h3>
        
        <!-- Integration Cards -->
        <div class="space-y-3">
          <!-- Webhook Integration -->
          <div class="p-3 border border-gray-200 rounded-lg">
            <div class="flex items-center justify-between">
              <div class="flex items-center space-x-3">
                <div class="w-8 h-8 bg-blue-100 rounded-lg flex items-center justify-center">
                  <svg class="w-4 h-4 text-blue-600" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M12.316 3.051a1 1 0 01.633 1.265l-4 12a1 1 0 11-1.898-.632l4-12a1 1 0 011.265-.633zM5.707 6.293a1 1 0 010 1.414L3.414 10l2.293 2.293a1 1 0 11-1.414 1.414l-3-3a1 1 0 010-1.414l3-3a1 1 0 011.414 0zm8.586 0a1 1 0 011.414 0l3 3a1 1 0 010 1.414l-3 3a1 1 0 11-1.414-1.414L16.586 10l-2.293-2.293a1 1 0 010-1.414z" clip-rule="evenodd"/>
                  </svg>
                </div>
                <div>
                  <div class="font-medium text-sm">Webhook</div>
                  <div class="text-xs text-gray-500">Send data to external services</div>
                </div>
              </div>
              <button class="text-sm text-indigo-600 hover:text-indigo-800">Configure</button>
            </div>
          </div>
          
          <!-- Email Integration -->
          <div class="p-3 border border-gray-200 rounded-lg">
            <div class="flex items-center justify-between">
              <div class="flex items-center space-x-3">
                <div class="w-8 h-8 bg-green-100 rounded-lg flex items-center justify-center">
                  <svg class="w-4 h-4 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 8l7.89 4.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"/>
                  </svg>
                </div>
                <div>
                  <div class="font-medium text-sm">Email Notifications</div>
                  <div class="text-xs text-gray-500">Get notified of new responses</div>
                </div>
              </div>
              <div class="flex items-center space-x-2">
                <div class="w-2 h-2 bg-green-500 rounded-full"></div>
                <span class="text-xs text-green-600">Active</span>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Available Integrations -->
      <div class="border-t pt-6">
        <h3 class="text-sm font-semibold text-gray-900 mb-3">Available Integrations</h3>
        <div class="grid grid-cols-2 gap-3">
          <button class="p-3 border border-gray-200 rounded-lg hover:border-gray-300 transition-colors">
            <div class="w-8 h-8 bg-blue-600 rounded mx-auto mb-2 flex items-center justify-center">
              <span class="text-white text-xs font-bold">SF</span>
            </div>
            <div class="text-xs font-medium">Salesforce</div>
          </button>
          <button class="p-3 border border-gray-200 rounded-lg hover:border-gray-300 transition-colors">
            <div class="w-8 h-8 bg-orange-500 rounded mx-auto mb-2 flex items-center justify-center">
              <span class="text-white text-xs font-bold">HS</span>
            </div>
            <div class="text-xs font-medium">HubSpot</div>
          </button>
          <button class="p-3 border border-gray-200 rounded-lg hover:border-gray-300 transition-colors">
            <div class="w-8 h-8 bg-purple-600 rounded mx-auto mb-2 flex items-center justify-center">
              <span class="text-white text-xs font-bold">S</span>
            </div>
            <div class="text-xs font-medium">Slack</div>
          </button>
          <button class="p-3 border border-gray-200 rounded-lg hover:border-gray-300 transition-colors">
            <div class="w-8 h-8 bg-blue-400 rounded mx-auto mb-2 flex items-center justify-center">
              <span class="text-white text-xs font-bold">Z</span>
            </div>
            <div class="text-xs font-medium">Zapier</div>
          </button>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
  .tab-button.active {
    background-color: #f3f4f6;
    color: #1f2937;
  }
  
  .tab-button:not(.active) {
    color: #6b7280;
  }
  
  .tab-button:not(.active):hover {
    background-color: #f9fafb;
    color: #374151;
  }
  
  .theme-option.active {
    border-color: #6366f1;
  }
</style>
</file>

<file path="views/forms/_form_card.html.erb">
<%# app/views/forms/_form_card.html.erb %>
<div class="agent-card bg-white p-5 rounded-xl shadow-sm animate-slide-in-up">
    <div class="flex items-center justify-between mb-4">
        <div class="flex items-center space-x-3">
            <div class="w-10 h-10 rounded-lg bg-blue-100 text-blue-600 flex items-center justify-center">
                <%= heroicon "chart-bar", variant: :outline, class: "w-6 h-6" %>
            </div>
            <div>
                <h3 class="font-semibold text-gray-900"><%= link_to form.name, edit_form_path(form) %></h3>
                <p class="text-xs text-gray-500">Creado: <%= form.created_at.strftime('%d/%m/%Y') %></p>
                <p class="text-xs text-gray-400">ID: <%= form.id.to_s.first(8) %></p>
            </div>
        </div>
        <% if form.published? %>
            <div class="flex items-center space-x-2 text-xs font-medium px-2 py-1 bg-green-100 text-green-800 rounded-full">
                <span class="w-2 h-2 bg-green-500 rounded-full"></span>
                <span>Activo</span>
            </div>
        <% else %>
            <div class="flex items-center space-x-2 text-xs font-medium px-2 py-1 bg-gray-100 text-gray-800 rounded-full">
                <span class="w-2 h-2 bg-gray-400 rounded-full"></span>
                <span><%= form.status.humanize %></span>
            </div>
        <% end %>
    </div>

    <div class="grid grid-cols-2 gap-4 text-center my-6">
        <div>
            <p class="text-3xl font-bold text-gray-900"><%= form.form_responses.count %></p>
            <p class="text-xs text-gray-500">Respuestas</p>
        </div>
        <div>
            <p class="text-3xl font-bold text-gray-900"><%= number_to_percentage(form.completion_rate, precision: 0) %></p>
            <p class="text-xs text-gray-500">Tasa de Finalizacin</p>
        </div>
    </div>

    <div class="mt-4 pt-4 border-t border-gray-100 flex items-center justify-between text-xs text-gray-500">
        <span><%= pluralize(form.form_questions.count, "pregunta") %></span>
        <div class="flex space-x-3">
           <%= link_to "Analticas", analytics_form_path(form), class: "font-medium text-indigo-600 hover:text-indigo-800" %>
           <%= link_to "Configurar", edit_form_path(form), class: "font-medium text-indigo-600 hover:text-indigo-800" %>
        </div>
    </div>
</div>
</file>

<file path="views/forms/_form_header.html.erb">
<%
  # Form Header Component
  # Displays form title, status, and primary actions in the form builder
%>

<div class="bg-white border-b border-gray-200 sticky top-0 z-10">
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
    <div class="flex items-center justify-between py-4">
      
      <!-- Left Section: Form Info -->
      <div class="flex items-center space-x-4">
        <!-- Back Button -->
        <a href="<%= forms_path %>" class="p-2 text-gray-400 hover:text-gray-600 transition-colors">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
          </svg>
        </a>
        
        <!-- Form Title and Status -->
        <div>
          <div class="flex items-center space-x-3">
            <h1 class="text-xl font-semibold text-gray-900 truncate max-w-md">
              <%= @form.name.present? ? @form.name : "Untitled Form" %>
            </h1>
            
            <!-- Status Badge -->
            <% case @form.status %>
            <% when 'draft' %>
              <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800">
                <div class="w-2 h-2 bg-gray-400 rounded-full mr-1.5"></div>
                Draft
              </span>
            <% when 'published' %>
              <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                <div class="w-2 h-2 bg-success rounded-full mr-1.5"></div>
                Published
              </span>
            <% when 'archived' %>
              <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800">
                <div class="w-2 h-2 bg-danger rounded-full mr-1.5"></div>
                Archived
              </span>
            <% end %>
            
            <!-- AI Enhanced Badge -->
            <% if @form.ai_enhanced? %>
              <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-purple-100 text-purple-800">
                <svg class="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
                  <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
                </svg>
                AI Enhanced
              </span>
            <% end %>
            
            <!-- Payment Status Badge -->
            <%= render 'forms/payment_status_indicator', form: @form %>
          </div>
          
          <!-- Form Meta Info -->
          <div class="flex items-center space-x-4 mt-1 text-sm text-gray-500">
            <span><%= pluralize(@form.questions_count, 'question') %></span>
            <span></span>
            <span><%= pluralize(@form.form_responses.count, 'response') %></span>
            <span></span>
            <span>Creado: <%= @form.created_at.strftime('%d/%m/%Y') %></span>
            <span></span>
            <span>Last updated <%= time_ago_in_words(@form.updated_at) %> ago</span>
          </div>
        </div>
      </div>

      <!-- Right Section: Actions -->
      <div class="flex items-center space-x-3">
        
        <!-- Preview Button -->
        <a href="<%= preview_form_path(@form) %>" target="_blank" class="inline-flex items-center px-3 py-2 border border-gray-300 text-sm font-medium rounded-lg text-gray-700 bg-white hover:bg-gray-50 transition-colors">
          <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"/>
          </svg>
          Preview
        </a>
        
        <!-- Share Button -->
        <% if @form.published? %>
          <button data-controller="clipboard" 
                  data-clipboard-text-value="<%= form_url(@form) %>"
                  data-action="click->clipboard#copy"
                  class="inline-flex items-center px-3 py-2 border border-gray-300 text-sm font-medium rounded-lg text-gray-700 bg-white hover:bg-gray-50 transition-colors">
            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.367 2.684 3 3 0 00-5.367-2.684z"/>
            </svg>
            Share
          </button>
        <% end %>
        
        <!-- Publish/Unpublish Button -->
        <% if @form.published? %>
          <form action="<%= unpublish_form_path(@form) %>" method="post" class="inline">
            <input type="hidden" name="_method" value="patch" />
            <button type="submit" class="inline-flex items-center px-3 py-2 border border-amber-300 text-sm font-medium rounded-lg text-amber-700 bg-amber-50 hover:bg-amber-100 transition-colors">
              <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728L5.636 5.636m12.728 12.728L18 12M6 6l12 12"/>
              </svg>
              Unpublish
            </button>
          </form>
        <% else %>
          <% if @form.form_questions.any? %>
            <form action="<%= publish_form_path(@form) %>" method="post" class="inline">
              <input type="hidden" name="_method" value="patch" />
              <button type="submit" class="inline-flex items-center px-4 py-2 bg-ai-gradient text-white text-sm font-medium rounded-lg hover:opacity-90 transition-opacity shadow-sm">
                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"/>
                </svg>
                Publish
              </button>
            </form>
          <% else %>
            <div class="relative group">
              <button disabled class="inline-flex items-center px-4 py-2 bg-gray-300 text-gray-500 text-sm font-medium rounded-lg cursor-not-allowed">
                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"/>
                </svg>
                Publish
              </button>
              <!-- Tooltip -->
              <div class="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-3 py-2 bg-gray-900 text-white text-xs rounded-lg opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap">
                Add questions to publish this form
                <div class="absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-900"></div>
              </div>
            </div>
          <% end %>
        <% end %>
        
        <!-- More Actions Dropdown -->
        <div class="relative" data-controller="dropdown">
          <button data-action="click->dropdown#toggle" 
                  class="p-2 text-gray-400 hover:text-gray-600 transition-colors">
            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
              <path d="M10 6a2 2 0 110-4 2 2 0 010 4zM10 12a2 2 0 110-4 2 2 0 010 4zM10 18a2 2 0 110-4 2 2 0 010 4z"/>
            </svg>
          </button>
          
          <div data-dropdown-target="menu" 
               class="hidden absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-lg border border-gray-200 z-20">
            <div class="py-1">
              <%= link_to "Duplicate Form", "#", 
                  class: "block px-4 py-2 text-sm text-gray-700 hover:bg-gray-50" %>
              <%= link_to "Export Data", "#", 
                  class: "block px-4 py-2 text-sm text-gray-700 hover:bg-gray-50" %>
              <%= link_to "Form Settings", "#", 
                  class: "block px-4 py-2 text-sm text-gray-700 hover:bg-gray-50" %>
              <hr class="my-1">
              <%= button_to "Delete Form", form_path(@form), 
                  method: :delete,
                  form: { data: { turbo_confirm: "Are you sure you want to delete this form? All questions and responses will be permanently removed. This action cannot be undone." } },
                  class: "block w-full text-left px-4 py-2 text-sm text-red-600 hover:bg-red-50 bg-transparent border-0 cursor-pointer" %>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Auto-save Indicator -->
<div id="autosave-indicator" class="hidden fixed top-20 right-4 z-50">
  <div class="bg-white border border-gray-200 rounded-lg shadow-lg px-3 py-2 flex items-center space-x-2">
    <div class="w-2 h-2 bg-green-500 rounded-full animate-pulse"></div>
    <span class="text-sm text-gray-700">Saving...</span>
  </div>
</div>

<style>
  .bg-ai-gradient {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  }
</style>
</file>

<file path="views/forms/_form.html.erb">
<%# Individual Form Card - Used in forms index %>
<div class="bg-white rounded-xl shadow-sm hover:shadow-md transition-shadow duration-200 border border-gray-200">
  <div class="p-6">
    <!-- Form Header -->
    <div class="flex items-start justify-between mb-4">
      <div class="flex-1 min-w-0">
        <h3 class="text-lg font-semibold text-gray-900 truncate">
          <%= link_to form.name, form_path(form), class: "hover:text-indigo-600" %>
        </h3>
        <p class="text-xs text-gray-500 mt-1">Creado: <%= form.created_at.strftime('%d/%m/%Y %H:%M') %></p>
        <p class="text-xs text-gray-400">ID: <%= form.id.to_s.first(8) %></p>
        <p class="text-sm text-gray-500 mt-1 line-clamp-2">
          <%= form.description.presence || "No description" %>
        </p>
      </div>
      
      <!-- Status Badge -->
      <div class="ml-3 flex-shrink-0">
        <% case form.status %>
        <% when 'published' %>
          <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">Published</span>
        <% when 'draft' %>
          <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800">Draft</span>
        <% when 'archived' %>
          <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800">Archived</span>
        <% else %>
          <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800">
            <%= form.status.humanize %>
          </span>
        <% end %>
      </div>
    </div>
    
    <!-- Form Stats -->
    <div class="grid grid-cols-3 gap-4 mb-4 text-center">
      <div>
        <div class="text-2xl font-bold text-gray-900"><%= form.questions_count %></div>
        <div class="text-xs text-gray-500">Questions</div>
      </div>
      
      <div>
        <div class="text-2xl font-bold text-gray-900"><%= form.form_responses.count %></div>
        <div class="text-xs text-gray-500">Responses</div>
      </div>
      
      <div>
        <div class="text-2xl font-bold text-gray-900"><%= form.completion_rate %>%</div>
        <div class="text-xs text-gray-500">Rate</div>
      </div>
    </div>
    
    <!-- Category and AI Badge -->
    <div class="flex items-center justify-between mb-4">
      <span class="text-xs text-gray-500">
        <%= form.category.humanize %>
      </span>
      
      <% if form.ai_enabled? %>
        <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-purple-100 text-purple-800">
          <svg class="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
            <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
          </svg>
          AI
        </span>
      <% end %>
    </div>
    
    <!-- Actions -->
    <div class="flex space-x-2">
      <%= link_to "Edit", edit_form_path(form), 
            class: "flex-1 text-center px-3 py-2 text-sm font-medium text-gray-700 bg-gray-100 rounded-md hover:bg-gray-200 transition-colors" %>
      
      <%= link_to "Preview", 
            form.published? ? public_form_path(form.share_token) : preview_form_path(form),
            target: form.published? ? "_blank" : nil,
            class: "flex-1 text-center px-3 py-2 text-sm font-medium text-white bg-indigo-600 rounded-md hover:bg-indigo-700 transition-colors" %>
    </div>
    
    <!-- Delete Button -->
    <div class="mt-3">
      <%= button_to "Delete Form", form_path(form), 
            method: :delete,
            form: { data: { turbo_confirm: "Are you sure you want to delete this form? All questions and responses will be permanently removed." } },
            class: "w-full px-3 py-2 text-sm font-medium text-red-700 bg-red-100 rounded-md hover:bg-red-200 transition-colors border border-red-200" %>
    </div>
  </div>
</div>

<style>
.line-clamp-2 {
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}
</style>
</file>

<file path="views/forms/_google_sheets_integration.html.erb">
<div class="bg-gray-50 rounded-lg p-4" data-controller="google-sheets-integration" data-google-sheets-integration-form-id-value="<%= @form.id %>">
  
  <% unless current_user.can_use_google_sheets? %>
    <!-- Premium Upgrade Prompt -->
    <div class="bg-gradient-to-r from-indigo-50 to-purple-50 border border-indigo-200 rounded-lg p-4">
      <div class="flex items-start">
        <div class="flex-shrink-0">
          <div class="flex items-center justify-center h-8 w-8 rounded-full bg-indigo-100">
            <svg class="h-5 w-5 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
            </svg>
          </div>
        </div>
        
        <div class="ml-4 flex-1">
          <h3 class="text-sm font-semibold text-indigo-900 mb-2">
            Premium Feature
          </h3>
          
          <div class="text-sm text-indigo-800 mb-3">
            Google Sheets integration is available with Premium subscription. Automatically export form responses to Google Sheets and keep your data synchronized.
          </div>
          
          <div class="flex items-center space-x-3">
            <%= link_to subscription_management_path, 
                  class: "inline-flex items-center px-3 py-1 border border-transparent text-xs font-medium rounded text-white bg-indigo-600 hover:bg-indigo-700" do %>
              <svg class="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
              </svg>
              Upgrade to Premium
            <% end %>
            
            <span class="text-xs text-indigo-600">
              Starting at $29/month
            </span>
          </div>
        </div>
      </div>
    </div>
  <% else %>
    <!-- Existing Google Sheets Integration UI -->
  <div class="flex items-center justify-between mb-3">
    <div class="flex items-center space-x-2">
      <div class="w-6 h-6 bg-green-100 rounded flex items-center justify-center">
        <svg class="w-4 h-4 text-green-600" fill="currentColor" viewBox="0 0 24 24">
          <path d="M19.5 3H4.5C3.12 3 2 4.12 2 5.5v13C2 19.88 3.12 21 4.5 21h15c1.38 0 2.5-1.12 2.5-2.5v-13C22 4.12 20.88 3 19.5 3zM19 18H5V6h14v12z"/>
          <path d="M7 8h10v2H7zm0 3h10v2H7zm0 3h7v2H7z"/>
        </svg>
      </div>
      <div>
        <h5 class="text-sm font-medium text-gray-900">Google Sheets</h5>
        <p class="text-xs text-gray-500">Auto-export responses</p>
      </div>
    </div>
    
    <% if @form.google_sheets_integration %>
      <span class="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
        <div class="w-1.5 h-1.5 bg-green-400 rounded-full mr-1"></div>
        Connected
      </span>
    <% else %>
      <span class="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800">
        Not setup
      </span>
    <% end %>
  </div>

  <% if @form.google_sheets_integration %>
    <!-- Existing Integration -->
    <div class="space-y-3">
      <div class="flex items-center justify-between">
        <label class="flex items-center">
          <input type="checkbox" 
                 <%= 'checked' if @form.google_sheets_integration.auto_sync? %>
                 class="rounded border-gray-300 text-green-600 shadow-sm focus:border-green-300 focus:ring focus:ring-green-200 focus:ring-opacity-50"
                 data-action="change->google-sheets-integration#toggleAutoSync">
          <span class="ml-2 text-xs text-gray-700">Auto-sync</span>
        </label>
        
        <a href="<%= @form.google_sheets_integration.spreadsheet_url %>" 
           target="_blank" 
           class="inline-flex items-center px-2 py-1 border border-gray-300 shadow-sm text-xs font-medium rounded text-gray-700 bg-white hover:bg-gray-50">
          <svg class="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
          </svg>
          Open
        </a>
      </div>
      
      <div class="flex space-x-2">
        <button type="button" 
                class="flex-1 inline-flex items-center justify-center px-2 py-1 border border-gray-300 shadow-sm text-xs font-medium rounded text-gray-700 bg-white hover:bg-gray-50"
                data-action="click->google-sheets-integration#exportNow">
          <svg class="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
          </svg>
          Export
        </button>
        
        <button type="button" 
                class="inline-flex items-center px-2 py-1 border border-red-300 shadow-sm text-xs font-medium rounded text-red-700 bg-white hover:bg-red-50"
                data-action="click->google-sheets-integration#disconnectIntegration">
          <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>
      </div>
      
      <% if @form.google_sheets_integration.last_sync_at %>
        <p class="text-xs text-gray-500">
          Last sync: <%= time_ago_in_words(@form.google_sheets_integration.last_sync_at) %> ago
        </p>
      <% end %>
      
      <% if @form.google_sheets_integration.error_message.present? %>
        <div class="p-2 bg-red-50 border border-red-200 rounded text-xs">
          <p class="text-red-800 font-medium">Sync Error</p>
          <p class="text-red-700"><%= @form.google_sheets_integration.error_message %></p>
        </div>
      <% end %>
    </div>
  <% else %>
    <!-- Setup Integration -->
    <div class="space-y-3">
      <% unless @form.user.google_integration&.valid_token? %>
        <!-- Need Google Connection First -->
        <div class="text-center py-3">
          <svg class="mx-auto h-8 w-8 text-amber-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
          </svg>
          <p class="mt-1 text-xs text-amber-600 font-medium">Connect Google Account First</p>
          <p class="text-xs text-gray-500">Required for Google Sheets integration</p>
        </div>
        
        <div class="text-center">
          <%= link_to google_oauth_connect_path, 
                data: { turbo: false },
                class: "inline-flex items-center px-3 py-1 border border-transparent text-xs font-medium rounded text-white bg-blue-600 hover:bg-blue-700" do %>
            <svg class="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path>
            </svg>
            Connect Google
          <% end %>
        </div>
      <% else %>
        <!-- Google Connected - Show Setup Options -->
        <div class="text-center py-3">
          <svg class="mx-auto h-8 w-8 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
          </svg>
          <p class="mt-1 text-xs text-gray-500">Export responses to Google Sheets</p>
        </div>
      
      <div class="space-y-2" data-google-sheets-integration-target="setupForm">
        <div class="space-y-2">
          <label class="flex items-center text-xs">
            <input type="radio" 
                   name="setup_type" 
                   value="create_new" 
                   class="rounded border-gray-300 text-green-600 shadow-sm focus:border-green-300 focus:ring focus:ring-green-200 focus:ring-opacity-50"
                   data-google-sheets-integration-target="setupType"
                   data-action="change->google-sheets-integration#setupTypeChanged"
                   checked>
            <span class="ml-2 text-gray-700">Create new spreadsheet</span>
          </label>
          
          <label class="flex items-center text-xs">
            <input type="radio" 
                   name="setup_type" 
                   value="use_existing" 
                   class="rounded border-gray-300 text-green-600 shadow-sm focus:border-green-300 focus:ring focus:ring-green-200 focus:ring-opacity-50"
                   data-google-sheets-integration-target="setupType"
                   data-action="change->google-sheets-integration#setupTypeChanged">
            <span class="ml-2 text-gray-700">Use existing spreadsheet</span>
          </label>
        </div>
        
        <div data-google-sheets-integration-target="newSpreadsheetOptions">
          <input type="text" 
                 placeholder="<%= @form.name %> - Responses"
                 class="w-full text-xs border border-gray-300 rounded px-2 py-1"
                 data-google-sheets-integration-target="spreadsheetTitle">
        </div>
        
        <div class="hidden" data-google-sheets-integration-target="existingSpreadsheetOptions">
          <input type="text" 
                 placeholder="Spreadsheet ID"
                 class="w-full text-xs border border-gray-300 rounded px-2 py-1"
                 data-google-sheets-integration-target="spreadsheetId">
        </div>
        
        <input type="text" 
               value="Responses"
               placeholder="Sheet Name"
               class="w-full text-xs border border-gray-300 rounded px-2 py-1"
               data-google-sheets-integration-target="sheetName">
        
        <div class="space-y-1">
          <label class="flex items-center text-xs">
            <input type="checkbox" 
                   checked
                   class="rounded border-gray-300 text-green-600 shadow-sm focus:border-green-300 focus:ring focus:ring-green-200 focus:ring-opacity-50"
                   data-google-sheets-integration-target="autoSync">
            <span class="ml-2 text-gray-700">Auto-sync new responses</span>
          </label>
          
          <label class="flex items-center text-xs">
            <input type="checkbox" 
                   checked
                   class="rounded border-gray-300 text-green-600 shadow-sm focus:border-green-300 focus:ring focus:ring-green-200 focus:ring-opacity-50"
                   data-google-sheets-integration-target="exportExisting">
            <span class="ml-2 text-gray-700">Export existing responses</span>
          </label>
        </div>
        
        <div class="flex space-x-2">
          <button type="button" 
                  class="flex-1 inline-flex items-center justify-center px-2 py-1 border border-gray-300 shadow-sm text-xs font-medium rounded text-gray-700 bg-white hover:bg-gray-50"
                  data-action="click->google-sheets-integration#testConnection">
            <svg class="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
            Test
          </button>
          
          <button type="button" 
                  class="flex-1 inline-flex items-center justify-center px-2 py-1 border border-transparent text-xs font-medium rounded text-white bg-green-600 hover:bg-green-700"
                  data-action="click->google-sheets-integration#setupIntegration">
            <svg class="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path>
            </svg>
            Connect
          </button>
        </div>
      <% end %>
    </div>
  <% end %>
  <% end %> <!-- End premium check -->
</div>
</file>

<file path="views/forms/_lead_routing_status.html.erb">
<%# app/views/forms/_lead_routing_status.html.erb %>
<%# Displays lead scoring and routing status for a form response %>

<div class="bg-white shadow rounded-lg p-4 mb-4 border-l-4 border-l-<%= lead_routing.priority_color %>"
     id="lead_routing_<%= lead_routing.id %>">
  
  <div class="flex items-center justify-between mb-3">
    <div class="flex items-center">
      <div class="flex-shrink-0">
        <% case lead_routing.priority %>
        <% when 'critical' %>
          <svg class="w-6 h-6 text-red-500" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
          </svg>
        <% when 'high' %>
          <svg class="w-6 h-6 text-orange-500" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
          </svg>
        <% when 'medium' %>
          <svg class="w-6 h-6 text-yellow-500" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
          </svg>
        <% else %>
          <svg class="w-6 h-6 text-blue-500" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
          </svg>
        <% end %>
      </div>
      <div class="ml-3">
        <h3 class="text-lg font-medium text-gray-900">
          Lead Score: <%= score.round %> / 100
          <span class="ml-2 inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-<%= lead_routing.priority_color %>-100 text-<%= lead_routing.priority_color %>-800">
            <%= lead_tier.humanize %> Lead
          </span>
        </h3>
        <p class="text-sm text-gray-500">
          <%= lead_routing.company_name %> - <%= lead_routing.respondent_name %>
        </p>
      </div>
    </div>
    
    <div class="text-sm text-gray-500">
      SLA: <%= lead_routing.sla_deadline.strftime("%b %d, %Y %H:%M") %>
    </div>
  </div>

  <!-- Status and Progress -->
  <div class="mb-4">
    <div class="flex items-center justify-between mb-2">
      <span class="text-sm font-medium text-gray-700">Routing Status</span>
      <span class="text-sm text-gray-500"><%= lead_routing.created_at.strftime("%b %d, %H:%M") %></span>
    </div>
    
    <div class="w-full bg-gray-200 rounded-full h-2">
      <% progress_percentage = case lead_routing.status
         when 'completed' then 100
         when 'processing' then 66
         when 'pending' then 33
         else 0
         end %>
      
      <div class="bg-<%= lead_routing.status_color %>-600 h-2 rounded-full" style="width: <%= progress_percentage %>"></div>
    </div>
    
    <div class="flex justify-between text-xs text-gray-500 mt-1">
      <span><%= lead_routing.status_label %></span>
      <span><%= lead_routing.sla_status.humanize %></span>
    </div>
  </div>

  <!-- Routing Actions -->
  <% if lead_routing.routing_actions_array.any? %>
    <div class="border-t pt-3">
      <h4 class="text-sm font-medium text-gray-700 mb-2">Next Actions</h4>
      <div class="space-y-2">
        <% lead_routing.routing_actions_array.each do |action| %>
          <div class="flex items-center justify-between p-2 bg-gray-50 rounded">
            <div>
              <span class="text-sm font-medium text-gray-900">
                <%= action[:action].humanize %>
              </span>
              <span class="text-xs text-gray-500 ml-2">
                via <%= action[:channels].join(', ') %>
              </span>
            </div>
            <span class="text-xs text-gray-500">
              <%= action[:assign_to].humanize %>
            </span>
          </div>
        <% end %>
      </div>
    </div>
  <% end %>

  <!-- Lead Details -->
  <% if lead_routing.lead_scoring.present? %>
    <div class="border-t pt-3 mt-3">
      <h4 class="text-sm font-medium text-gray-700 mb-2">Lead Details</h4>
      <div class="grid grid-cols-2 gap-4 text-sm">
        <div>
          <span class="text-gray-500">Respondent:</span>
          <span class="text-gray-900 ml-1"><%= lead_routing.respondent_name %></span>
        </div>
        <div>
          <span class="text-gray-500">Company:</span>
          <span class="text-gray-900 ml-1"><%= lead_routing.company_name %></span>
        </div>
        <div>
          <span class="text-gray-500">Email:</span>
          <span class="text-gray-900 ml-1"><%= lead_routing.respondent_email %></span>
        </div>
        <div>
          <span class="text-gray-500">Confidence:</span>
          <span class="text-gray-900 ml-1"><%= lead_routing.lead_scoring.confidence_percentage %>%</span>
        </div>
      </div>

      <!-- Buying Signals -->
      <% if lead_routing.lead_scoring.buying_signals_summary.any? %>
        <div class="mt-3">
          <span class="text-sm font-medium text-gray-700">Buying Signals:</span>
          <div class="flex flex-wrap gap-1 mt-1">
            <% lead_routing.lead_scoring.buying_signals_summary.each do |signal| %>
              <span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800">
                <%= signal %>
              </span>
            <% end %>
          </div>
        </div>
      <% end %>

      <!-- Next Best Action -->
      <% if lead_routing.lead_scoring.next_best_action.present? %>
        <div class="mt-3 p-3 bg-blue-50 rounded-md">
          <span class="text-sm font-medium text-blue-900">Next Best Action:</span>
          <p class="text-sm text-blue-700 mt-1"><%= lead_routing.lead_scoring.next_best_action %></p>
        </div>
      <% end %>
    </div>
  <% end %>
</div>
</file>

<file path="views/forms/_payment_notification_bar.html.erb">
<%
  # Payment Setup Notification Bar Component
  # Shows persistent notification for incomplete payment setup
  has_payment_questions = form.has_payment_questions?
  setup_complete = form.payment_setup_complete?
  missing_requirements = form.payment_setup_requirements
  completion_percentage = form.user.payment_setup_status[:setup_completion_percentage]
%>

<% if has_payment_questions %>
  <div class="payment-notification-bar <%= 'hidden' unless has_payment_questions %>" 
       data-payment-setup-status-target="notificationBar">
    
    <% if setup_complete %>
      <!-- Success notification -->
      <div class="bg-green-50 border-l-4 border-green-400 p-4 mb-6">
        <div class="flex items-center justify-between">
          <div class="flex">
            <div class="flex-shrink-0">
              <svg class="h-5 w-5 text-green-400" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
              </svg>
            </div>
            <div class="ml-3">
              <p class="text-sm text-green-700">
                <strong>Payment setup complete!</strong> Your form is ready to accept payments.
              </p>
            </div>
          </div>
        </div>
      </div>
    <% else %>
      <!-- Setup required notification -->
      <div class="bg-amber-50 border-l-4 border-amber-400 p-4 mb-6">
        <div class="flex items-center justify-between">
          <div class="flex">
            <div class="flex-shrink-0">
              <svg class="h-5 w-5 text-amber-400" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
              </svg>
            </div>
            <div class="ml-3 flex-1">
              <p class="text-sm text-amber-700">
                <strong>Payment setup required</strong> to publish this form with payment questions.
              </p>
              
              <!-- Progress bar -->
              <div class="mt-2 mb-3">
                <div class="flex items-center justify-between text-xs text-amber-600 mb-1">
                  <span>Setup Progress</span>
                  <span data-payment-setup-status-target="progressText"><%= completion_percentage %>% Complete</span>
                </div>
                <div class="w-full bg-amber-200 rounded-full h-2">
                  <div class="h-2 rounded-full transition-all duration-300 <%= completion_percentage < 50 ? 'bg-red-500' : completion_percentage < 100 ? 'bg-yellow-500' : 'bg-green-500' %>" 
                       style="width: <%= completion_percentage %>%"
                       data-payment-setup-status-target="progressBar"></div>
                </div>
              </div>
              
              <!-- Missing requirements -->
              <ul class="mt-2 text-sm text-amber-600 list-disc list-inside">
                <% missing_requirements.each do |requirement| %>
                  <li>
                    <% case requirement %>
                    <% when 'stripe_configuration' %>
                      Configure Stripe payment processing
                    <% when 'premium_subscription' %>
                      Upgrade to Premium subscription
                    <% else %>
                      <%= requirement.humanize %>
                    <% end %>
                  </li>
                <% end %>
              </ul>
            </div>
          </div>
          <div class="ml-4 flex-shrink-0">
            <button data-action="click->payment-setup-status#openSetupModal" 
                    data-payment-setup-status-target="actionButton"
                    class="bg-amber-100 hover:bg-amber-200 text-amber-800 px-3 py-2 rounded-md text-sm font-medium transition-colors">
              Complete Setup
            </button>
          </div>
        </div>
      </div>
    <% end %>
  </div>
<% end %>
</file>

<file path="views/forms/_payment_setup_modal.html.erb">
<%
  # Payment Setup Modal Component
  # Provides guided setup for payment requirements
  has_payment_questions = form.has_payment_questions?
  missing_requirements = form.payment_setup_requirements
%>

<% if has_payment_questions %>
  <!-- Payment Setup Modal -->
  <div class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50" 
       data-payment-setup-status-target="setupModal">
    <div class="relative top-20 mx-auto p-5 border w-11/12 md:w-3/4 lg:w-1/2 shadow-lg rounded-md bg-white">
      
      <!-- Modal Header -->
      <div class="flex items-center justify-between pb-4 border-b border-gray-200">
        <h3 class="text-lg font-semibold text-gray-900">Complete Payment Setup</h3>
        <button data-action="click->payment-setup-status#closeSetupModal" 
                class="text-gray-400 hover:text-gray-600 transition-colors">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>
      
      <!-- Modal Body -->
      <div class="mt-4">
        <p class="text-sm text-gray-600 mb-4">
          Your form contains payment questions that require additional setup. Complete the following steps to enable payment processing:
        </p>
        
        <!-- Requirements List -->
        <div class="space-y-3">
          <h4 class="font-medium text-gray-900">Required Setup Steps:</h4>
          <ul class="space-y-2" data-payment-setup-status-target="requirementsList">
            <% missing_requirements.each do |requirement| %>
              <li class="flex items-center justify-between py-3 border-b border-gray-200 last:border-b-0">
                <span class="text-sm text-gray-700">
                  <% case requirement %>
                  <% when 'stripe_configuration' %>
                    Configure Stripe payment processing
                  <% when 'premium_subscription' %>
                    Upgrade to Premium subscription
                  <% else %>
                    <%= requirement.humanize %>
                  <% end %>
                </span>
                <% case requirement %>
                <% when 'stripe_configuration' %>
                  <a href="/stripe_settings" target="_blank" 
                     class="inline-flex items-center px-3 py-1 border border-transparent text-xs font-medium rounded text-indigo-700 bg-indigo-100 hover:bg-indigo-200 transition-colors">
                    Configure Stripe
                  </a>
                <% when 'premium_subscription' %>
                  <a href="/subscription_management" target="_blank" 
                     class="inline-flex items-center px-3 py-1 border border-transparent text-xs font-medium rounded text-indigo-700 bg-indigo-100 hover:bg-indigo-200 transition-colors">
                    Upgrade Plan
                  </a>
                <% else %>
                  <button class="inline-flex items-center px-3 py-1 border border-transparent text-xs font-medium rounded text-indigo-700 bg-indigo-100 hover:bg-indigo-200 transition-colors">
                    Setup
                  </button>
                <% end %>
              </li>
            <% end %>
          </ul>
        </div>
        
        <!-- Help Text -->
        <div class="mt-6 p-4 bg-blue-50 rounded-lg">
          <div class="flex">
            <div class="flex-shrink-0">
              <svg class="h-5 w-5 text-blue-400" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
              </svg>
            </div>
            <div class="ml-3">
              <h4 class="text-sm font-medium text-blue-800">Need Help?</h4>
              <p class="mt-1 text-sm text-blue-700">
                Each setup step will open in a new tab so you can complete the configuration without losing your form progress. 
                The status will update automatically once setup is complete.
              </p>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Modal Footer -->
      <div class="flex items-center justify-end pt-4 border-t border-gray-200 mt-6 space-x-3">
        <button data-action="click->payment-setup-status#closeSetupModal" 
                class="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 transition-colors">
          Close
        </button>
        <a href="/payment_setup" target="_blank" 
           class="px-4 py-2 text-sm font-medium text-white bg-indigo-600 border border-transparent rounded-md hover:bg-indigo-700 transition-colors">
          Open Setup Guide
        </a>
      </div>
    </div>
  </div>
<% end %>
</file>

<file path="views/forms/_payment_status_indicator.html.erb">
<%
  # Payment Status Indicator Component
  # Shows payment setup status in form header
  has_payment_questions = form.has_payment_questions?
  setup_complete = form.payment_setup_complete?
  completion_percentage = form.user.payment_setup_status[:setup_completion_percentage]
%>

<% if has_payment_questions %>
  <div class="payment-status-indicator" 
       data-payment-setup-status-target="statusIndicator">
    <% if setup_complete %>
      <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
        <div class="w-2 h-2 bg-green-400 rounded-full mr-1.5"></div>
        Payment Ready
      </span>
    <% else %>
      <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-amber-100 text-amber-800">
        <div class="w-2 h-2 bg-amber-400 rounded-full mr-1.5"></div>
        Setup Required
      </span>
    <% end %>
  </div>
<% end %>
</file>

<file path="views/forms/_publish_section_with_payment_guidance.html.erb">
<div id="form-publish-section" class="bg-white border border-gray-200 rounded-lg p-6">
  <div class="flex items-center justify-between mb-4">
    <h3 class="text-lg font-semibold text-gray-900">Publish Form</h3>
    <div id="form-status-indicator">
      <%= render 'forms/status_indicator', form: form %>
    </div>
  </div>

  <% if error.present? %>
    <!-- Payment Setup Required Section -->
    <div class="bg-amber-50 border border-amber-200 rounded-lg p-4 mb-6">
      <div class="flex items-start">
        <div class="flex-shrink-0">
          <svg class="h-5 w-5 text-amber-400" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
          </svg>
        </div>
        <div class="ml-3 flex-1">
          <h4 class="text-sm font-medium text-amber-800">Payment Setup Required</h4>
          <p class="mt-1 text-sm text-amber-700"><%= error.message %></p>
          
          <% if error.user_guidance[:description].present? %>
            <p class="mt-2 text-sm text-amber-600"><%= error.user_guidance[:description] %></p>
          <% end %>

          <% if error.actionable? %>
            <div class="mt-4">
              <% if error.primary_action_url.present? %>
                <%= link_to error.primary_action_text || 'Complete Setup',
                           error.primary_action_url,
                           class: "inline-flex items-center px-3 py-2 border border-transparent text-sm leading-4 font-medium rounded-md text-amber-700 bg-amber-100 hover:bg-amber-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-amber-500 transition-colors",
                           data: { turbo: false } %>
              <% end %>
            </div>
          <% end %>
        </div>
      </div>
    </div>

    <!-- Payment Setup Checklist -->
    <div class="bg-gray-50 border border-gray-200 rounded-lg p-4 mb-6">
      <h4 class="text-sm font-medium text-gray-900 mb-3">Setup Checklist</h4>
      <div class="space-y-2">
        <div class="flex items-center">
          <% if current_user.stripe_configured? %>
            <svg class="h-4 w-4 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" />
            </svg>
          <% else %>
            <svg class="h-4 w-4 text-gray-400 mr-2" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
            </svg>
          <% end %>
          <span class="text-sm <%= current_user.stripe_configured? ? 'text-green-700' : 'text-gray-600' %>">
            Stripe Configuration
          </span>
          <% unless current_user.stripe_configured? %>
            <%= link_to 'Configure', stripe_settings_path, 
                       class: "ml-2 text-xs text-indigo-600 hover:text-indigo-500" %>
          <% end %>
        </div>
        
        <div class="flex items-center">
          <% if current_user.premium? %>
            <svg class="h-4 w-4 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" />
            </svg>
          <% else %>
            <svg class="h-4 w-4 text-gray-400 mr-2" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
            </svg>
          <% end %>
          <span class="text-sm <%= current_user.premium? ? 'text-green-700' : 'text-gray-600' %>">
            Premium Subscription
          </span>
          <% unless current_user.premium? %>
            <%= link_to 'Upgrade', subscription_management_path, 
                       class: "ml-2 text-xs text-indigo-600 hover:text-indigo-500" %>
          <% end %>
        </div>
      </div>
    </div>

    <!-- Disabled Publish Button -->
    <button type="button" 
            disabled
            class="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-gray-400 bg-gray-100 cursor-not-allowed">
      <svg class="h-4 w-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
      </svg>
      Complete Setup to Publish
    </button>

  <% else %>
    <!-- Normal Publish Section -->
    <div class="space-y-4">
      <p class="text-sm text-gray-600">
        Your form is ready to be published. Once published, it will be accessible via a public URL.
      </p>

      <% if form.has_payment_questions? %>
        <div class="bg-green-50 border border-green-200 rounded-lg p-3">
          <div class="flex items-center">
            <svg class="h-4 w-4 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" />
            </svg>
            <span class="text-sm text-green-700 font-medium">Payment setup complete</span>
          </div>
        </div>
      <% end %>

      <form action="<%= publish_form_path(form) %>" method="post" data-turbo="false" class="space-y-4">
        <%= hidden_field_tag :authenticity_token, form_authenticity_token %>
        <button type="submit" 
                class="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors">
          <svg class="h-4 w-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
          </svg>
          Publish Form
        </button>
      </form>
    </div>
  <% end %>
</div>
</file>

<file path="views/forms/_question_card_ajax.html.erb">
<%# app/views/forms/_question_card_ajax.html.erb %>
<div class="bg-white rounded-xl border border-gray-200 p-6 hover:shadow-md transition-shadow" 
     data-question-id="<%= question.id %>"
     data-form-builder-target="questionCard">
  
  <!-- Drag Handle -->
  <div class="flex items-start justify-between mb-4">
    <div class="flex items-start space-x-3">
      <div class="drag-handle cursor-grab text-gray-400 hover:text-gray-600 mt-1">
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8h16M4 16h16"/>
        </svg>
      </div>
      
      <div class="flex-1">
        <div class="flex items-center space-x-2 mb-1">
          <span class="inline-flex items-center px-2 py-1 text-xs font-medium bg-purple-100 text-purple-800 rounded-full">
            Step <%= index + 1 %>
          </span>
          <% if question.ai_enhanced? %>
            <span class="ai-indicator inline-flex items-center px-2 py-1 text-xs font-medium bg-green-100 text-green-800 rounded-full">
              AI Enhanced
            </span>
          <% end %>
          <% if question.required? %>
            <span class="inline-flex items-center px-2 py-1 text-xs font-medium bg-red-100 text-red-800 rounded-full">
              Required
            </span>
          <% end %>
        </div>
        <h3 class="question-title font-semibold text-gray-900 mb-1"><%= question.title %></h3>
        <% if question.description.present? %>
          <p class="text-sm text-gray-600 mb-2"><%= question.description %></p>
        <% end %>
        <div class="text-xs text-gray-500">
          Type: <span class="font-medium"><%= question.question_type.humanize %></span>
        </div>
      </div>
    </div>
    
    <!-- Action Buttons -->
    <div class="flex items-center space-x-1">
      <button type="button" 
              class="p-2 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg transition-colors"
              data-action="click->form-builder#editQuestion"
              title="Edit question">
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/>
        </svg>
      </button>
      
      <button type="button" 
              class="p-2 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg transition-colors"
              data-action="click->form-builder#duplicateQuestion"
              title="Duplicate question">
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"/>
        </svg>
      </button>
      
      <button type="button" 
              class="p-2 text-gray-400 hover:text-green-600 hover:bg-green-50 rounded-lg transition-colors"
              data-action="click->form-builder#enhanceWithAI"
              title="Enhance with AI">
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
        </svg>
      </button>
      
      <button type="button" 
              class="p-2 text-red-400 hover:text-red-600 hover:bg-red-50 rounded-lg transition-colors"
              data-action="click->form-builder#deleteQuestion"
              title="Delete question">
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
        </svg>
      </button>
    </div>
  </div>
  
  <!-- Quick Required Toggle -->
  <div class="flex items-center justify-between pt-4 border-t border-gray-200">
    <span class="text-sm text-gray-700">Required field</span>
    <label class="relative inline-flex items-center cursor-pointer">
      <input type="checkbox" 
             class="sr-only peer" 
             <%= 'checked' if question.required? %>
             data-action="change->form-builder#toggleRequired">
      <div class="w-9 h-5 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-purple-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-purple-600"></div>
    </label>
  </div>
</div>
</file>

<file path="views/forms/_question_card.html.erb">
<%
  # Individual Question Card Component
  # Used within the questions panel for each form question
%>

<div class="question-card bg-white rounded-xl p-4 shadow-sm hover:shadow-md transition-all duration-200 border border-gray-200 group"
     data-sortable-target="item"
     data-question-id="<%= question.id %>"
     data-controller="question-card">
  
  <!-- Question Header -->
  <div class="flex items-start space-x-3">
    <!-- Drag Handle & Number -->
    <div class="flex items-center space-x-2 text-gray-400">
      <span class="text-sm font-medium w-6 text-center"><%= index + 1 %></span>
      <svg class="w-4 h-4 cursor-grab" data-sortable-target="handle">
        <path fill="currentColor" d="M3 7h2v2H3V7zm0 4h2v2H3v-2zm4-4h2v2H7V7zm0 4h2v2H7v-2zm4-4h2v2h-2V7zm0 4h2v2h-2v-2z"/>
      </svg>
    </div>
    
    <!-- Question Content -->
    <div class="flex-1 min-w-0">
      <div class="flex items-start justify-between">
        <div class="flex-1">
          <h3 class="font-medium text-gray-900 mb-1 truncate">
            <%= question.title.present? ? question.title : "Untitled Question" %>
          </h3>
          <div class="flex items-center space-x-3 text-sm text-gray-500">
            <span class="px-2 py-1 bg-gray-100 rounded text-xs font-medium">
              <%= question.question_type.humanize %>
            </span>
            <% if question.required? %>
              <span class="text-red-600 font-medium">Required</span>
            <% end %>
            <% if question.ai_enhanced? %>
              <span class="flex items-center text-purple-600 font-medium">
                <svg class="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
                  <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
                </svg>
                AI Enhanced
              </span>
            <% end %>
          </div>
        </div>
        
        <!-- Question Actions -->
        <div class="flex items-center space-x-1 opacity-0 group-hover:opacity-100 transition-opacity">
          <%= link_to edit_form_question_path(@form, question),
              data: { action: "click->question-card#edit" },
              class: "p-1.5 text-gray-400 hover:text-indigo-600 transition-colors" do %>
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/>
            </svg>
          <% end %>
          
          <button data-action="click->question-card#duplicate"
                  class="p-1.5 text-gray-400 hover:text-blue-600 transition-colors">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"/>
            </svg>
          </button>
          
          <%= link_to form_question_path(@form, question),
              method: :delete,
              data: { 
                confirm: "Are you sure you want to delete this question?",
                action: "click->question-card#delete"
              },
              class: "p-1.5 text-gray-400 hover:text-red-600 transition-colors" do %>
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
            </svg>
          <% end %>
        </div>
      </div>
      
      <!-- Question Preview -->
      <% if question.description.present? %>
        <p class="text-sm text-gray-600 mt-2 line-clamp-2">
          <%= question.description %>
        </p>
      <% end %>
      
      <!-- Question Options Preview (for multiple choice, etc.) -->
      <% if question.question_type.in?(['multiple_choice', 'single_choice']) && question.options.present? %>
        <div class="mt-3 space-y-1">
          <% question.options.first(3).each do |option| %>
            <div class="flex items-center space-x-2 text-sm text-gray-600">
              <div class="w-3 h-3 border border-gray-300 rounded <%= 'rounded-full' if question.question_type == 'single_choice' %>"></div>
              <span><%= option %></span>
            </div>
          <% end %>
          <% if question.options.count > 3 %>
            <div class="text-xs text-gray-500 ml-5">
              +<%= question.options.count - 3 %> more options
            </div>
          <% end %>
        </div>
      <% end %>
    </div>
  </div>
  
  <!-- Conditional Logic Indicator -->
  <% if question.conditional_logic.present? %>
    <div class="mt-3 pt-3 border-t border-gray-100">
      <div class="flex items-center space-x-2 text-xs text-amber-600">
        <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M3 3a1 1 0 000 2v8a2 2 0 002 2h2.586l-1.293 1.293a1 1 0 101.414 1.414L10 15.414l2.293 2.293a1 1 0 001.414-1.414L12.414 15H15a2 2 0 002-2V5a1 1 0 100-2H3zm11.707 4.707a1 1 0 00-1.414-1.414L10 9.586 8.707 8.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
        </svg>
        <span>Has conditional logic</span>
      </div>
    </div>
  <% end %>
</div>

<style>
  .line-clamp-2 {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
</style>
</file>

<file path="views/forms/_questions_panel.html.erb">
<%
  # Questions Panel Component
  # Main panel for managing form questions with drag-and-drop functionality
%>

<div class="flex-1 bg-gray-50 overflow-y-auto" data-controller="sortable form-builder">
  
  <!-- Questions Header -->
  <div class="bg-white border-b border-gray-200 px-6 py-4">
    <div class="flex items-center justify-between">
      <div>
        <h2 class="text-lg font-semibold text-gray-900">Questions</h2>
        <p class="text-sm text-gray-500 mt-1">
          <%= pluralize(@form.form_questions.count, 'question') %>  Drag to reorder
        </p>
      </div>
      
      <!-- Add Question Button -->
      <button data-action="click->form-builder#showAddQuestion"
              class="inline-flex items-center px-4 py-2 bg-ai-gradient text-white text-sm font-medium rounded-lg hover:opacity-90 transition-opacity">
        <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
        </svg>
        Add Question
      </button>
    </div>
  </div>

  <!-- Questions List -->
  <div class="p-6">
    <% if @form.form_questions.any? %>
      <div id="questions-list" 
           data-sortable-target="container"
           data-sortable-url-value="<%= reorder_form_questions_path(@form) %>"
           class="space-y-4">
        
        <% @form.form_questions.ordered.each_with_index do |question, index| %>
          <%= render 'question_card', question: question, index: index %>
        <% end %>
      </div>
      
      <!-- Add Question at End -->
      <div class="mt-6 pt-6 border-t border-gray-200">
        <button data-action="click->form-builder#showAddQuestion"
                class="w-full flex items-center justify-center px-4 py-3 border-2 border-dashed border-gray-300 rounded-lg text-gray-500 hover:border-gray-400 hover:text-gray-600 transition-colors">
          <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
          </svg>
          Add Another Question
        </button>
      </div>
      
    <% else %>
      <!-- Empty State -->
      <div class="text-center py-12">
        <div class="mx-auto w-16 h-16 bg-gray-100 rounded-full flex items-center justify-center mb-4">
          <svg class="w-8 h-8 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
          </svg>
        </div>
        <h3 class="text-lg font-medium text-gray-900 mb-2">No questions yet</h3>
        <p class="text-gray-600 mb-6 max-w-md mx-auto">
          Start building your form by adding your first question. You can choose from various question types and enable AI features.
        </p>
        <button data-action="click->form-builder#showAddQuestion"
                class="inline-flex items-center px-6 py-3 bg-ai-gradient text-white text-sm font-medium rounded-lg hover:opacity-90 transition-opacity">
          <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
          </svg>
          Add Your First Question
        </button>
      </div>
    <% end %>
  </div>
</div>

<!-- Question Card Partial -->
<% content_for :question_card do %>
  <div class="question-card bg-white rounded-xl p-4 shadow-sm hover:shadow-md transition-all duration-200 border border-gray-200 group"
       data-sortable-target="item"
       data-question-id="<%= question.id %>"
       data-controller="question-card">
    
    <!-- Question Header -->
    <div class="flex items-start space-x-3">
      <!-- Drag Handle & Number -->
      <div class="flex items-center space-x-2 text-gray-400">
        <span class="text-sm font-medium w-6 text-center"><%= index + 1 %></span>
        <svg class="w-4 h-4 cursor-grab" data-sortable-target="handle">
          <path fill="currentColor" d="M3 7h2v2H3V7zm0 4h2v2H3v-2zm4-4h2v2H7V7zm0 4h2v2H7v-2zm4-4h2v2h-2V7zm0 4h2v2h-2v-2z"/>
        </svg>
      </div>
      
      <!-- Question Content -->
      <div class="flex-1 min-w-0">
        <div class="flex items-start justify-between">
          <div class="flex-1">
            <h3 class="font-medium text-gray-900 mb-1 truncate">
              <%= question.title.present? ? question.title : "Untitled Question" %>
            </h3>
            <div class="flex items-center space-x-3 text-sm text-gray-500">
              <span class="px-2 py-1 bg-gray-100 rounded text-xs font-medium">
                <%= question.question_type.humanize %>
              </span>
              <% if question.required? %>
                <span class="text-red-600 font-medium">Required</span>
              <% end %>
              <% if question.ai_enhanced? %>
                <span class="flex items-center text-purple-600 font-medium">
                  <svg class="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
                    <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
                  </svg>
                  AI Enhanced
                </span>
              <% end %>
            </div>
          </div>
          
          <!-- Question Actions -->
          <div class="flex items-center space-x-1 opacity-0 group-hover:opacity-100 transition-opacity">
            <button data-action="click->question-card#edit"
                    class="p-1.5 text-gray-400 hover:text-indigo-600 transition-colors">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/>
              </svg>
            </button>
            <button data-action="click->question-card#duplicate"
                    class="p-1.5 text-gray-400 hover:text-blue-600 transition-colors">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"/>
              </svg>
            </button>
            <button data-action="click->question-card#delete"
                    data-confirm="Are you sure you want to delete this question?"
                    class="p-1.5 text-gray-400 hover:text-red-600 transition-colors">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
              </svg>
            </button>
          </div>
        </div>
        
        <!-- Question Preview -->
        <% if question.description.present? %>
          <p class="text-sm text-gray-600 mt-2 line-clamp-2">
            <%= question.description %>
          </p>
        <% end %>
        
        <!-- Question Options Preview (for multiple choice, etc.) -->
        <% if question.question_type.in?(['multiple_choice', 'single_choice']) && question.options.present? %>
          <div class="mt-3 space-y-1">
            <% question.options.first(3).each do |option| %>
              <div class="flex items-center space-x-2 text-sm text-gray-600">
                <div class="w-3 h-3 border border-gray-300 rounded <%= 'rounded-full' if question.question_type == 'single_choice' %>"></div>
                <span><%= option %></span>
              </div>
            <% end %>
            <% if question.options.count > 3 %>
              <div class="text-xs text-gray-500 ml-5">
                +<%= question.options.count - 3 %> more options
              </div>
            <% end %>
          </div>
        <% end %>
      </div>
    </div>
    
    <!-- Conditional Logic Indicator -->
    <% if question.conditional_logic.present? %>
      <div class="mt-3 pt-3 border-t border-gray-100">
        <div class="flex items-center space-x-2 text-xs text-amber-600">
          <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M3 3a1 1 0 000 2v8a2 2 0 002 2h2.586l-1.293 1.293a1 1 0 101.414 1.414L10 15.414l2.293 2.293a1 1 0 001.414-1.414L12.414 15H15a2 2 0 002-2V5a1 1 0 100-2H3zm11.707 4.707a1 1 0 00-1.414-1.414L10 9.586 8.707 8.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
          </svg>
          <span>Has conditional logic</span>
        </div>
      </div>
    <% end %>
  </div>
<% end %>

<style>
  .bg-ai-gradient {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  }
  
  .line-clamp-2 {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
</style>
</file>

<file path="views/forms/_status_indicator.html.erb">
<% case form.status %>
<% when 'published' %>
  <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
    <svg class="w-2 h-2 mr-1" fill="currentColor" viewBox="0 0 8 8">
      <circle cx="4" cy="4" r="3" />
    </svg>
    Published
  </span>
<% when 'draft' %>
  <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800">
    <svg class="w-2 h-2 mr-1" fill="currentColor" viewBox="0 0 8 8">
      <circle cx="4" cy="4" r="3" />
    </svg>
    Draft
  </span>
<% when 'archived' %>
  <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800">
    <svg class="w-2 h-2 mr-1" fill="currentColor" viewBox="0 0 8 8">
      <circle cx="4" cy="4" r="3" />
    </svg>
    Archived
  </span>
<% else %>
  <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800">
    <svg class="w-2 h-2 mr-1" fill="currentColor" viewBox="0 0 8 8">
      <circle cx="4" cy="4" r="3" />
    </svg>
    <%= form.status.humanize %>
  </span>
<% end %>
</file>

<file path="views/forms/ai_generation_error.html.erb">
<% content_for :title, "AI Form Generation" %>

<div class="min-h-screen bg-gray-50 py-8">
  <div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8">
    <!-- Header -->
    <div class="text-center mb-8">
      <h1 class="text-3xl font-bold text-gray-900 mb-2">AI Form Generation</h1>
      <p class="text-lg text-gray-600">Create intelligent forms with AI assistance</p>
    </div>

    <!-- Error Alert -->
    <div class="mb-8">
      <div class="bg-white rounded-lg shadow-sm border-l-4 <%= error_border_color(@error_info[:severity]) %> p-6">
        <div class="flex items-start">
          <div class="flex-shrink-0">
            <%= error_icon(@error_info[:severity]) %>
          </div>
          <div class="ml-3 flex-1">
            <h3 class="text-lg font-medium <%= error_text_color(@error_info[:severity]) %>">
              <%= @error_info[:title] %>
            </h3>
            <div class="mt-2 text-sm text-gray-700">
              <p><%= @error_info[:message] %></p>
            </div>
            
            <% if @error_info[:guidance].present? %>
              <div class="mt-3 text-sm text-gray-600">
                <p class="font-medium">What you can do:</p>
                <p><%= @error_info[:guidance] %></p>
              </div>
            <% end %>

            <!-- Action Buttons -->
            <% if @error_info[:actions].present? %>
              <div class="mt-4 flex flex-wrap gap-3">
                <% @error_info[:actions].each do |action| %>
                  <% if action[:primary] %>
                    <%= link_to action[:label], 
                        Ai::ErrorMessageService.get_action_url(action[:action], { current_url: request.url }),
                        class: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500",
                        data: { action: action[:action] } %>
                  <% else %>
                    <%= link_to action[:label], 
                        Ai::ErrorMessageService.get_action_url(action[:action], { current_url: request.url }),
                        class: "inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500",
                        data: { action: action[:action] } %>
                  <% end %>
                <% end %>
              </div>
            <% end %>

            <!-- Retry Information -->
            <% if @retry_plan.present? && @retry_plan[:can_retry] %>
              <div class="mt-4 p-3 bg-blue-50 rounded-md">
                <div class="flex items-center">
                  <svg class="w-5 h-5 text-blue-400 mr-2" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path>
                  </svg>
                  <div class="text-sm text-blue-800">
                    <p class="font-medium">Automatic Retry Available</p>
                    <p><%= @retry_plan[:user_guidance] %></p>
                    <% if @retry_plan[:estimated_success_rate] %>
                      <p class="mt-1">Estimated success rate: <%= @retry_plan[:estimated_success_rate] %>%</p>
                    <% end %>
                  </div>
                </div>
              </div>
            <% end %>
          </div>
        </div>
      </div>
    </div>

    <!-- Form with Preserved Input -->
    <div class="bg-white rounded-lg shadow-sm">
      <div class="px-6 py-4 border-b border-gray-200">
        <h2 class="text-lg font-medium text-gray-900">Try Again</h2>
        <p class="mt-1 text-sm text-gray-600">Your previous input has been preserved. Make any adjustments and try again.</p>
      </div>

      <%= form_with url: generate_from_ai_forms_path, method: :post, multipart: true, 
                    data: { controller: "ai-form-generator tabs form-preview" }, 
                    class: "space-y-6 p-6" do |form| %>
        
        <!-- Input Method Tabs -->
        <div data-controller="tabs" data-tabs-default-tab-value="<%= @document.present? ? 'document' : 'prompt' %>">
          <div class="border-b border-gray-200">
            <nav class="-mb-px flex space-x-8">
              <button type="button" 
                      data-action="click->tabs#switch" 
                      data-tabs-target="tab" 
                      data-tab-name="prompt"
                      class="py-2 px-1 border-b-2 font-medium text-sm whitespace-nowrap">
                Text Prompt
              </button>
              <button type="button" 
                      data-action="click->tabs#switch" 
                      data-tabs-target="tab" 
                      data-tab-name="document"
                      class="py-2 px-1 border-b-2 font-medium text-sm whitespace-nowrap">
                Upload Document
              </button>
            </nav>
          </div>

          <!-- Prompt Tab -->
          <div data-tabs-target="content" data-tab-name="prompt" class="mt-6">
            <div class="space-y-4">
              <div>
                <%= form.label :prompt, "Describe your form", class: "block text-sm font-medium text-gray-700" %>
                <p class="mt-1 text-sm text-gray-500">
                  Tell us about the form you want to create. Include the purpose, target audience, and what information you need to collect.
                </p>
                <%= form.text_area :prompt, 
                    value: @prompt,
                    placeholder: "Example: I need a customer feedback form for my restaurant. I want to collect ratings for food quality, service, atmosphere, and get suggestions for improvement. The form should be quick to complete and mobile-friendly.",
                    rows: 6,
                    class: "mt-2 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500",
                    data: { 
                      action: "input->form-preview#updatePreview",
                      "form-preview-target": "promptInput"
                    } %>
              </div>

              <!-- Word Count Display -->
              <div class="flex justify-between text-sm text-gray-500">
                <span>Word count: <span data-form-preview-target="wordCount">0</span></span>
                <span>10-5000 words recommended</span>
              </div>
            </div>
          </div>

          <!-- Document Tab -->
          <div data-tabs-target="content" data-tab-name="document" class="mt-6 hidden">
            <div class="space-y-4">
              <div>
                <%= form.label :document, "Upload Document", class: "block text-sm font-medium text-gray-700" %>
                <p class="mt-1 text-sm text-gray-500">
                  Upload a PDF, Markdown, or text file that describes your form requirements.
                </p>
                
                <div class="mt-2 flex justify-center px-6 pt-5 pb-6 border-2 border-gray-300 border-dashed rounded-md hover:border-gray-400 transition-colors"
                     data-controller="file-upload"
                     data-action="dragover->file-upload#dragOver dragenter->file-upload#dragEnter dragleave->file-upload#dragLeave drop->file-upload#drop">
                  <div class="space-y-1 text-center">
                    <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48">
                      <path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                    </svg>
                    <div class="flex text-sm text-gray-600">
                      <label for="document" class="relative cursor-pointer bg-white rounded-md font-medium text-indigo-600 hover:text-indigo-500 focus-within:outline-none focus-within:ring-2 focus-within:ring-offset-2 focus-within:ring-indigo-500">
                        <span>Upload a file</span>
                        <%= form.file_field :document, 
                            class: "sr-only",
                            accept: ".pdf,.md,.txt,text/plain,text/markdown,application/pdf",
                            data: { 
                              action: "change->file-upload#fileSelected",
                              "file-upload-target": "fileInput"
                            } %>
                      </label>
                      <p class="pl-1">or drag and drop</p>
                    </div>
                    <p class="text-xs text-gray-500">PDF, MD, TXT up to 10MB</p>
                  </div>
                </div>

                <!-- File Info Display -->
                <div data-file-upload-target="fileInfo" class="hidden mt-2 p-3 bg-gray-50 rounded-md">
                  <div class="flex items-center">
                    <svg class="w-5 h-5 text-gray-400 mr-2" fill="currentColor" viewBox="0 0 20 20">
                      <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4z" clip-rule="evenodd"></path>
                    </svg>
                    <div class="flex-1">
                      <p class="text-sm font-medium text-gray-900" data-file-upload-target="fileName"></p>
                      <p class="text-xs text-gray-500" data-file-upload-target="fileSize"></p>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Advanced Options -->
        <div class="border-t border-gray-200 pt-6">
          <h3 class="text-lg font-medium text-gray-900 mb-4">Options</h3>
          <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <%= form.label :max_questions, "Maximum Questions", class: "block text-sm font-medium text-gray-700" %>
              <%= form.select :max_questions, 
                  options_for_select([
                    ['5 questions', 5],
                    ['10 questions', 10],
                    ['15 questions', 15],
                    ['20 questions', 20]
                  ], @max_questions || 10),
                  {},
                  { class: "mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500" } %>
            </div>
            <div>
              <%= form.label :complexity, "Form Complexity", class: "block text-sm font-medium text-gray-700" %>
              <%= form.select :complexity, 
                  options_for_select([
                    ['Simple', 'simple'],
                    ['Moderate', 'moderate'],
                    ['Complex', 'complex']
                  ], @complexity || 'moderate'),
                  {},
                  { class: "mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500" } %>
            </div>
          </div>
        </div>

        <!-- Cost and Credits Info -->
        <div class="bg-gray-50 rounded-lg p-4">
          <div class="flex justify-between items-center">
            <div>
              <p class="text-sm font-medium text-gray-900">AI Credits Remaining</p>
              <p class="text-lg font-bold text-indigo-600"><%= @ai_credits_remaining %></p>
            </div>
            <div class="text-right">
              <p class="text-sm font-medium text-gray-900">Estimated Cost</p>
              <p class="text-lg font-bold text-gray-900"><%= @estimated_cost %> credits</p>
            </div>
          </div>
        </div>

        <!-- Submit Button -->
        <div class="flex justify-end">
          <%= form.submit "Generate Form", 
              class: "inline-flex items-center px-6 py-3 border border-transparent text-base font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed",
              data: { 
                "ai-form-generator-target": "submitButton",
                action: "click->ai-form-generator#handleSubmit"
              } %>
        </div>
      <% end %>
    </div>

    <!-- Help Section -->
    <div class="mt-8 bg-white rounded-lg shadow-sm p-6">
      <h3 class="text-lg font-medium text-gray-900 mb-4">Need Help?</h3>
      <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div>
          <h4 class="font-medium text-gray-900 mb-2">Common Issues</h4>
          <ul class="text-sm text-gray-600 space-y-1">
            <li> Make sure your content is between 10-5000 words</li>
            <li> Upload only PDF, Markdown, or text files</li>
            <li> Check that you have sufficient AI credits</li>
            <li> Try simplifying complex requirements</li>
          </ul>
        </div>
        <div>
          <h4 class="font-medium text-gray-900 mb-2">Get Support</h4>
          <div class="space-y-2">
            <%= link_to "View Examples", "/help/examples", class: "block text-sm text-indigo-600 hover:text-indigo-500" %>
            <%= link_to "Contact Support", "/support", class: "block text-sm text-indigo-600 hover:text-indigo-500" %>
            <%= link_to "Check System Status", "https://status.agentform.com", class: "block text-sm text-indigo-600 hover:text-indigo-500", target: "_blank" %>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  // Auto-retry functionality
  <% if @retry_plan.present? && @retry_plan[:automatic] && @retry_plan[:delay_seconds] > 0 %>
    setTimeout(function() {
      if (confirm('Would you like to automatically retry with optimized settings?')) {
        document.querySelector('[data-ai-form-generator-target="submitButton"]').click();
      }
    }, <%= @retry_plan[:delay_seconds] * 1000 %>);
  <% end %>
</script>
</file>

<file path="views/forms/ai_generation_result.html.erb">
<% content_for :title, "AI Form Generated Successfully" %>

<div class="container mx-auto px-4 py-8">
  <div class="max-w-4xl mx-auto">
    <!-- Success Header -->
    <div class="text-center mb-8">
      <div class="w-16 h-16 bg-green-100 rounded-full flex items-center justify-center mx-auto mb-4">
        <svg class="w-8 h-8 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
      </div>
      <h1 class="text-3xl font-bold text-gray-900 mb-2">Form Generated Successfully!</h1>
      <p class="text-lg text-gray-600">
        Your AI-powered form "<%= @form.name %>" has been created and is ready for customization.
      </p>
    </div>

    <!-- Generation Summary Card -->
    <div class="bg-gradient-to-r from-purple-50 to-indigo-50 rounded-2xl p-6 mb-8 border border-purple-100">
      <h2 class="text-xl font-semibold text-gray-900 mb-4 flex items-center">
        <svg class="w-6 h-6 text-purple-600 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2-2V7a2 2 0 012-2h2a2 2 0 002 2v2a2 2 0 002 2h2a2 2 0 002-2V7a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 00-2 2h-2a2 2 0 00-2 2v6a2 2 0 01-2 2H9z" />
        </svg>
        Generation Summary
      </h2>
      
      <div class="grid md:grid-cols-3 gap-6">
        <!-- Cost Information -->
        <div class="bg-white rounded-xl p-4 border border-purple-100">
          <div class="flex items-center justify-between mb-2">
            <span class="text-sm font-medium text-gray-600">AI Cost</span>
            <svg class="w-4 h-4 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1" />
            </svg>
          </div>
          <div class="text-2xl font-bold text-gray-900">
            $<%= number_with_precision(@form.metadata['ai_cost'] || 0.05, precision: 2) %>
          </div>
          <div class="text-xs text-gray-500">Deducted from your credits</div>
        </div>

        <!-- Questions Count -->
        <div class="bg-white rounded-xl p-4 border border-purple-100">
          <div class="flex items-center justify-between mb-2">
            <span class="text-sm font-medium text-gray-600">Questions</span>
            <svg class="w-4 h-4 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          </div>
          <div class="text-2xl font-bold text-gray-900">
            <%= @form.form_questions.count %>
          </div>
          <div class="text-xs text-gray-500">AI-generated questions</div>
        </div>

        <!-- Complexity Level -->
        <div class="bg-white rounded-xl p-4 border border-purple-100">
          <div class="flex items-center justify-between mb-2">
            <span class="text-sm font-medium text-gray-600">Complexity</span>
            <svg class="w-4 h-4 text-orange-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
            </svg>
          </div>
          <div class="text-lg font-bold text-gray-900 capitalize">
            <%= @form.metadata.dig('content_analysis', 'complexity_level') || 'Moderate' %>
          </div>
          <div class="text-xs text-gray-500">Based on content analysis</div>
        </div>
      </div>
    </div>

    <!-- Form Preview and Actions -->
    <div class="grid lg:grid-cols-2 gap-8">
      <!-- Form Preview -->
      <div class="bg-white rounded-2xl shadow-lg border border-gray-200 overflow-hidden">
        <div class="bg-gray-50 px-6 py-4 border-b border-gray-200">
          <h3 class="text-lg font-semibold text-gray-900 flex items-center">
            <svg class="w-5 h-5 text-gray-600 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
            </svg>
            Form Preview
          </h3>
        </div>
        
        <div class="p-6 max-h-96 overflow-y-auto">
          <!-- Form Header -->
          <div class="mb-6">
            <h2 class="text-xl font-bold text-gray-900 mb-2"><%= @form.name %></h2>
            <% if @form.description.present? %>
              <p class="text-gray-600"><%= @form.description %></p>
            <% end %>
          </div>

          <!-- Questions Preview -->
          <div class="space-y-4">
            <% @form.form_questions.order(:position).limit(5).each_with_index do |question, index| %>
              <div class="border border-gray-200 rounded-lg p-4">
                <div class="flex items-start justify-between mb-2">
                  <h4 class="font-medium text-gray-900 flex items-center">
                    <span class="w-6 h-6 bg-indigo-100 text-indigo-600 rounded-full flex items-center justify-center text-sm font-semibold mr-2">
                      <%= index + 1 %>
                    </span>
                    <%= question.title %>
                    <% if question.required? %>
                      <span class="text-red-500 ml-1">*</span>
                    <% end %>
                  </h4>
                  <% if question.ai_enhanced? %>
                    <div class="flex items-center space-x-1">
                      <div class="w-2 h-2 bg-purple-500 rounded-full"></div>
                      <span class="text-xs text-purple-600 font-medium">AI</span>
                    </div>
                  <% end %>
                </div>
                
                <% if question.description.present? %>
                  <p class="text-sm text-gray-600 mb-2"><%= question.description %></p>
                <% end %>
                
                <div class="text-xs text-gray-500 bg-gray-50 px-2 py-1 rounded">
                  <%= question.question_type.humanize %>
                </div>
              </div>
            <% end %>
            
            <% if @form.form_questions.count > 5 %>
              <div class="text-center py-4 text-gray-500">
                <span class="text-sm">... and <%= @form.form_questions.count - 5 %> more questions</span>
              </div>
            <% end %>
          </div>
        </div>
      </div>

      <!-- Actions and Recommendations -->
      <div class="space-y-6">
        <!-- Primary Actions -->
        <div class="bg-white rounded-2xl shadow-lg border border-gray-200 p-6">
          <h3 class="text-lg font-semibold text-gray-900 mb-4">What's Next?</h3>
          
          <div class="space-y-3">
            <%= link_to edit_form_path(@form), 
                class: "w-full flex items-center justify-center px-6 py-3 bg-gradient-to-r from-purple-600 to-indigo-600 text-white font-semibold rounded-xl hover:from-purple-700 hover:to-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition-all duration-200 shadow-lg hover:shadow-xl transform hover:-translate-y-0.5" do %>
              <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
              </svg>
              Customize Your Form
            <% end %>
            
            <%= link_to preview_form_path(@form), 
                target: "_blank",
                class: "w-full flex items-center justify-center px-6 py-3 bg-white border-2 border-gray-300 text-gray-700 font-semibold rounded-xl hover:bg-gray-50 hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-all duration-200" do %>
              <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
              </svg>
              Preview Form
            <% end %>
            
            <%= link_to form_path(@form), 
                class: "w-full flex items-center justify-center px-6 py-3 bg-white border border-gray-300 text-gray-600 font-medium rounded-xl hover:bg-gray-50 hover:text-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-all duration-200" do %>
              <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2-2V7a2 2 0 012-2h2a2 2 0 002 2v2a2 2 0 002 2h2a2 2 0 002-2V7a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 00-2 2h-2a2 2 0 00-2 2v6a2 2 0 01-2 2H9z" />
              </svg>
              View Form Details
            <% end %>
          </div>
        </div>

        <!-- AI Recommendations -->
        <% if @form.metadata.dig('content_analysis', 'recommendations').present? %>
          <div class="bg-gradient-to-r from-blue-50 to-indigo-50 rounded-2xl p-6 border border-blue-100">
            <h3 class="text-lg font-semibold text-gray-900 mb-3 flex items-center">
              <svg class="w-5 h-5 text-blue-600 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
              </svg>
              AI Recommendations
            </h3>
            <div class="space-y-2">
              <% @form.metadata.dig('content_analysis', 'recommendations').each do |recommendation| %>
                <div class="flex items-start space-x-2">
                  <svg class="w-4 h-4 text-blue-600 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                  </svg>
                  <span class="text-sm text-gray-700"><%= recommendation %></span>
                </div>
              <% end %>
            </div>
          </div>
        <% end %>

        <!-- AI Features Enabled -->
        <% if @form.ai_enabled? && @form.ai_configuration['features'].present? %>
          <div class="bg-white rounded-2xl shadow-lg border border-gray-200 p-6">
            <h3 class="text-lg font-semibold text-gray-900 mb-3 flex items-center">
              <svg class="w-5 h-5 text-purple-600 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
              </svg>
              AI Features Enabled
            </h3>
            <div class="grid grid-cols-2 gap-2">
              <% @form.ai_configuration['features'].each do |feature| %>
                <div class="flex items-center space-x-2 text-sm">
                  <div class="w-2 h-2 bg-green-500 rounded-full"></div>
                  <span class="text-gray-700"><%= feature.humanize %></span>
                </div>
              <% end %>
            </div>
          </div>
        <% end %>

        <!-- Share Options -->
        <div class="bg-white rounded-2xl shadow-lg border border-gray-200 p-6">
          <h3 class="text-lg font-semibold text-gray-900 mb-3">Share Your Success</h3>
          <p class="text-sm text-gray-600 mb-4">
            Let others know about your AI-generated form!
          </p>
          <div class="flex space-x-2">
            <button class="flex-1 px-4 py-2 bg-blue-600 text-white text-sm font-medium rounded-lg hover:bg-blue-700 transition-colors"
                    onclick="shareOnTwitter()">
              <svg class="w-4 h-4 inline mr-1" fill="currentColor" viewBox="0 0 24 24">
                <path d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z"/>
              </svg>
              Twitter
            </button>
            <button class="flex-1 px-4 py-2 bg-blue-800 text-white text-sm font-medium rounded-lg hover:bg-blue-900 transition-colors"
                    onclick="shareOnLinkedIn()">
              <svg class="w-4 h-4 inline mr-1" fill="currentColor" viewBox="0 0 24 24">
                <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
              </svg>
              LinkedIn
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Navigation -->
    <div class="mt-12 flex justify-between items-center">
      <%= link_to forms_path, class: "inline-flex items-center text-gray-600 hover:text-indigo-600 font-medium transition-colors" do %>
        <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
        </svg>
        Back to Forms
      <% end %>
      
      <%= link_to new_from_ai_forms_path, class: "inline-flex items-center text-indigo-600 hover:text-indigo-700 font-medium transition-colors" do %>
        Create Another AI Form
        <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
        </svg>
      <% end %>
    </div>
  </div>
</div>

<script>
  function shareOnTwitter() {
    const text = `Just created an amazing form with AI using @AgentForm!  Generated <%= @form.form_questions.count %> questions in seconds. The future of form building is here! #AI #FormBuilder #NoCode`;
    const url = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}`;
    window.open(url, '_blank', 'width=600,height=400');
  }

  function shareOnLinkedIn() {
    const text = `Just experienced the future of form building with AgentForm's AI! Generated a complete <%= @form.form_questions.count %>-question form in seconds. This is what intelligent automation looks like. #AI #FormBuilder #Productivity`;
    const url = `https://www.linkedin.com/sharing/share-offsite/?url=${encodeURIComponent(window.location.origin)}&summary=${encodeURIComponent(text)}`;
    window.open(url, '_blank', 'width=600,height=400');
  }
</script>
</file>

<file path="views/forms/analytics.html.erb">
<%# app/views/forms/analytics.html.erb %>
<main class="p-6 lg:p-8">
    <div class="max-w-7xl mx-auto space-y-8">
        <!-- Key Metrics -->
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
            <div class="bg-white p-5 rounded-lg shadow-sm border-l-4 border-indigo-500">
                <h3 class="text-sm font-medium text-gray-500">Completion Rate</h3>
                <p class="mt-2 text-3xl font-bold text-gray-900"><%= number_to_percentage(@analytics_data[:completion_rate], precision: 1) %></p>
            </div>
            <%# ... otras mtricas ... %>
        </div>

        <!-- Grficos -->
        <div class="grid grid-cols-1 lg:grid-cols-5 gap-6">
            <div class="lg:col-span-3 bg-white p-6 rounded-lg shadow-sm">
                <h3 class="text-lg font-semibold text-gray-800 mb-4">Response Trends</h3>
                <%# @response_trends debe ser un hash de Fecha -> Conteo %>
                <%= line_chart @response_trends, height: "300px", library: { scales: { y: { beginAtZero: true } } } %>
            </div>
            <div class="lg:col-span-2 bg-white p-6 rounded-lg shadow-sm">
                <h3 class="text-lg font-semibold text-gray-800 mb-4">Drop-off Analysis</h3>
                <%# @dropoff_data debe ser un hash de Pregunta -> Conteo %>
                <%= bar_chart @dropoff_data, height: "300px", library: { indexAxis: 'y' } %>
            </div>
        </div>

        <!-- Insights de IA -->
        <div class="bg-purple-50 p-6 rounded-lg border border-purple-200">
            <h3 class="text-lg font-semibold text-gray-800 mb-4 flex items-center">
                <%= heroicon "sparkles", variant: :solid, options: { class: "w-6 h-6 mr-3 text-purple-600" } %>
                Actionable AI Insights
            </h3>
            <%# ... renderizar insights de IA si existen ... %>
        </div>
    </div>
</main>
</file>

<file path="views/forms/edit.html.erb">
<%# app/views/forms/edit.html.erb %>
<% content_for :layout_name, "form_builder" %>

<div class="h-screen flex flex-col bg-gray-50" 
     data-controller="form-builder payment-setup-status" 
     data-form-builder-form-id-value="<%= @form.id %>" 
     data-form-builder-csrf-token-value="<%= form_authenticity_token %>"
     data-payment-setup-status-form-id-value="<%= @form.id %>"
     data-payment-setup-status-has-payment-questions-value="<%= @form.has_payment_questions? %>"
     data-payment-setup-status-stripe-configured-value="<%= @form.user.stripe_configured? %>"
     data-payment-setup-status-is-premium-value="<%= @form.user.premium? %>"
     data-payment-setup-status-setup-complete-value="<%= @form.payment_setup_complete? %>"
     data-payment-setup-status-completion-percentage-value="<%= @form.user.payment_setup_status[:setup_completion_percentage] %>">

  <!-- Form Header -->
  <%= render 'forms/form_header', form: @form %>

  <div class="flex-1 flex overflow-hidden">
    
    <!-- Main Questions Panel -->
    <main class="flex-1 p-6 overflow-y-auto">
      <div class="max-w-4xl">
        
        <!-- Save Status Indicator -->
        <div class="mb-4 flex items-center space-x-2">
          <div class="w-2 h-2 rounded-full bg-green-400" data-form-builder-target="saveIndicator"></div>
          <span class="text-sm text-gray-600" data-form-builder-target="saveStatus">Saved</span>
        </div>

        <!-- Payment Setup Notification Bar -->
        <%= render 'forms/payment_notification_bar', form: @form %>

        <!-- Workflow Summary Card -->
        <div class="mb-6 bg-white/80 backdrop-blur-md rounded-xl p-6 border">
          <h2 class="text-xl font-bold text-gray-900">AI Workflow Designer</h2>
          <p class="text-gray-600">Powered by SuperAgent orchestration engine</p>
          
          <div class="mt-4 grid grid-cols-3 gap-4">
            <div class="text-center">
              <div class="text-2xl font-bold text-purple-600"><%= @form.questions_count %></div>
              <div class="text-sm text-gray-600">Workflow Steps</div>
            </div>
            <div class="text-center">
              <div class="text-2xl font-bold text-green-600"><%= @form.form_responses.count %></div>
              <div class="text-sm text-gray-600">Executions</div>
            </div>
            <div class="text-center">
              <div class="text-2xl font-bold text-blue-600">
                <%= @form.ai_enabled? ? 'ON' : 'OFF' %>
              </div>
              <div class="text-sm text-gray-600">AI Processing</div>
            </div>
          </div>
        </div>

        <!-- Questions Container - FIXED TARGET NAME -->
        <div class="space-y-3" 
             id="questions-container" 
             data-form-builder-target="questionsList">
          <% @form.form_questions.each_with_index do |question, index| %>
            <div class="bg-white rounded-xl border border-gray-200 p-6 hover:shadow-md transition-shadow" 
                 data-question-id="<%= question.id %>"
                 data-form-builder-target="questionCard">
              
              <!-- Drag Handle -->
              <div class="flex items-start justify-between mb-4">
                <div class="flex items-start space-x-3">
                  <div class="drag-handle cursor-grab text-gray-400 hover:text-gray-600 mt-1">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8h16M4 16h16"/>
                    </svg>
                  </div>
                  
                  <div class="flex-1">
                    <div class="flex items-center space-x-2 mb-1">
                      <span class="inline-flex items-center px-2 py-1 text-xs font-medium bg-purple-100 text-purple-800 rounded-full">
                        Step <%= index + 1 %>
                      </span>
                      <% if question.ai_enhanced? %>
                        <span class="ai-indicator inline-flex items-center px-2 py-1 text-xs font-medium bg-green-100 text-green-800 rounded-full">
                          AI Enhanced
                        </span>
                      <% end %>
                      <% if question.required? %>
                        <span class="inline-flex items-center px-2 py-1 text-xs font-medium bg-red-100 text-red-800 rounded-full">
                          Required
                        </span>
                      <% end %>
                    </div>
                    <h3 class="question-title font-semibold text-gray-900 mb-1"><%= question.title %></h3>
                    <% if question.description.present? %>
                      <p class="text-sm text-gray-600 mb-2"><%= question.description %></p>
                    <% end %>
                    <div class="text-xs text-gray-500">
                      Type: <span class="font-medium"><%= question.question_type.humanize %></span>
                    </div>
                  </div>
                </div>
                
                <!-- Action Buttons -->
                <div class="flex items-center space-x-1">
                  <button type="button" 
                          class="p-2 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg transition-colors"
                          data-action="click->form-builder#editQuestion"
                          title="Edit question">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/>
                    </svg>
                  </button>
                  
                  <button type="button" 
                          class="p-2 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg transition-colors"
                          data-action="click->form-builder#duplicateQuestion"
                          title="Duplicate question">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"/>
                    </svg>
                  </button>
                  
                  <button type="button" 
                          class="p-2 text-gray-400 hover:text-green-600 hover:bg-green-50 rounded-lg transition-colors"
                          data-action="click->form-builder#enhanceWithAI"
                          title="Enhance with AI">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
                    </svg>
                  </button>
                  
                  <button type="button" 
                          class="p-2 text-red-400 hover:text-red-600 hover:bg-red-50 rounded-lg transition-colors"
                          data-action="click->form-builder#deleteQuestion"
                          title="Delete question">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                    </svg>
                  </button>
                </div>
              </div>
              
              <!-- Quick Required Toggle -->
              <div class="flex items-center justify-between pt-4 border-t border-gray-200">
                <span class="text-sm text-gray-700">Required field</span>
                <label class="relative inline-flex items-center cursor-pointer">
                  <input type="checkbox" 
                         class="sr-only peer" 
                         <%= 'checked' if question.required? %>
                         data-action="change->form-builder#toggleRequired">
                  <div class="w-9 h-5 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-purple-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-purple-600"></div>
                </label>
              </div>
            </div>
          <% end %>
        </div>

        <!-- Add Question Button -->
        <div class="mt-6 space-y-2">
          <!-- Main Add Button -->
<button data-action="click->form-builder#addQuestion" 
        class="mt-4 w-full p-4 border-2 border-dashed border-gray-300 rounded-xl text-gray-600 hover:border-purple-400 hover:text-purple-600 transition-colors group">
  <div class="flex items-center justify-center space-x-2">
    <svg class="w-5 h-5 group-hover:scale-110 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"/>
    </svg>
    <span class="font-medium">Add Step to Workflow</span>
  </div>
</button>
          
          <!-- Quick Add Buttons -->
          <div class="grid grid-cols-2 md:grid-cols-4 gap-2">
            <button data-action="click->form-builder#addQuestion" 
                    data-question-type="text_short"
                    class="p-2 text-xs bg-white border border-gray-200 rounded-lg hover:border-purple-300 hover:text-purple-600 transition-colors">
              Short Text
            </button>
            <button data-action="click->form-builder#addQuestion" 
                    data-question-type="text_long"
                    class="p-2 text-xs bg-white border border-gray-200 rounded-lg hover:border-purple-300 hover:text-purple-600 transition-colors">
              Long Text
            </button>
            <button data-action="click->form-builder#addQuestion" 
                    data-question-type="multiple_choice"
                    class="p-2 text-xs bg-white border border-gray-200 rounded-lg hover:border-purple-300 hover:text-purple-600 transition-colors">
              Multiple Choice
            </button>
            <button data-action="click->form-builder#addQuestion" 
                    data-question-type="email"
                    class="p-2 text-xs bg-white border border-gray-200 rounded-lg hover:border-purple-300 hover:text-purple-600 transition-colors">
              Email
            </button>
          </div>
        </div>
      </div>
    </main>

    <!-- Configuration Sidebar -->
    <aside class="w-80 bg-white border-l border-gray-200 overflow-y-auto">
      <%= render 'forms/configuration_panel', form: @form %>
    </aside>

  </div>
</div>

<!-- Modals (if needed by the controller) -->
<div id="add-question-modal" 
     class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
     data-form-builder-target="addQuestionModal">
  <!-- Modal content will be loaded here -->
</div>

<div id="edit-question-modal" 
     class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
     data-form-builder-target="editQuestionModal">
  <!-- Modal content will be loaded here -->
</div>

<!-- Payment Setup Modal -->
<%= render 'forms/payment_setup_modal', form: @form %>
</file>

<file path="views/forms/index.html.erb">
<%# app/views/forms/index.html.erb %>
<div class="bg-gray-100 min-h-screen">
  <% if @forms.any? %>
    <div class="max-w-7xl mx-auto p-4">
      <div class="flex justify-between items-center mb-6">
        <h2 class="text-2xl font-bold text-gray-900">Your Agents</h2>
        <div class="flex space-x-4">
          <%= link_to "Templates", templates_path, class: "px-4 py-2 bg-purple-600 text-white rounded-md text-sm font-semibold hover:bg-purple-700" %>
          <%= link_to new_from_ai_forms_path, class: "px-4 py-2 bg-emerald-500 text-white rounded-md text-sm font-bold hover:bg-emerald-600 transition-colors duration-200 shadow-md hover:shadow-lg border-2 border-emerald-500 hover:border-emerald-600" do %>
            <svg class="w-4 h-4 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
            </svg>
             Create with AI
          <% end %>
          <%= link_to "Create New Agent Form", new_form_path, class: "px-4 py-2 bg-indigo-600 text-white rounded-md text-sm font-semibold hover:bg-indigo-700" %>
        </div>
      </div>
            
      <% if current_user.superadmin? %>
        <div class="mb-4 flex justify-end">
          <div class="bg-white p-4 rounded-lg shadow-sm border border-gray-200">
            <label class="block text-sm font-medium text-gray-700 mb-2">Filter by User</label>
            <%= form_tag forms_path, method: :get, class: "flex items-center space-x-2" do %>
              <%= select_tag :user_id,
                     options_from_collection_for_select(User.order(:email), :id, :email, params[:user_id]),
                    include_blank: "All Users",
                    class: "px-3 py-2 border border-gray-300 rounded-md text-sm" %>
              <%= submit_tag "Filter", class: "px-4 py-2 bg-indigo-600 text-white text-sm rounded-md hover:bg-indigo-700" %>
            <% end %>
          </div>
        </div>
      <% end %>

      <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <%= render @forms %>
      </div>
    </div>
  <% else %>
    <div class="text-center py-12">
      <h3 class="text-lg font-medium text-gray-900">You haven't created any agents yet.</h3>
      <p class="mt-2 text-sm text-gray-500">Start by creating your first intelligent agent to collect data.</p>
      <div class="mt-6 flex justify-center space-x-4">
        <%= link_to new_from_ai_forms_path, class: "px-4 py-2 bg-purple-600 text-white rounded-md text-sm font-bold hover:bg-purple-700 transition-colors duration-200 shadow-md hover:shadow-lg" do %>
           Create with AI
        <% end %>
        <%= link_to "Create Manually", new_form_path, class: "px-6 py-3 bg-indigo-600 text-white rounded-lg text-sm font-semibold hover:bg-indigo-700" %>
      </div>
    </div>
  <% end %>
</div>
</file>

<file path="views/forms/new_from_ai.html.erb">
<% content_for :title, "Create Form with AI" %>

<div class="container mx-auto px-4 py-8">
  <div class="max-w-4xl mx-auto">
    <!-- Header Section -->
    <div class="text-center mb-8">
      <div class="flex items-center justify-center mb-4">
        <div class="w-12 h-12 bg-gradient-to-br from-purple-500 to-indigo-600 rounded-xl flex items-center justify-center mr-3">
          <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
          </svg>
        </div>
        <h1 class="text-3xl font-bold text-gray-900">Create Form with AI</h1>
      </div>
      <p class="text-lg text-gray-600 max-w-2xl mx-auto">
        Transform your ideas into professional forms instantly. Describe what you need or upload a document, and our AI will create a complete form for you.
      </p>
    </div>

    <!-- AI Credits Display -->
    <% if user_signed_in? %>
      <div class="bg-gradient-to-r from-purple-50 to-indigo-50 rounded-xl p-4 mb-8 border border-purple-100">
        <div class="flex items-center justify-between">
          <div class="flex items-center space-x-3">
            <div class="w-10 h-10 bg-purple-100 rounded-lg flex items-center justify-center">
              <svg class="w-5 h-5 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
              </svg>
            </div>
            <div>
              <h3 class="text-sm font-semibold text-gray-900">AI Credits</h3>
              <p class="text-xs text-gray-600">Monthly usage tracking</p>
            </div>
          </div>
          <div class="text-right">
            <div class="text-2xl font-bold text-gray-900">
              <%= number_with_precision(current_user.ai_credits_remaining, precision: 2) %>
            </div>
            <div class="text-xs text-gray-500">
              of <%= number_with_precision(current_user.monthly_ai_limit, precision: 0) %> remaining
            </div>
            <!-- Progress bar -->
            <div class="w-24 bg-gray-200 rounded-full h-2 mt-1">
              <% usage_percentage = ((current_user.ai_credits_used_this_month / current_user.monthly_ai_limit) * 100).round(1) %>
              <div class="bg-gradient-to-r from-purple-500 to-indigo-600 h-2 rounded-full transition-all duration-300" 
                   style="width: <%= [usage_percentage, 100].min %>%"></div>
            </div>
          </div>
        </div>
      </div>
    <% end %>

    <!-- Main Form Interface -->
    <div class="bg-white rounded-2xl shadow-lg border border-gray-200 overflow-hidden"
         data-controller="tabs ai-form-generator form-preview"
         data-tabs-default-tab-value="prompt">
      
      <!-- Tab Navigation -->
      <div class="border-b border-gray-200 bg-gray-50">
        <nav class="flex space-x-8 px-6" aria-label="Tabs">
          <button data-tabs-target="tab" 
                  data-tab="prompt"
                  data-action="click->tabs#switch"
                  class="whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
                  role="tab"
                  aria-selected="true">
            <div class="flex items-center space-x-2">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
              </svg>
              <span>Describe Your Form</span>
            </div>
          </button>
          <button data-tabs-target="tab" 
                  data-tab="document"
                  data-action="click->tabs#switch"
                  class="whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
                  role="tab"
                  aria-selected="false">
            <div class="flex items-center space-x-2">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
              </svg>
              <span>Upload Document</span>
            </div>
          </button>
        </nav>
      </div>

      <!-- Tab Panels -->
      <div class="p-6">
        <!-- Prompt Input Panel -->
        <div data-tabs-target="panel" data-panel="prompt" class="space-y-6">
          <%= form_with url: generate_from_ai_forms_path, method: :post, 
                        multipart: true, 
                        class: "space-y-6",
                        data: { 
                          controller: "form-preview",
                          action: "submit->ai-form-generator#handleSubmit"
                        } do |form| %>
            
            <!-- Prompt Input -->
            <div>
              <label for="prompt" class="block text-sm font-semibold text-gray-900 mb-2">
                What kind of form do you want to create?
              </label>
              <div class="relative">
                <%= form.text_area :prompt, 
                    placeholder: "Describe your form in detail. For example: 'I need a customer feedback form for my restaurant with questions about food quality, service, and overall experience. Include rating scales and a comment section.'",
                    rows: 6,
                    class: "w-full px-4 py-3 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent resize-none text-gray-900 placeholder-gray-500",
                    data: { 
                      action: "input->form-preview#updatePreview",
                      "form-preview-target": "promptInput"
                    } %>
                
                <!-- Word Count Display -->
                <div class="absolute bottom-3 right-3 text-xs text-gray-400">
                  <span data-form-preview-target="wordCount">0</span> words
                </div>
              </div>
              <p class="mt-2 text-sm text-gray-500">
                Be specific about your requirements. Include the purpose, target audience, and types of questions you need.
              </p>
            </div>

            <!-- Cost Estimation -->
            <div class="bg-gray-50 rounded-lg p-4">
              <div class="flex items-center justify-between">
                <div class="flex items-center space-x-2">
                  <svg class="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1" />
                  </svg>
                  <span class="text-sm font-medium text-gray-700">Estimated Cost</span>
                </div>
                <div class="text-right">
                  <div class="text-lg font-semibold text-gray-900" data-form-preview-target="costEstimate">
                    $0.05
                  </div>
                  <div class="text-xs text-gray-500">Base cost + per question</div>
                </div>
              </div>
            </div>

            <!-- Submit Button -->
            <div class="flex justify-end">
              <%= form.submit "Generate Form with AI", 
                  class: "px-8 py-3 bg-gradient-to-r from-purple-600 to-indigo-600 text-white font-semibold rounded-xl hover:from-purple-700 hover:to-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition-all duration-200 shadow-lg hover:shadow-xl transform hover:-translate-y-0.5",
                  data: { "ai-form-generator-target": "submitButton" } %>
            </div>
          <% end %>
        </div>

        <!-- Document Upload Panel -->
        <div data-tabs-target="panel" data-panel="document" class="hidden space-y-6">
          <%= form_with url: generate_from_ai_forms_path, method: :post, 
                        multipart: true, 
                        class: "space-y-6",
                        data: { 
                          action: "submit->ai-form-generator#handleSubmit"
                        } do |form| %>
            
            <!-- File Upload Area -->
            <div data-controller="file-upload">
              <label class="block text-sm font-semibold text-gray-900 mb-2">
                Upload Your Document
              </label>
              
              <!-- Drag and Drop Zone -->
              <div class="relative border-2 border-dashed border-gray-300 rounded-xl p-8 text-center hover:border-indigo-400 transition-colors"
                   data-file-upload-target="dropZone"
                   data-action="dragover->file-upload#dragOver dragenter->file-upload#dragEnter dragleave->file-upload#dragLeave drop->file-upload#drop">
                
                <input type="file" 
                       name="document" 
                       accept=".pdf,.md,.txt,text/plain,text/markdown,application/pdf"
                       class="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                       data-file-upload-target="fileInput"
                       data-action="change->file-upload#fileSelected">
                
                <div data-file-upload-target="uploadPrompt">
                  <svg class="mx-auto h-12 w-12 text-gray-400 mb-4" stroke="currentColor" fill="none" viewBox="0 0 48 48">
                    <path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                  </svg>
                  <div class="text-lg font-medium text-gray-900 mb-2">
                    Drop your document here, or click to browse
                  </div>
                  <p class="text-sm text-gray-500 mb-4">
                    Supports PDF, Markdown (.md), and Text (.txt) files up to 10MB
                  </p>
                </div>
                
                <!-- File Info Display (Hidden by default) -->
                <div data-file-upload-target="fileInfo" class="hidden">
                  <div class="flex items-center justify-center space-x-3">
                    <svg class="w-8 h-8 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    <div class="text-left">
                      <div class="font-medium text-gray-900" data-file-upload-target="fileName"></div>
                      <div class="text-sm text-gray-500" data-file-upload-target="fileSize"></div>
                    </div>
                  </div>
                  <button type="button" 
                          class="mt-3 text-sm text-indigo-600 hover:text-indigo-700 font-medium"
                          data-action="click->file-upload#clearFile">
                    Choose different file
                  </button>
                </div>
              </div>
              
              <!-- Supported Formats -->
              <div class="mt-4 flex flex-wrap gap-2">
                <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800">
                  <svg class="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4z" clip-rule="evenodd" />
                  </svg>
                  PDF
                </span>
                <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                  <svg class="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4z" clip-rule="evenodd" />
                  </svg>
                  Markdown
                </span>
                <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800">
                  <svg class="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4z" clip-rule="evenodd" />
                  </svg>
                  Text
                </span>
              </div>
            </div>

            <!-- Submit Button -->
            <div class="flex justify-end">
              <%= form.submit "Generate Form from Document", 
                  class: "px-8 py-3 bg-gradient-to-r from-purple-600 to-indigo-600 text-white font-semibold rounded-xl hover:from-purple-700 hover:to-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition-all duration-200 shadow-lg hover:shadow-xl transform hover:-translate-y-0.5",
                  data: { "ai-form-generator-target": "submitButton" } %>
            </div>
          <% end %>
        </div>
      </div>
    </div>

    <!-- Example Prompts Section -->
    <div class="mt-12">
      <h2 class="text-xl font-semibold text-gray-900 mb-6 text-center">Need inspiration? Try these examples</h2>
      <div class="grid md:grid-cols-2 lg:grid-cols-3 gap-6">
        <!-- Customer Feedback Example -->
        <div class="bg-white rounded-xl border border-gray-200 p-6 hover:shadow-lg transition-shadow cursor-pointer"
             data-action="click->form-preview#useExample"
             data-example-prompt="I need a customer feedback form for my restaurant. Include questions about food quality (rating 1-5), service speed (rating 1-5), staff friendliness (rating 1-5), cleanliness (rating 1-5), overall experience (rating 1-5), likelihood to recommend (NPS scale), and a comment section for additional feedback. Also collect customer contact info for follow-up.">
          <div class="flex items-start space-x-3">
            <div class="w-10 h-10 bg-orange-100 rounded-lg flex items-center justify-center flex-shrink-0">
              <svg class="w-5 h-5 text-orange-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 8h10m0 0V6a2 2 0 00-2-2H9a2 2 0 00-2 2v2m10 0v10a2 2 0 01-2 2H9a2 2 0 01-2-2V8m10 0H7" />
              </svg>
            </div>
            <div>
              <h3 class="font-semibold text-gray-900 mb-2">Restaurant Feedback</h3>
              <p class="text-sm text-gray-600">Customer satisfaction survey with ratings and NPS scoring</p>
            </div>
          </div>
        </div>

        <!-- Lead Generation Example -->
        <div class="bg-white rounded-xl border border-gray-200 p-6 hover:shadow-lg transition-shadow cursor-pointer"
             data-action="click->form-preview#useExample"
             data-example-prompt="Create a lead qualification form for my B2B software company. I need to capture company name, industry, company size (dropdown: 1-10, 11-50, 51-200, 201-1000, 1000+), annual revenue range, current challenges with project management, budget range for software solutions, decision timeline, and contact information. Include qualifying questions to identify high-value prospects.">
          <div class="flex items-start space-x-3">
            <div class="w-10 h-10 bg-blue-100 rounded-lg flex items-center justify-center flex-shrink-0">
              <svg class="w-5 h-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 13.255A23.931 23.931 0 0112 15c-3.183 0-6.22-.62-9-1.745M16 6V4a2 2 0 00-2-2h-4a2 2 0 00-2-2v2m8 0V6a2 2 0 012 2v6a2 2 0 01-2 2H6a2 2 0 01-2-2V8a2 2 0 012-2V6" />
              </svg>
            </div>
            <div>
              <h3 class="font-semibold text-gray-900 mb-2">B2B Lead Qualification</h3>
              <p class="text-sm text-gray-600">Capture and qualify potential business customers</p>
            </div>
          </div>
        </div>

        <!-- Event Registration Example -->
        <div class="bg-white rounded-xl border border-gray-200 p-6 hover:shadow-lg transition-shadow cursor-pointer"
             data-action="click->form-preview#useExample"
             data-example-prompt="I'm organizing a tech conference and need a registration form. Collect attendee name, email, phone, company, job title, years of experience, areas of interest (checkboxes: AI/ML, Web Development, Mobile Apps, DevOps, Data Science), dietary restrictions, t-shirt size, networking preferences, and payment information. Include early bird pricing options.">
          <div class="flex items-start space-x-3">
            <div class="w-10 h-10 bg-green-100 rounded-lg flex items-center justify-center flex-shrink-0">
              <svg class="w-5 h-5 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3a2 2 0 012-2h4a2 2 0 012 2v4m-6 0V6a2 2 0 012-2h4a2 2 0 012 2v1m-6 0h8m-9 0v10a2 2 0 002 2h8a2 2 0 002-2V7H7z" />
              </svg>
            </div>
            <div>
              <h3 class="font-semibold text-gray-900 mb-2">Event Registration</h3>
              <p class="text-sm text-gray-600">Conference signup with preferences and payment</p>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Back to Forms Link -->
    <div class="mt-12 text-center">
      <%= link_to forms_path, class: "inline-flex items-center text-gray-600 hover:text-indigo-600 font-medium transition-colors" do %>
        <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
        </svg>
        Back to Forms
      <% end %>
    </div>
  </div>
</div>

<!-- Loading Overlay for AI Processing -->
<div id="ai-processing-overlay" class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center">
  <div class="bg-white rounded-2xl p-8 max-w-md mx-4 text-center">
    <div class="w-16 h-16 bg-gradient-to-br from-purple-500 to-indigo-600 rounded-full flex items-center justify-center mx-auto mb-4">
      <svg class="w-8 h-8 text-white animate-pulse" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
      </svg>
    </div>
    <h3 class="text-lg font-semibold text-gray-900 mb-2">AI is creating your form...</h3>
    <p class="text-gray-600 mb-4">This may take a few moments while we analyze your content and generate the perfect form structure.</p>
    <div class="flex items-center justify-center space-x-1">
      <div class="w-2 h-2 bg-indigo-600 rounded-full animate-bounce"></div>
      <div class="w-2 h-2 bg-indigo-600 rounded-full animate-bounce" style="animation-delay: 0.1s"></div>
      <div class="w-2 h-2 bg-indigo-600 rounded-full animate-bounce" style="animation-delay: 0.2s"></div>
    </div>
  </div>
</div>
</file>

<file path="views/forms/new.html.erb">
<div class="container mx-auto px-4 py-8">
  <div class="max-w-2xl mx-auto">
    <h1 class="text-3xl font-bold text-gray-900 mb-6">Create New Form</h1>

    <%= form_with model: @form, local: true, class: "space-y-6" do |form| %>
      <% if @form.errors.any? %>
        <div class="bg-red-50 border border-red-200 rounded-md p-4">
          <h3 class="text-sm font-medium text-red-800">Please fix the following errors:</h3>
          <ul class="mt-2 text-sm text-red-700 list-disc list-inside">
            <% @form.errors.full_messages.each do |message| %>
              <li><%= message %></li>
            <% end %>
          </ul>
        </div>
      <% end %>

      <div>
        <%= form.label :name, class: "block text-sm font-medium text-gray-700 mb-1" %>
        <%= form.text_field :name, class: "w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500", placeholder: "Enter form name" %>
      </div>

      <div>
        <%= form.label :description, class: "block text-sm font-medium text-gray-700 mb-1" %>
        <%= form.text_area :description, rows: 3, class: "w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500", placeholder: "Describe your form (optional)" %>
      </div>

      <div>
        <%= form.label :category, class: "block text-sm font-medium text-gray-700 mb-1" %>
        <%= form.select :category, options_for_select(Form.categories.map { |key, value| [key.humanize, key] }), { prompt: "Select a category" }, { class: "w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500" } %>
      </div>

      <% if current_user.can_use_ai_features? %>
        <div class="flex items-center">
          <%= form.check_box :ai_enabled, class: "h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded" %>
          <%= form.label :ai_enabled, "Enable AI features", class: "ml-2 block text-sm text-gray-900" %>
          <p class="ml-2 text-xs text-gray-500">(Response analysis, dynamic questions, etc.)</p>
        </div>
      <% else %>
        <div class="flex items-center p-3 bg-yellow-50 border border-yellow-200 rounded-md">
          <svg class="w-5 h-5 text-yellow-600 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
          </svg>
          <div>
            <p class="text-sm font-medium text-yellow-800">AI features require Premium plan</p>
            <p class="text-xs text-yellow-700">Upgrade to unlock response analysis, dynamic questions, and more.</p>
          </div>
        </div>
      <% end %>

      <div class="flex justify-between">
        <%= link_to "Cancel", forms_path, class: "px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50" %>
        <%= form.submit "Create Form", class: "px-6 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500" %>
      </div>
    <% end %>

    <!-- Template Selection CTA -->
    <div class="mt-12 p-6 bg-gradient-to-r from-purple-50 to-indigo-50 rounded-2xl border border-purple-100">
      <div class="text-center">
        <h2 class="text-xl font-semibold text-gray-900 mb-2">Prefer to start with a pre-designed template?</h2>
        <p class="text-gray-600 mb-4">
          Save time with our professional templates based on best practices.
        </p>
        <%= link_to templates_path, class: "inline-flex items-center px-6 py-3 bg-purple-600 text-white font-medium rounded-lg hover:bg-purple-700 transition-colors" do %><svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" /></svg>Browse template gallery<% end %>
      </div>
    </div>
  </div>
</div>
</file>

<file path="views/forms/preview.html.erb">
<div class="min-h-screen bg-gray-50 py-8">
  <div class="container mx-auto px-4">
    <div class="max-w-2xl mx-auto">
      <div class="bg-white rounded-lg shadow-md p-8">
        <div class="text-center mb-8">
          <h1 class="text-3xl font-bold text-gray-900"><%= @form.name %></h1>
          <% if @form.description.present? %>
            <p class="text-gray-600 mt-2"><%= @form.description %></p>
          <% end %>
          <div class="mt-4 p-3 bg-blue-50 border border-blue-200 rounded-md">
            <p class="text-sm text-blue-800">
              <strong>Preview Mode:</strong> This is how your form will appear to respondents.
            </p>
          </div>
        </div>

        <% if @form.form_questions.any? %>
          <div class="space-y-6">
            <% @form.form_questions.order(:position).each_with_index do |question, index| %>
              <div class="border-b pb-6 last:border-b-0">
                <label class="block text-sm font-medium text-gray-700 mb-2">
                  <%= index + 1 %>. <%= question.title %>
                  <% if question.required? %>
                    <span class="text-red-500">*</span>
                  <% end %>
                </label>
                
                <% if question.description.present? %>
                  <p class="text-sm text-gray-600 mb-3"><%= question.description %></p>
                <% end %>

                <!-- Render different input types based on question type -->
                <% case question.question_type %>
                <% when 'text_short' %>
                  <input type="text" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Your answer..." disabled>
                
                <% when 'text_long' %>
                  <textarea rows="4" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Your answer..." disabled></textarea>
                
                <% when 'email' %>
                  <input type="email" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="your@email.com" disabled>
                
                <% when 'multiple_choice' %>
                  <div class="space-y-2">
                    <label class="flex items-center">
                      <input type="checkbox" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded" disabled>
                      <span class="ml-2 text-sm text-gray-700">Option 1</span>
                    </label>
                    <label class="flex items-center">
                      <input type="checkbox" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded" disabled>
                      <span class="ml-2 text-sm text-gray-700">Option 2</span>
                    </label>
                    <label class="flex items-center">
                      <input type="checkbox" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded" disabled>
                      <span class="ml-2 text-sm text-gray-700">Option 3</span>
                    </label>
                  </div>
                
                <% when 'rating' %>
                  <div class="flex space-x-2">
                    <% (1..5).each do |i| %>
                      <button class="w-8 h-8 border border-gray-300 rounded-full hover:bg-indigo-100 focus:outline-none focus:ring-2 focus:ring-indigo-500" disabled>
                        <%= i %>
                      </button>
                    <% end %>
                  </div>
                
                <% else %>
                  <input type="text" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Your answer..." disabled>
                <% end %>
              </div>
            <% end %>
          </div>

          <div class="mt-8 text-center">
            <button class="bg-indigo-600 text-white px-8 py-3 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500" disabled>
              Submit Response
            </button>
          </div>
        <% else %>
          <div class="text-center py-8">
            <p class="text-gray-600">No questions have been added to this form yet.</p>
            <%= link_to "Add Questions", edit_form_path(@form), class: "mt-4 inline-block bg-indigo-600 text-white px-6 py-2 rounded-lg hover:bg-indigo-700" %>
          </div>
        <% end %>
      </div>

      <div class="mt-6 text-center">
        <%= link_to " Back to Form", @form, class: "text-indigo-600 hover:text-indigo-800" %>
      </div>
    </div>
  </div>
</div>
</file>

<file path="views/forms/responses.html.erb">
<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
  <!-- Header -->
  <div class="flex items-center justify-between mb-8">
    <div>
      <h1 class="text-3xl font-bold text-gray-900">Form Responses</h1>
      <p class="mt-2 text-lg text-gray-600">
        <%= @form.name %>
      </p>
    </div>
    
    <div class="flex items-center space-x-4">
      <%= link_to download_responses_form_path(@form, format: :csv), class: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" do %>
        <svg class="-ml-1 mr-2 h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
        </svg>
        Descargar CSV
      <% end %>
      
      <%= link_to analytics_form_path(@form), class: "inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" do %>
        <svg class="-ml-1 mr-2 h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
        </svg>
        Ver Analiticas
      <% end %>
    </div>
  </div>

  <!-- Stats Cards -->
  <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
    <div class="bg-white overflow-hidden shadow rounded-lg">
      <div class="px-4 py-5 sm:p-6">
        <dt class="text-sm font-medium text-gray-500 truncate">Total Responses</dt>
        <dd class="mt-1 text-3xl font-semibold text-gray-900"><%= @responses.total_count %></dd>
      </div>
    </div>
    
    <div class="bg-white overflow-hidden shadow rounded-lg">
      <div class="px-4 py-5 sm:p-6">
        <dt class="text-sm font-medium text-gray-500 truncate">Completion Rate</dt>
        <dd class="mt-1 text-3xl font-semibold text-gray-900">
          <% if @form.form_responses.any? %>
            <%= number_to_percentage((@form.form_responses.completed.count.to_f / @form.form_responses.count * 100), precision: 1) %>
          <% else %>
            0%
          <% end %>
        </dd>
      </div>
    </div>
    
    <div class="bg-white overflow-hidden shadow rounded-lg">
      <div class="px-4 py-5 sm:p-6">
        <dt class="text-sm font-medium text-gray-500 truncate">Average Time</dt>
        <dd class="mt-1 text-3xl font-semibold text-gray-900">
          <% avg_seconds = @responses.where.not(completed_at: nil).average("EXTRACT(EPOCH FROM (completed_at - started_at))") %>
          <%= avg_seconds ? "#{avg_seconds.round} seg" : "N/A" %>
        </dd>
      </div>
    </div>
  </div>

  <!-- Responses Table -->
  <div class="bg-white shadow overflow-hidden sm:rounded-md">
    <div class="px-4 py-5 border-b border-gray-200 sm:px-6">
      <h3 class="text-lg leading-6 font-medium text-gray-900">Response List</h3>
    </div>
    
    <div class="overflow-x-auto">
      <table class="min-w-full divide-y divide-gray-200">
        <thead class="bg-gray-50">
          <tr>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              ID
            </th>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Status
            </th>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Date
            </th>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Time
            </th>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              IP
            </th>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Answers
            </th>
            <th scope="col" class="relative px-6 py-3">
              <span class="sr-only">Actions</span>
            </th>
          </tr>
        </thead>
        
        <tbody class="bg-white divide-y divide-gray-200">
          <% @responses.each do |response| %>
            <tr class="hover:bg-gray-50">
              <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                <%= response.id %>
              </td>
              
              <td class="px-6 py-4 whitespace-nowrap">
                <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium %>
                  <% case response.status %>
                  <% when 'completed' %>
                    <span class="bg-green-100 text-green-800">Completado</span>
                  <% when 'in_progress' %>
                    <span class="bg-yellow-100 text-yellow-800">En Progreso</span>
                  <% when 'abandoned' %>
                    <span class="bg-red-100 text-red-800">Abandonado</span>
                  <% when 'paused' %>
                    <span class="bg-blue-100 text-blue-800">Pausado</span>
                  <% else %>
                    <span class="bg-gray-100 text-gray-800"><%= response.status.humanize %></span>
                  <% end %>
                </span>
              </td>
              
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                <% if response.status == 'completed' %>
                  <%= response.completed_at&.strftime('%d/%m/%Y %H:%M') %>
                <% else %>
                  <%= response.created_at.strftime('%d/%m/%Y %H:%M') %>
                <% end %>
              </td>
              
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                <% if response.completed_at && response.started_at %>
                  <%= ((response.completed_at - response.started_at).to_i) %> seg
                <% else %>
                  N/A
                <% end %>
              </td>
              
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                <%= response.ip_address %>
              </td>
              
              <td class="px-6 py-4 text-sm text-gray-500">
                <div class="max-w-xs truncate">
                  <% response.question_responses.first(3).each do |qr| %>
                    <span class="inline-block bg-gray-100 rounded px-2 py-1 text-xs mr-1 mb-1">
                      <%= qr.form_question.title %>: <%= qr.answer_data['value'].to_s.truncate(20) %>
                    </span>
                  <% end %>
                  <% if response.respond_to?(:has_answered_dynamic_questions?) && response.has_answered_dynamic_questions? %>
                    <span class="inline-block bg-purple-100 text-purple-800 rounded px-2 py-1 text-xs mr-1 mb-1">
                      +<%= response.respond_to?(:dynamic_questions) ? response.dynamic_questions.answered.count : 0 %> dynamic
                    </span>
                  <% end %>
                </div>
              </td>
              
              <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                <div class="flex items-center justify-end space-x-2">
                  <%= link_to "View", "#", class: "text-indigo-600 hover:text-indigo-900", onclick: "toggleDetails('#{response.id}'); return false;" %>
                  
                  <% completed_reports = response.analysis_reports.where(status: 'completed') %>
                  <% if response.status != 'completed' %>
                    <span class="text-gray-400 cursor-not-allowed" title="Reports can only be generated for completed responses">Generate Report</span>
                  <% elsif completed_reports.any? %>
                    <%= link_to " Report", analysis_report_path(completed_reports.last), 
                                class: "text-green-600 hover:text-green-900 font-medium" %>
                  <% elsif current_user.can_use_ai_features? %>
                    <%= link_to "Generate Report", generate_reports_path(form_response_id: response.id), 
                                method: :post, 
                                class: "text-blue-600 hover:text-blue-900 font-medium" %>
                  <% else %>
                    <span class="text-gray-400 cursor-not-allowed" title="Report generation requires Premium plan">Generate Report</span>
                  <% end %>
                </div>
              </td>
            </tr>
            
            <!-- Expandable details row -->
            <tr id="details-<%= response.id %>" class="hidden bg-gray-50">
              <td colspan="7" class="px-6 py-4">
                <div class="bg-white rounded-lg p-4">
                  <h4 class="font-medium text-gray-900 mb-4">Detalles de la respuesta #<%= response.id %></h4>
                  
                  <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                      <h5 class="text-sm font-medium text-gray-500 mb-2">Basic Information</h5>
                      <dl class="space-y-2 text-sm">
                        <dt class="font-medium text-gray-900">Status:</dt>
                        <dd class="text-gray-600">
                          <% case response.status %>
                          <% when 'completed' %>
                            <span class="text-green-600">Completado</span>
                          <% when 'in_progress' %>
                            <span class="text-yellow-600">En Progreso</span>
                          <% when 'abandoned' %>
                            <span class="text-red-600">Abandonado</span>
                          <% else %>
                            <%= response.status.humanize %>
                          <% end %>
                        </dd>
                        
                        <dt class="font-medium text-gray-900"><% if response.status == 'completed' %>Completed on:<% else %>Started on:<% end %>:</dt>
                        <dd class="text-gray-600"><%= response.status == 'completed' ? response.completed_at.strftime('%d/%m/%Y %H:%M:%S') : response.created_at.strftime('%d/%m/%Y %H:%M:%S') %></dd>
                        
                        <dt class="font-medium text-gray-900">Total time:</dt>
                        <dd class="text-gray-600"><%= response.completed_at && response.started_at ? ((response.completed_at - response.started_at).to_i) : 'N/A' %> segundos</dd>
                        
                        <dt class="font-medium text-gray-900">IP Address:</dt>
                        <dd class="text-gray-600"><%= response.ip_address %></dd>
                        
                        <dt class="font-medium text-gray-900">User Agent:</dt>
                        <dd class="text-gray-600 text-xs"><%= response.user_agent %></dd>
                      </dl>
                    </div>
                    
                    <div>
                      <h5 class="text-sm font-medium text-gray-500 mb-2">All Answers</h5>
                      <dl class="space-y-2 text-sm">
                        <% response.question_responses.each do |qr| %>
                          <dt class="font-medium text-gray-900"><%= qr.form_question.title %>:</dt>
                          <dd class="text-gray-600"><%= qr.answer_data['value'] %></dd>
                        <% end %>
                      </dl>
                      
                      <% if response.respond_to?(:has_answered_dynamic_questions?) && response.has_answered_dynamic_questions? %>
                        <h5 class="text-sm font-medium text-gray-500 mb-2 mt-4">Additional Dynamic Questions</h5>
                        <dl class="space-y-2 text-sm">
                          <% if response.respond_to?(:dynamic_question_responses) %>
                            <% response.dynamic_question_responses.each do |question_title, response_data| %>
                              <dt class="font-medium text-gray-900"><%= question_title %>:</dt>
                              <dd class="text-gray-600"><%= response_data[:answer] %></dd>
                            <% end %>
                          <% end %>
                        </dl>
                      <% end %>
                      
                      <!-- Strategic Analysis Report -->
                      <% completed_reports = response.analysis_reports.where(status: 'completed') %>
                      <% pending_reports = response.analysis_reports.where(status: 'pending').or(response.analysis_reports.where(status: 'processing')) %>
                      <% failed_reports = response.analysis_reports.where(status: 'failed') %>
                      
                      <% if completed_reports.any? %>
                        <div class="mt-6 border-t pt-4">
                          <h5 class="text-sm font-medium text-green-600 mb-2"> Strategic Analysis Report</h5>
                          <% report = completed_reports.last %>
                          <div class="bg-green-50 rounded-lg p-3">
                            <p class="text-sm text-green-800 mb-2">
                              <strong>Report ID:</strong> <%= report.id %>
                            </p>
                            <p class="text-sm text-green-800 mb-2">
                              <strong>Generated:</strong> <%= report.respond_to?(:generated_at) && report.generated_at ? report.generated_at.strftime('%d/%m/%Y %H:%M') : report.created_at.strftime('%d/%m/%Y %H:%M') %>
                            </p>
                            <p class="text-sm text-green-800 mb-2">
                              <strong>AI Cost:</strong> $<%= report.respond_to?(:ai_cost) ? (report.ai_cost || '0.00') : '0.00' %>
                            </p>
                            <div class="flex space-x-2 mt-3">
                              <%= link_to "View Report", analysis_report_path(report), 
                                          class: "text-sm bg-green-600 text-white px-3 py-1 rounded hover:bg-green-700" %>
                              <% if respond_to?(:download_analysis_report_path) %>
                                <%= link_to "Download", download_analysis_report_path(report), 
                                            class: "text-sm bg-gray-600 text-white px-3 py-1 rounded hover:bg-gray-700" %>
                              <% end %>
                            </div>
                          </div>
                        </div>
                      <% elsif pending_reports.any? %>
                        <div class="mt-6 border-t pt-4">
                          <h5 class="text-sm font-medium text-yellow-600 mb-2"> Generating Report...</h5>
                          <div class="bg-yellow-50 rounded-lg p-3">
                            <p class="text-sm text-yellow-800">Report is being generated. Please refresh in a few minutes.</p>
                          </div>
                        </div>
                      <% elsif failed_reports.any? %>
                        <div class="mt-6 border-t pt-4">
                          <h5 class="text-sm font-medium text-red-600 mb-2"> Report Failed</h5>
                          <div class="bg-red-50 rounded-lg p-3">
                            <p class="text-sm text-red-800">Report generation failed. <%= link_to "Try Again", generate_reports_path(form_response_id: response.id), method: :post, class: "underline" %></p>
                          </div>
                        </div>
                      <% else %>
                        <div class="mt-6 border-t pt-4">
                          <% if current_user.can_use_ai_features? %>
                            <%= button_to "Generate Strategic Report", generate_reports_path, params: { form_response_id: response.id }, class: "text-sm bg-blue-600 text-white px-3 py-1 rounded hover:bg-blue-700 border-none cursor-pointer" %>
                          <% else %>
                            <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-3">
                              <p class="text-sm text-yellow-800 mb-2"><strong>Report generation requires Premium plan</strong></p>
                              <p class="text-xs text-yellow-700 mb-2">Upgrade to unlock strategic analysis reports, AI insights, and comprehensive response analysis.</p>
                              <%= link_to "Upgrade to Premium", new_subscription_path, class: "text-sm bg-yellow-600 text-white px-3 py-1 rounded hover:bg-yellow-700 no-underline" %>
                            </div>
                          <% end %>
                        </div>
                      <% end %>
                    </div>
                  </div>
                </div>
              </td>
            </tr>
          <% end %>
        </tbody>
      </table>
    </div>
    
    <% if @responses.empty? %>
      <div class="text-center py-12">
        <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path>
        </svg>
        <h3 class="mt-2 text-sm font-medium text-gray-900">No responses yet</h3>
        <p class="mt-1 text-sm text-gray-500">
          There are no completed responses for this form yet.
        </p>
      </div>
    <% end %>
  </div>

  <!-- Pagination -->
  <div class="mt-6">
    <%= paginate @responses %>
  </div>

  <!-- Back button -->
  <div class="mt-8">
    <%= link_to " Back to form", @form, class: "text-indigo-600 hover:text-indigo-900" %>
  </div>
</div>

<script>
function toggleDetails(responseId) {
  const detailsRow = document.getElementById('details-' + responseId);
  if (!detailsRow) {
    console.error('Details row not found for ID: details-' + responseId);
    return;
  }
  
  if (detailsRow.classList.contains('hidden')) {
    detailsRow.classList.remove('hidden');
  } else {
    detailsRow.classList.add('hidden');
  }
}

// Asegurar que la funcin est disponible globalmente
window.toggleDetails = toggleDetails;
</script>
</file>

<file path="views/forms/show.html.erb">
<%# Admin form details view %>
<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
  <!-- Header -->
  <div class="bg-white shadow rounded-lg mb-6">
    <div class="px-6 py-4 border-b border-gray-200">
      <div class="flex items-center justify-between">
        <h1 class="text-2xl font-bold text-gray-900"><%= @form.name %></h1>
        <div class="flex items-center space-x-2">          
          <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800">
            <%= @form.status.humanize %>
          </span>
          <% if @form.ai_enabled? %>
            <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-purple-100 text-purple-800">
              AI Enabled
            </span>
          <% end %>
        </div>
      </div>
    </div>
    
    <div class="px-6 py-4">
      <p class="text-gray-600"><%= @form.description %></p>
      <div class="mt-4 flex items-center space-x-4 text-sm text-gray-500">
        <span><%= pluralize(@form.questions_count, 'question') %></span>
        <span></span>
        <%= link_to pluralize(@form.form_responses.count, 'response'), responses_form_path(@form), class: "text-indigo-600 hover:text-indigo-900" %>
        <span></span>
        <span>Creado: <%= @form.created_at.strftime('%d/%m/%Y') %></span>
        <span></span>
        <span>Category: <%= @form.category.humanize %></span>
      </div>
    </div>
  </div>
  
  <!-- Quick Stats -->
  <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
    <%= link_to responses_form_path(@form), class: "bg-white shadow rounded-lg p-6 hover:shadow-md transition-shadow" do %>
      <div class="text-2xl font-bold text-gray-900"><%= @form.form_responses.count %></div>
      <div class="text-sm text-gray-500">Total Responses</div>
    <% end %>
    
    <div class="bg-white shadow rounded-lg p-6">      
      <div class="text-2xl font-bold text-gray-900"><%= @form.completion_rate %>%</div>
      <div class="text-sm text-gray-500">Completion Rate</div>
    </div>
    
    <div class="bg-white shadow rounded-lg p-6">      
      <div class="text-2xl font-bold text-gray-900"><%= @form.questions_count %></div>
      <div class="text-sm text-gray-500">Questions</div>
    </div>
  </div>
  
  <!-- Recent Responses -->
  <div class="bg-white shadow rounded-lg mb-6">
    <div class="px-6 py-4 border-b border-gray-200">      
      <h2 class="text-lg font-medium text-gray-900">Recent Responses</h2>
    </div>
    
    <div class="px-6 py-4">
      <% if @recent_responses.any? %>
        <div class="space-y-4">
          <% @recent_responses.each do |response| %>
            <div class="border-b border-gray-200 pb-4 last:border-b-0">
              <div class="flex items-center justify-between">
                <span class="text-sm text-gray-600"><%= response.created_at.strftime("%B %d, %Y at %I:%M %p") %></span>
                <span class="text-sm text-gray-500"><%= response.status.humanize %></span>
              </div>
              <div class="mt-2 text-sm text-gray-700">
                <%= response.question_responses.count %> questions answered
              </div>
            </div>
          <% end %>
        </div>
      <% else %>
        <p class="text-gray-500 text-center py-4">No responses yet.</p>
      <% end %>
    </div>
  </div>
  
  <!-- Questions List -->
  <div class="bg-white shadow rounded-lg mb-6">
    <div class="px-6 py-4 border-b border-gray-200">      
      <h2 class="text-lg font-medium text-gray-900">Questions</h2>
    </div>
    
    <div class="px-6 py-4">
      <% if @form_questions.any? %>
        <div class="space-y-3">
          <% @form_questions.each_with_index do |question, index| %>
            <div class="flex items-center justify-between p-3 border rounded-lg">
              <div>
                <span class="text-sm font-medium text-gray-900"><%= index + 1 %>. <%= question.title.truncate(50) %></span>
                <span class="text-xs text-gray-500 ml-2"><%= question.question_type.humanize %></span>
              </div>
              <div class="text-sm text-gray-500"><%= question.required? ? 'Required' : 'Optional' %></div>
            </div>
          <% end %>
        </div>
      <% else %>
        <p class="text-gray-500 text-center py-4">No questions added yet.</p>
      <% end %>
    </div>
  </div>
  
  <!-- Actions -->
  <div class="flex space-x-4">
    <%= link_to "Edit Form", edit_form_path(@form), class: "px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700" %>
    <%= link_to "Preview", preview_form_path(@form), class: "px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700" %>
    <%= link_to "Analytics", analytics_form_path(@form), class: "px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700" %>
    <%= link_to "Responses", responses_form_path(@form), class: "px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700" %>
    
    <% if @form.published? %>
      <%= link_to "View Public Form", public_form_path(@form.share_token), target: "_blank", class: "px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700" %>
    <% end %>
  </div>
</div>
</file>

<file path="views/google_integrations/show.html.erb">
<div class="max-w-4xl mx-auto p-6">
  <div class="bg-white shadow rounded-lg">
    <div class="px-6 py-4 border-b border-gray-200">
      <h1 class="text-2xl font-bold text-gray-900">Google Sheets Integration</h1>
      <p class="mt-1 text-sm text-gray-600">Connect your forms to Google Sheets for automatic data export</p>
    </div>

    <div class="p-6">
      <% if @integration&.active? %>
        <!-- Connected State -->
        <div class="bg-green-50 border border-green-200 rounded-md p-4 mb-6">
          <div class="flex items-center">
            <svg class="h-5 w-5 text-green-400" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
            </svg>
            <h3 class="ml-3 text-sm font-medium text-green-800">Connected to Google Sheets</h3>
          </div>
          <div class="mt-2 text-sm text-green-700">
            <p>Account: <%= @integration.user_info['email'] %></p>
            <p>Connected: <%= time_ago_in_words(@integration.created_at) %> ago</p>
            <p>Last used: <%= @integration.last_used_at ? time_ago_in_words(@integration.last_used_at) + ' ago' : 'Never' %></p>
          </div>
        </div>

        <!-- Test Connection -->
        <div class="mb-6">
          <button id="test-connection" 
                  class="inline-flex items-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50">
            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
            </svg>
            Test Connection
          </button>
          <div id="test-result" class="mt-2"></div>
        </div>

        <!-- Recent Exports -->
        <% if @recent_exports.any? %>
          <div class="mb-6">
            <h3 class="text-lg font-medium text-gray-900 mb-4">Recent Exports</h3>
            <div class="bg-white shadow overflow-hidden sm:rounded-md">
              <ul class="divide-y divide-gray-200">
                <% @recent_exports.each do |export| %>
                  <li class="px-6 py-4">
                    <div class="flex items-center justify-between">
                      <div class="flex items-center">
                        <div class="flex-shrink-0">
                          <% case export.status %>
                          <% when 'completed' %>
                            <div class="h-2 w-2 bg-green-400 rounded-full"></div>
                          <% when 'processing' %>
                            <div class="h-2 w-2 bg-yellow-400 rounded-full animate-pulse"></div>
                          <% when 'failed' %>
                            <div class="h-2 w-2 bg-red-400 rounded-full"></div>
                          <% else %>
                            <div class="h-2 w-2 bg-gray-400 rounded-full"></div>
                          <% end %>
                        </div>
                        <div class="ml-4">
                          <div class="text-sm font-medium text-gray-900">
                            <%= export.form.name %>
                          </div>
                          <div class="text-sm text-gray-500">
                            <%= export.status.humanize %>  
                            <%= export.records_exported %> records  
                            <%= time_ago_in_words(export.created_at) %> ago
                          </div>
                        </div>
                      </div>
                      <% if export.spreadsheet_url.present? %>
                        <div class="flex-shrink-0">
                          <%= link_to export.spreadsheet_url, 
                                      target: '_blank',
                                      class: "text-indigo-600 hover:text-indigo-900 text-sm font-medium" do %>
                            View Spreadsheet
                          <% end %>
                        </div>
                      <% end %>
                    </div>
                  </li>
                <% end %>
              </ul>
            </div>
          </div>
        <% end %>

        <!-- Disconnect -->
        <div class="mb-6">
          <%= link_to disconnect_google_integration_path, 
                      method: :delete,
                      class: "inline-flex items-center px-4 py-2 border border-red-300 rounded-md shadow-sm text-sm font-medium text-red-700 bg-white hover:bg-red-50",
                      data: { confirm: 'Are you sure you want to disconnect from Google Sheets?' } do %>
            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
            </svg>
            Disconnect
          <% end %>
        </div>

      <% else %>
        <!-- Not Connected State -->
        <div class="text-center py-12">
          <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 48 48">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5l7-7 7 7M9 20h6"/>
          </svg>
          <h3 class="mt-2 text-sm font-medium text-gray-900">No Google Sheets connection</h3>
          <p class="mt-1 text-sm text-gray-500">Connect your Google account to start exporting form responses automatically.</p>
          <div class="mt-6">
            <%= link_to connect_google_integration_path,
                        class: "inline-flex items-center px-4 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700" do %>
              <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
                <path d="M10.394 2.08a1 1 0 00-.788 0l-7 3a1 1 0 000 1.84L5.25 8.051a.999.999 0 01.356-.257l4-1.714a1 1 0 11.788 1.838L7.667 9.088l1.94.831a1 1 0 00.787 0l7-3a1 1 0 000-1.838l-7-3zM3.31 9.397L5 10.12v4.102a8.969 8.969 0 00-1.05-.174 1 1 0 01-.89-.89 11.115 11.115 0 01.25-3.762zM9.3 16.573A9.026 9.026 0 007 14.935v-3.957l1.818.78a3 3 0 002.364 0l5.508-2.361a11.026 11.026 0 01.25 3.762 1 1 0 01-.89.89 8.968 8.968 0 00-5.35 2.524 1 1 0 01-1.4 0zM6 18a1 1 0 001-1v-2.065a8.935 8.935 0 00-2-.712V17a1 1 0 001 1z"/>
              </svg>
              Connect to Google Sheets
            <% end %>
          </div>
        </div>
      <% end %>
    </div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const testButton = document.getElementById('test-connection');
  const testResult = document.getElementById('test-result');
  
  if (testButton) {
    testButton.addEventListener('click', function() {
      testButton.disabled = true;
      testButton.innerHTML = '<svg class="animate-spin -ml-1 mr-3 h-4 w-4 text-gray-700" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>Testing...';
      
      fetch('<%= test_connection_google_integration_path %>', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content
        }
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          testResult.innerHTML = '<div class="text-sm text-green-600"> Connection successful</div>';
        } else {
          testResult.innerHTML = '<div class="text-sm text-red-600"> ' + data.error + '</div>';
        }
      })
      .catch(error => {
        testResult.innerHTML = '<div class="text-sm text-red-600"> Connection test failed</div>';
      })
      .finally(() => {
        testButton.disabled = false;
        testButton.innerHTML = '<svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>Test Connection';
      });
    });
  }
});
</script>
</file>

<file path="views/landing/index.html.erb">
<% content_for :head do %>
  <!-- Custom Styles for Landing Page -->
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #f8fafc; /* slate-50 */
    }
    .ai-gradient-text {
      background: linear-gradient(135deg, #6366f1 0%, #a855f7 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .ai-gradient-bg {
      background: linear-gradient(135deg, #6366f1 0%, #a855f7 100%);
    }
    .feature-card:hover .feature-icon {
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(99, 102, 241, 0.3);
    }
    .plan-card.recommended {
      border-color: #6366f1;
      transform: scale(1.05);
    }
    .faq-answer {
      transition: max-height 0.3s ease-out, opacity 0.3s ease-in-out;
      max-height: 0;
      opacity: 0;
      overflow: hidden;
    }
    .faq-question.open + .faq-answer {
      max-height: 500px; /* A large enough value */
      opacity: 1;
    }
    .faq-question.open svg {
      transform: rotate(180deg);
    }
  </style>
<% end %>

<!-- Header -->
<header class="bg-white/95 backdrop-blur-sm border-b border-gray-100 sticky top-0 z-50 shadow-sm">
  <div class="container mx-auto px-6 py-4 flex justify-between items-center">
    <a href="#" class="flex items-center space-x-2">
      <div class="w-8 h-8 ai-gradient-bg rounded-lg flex items-center justify-center shadow-sm">
        <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01"></path>
        </svg>
      </div>
      <span class="text-xl font-bold text-slate-900">mydialogform</span>
    </a>
    
    <!-- Desktop Navigation -->
    <nav class="hidden md:flex items-center space-x-8">
      <a href="#features" class="text-slate-600 hover:text-indigo-600 transition-colors font-medium">Features</a>
      <a href="#pricing" class="text-slate-600 hover:text-indigo-600 transition-colors font-medium">Pricing</a>
      <a href="#faq" class="text-slate-600 hover:text-indigo-600 transition-colors font-medium">FAQ</a>
    </nav>
    
    <div class="flex items-center space-x-4">
      <% if user_signed_in? %>
        <%= link_to "Dashboard", forms_path, class: "bg-indigo-600 text-white font-semibold px-6 py-2.5 rounded-lg hover:bg-indigo-700 transition-all duration-200 shadow-sm hover:shadow-md" %>
      <% else %>
        <a href="/users/sign_in" class="hidden sm:block text-slate-600 hover:text-indigo-600 transition-colors font-medium">Log In</a>
        <a href="/users/sign_up" class="bg-indigo-600 text-white font-semibold px-6 py-2.5 rounded-lg hover:bg-indigo-700 transition-all duration-200 shadow-sm hover:shadow-md">
          Start Free Trial
        </a>
      <% end %>
    </div>
    
    <!-- Mobile menu button -->
    <div class="md:hidden">
      <button type="button" class="mobile-menu-button text-slate-600 hover:text-indigo-600 focus:outline-none focus:text-indigo-600 p-2 rounded-lg hover:bg-slate-50 transition-colors">
        <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
        </svg>
      </button>
    </div>
  </div>
  
  <!-- Mobile Navigation -->
  <div class="mobile-menu hidden md:hidden pb-4 border-t border-gray-100 mt-4 pt-4">
    <div class="container mx-auto px-6">
      <div class="flex flex-col space-y-3">
        <a href="#features" class="text-slate-600 hover:text-indigo-600 transition-colors py-2 font-medium">Features</a>
        <a href="#pricing" class="text-slate-600 hover:text-indigo-600 transition-colors py-2 font-medium">Pricing</a>
        <a href="#faq" class="text-slate-600 hover:text-indigo-600 transition-colors py-2 font-medium">FAQ</a>
        
        <div class="pt-3 border-t border-gray-100 space-y-3">
          <% if user_signed_in? %>
            <%= link_to "Dashboard", forms_path, class: "bg-indigo-600 text-white px-4 py-2.5 rounded-lg hover:bg-indigo-700 transition-colors text-center font-medium block" %>
          <% else %>
            <a href="/users/sign_in" class="text-slate-600 hover:text-indigo-600 transition-colors py-2 font-medium block">Log In</a>
            <a href="/users/sign_up" class="bg-indigo-600 text-white px-4 py-2.5 rounded-lg hover:bg-indigo-700 transition-colors text-center font-medium block">
              Start Free Trial
            </a>
          <% end %>
        </div>
      </div>
    </div>
  </div>
</header>
<!-- 
Hero Section -->
<section class="relative bg-white pt-20 pb-24 md:pt-32 md:pb-32">
  <div class="container mx-auto px-6 text-center">
    <span class="inline-block bg-indigo-100 text-indigo-700 text-sm font-semibold px-4 py-1 rounded-full mb-4">Powered by SuperAgent AI</span>
    <h1 class="text-4xl md:text-6xl font-extrabold text-slate-900 leading-tight">
      Build Forms That <span class="ai-gradient-text">Think</span>,<br> Not Just Collect.
    </h1>
    <p class="mt-6 max-w-2xl mx-auto text-lg md:text-xl text-slate-600">
      The AI-first form platform that turns every submission into an intelligent conversation. Automate lead qualification, analyze feedback in real-time, and build workflows that deliver results.
    </p>
    <div class="mt-10 flex flex-col sm:flex-row justify-center items-center space-y-4 sm:space-y-0 sm:space-x-4">
      <a href="/users/sign_up" class="ai-gradient-bg text-white font-semibold px-8 py-4 rounded-lg hover:opacity-90 transition-opacity shadow-lg">
        Start Your 14-Day Premium Trial
      </a>
      <div class="text-sm text-slate-600">
        <span class="font-medium">No credit card required</span>  Cancel anytime
      </div>
    </div>
    <div class="mt-6 flex justify-center">
      <div class="bg-white/80 backdrop-blur-sm border border-slate-200 rounded-lg px-6 py-3 shadow-sm">
        <p class="text-sm text-slate-700">
          <span class="font-semibold text-green-600"> Average ROI:</span> Premium users see 3-5x return on investment within 30 days
        </p>
      </div>
    </div>
  </div>
</section>

<!-- Social Proof -->
<section class="bg-slate-50 py-12">
  <div class="container mx-auto px-6">
    <p class="text-center text-sm font-semibold text-slate-500">
      TRUSTED BY INNOVATIVE TEAMS AT
    </p>
    <div class="mt-6 flex justify-center items-center flex-wrap gap-x-12 gap-y-4">
      <svg class="h-8 text-slate-400" viewBox="0 0 125 29" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M40.23 28.5H30.76L16.81 12.3V28.5H7.32V0.5H16.81L30.76 16.7V0.5H40.23V28.5Z" fill="currentColor"></path>
        <path d="M72.23 28.5H62.76L48.81 12.3V28.5H39.32V0.5H48.81L62.76 16.7V0.5H72.23V28.5Z" fill="currentColor"></path>
        <path d="M124.24 28.5H114.77L100.82 12.3V28.5H91.33V0.5H100.82L114.77 16.7V0.5H124.24V28.5Z" fill="currentColor"></path>
        <path d="M16.48 0.5H0V28.5H16.48V0.5Z" fill="currentColor"></path>
        <path d="M88.48 0.5H72V28.5H88.48V0.5Z" fill="currentColor"></path>
      </svg>
      <p class="text-2xl font-bold text-slate-400 tracking-widest">NEXUS</p>
      <p class="text-2xl font-bold text-slate-400">Quantum</p>
      <p class="text-2xl font-bold text-slate-400 tracking-wider">Aperture</p>
    </div>
  </div>
</section><!-
- Success Stories Section -->
<section class="py-16 bg-gradient-to-r from-indigo-600 to-purple-700 text-white">
  <div class="container mx-auto px-6">
    <div class="text-center mb-12">
      <h2 class="text-3xl md:text-4xl font-bold mb-4">Premium Users Are Winning</h2>
      <p class="text-xl text-indigo-100">See what happens when you unlock the full power of mydialogform</p>
    </div>
    <div class="grid md:grid-cols-3 gap-8">
      <!-- Success Story 1 -->
      <div class="bg-white/10 backdrop-blur-sm rounded-xl p-6 border border-white/20">
        <div class="text-4xl font-bold text-green-300 mb-2">340%</div>
        <div class="text-lg font-semibold mb-2">More Qualified Leads</div>
        <p class="text-indigo-100 text-sm">
          "Our AI qualification agent automatically scores leads using BANT criteria. We went from 20% qualified leads to 68% qualified leads."
        </p>
        <div class="mt-4 text-xs text-indigo-200">
           SaaS Startup, 50 employees
        </div>
      </div>
      
      <!-- Success Story 2 -->
      <div class="bg-white/10 backdrop-blur-sm rounded-xl p-6 border border-white/20">
        <div class="text-4xl font-bold text-green-300 mb-2">$12K</div>
        <div class="text-lg font-semibold mb-2">Monthly Revenue Added</div>
        <p class="text-indigo-100 text-sm">
          "Payment processing in forms was a game-changer. We now collect event registrations and course payments directly through our forms."
        </p>
        <div class="mt-4 text-xs text-indigo-200">
           Online Education Company
        </div>
      </div>
      
      <!-- Success Story 3 -->
      <div class="bg-white/10 backdrop-blur-sm rounded-xl p-6 border border-white/20">
        <div class="text-4xl font-bold text-green-300 mb-2">15hrs</div>
        <div class="text-lg font-semibold mb-2">Saved Per Week</div>
        <p class="text-indigo-100 text-sm">
          "Salesforce integration eliminated manual data entry. Our team now focuses on closing deals instead of copying data."
        </p>
        <div class="mt-4 text-xs text-indigo-200">
           Digital Marketing Agency
        </div>
      </div>
    </div>
    <div class="text-center mt-12">
      <a href="/users/sign_up" class="bg-white text-indigo-600 font-semibold px-8 py-4 rounded-lg hover:bg-gray-50 transition-colors shadow-lg">
        Join the Premium Winners
      </a>
    </div>
  </div>
</section>

<!-- Features Section -->
<section id="features" class="py-20 md:py-28 bg-white">
  <div class="container mx-auto px-6">
    <div class="text-center max-w-3xl mx-auto">
      <h2 class="text-3xl md:text-4xl font-bold text-slate-900">Your Forms, Now with a Brain</h2>
      <p class="mt-4 text-lg text-slate-600">
        mydialogform goes beyond simple data collection. It's an intelligent platform that understands, adapts, and automates your most critical business processes.
      </p>
    </div>
    <div class="mt-16 grid md:grid-cols-2 lg:grid-cols-4 gap-8">
      <!-- Feature 1: AI Agents -->
      <div class="feature-card bg-slate-50 p-8 rounded-xl border border-slate-200">
        <div class="feature-icon w-12 h-12 rounded-lg bg-indigo-100 text-indigo-600 flex items-center justify-center transition-transform duration-300">
          <svg class="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01"></path>
          </svg>
        </div>
        <h3 class="mt-4 text-xl font-semibold">AI Qualification Agents</h3>
        <p class="mt-2 text-slate-600">Deploy pre-built BANT/CHAMP agents to automatically qualify leads, asking dynamic follow-up questions to uncover budget, authority, and need.</p>
      </div>
      
      <!-- Feature 2: Visual Builder -->
      <div class="feature-card bg-slate-50 p-8 rounded-xl border border-slate-200">
        <div class="feature-icon w-12 h-12 rounded-lg bg-indigo-100 text-indigo-600 flex items-center justify-center transition-transform duration-300">
          <svg class="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
          </svg>
        </div>
        <h3 class="mt-4 text-xl font-semibold">Build Without Limits</h3>
        <p class="mt-2 text-slate-600">Create unlimited forms with unlimited questions and receive unlimited responses. From file uploads to payments, our builder handles it all.</p>
      </div>
      
      <!-- Feature 3: Workflows -->
      <div class="feature-card bg-slate-50 p-8 rounded-xl border border-slate-200">
        <div class="feature-icon w-12 h-12 rounded-lg bg-indigo-100 text-indigo-600 flex items-center justify-center transition-transform duration-300">
          <svg class="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9V3m0 18a9 9 0 009-9m-9 9a9 9 0 00-9-9"></path>
          </svg>
        </div>
        <h3 class="mt-4 text-xl font-semibold">Automate Anything</h3>
        <p class="mt-2 text-slate-600">Connect to your CRM, send Slack notifications, trigger webhooks, and sync to Google Sheets. Automate your entire data pipeline from a single form.</p>
      </div>
      
      <!-- Feature 4: Analytics -->
      <div class="feature-card bg-slate-50 p-8 rounded-xl border border-slate-200">
        <div class="feature-icon w-12 h-12 rounded-lg bg-indigo-100 text-indigo-600 flex items-center justify-center transition-transform duration-300">
          <svg class="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
          </svg>
        </div>
        <h3 class="mt-4 text-xl font-semibold">Actionable Insights</h3>
        <p class="mt-2 text-slate-600">Pinpoint exactly where users drop off, analyze sentiment, and get AI-powered recommendations to boost your completion rates.</p>
      </div>
    </div>
  </div>
</section><!-- P
ricing Section -->
<section id="pricing" class="py-20 md:py-28 bg-slate-50">
  <div class="container mx-auto px-6">
    <div class="text-center max-w-3xl mx-auto">
      <h2 class="text-3xl md:text-4xl font-bold text-slate-900">Choose Your Power Level</h2>
      <p class="mt-4 text-lg text-slate-600">
        Start with Basic or go Premium to unlock the full potential of intelligent forms. Both plans include a 14-day free trial.
      </p>
    </div>
    <div class="mt-16 grid lg:grid-cols-2 gap-8 items-start max-w-5xl mx-auto">
      <!-- Basic Plan -->
      <div class="plan-card bg-white p-8 rounded-xl shadow-lg border h-full flex flex-col relative">
        <div class="absolute top-4 right-4 bg-slate-100 text-slate-600 text-xs font-semibold px-3 py-1 rounded-full">
          Limited Features
        </div>
        <h3 class="text-2xl font-bold text-gray-900">Basic</h3>
        <p class="mt-2 text-gray-500">For simple forms and getting started</p>
        <p class="mt-6"><span class="text-4xl font-bold">Free</span><span class="text-gray-500"> forever</span></p>
        <a href="/users/sign_up" class="w-full mt-6 py-3 bg-slate-100 text-slate-700 font-semibold rounded-lg text-center hover:bg-slate-200 transition-colors">Start with Basic</a>
        
        <div class="mt-8 flex-1">
          <h4 class="font-semibold text-gray-900 mb-4">What's Included:</h4>
          <ul class="space-y-3 text-gray-600 text-sm">
            <li class="flex items-start">
              <svg class="w-5 h-5 text-green-500 mr-2 shrink-0 mt-0.5" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
              </svg>
              <span>Unlimited forms & responses</span>
            </li>
            <li class="flex items-start">
              <svg class="w-5 h-5 text-green-500 mr-2 shrink-0 mt-0.5" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
              </svg>
              <span>Basic conditional logic</span>
            </li>
            <li class="flex items-start">
              <svg class="w-5 h-5 text-green-500 mr-2 shrink-0 mt-0.5" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
              </svg>
              <span>File uploads (100 MB storage)</span>
            </li>
            <li class="flex items-start">
              <svg class="w-5 h-5 text-green-500 mr-2 shrink-0 mt-0.5" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
              </svg>
              <span>Basic integrations (Sheets, Slack, Webhooks)</span>
            </li>
            <li class="flex items-start">
              <svg class="w-5 h-5 text-green-500 mr-2 shrink-0 mt-0.5" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
              </svg>
              <span>10 AI credits / month</span>
            </li>
          </ul>
        </div>
      </div>

      <!-- Premium Plan -->
      <div class="plan-card bg-white p-8 rounded-xl shadow-2xl border-2 h-full flex flex-col recommended relative">
        <div class="absolute top-0 -translate-y-1/2 left-1/2 -translate-x-1/2 px-4 py-1 bg-gradient-to-r from-green-500 to-emerald-500 text-white text-xs font-semibold rounded-full uppercase tracking-wider">
           Most Popular
        </div>
        <div class="absolute top-4 right-4 bg-green-100 text-green-700 text-xs font-semibold px-3 py-1 rounded-full">
          Full Power
        </div>
        <h3 class="text-2xl font-bold text-gray-900">Premium</h3>
        <p class="mt-2 text-gray-500">For businesses that want to maximize results</p>
        <div class="mt-6">
          <span class="text-4xl font-bold">$35</span><span class="text-gray-500"> / month</span>
          <div class="mt-2 text-sm text-green-600 font-medium">
             ROI: Typically pays for itself in the first week
          </div>
        </div>
        <a href="/users/sign_up" class="w-full mt-6 py-3 ai-gradient-bg text-white font-semibold rounded-lg text-center hover:opacity-90 transition-opacity">Start 14-Day Free Trial</a>
        
        <div class="mt-8 flex-1">
          <h4 class="font-semibold text-green-900 mb-4">Everything in Basic, PLUS:</h4>
          <ul class="space-y-3 text-gray-600 text-sm">
            <li class="flex items-start">
              <svg class="w-5 h-5 text-green-500 mr-2 shrink-0 mt-0.5" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
              </svg>
              <span><strong> Stripe Payment Processing</strong> - Collect payments directly</span>
            </li>
            <li class="flex items-start">
              <svg class="w-5 h-5 text-green-500 mr-2 shrink-0 mt-0.5" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
              </svg>
              <span><strong> AI Qualification Agents</strong> - Auto-qualify leads (BANT/CHAMP)</span>
            </li>
            <li class="flex items-start">
              <svg class="w-5 h-5 text-green-500 mr-2 shrink-0 mt-0.5" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
              </svg>
              <span><strong> Remove mydialogform branding</strong> - Professional appearance</span>
            </li>
            <li class="flex items-start">
              <svg class="w-5 h-5 text-green-500 mr-2 shrink-0 mt-0.5" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
              </svg>
              <span><strong> Advanced Analytics</strong> - Deep insights and optimization</span>
            </li>
            <li class="flex items-start">
              <svg class="w-5 h-5 text-green-500 mr-2 shrink-0 mt-0.5" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
              </svg>
              <span><strong> Premium Integrations</strong> - Salesforce, HubSpot, and more</span>
            </li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</section>

<!-- FAQ Section -->
<section id="faq" class="py-20 md:py-28 bg-white">
  <div class="container mx-auto px-6">
    <div class="text-center max-w-3xl mx-auto mb-16">
      <h2 class="text-3xl md:text-4xl font-bold text-slate-900">Frequently Asked Questions</h2>
      <p class="mt-4 text-lg text-slate-600">
        Everything you need to know about mydialogform and our intelligent form platform.
      </p>
    </div>
    
    <div class="max-w-4xl mx-auto space-y-6">
      <!-- FAQ Item 1 -->
      <div class="border border-slate-200 rounded-lg">
        <button class="faq-question w-full px-6 py-4 text-left flex justify-between items-center hover:bg-slate-50 transition-colors">
          <span class="font-semibold text-slate-900">What makes mydialogform different from other form builders?</span>
          <svg class="w-5 h-5 text-slate-500 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
          </svg>
        </button>
        <div class="faq-answer hidden px-6 pb-4">
          <p class="text-slate-600">mydialogform is the first AI-native form platform. While other tools just collect data, we turn every form into an intelligent agent that can qualify leads, analyze sentiment, ask dynamic follow-up questions, and automate complex workflows. Our SuperAgent AI framework makes forms truly conversational and intelligent.</p>
        </div>
      </div>
      
      <!-- FAQ Item 2 -->
      <div class="border border-slate-200 rounded-lg">
        <button class="faq-question w-full px-6 py-4 text-left flex justify-between items-center hover:bg-slate-50 transition-colors">
          <span class="font-semibold text-slate-900">How does the 14-day free trial work?</span>
          <svg class="w-5 h-5 text-slate-500 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
          </svg>
        </button>
        <div class="faq-answer hidden px-6 pb-4">
          <p class="text-slate-600">You get full access to all Premium features for 14 days, no credit card required. You can create unlimited forms, use AI agents, process payments, and access all integrations. If you don't upgrade, you'll automatically move to our generous Basic plan with unlimited forms and responses.</p>
        </div>
      </div>
      
      <!-- FAQ Item 3 -->
      <div class="border border-slate-200 rounded-lg">
        <button class="faq-question w-full px-6 py-4 text-left flex justify-between items-center hover:bg-slate-50 transition-colors">
          <span class="font-semibold text-slate-900">Can I integrate mydialogform with my existing tools?</span>
          <svg class="w-5 h-5 text-slate-500 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
          </svg>
        </button>
        <div class="faq-answer hidden px-6 pb-4">
          <p class="text-slate-600">Absolutely! We offer native integrations with Salesforce, HubSpot, Google Sheets, Slack, Stripe, and many more. Our API-first approach means you can also build custom integrations. Premium users get access to advanced integrations and webhook capabilities.</p>
        </div>
      </div>
      
      <!-- FAQ Item 4 -->
      <div class="border border-slate-200 rounded-lg">
        <button class="faq-question w-full px-6 py-4 text-left flex justify-between items-center hover:bg-slate-50 transition-colors">
          <span class="font-semibold text-slate-900">Is my data secure with mydialogform?</span>
          <svg class="w-5 h-5 text-slate-500 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
          </svg>
        </button>
        <div class="faq-answer hidden px-6 pb-4">
          <p class="text-slate-600">Security is our top priority. We use enterprise-grade encryption, SOC 2 compliance, and follow GDPR guidelines. All data is encrypted in transit and at rest. We never share your data with third parties, and you maintain full ownership of all responses and analytics.</p>
        </div>
      </div>
    </div>
  </div>
</section><!-- 
JavaScript for Landing Page Functionality -->
<% content_for :scripts do %>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Mobile Menu Toggle
      const mobileMenuButton = document.querySelector('.mobile-menu-button');
      const mobileMenu = document.querySelector('.mobile-menu');
      
      if (mobileMenuButton && mobileMenu) {
        mobileMenuButton.addEventListener('click', function() {
          mobileMenu.classList.toggle('hidden');
        });
      }
      
      // FAQ Toggle
      document.querySelectorAll('.faq-question').forEach(button => {
        button.addEventListener('click', function() {
          const answer = this.nextElementSibling;
          const icon = this.querySelector('svg');
          
          // Close all other FAQ items
          document.querySelectorAll('.faq-answer').forEach(otherAnswer => {
            if (otherAnswer !== answer && !otherAnswer.classList.contains('hidden')) {
              otherAnswer.classList.add('hidden');
              otherAnswer.previousElementSibling.querySelector('svg').classList.remove('rotate-180');
            }
          });
          
          // Toggle current FAQ item
          answer.classList.toggle('hidden');
          icon.classList.toggle('rotate-180');
        });
      });
      
      // Smooth scrolling for anchor links
      document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener('click', function (e) {
          e.preventDefault();
          const target = document.querySelector(this.getAttribute('href'));
          if (target) {
            target.scrollIntoView({
              behavior: 'smooth',
              block: 'start'
            });
            // Close mobile menu if open
            if (mobileMenu && !mobileMenu.classList.contains('hidden')) {
              mobileMenu.classList.add('hidden');
            }
          }
        });
      });
      
      // Add scroll effect to header
      const header = document.querySelector('header');
      if (header) {
        window.addEventListener('scroll', function() {
          if (window.scrollY > 10) {
            header.classList.add('shadow-md');
          } else {
            header.classList.remove('shadow-md');
          }
        });
      }
    });
  </script>
<% end %>
</file>

<file path="views/layouts/admin.html.erb">
<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-50">
  <head>
    <meta charset="utf-8">
    <title><%= content_for(:title) || "Admin Dashboard - mydialogform" %></title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    
    <%= csrf_meta_tags %>
    <%= csp_meta_tag %>
    <%= stylesheet_link_tag "tailwind", "data-turbo-track": "reload" %>
    <%= stylesheet_link_tag "application", "data-turbo-track": "reload" %>
    <%= javascript_importmap_tags %>
    <%= yield :head %>

    <!-- Favicon -->
    <link rel="icon" href="/icon.png" type="image/png">
    <link rel="icon" href="/icon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="/icon.png">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

    <%= stylesheet_link_tag :app, "data-turbo-track": "reload" %>
  </head>

  <body class="h-full bg-gray-50 font-sans antialiased">
    <div class="min-h-full">
      <!-- Admin Header -->
      <header class="bg-white shadow-sm border-b border-gray-200 fixed top-0 left-0 right-0 z-40 h-16">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div class="flex justify-between items-center h-16">
            <!-- Logo and admin indicator -->
            <div class="flex items-center space-x-4">
              <%= link_to admin_dashboard_path, class: "flex items-center space-x-2" do %>
                <div class="w-8 h-8 bg-gradient-to-br from-red-500 to-red-600 rounded-lg flex items-center justify-center">
                  <span class="text-white font-bold text-sm">M</span>
                </div>
                <span class="text-xl font-bold text-gray-900">mydialogform</span>
              <% end %>
              
              <div class="flex items-center space-x-2">
                <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800">
                  <svg class="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M18 8a6 6 0 01-7.743 5.743L10 14l-1 1-1 1H6v2H2v-4l4.257-4.257A6 6 0 1118 8zm-6-4a1 1 0 100 2 2 2 0 012 2 1 1 0 102 0 4 4 0 00-4-4z" clip-rule="evenodd" />
                  </svg>
                  Admin Panel
                </span>
              </div>
            </div>

            <!-- Admin Navigation -->
            <nav class="hidden md:flex md:space-x-8">
              <%= link_to "Dashboard", admin_dashboard_path, 
                  class: admin_nav_class(admin_dashboard_path) %>
              <%= link_to "Users", admin_users_path, 
                  class: admin_nav_class(admin_users_path) %>
              <%= link_to "Discount Codes", admin_discount_codes_path, 
                  class: admin_nav_class(admin_discount_codes_path) %>
              
              <!-- Notifications with counter -->
              <div class="relative">
                <%= link_to admin_notifications_path, 
                    class: "#{admin_nav_class(admin_notifications_path)} relative" do %>
                  Notifications
                  <% unread_count = AdminNotification.unread.count %>
                  <% if unread_count > 0 %>
                    <span id="nav-notification-counter" class="absolute -top-2 -right-2 inline-flex items-center justify-center px-2 py-1 text-xs font-bold leading-none text-white transform translate-x-1/2 -translate-y-1/2 bg-red-600 rounded-full">
                      <%= unread_count %>
                    </span>
                  <% end %>
                <% end %>
              </div>
            </nav>

            <!-- Admin user menu -->
            <div class="flex items-center space-x-4">
              <!-- Quick stats -->
              <div class="hidden lg:flex items-center space-x-4 text-sm text-gray-600">
                <span>Session: <%= time_ago_in_words(Time.at(session[:admin_last_activity] || Time.current.to_i)) %> ago</span>
              </div>

              <!-- User menu -->
              <div class="relative" data-controller="dropdown">
                <button type="button" 
                        class="flex items-center space-x-2 text-sm rounded-full focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2"
                        data-action="click->dropdown#toggle">
                  <div class="w-8 h-8 bg-red-100 rounded-full flex items-center justify-center">
                    <span class="text-red-600 font-medium text-sm">
                      <%= current_user.email.first.upcase %>
                    </span>
                  </div>
                  <span class="text-gray-700 font-medium hidden sm:inline"><%= current_user.email %></span>
                  <svg class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                  </svg>
                </button>
                
                <!-- Dropdown menu -->
                <div class="hidden absolute right-0 mt-2 w-48 bg-white rounded-md shadow-lg py-1 z-50"
                     data-dropdown-target="menu">
                  <%= link_to "Back to App", root_path, 
                      class: "block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" %>
                  <%= link_to "Profile", profile_path, 
                      class: "block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" %>
                  
                  <div class="border-t border-gray-100"></div>
                  <%= form_tag destroy_user_session_path, method: :delete, class: "block" do %>
                    <%= submit_tag "Sign out", class: "block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 bg-transparent border-none cursor-pointer" %>
                  <% end %>
                </div>
              </div>
            </div>
          </div>
        </div>
      </header>

      <!-- Main content area -->
      <div class="pt-16">
        <!-- Breadcrumb navigation -->
        <% if admin_breadcrumbs.length > 1 %>
          <nav class="bg-white border-b border-gray-200 px-4 sm:px-6 lg:px-8">
            <div class="max-w-7xl mx-auto">
              <div class="flex items-center space-x-2 py-3 text-sm">
                <% admin_breadcrumbs.each_with_index do |breadcrumb, index| %>
                  <% if index > 0 %>
                    <svg class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                    </svg>
                  <% end %>
                  
                  <% if breadcrumb[:path] && index < admin_breadcrumbs.length - 1 %>
                    <%= link_to breadcrumb[:name], breadcrumb[:path], 
                        class: "text-gray-500 hover:text-gray-700 transition-colors" %>
                  <% else %>
                    <span class="text-gray-900 font-medium"><%= breadcrumb[:name] %></span>
                  <% end %>
                <% end %>
              </div>
            </div>
          </nav>
        <% end %>

        <!-- Page content -->
        <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
          <!-- Page header -->
          <% if content_for?(:page_header) %>
            <div class="mb-8">
              <%= yield :page_header %>
            </div>
          <% end %>

          <!-- Main content -->
          <%= yield %>
        </main>
      </div>
    </div>

    <!-- Flash messages -->
    <% if flash.any? %>
      <div class="fixed top-20 right-4 z-50 space-y-2">
        <% flash.each do |type, message| %>
          <div class="bg-white border-l-4 <%= type.to_s == 'error' || type.to_s == 'alert' ? 'border-red-400' : 'border-green-400' %> p-4 shadow-lg rounded-r-lg max-w-sm animate-slide-in-up">
            <div class="flex">
              <div class="flex-shrink-0">
                <% if type.to_s == 'error' || type.to_s == 'alert' %>
                  <svg class="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
                  </svg>
                <% else %>
                  <svg class="h-5 w-5 text-green-400" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
                  </svg>
                <% end %>
              </div>
              <div class="ml-3">
                <p class="text-sm text-gray-700"><%= message %></p>
              </div>
              <div class="ml-auto pl-3">
                <button type="button" class="text-gray-400 hover:text-gray-600" onclick="this.parentElement.parentElement.parentElement.remove()">
                  <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                  </svg>
                </button>
              </div>
            </div>
          </div>
        <% end %>
      </div>
    <% end %>

    <!-- Loading overlay -->
    <div id="loading-overlay" class="hidden fixed inset-0 bg-gray-900 bg-opacity-50 z-50 flex items-center justify-center">
      <div class="bg-white rounded-lg p-6 flex items-center space-x-3">
        <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-red-600"></div>
        <span class="text-gray-900">Processing...</span>
      </div>
    </div>
  </body>
</html>
</file>

<file path="views/layouts/application.html.erb">
<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-50">
  <head>
    <meta charset="utf-8">
    <title><%= content_for(:title) || "mydialogform" %></title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    
    <%= csrf_meta_tags %>
    <%= csp_meta_tag %>
    <%= stylesheet_link_tag "tailwind", "data-turbo-track": "reload" %>

    <%= stylesheet_link_tag "application", "data-turbo-track": "reload" %>
    <%= javascript_importmap_tags %>
    <%= yield :head %>

    <%# Enable PWA manifest for installable apps %>
    <%#= tag.link rel: "manifest", href: pwa_manifest_path(format: :json) %>

    <!-- Favicon -->
    <link rel="icon" href="/icon.png" type="image/png">
    <link rel="icon" href="/icon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="/icon.png">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

  </head>

  <body class="h-full bg-gray-50 font-sans antialiased">
    <!-- Main application layout with header and sidebar -->
    <div class="min-h-full">
      <!-- Header Navigation -->
      <header class="bg-white shadow-sm border-b border-gray-200 fixed top-0 left-0 right-0 z-40 h-16">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div class="flex justify-between items-center h-16">
            <!-- Logo and brand -->
            <div class="flex items-center">
              <div class="flex-shrink-0">
                <%= link_to root_path, class: "flex items-center space-x-2" do %>
                  <div class="w-8 h-8 bg-gradient-to-br from-indigo-500 to-purple-600 rounded-lg flex items-center justify-center">
                    <span class="text-white font-bold text-sm">M</span>
                  </div>
                  <span class="text-xl font-bold text-gray-900">mydialogform</span>
                <% end %>
              </div>
              
              <!-- Navigation items -->
              <nav class="hidden md:ml-8 md:flex md:space-x-8">
                <%= link_to "Forms", forms_path, 
                    class: "text-gray-900 hover:text-indigo-600 px-3 py-2 text-sm font-medium transition-colors" %>
                <%= link_to "Blog", blogs_path, 
                    class: "text-gray-500 hover:text-indigo-600 px-3 py-2 text-sm font-medium transition-colors" %>
                <%= link_to "Analytics", "#", 
                    class: "text-gray-500 hover:text-indigo-600 px-3 py-2 text-sm font-medium transition-colors" %>
              </nav>
            </div>

            <!-- Right side items -->
            <div class="flex items-center space-x-4">
              <!-- Navigation links for authenticated users -->
              <% if user_signed_in? %>
                <!-- Tier indicator -->
                <div class="flex items-center space-x-2">
                  <span class="text-sm text-gray-600">Plan:</span>
                  <% if current_user.premium? %>
                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-purple-100 text-purple-800">
                      <svg class="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M5 2a1 1 0 011 1v1h1v1a1 1 0 001 1h1a1 1 0 001-1V4h1V3a1 1 0 011-1H5zm4 5H7a1 1 0 01-1-1V6a1 1 0 011-1h2a1 1 0 011 1v1a1 1 0 01-1 1zM5 9a1 1 0 011-1h2a1 1 0 110 2H6a1 1 0 01-1-1zm1 4a1 1 0 100 2h2a1 1 0 100-2H6a1 1 0 00-1 1z" clip-rule="evenodd" />
                      </svg>
                      Premium
                    </span>
                  <% else %>
                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800">
                      <svg class="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V7z" clip-rule="evenodd" />
                      </svg>
                      Basic
                    </span>
                  <% end %>
                </div>
                
                <!-- User menu -->
                <div class="relative" data-controller="dropdown">
                  <button type="button" 
                          class="flex items-center space-x-2 text-sm rounded-full focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
                          data-action="click->dropdown#toggle">
                    <div class="w-8 h-8 bg-indigo-100 rounded-full flex items-center justify-center">
                      <span class="text-indigo-600 font-medium text-sm">
                        <%= current_user.email.first.upcase %>
                      </span>
                    </div>
                    <span class="text-gray-700 font-medium hidden sm:inline"><%= current_user.email %></span>
                    <svg class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                  </button>
                  
                  <!-- Dropdown menu -->
                  <div class="hidden absolute right-0 mt-2 w-48 bg-white rounded-md shadow-lg py-1 z-50"
                       data-dropdown-target="menu">
                    <%= link_to "Profile", profile_path, 
                        class: "block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" %>
                    <%= link_to "Settings", "#", 
                        class: "block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" %>
                    
                    <% if current_user.premium? %>
                      <div class="border-t border-gray-100"></div>
                      <%= link_to stripe_settings_path, 
                          class: "block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" do %>
                        <div class="flex items-center">
                          <svg class="w-4 h-4 mr-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h18M7 15h1m4 0h1m-7 4h12a3 3 0 003-3V8a3 3 0 00-3-3H6a3 3 0 00-3 3v8a3 3 0 003 3z"></path>
                          </svg>
                          Payment Settings
                          <% unless current_user.stripe_configured? %>
                            <span class="ml-auto w-2 h-2 bg-amber-400 rounded-full"></span>
                          <% end %>
                        </div>
                      <% end %>
                      
                      <%= link_to subscription_management_path, 
                          class: "block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" do %>
                        <div class="flex items-center">
                          <svg class="w-4 h-4 mr-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                          </svg>
                          Subscription
                          <% if current_user.subscription_expires_soon? %>
                            <span class="ml-auto w-2 h-2 bg-red-400 rounded-full"></span>
                          <% elsif current_user.subscription_canceling? %>
                            <span class="ml-auto w-2 h-2 bg-yellow-400 rounded-full"></span>
                          <% end %>
                        </div>
                      <% end %>
                    <% else %>
                      <div class="border-t border-gray-100"></div>
                      <%= link_to subscription_management_path, 
                          class: "block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" do %>
                        <div class="flex items-center">
                          <svg class="w-4 h-4 mr-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                          </svg>
                          Upgrade to Premium
                        </div>
                      <% end %>
                    <% end %>
                    
                    <div class="border-t border-gray-100"></div>
                    <%= form_tag destroy_user_session_path, method: :delete, class: "block" do %>
                      <%= submit_tag "Sign out", class: "block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 bg-transparent border-none cursor-pointer" %>
                    <% end %>
                  </div>
                </div>
              <% else %>
                <nav class="hidden md:flex md:space-x-4">
                  <%= link_to "Sign in", new_user_session_path, 
                      class: "text-gray-500 hover:text-indigo-600 px-3 py-2 text-sm font-medium transition-colors" %>
                  <%= link_to "Sign up", new_user_registration_path, 
                      class: "bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-2 text-sm font-medium rounded-md transition-colors" %>
                </nav>
                
                <!-- Mobile menu button -->
                <div class="md:hidden flex items-center space-x-2">
                  <%= link_to "Blog", blogs_path, 
                      class: "text-gray-500 hover:text-indigo-600 px-3 py-2 text-sm font-medium" %>
                  <span class="text-gray-300">|</span>
                  <%= link_to "Sign in", new_user_session_path, 
                      class: "text-gray-500 hover:text-indigo-600 px-3 py-2 text-sm font-medium" %>
                  <span class="text-gray-300">|</span>
                  <%= link_to "Sign up", new_user_registration_path, 
                      class: "text-indigo-600 hover:text-indigo-700 px-3 py-2 text-sm font-medium" %>
                </div>
              <% end %>
            </div>
          </div>
        </div>
      </header>

      <!-- Main content area -->
      <div class="pt-16">
        <!-- Sidebar (if content_for :sidebar is provided) -->
        <% if content_for?(:sidebar) %>
          <div class="flex">
            <aside class="w-64 bg-white border-r border-gray-200 min-h-screen">
              <%= yield :sidebar %>
            </aside>
            <main class="flex-1 bg-gray-50">
              <%= yield %>
            </main>
          </div>
        <% else %>
          <!-- Full width content -->
          <main class="bg-gray-50 min-h-screen">
            <%= yield %>
          </main>
        <% end %>
      </div>
    </div>

    <!-- Flash messages -->
    <% if flash.any? %>
      <div class="fixed top-20 right-4 z-50 space-y-2">
        <% flash.each do |type, message| %>
          <div class="bg-white border-l-4 <%= type.to_s == 'error' || type.to_s == 'alert' ? 'border-red-400' : 'border-green-400' %> p-4 shadow-lg rounded-r-lg max-w-sm animate-slide-in-up">
            <div class="flex">
              <div class="flex-shrink-0">
                <% if type.to_s == 'error' || type.to_s == 'alert' %>
                  <svg class="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
                  </svg>
                <% else %>
                  <svg class="h-5 w-5 text-green-400" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
                  </svg>
                <% end %>
              </div>
              <div class="ml-3">
                <p class="text-sm text-gray-700"><%= message %></p>
              </div>
              <div class="ml-auto pl-3">
                <button type="button" class="text-gray-400 hover:text-gray-600" onclick="this.parentElement.parentElement.parentElement.remove()">
                  <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                  </svg>
                </button>
              </div>
            </div>
          </div>
        <% end %>
      </div>
    <% end %>

    <!-- Loading overlay -->
    <div id="loading-overlay" class="hidden fixed inset-0 bg-gray-900 bg-opacity-50 z-50 flex items-center justify-center">
      <div class="bg-white rounded-lg p-6 flex items-center space-x-3">
        <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-indigo-600"></div>
        <span class="text-gray-900">Processing...</span>
      </div>
    </div>
  </body>
</html>
</file>

<file path="views/layouts/devise.html.erb">
<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-50">
  <head>
    <meta charset="utf-8">
    <title><%= content_for(:title) || "mydialogform" %></title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    
    <%= csrf_meta_tags %>
    <%= csp_meta_tag %>

    <%= yield :head %>

    <!-- Favicon -->
    <link rel="icon" href="/icon.png" type="image/png">
    <link rel="icon" href="/icon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="/icon.png">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

    <%# Includes all stylesheet files in app/assets/stylesheets %>
    <%= stylesheet_link_tag :app, "data-turbo-track": "reload" %>
    <%= javascript_importmap_tags %>
  </head>

  <body class="h-full bg-gray-50 font-sans antialiased">
    <%= yield %>

    <!-- Flash messages -->
    <% if flash.any? %>
      <div class="fixed top-4 right-4 z-50 space-y-2">
        <% flash.each do |type, message| %>
          <div class="bg-white border-l-4 <%= type.to_s == 'error' || type.to_s == 'alert' ? 'border-red-400' : 'border-green-400' %> p-4 shadow-lg rounded-r-lg max-w-sm">
            <div class="flex">
              <div class="flex-shrink-0">
                <% if type.to_s == 'error' || type.to_s == 'alert' %>
                  <svg class="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
                  </svg>
                <% else %>
                  <svg class="h-5 w-5 text-green-400" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
                  </svg>
                <% end %>
              </div>
              <div class="ml-3">
                <p class="text-sm text-gray-700"><%= message %></p>
              </div>
            </div>
          </div>
        <% end %>
      </div>
    <% end %>
  </body>
</html>
</file>

<file path="views/layouts/error.html.erb">
<!DOCTYPE html>
<html>
  <head>
    <title>AgentForm - Error</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <%= csrf_meta_tags %>
    <%= csp_meta_tag %>
    
    <%= stylesheet_link_tag "application", "data-turbo-track": "reload" %>
    <%= javascript_importmap_tags %>
  </head>

  <body class="bg-gray-50 min-h-screen flex items-center justify-center">
    <div class="max-w-md w-full mx-auto">
      <div class="text-center">
        <%= yield %>
        
        <div class="mt-8">
          <%= link_to " Back to AgentForm", root_path, 
                      class: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" %>
        </div>
      </div>
    </div>
  </body>
</html>
</file>

<file path="views/layouts/form_builder.html.erb">
<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-50">
  <head>
    <meta charset="utf-8">
    <title><%= content_for(:title) || "Form Builder" %> | mydialogform</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    
    <%= csrf_meta_tags %>
    <%= csp_meta_tag %>

    <%= yield :head %>

    <!-- Favicon -->
    <link rel="icon" href="/icon.png" type="image/png">
    <link rel="icon" href="/icon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="/icon.png">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

    <%# Includes all stylesheet files in app/assets/stylesheets %>
    <%= stylesheet_link_tag :app, "data-turbo-track": "reload" %>
    <%= javascript_importmap_tags %>
  </head>

  <body class="h-full bg-gray-50 font-sans antialiased" data-controller="form-builder debug" data-action="turbo:before-stream-render@document->debug#turboStreamReceived">
    <!-- Form Builder Layout -->
    <div class="h-full flex flex-col">
      <!-- Header -->
      <header class="bg-white shadow-sm border-b border-gray-200 h-16 flex-shrink-0">
        <div class="h-full px-4 sm:px-6 lg:px-8">
          <div class="flex justify-between items-center h-full">
            <!-- Left side - Logo and form info -->
            <div class="flex items-center space-x-4">
              <!-- Back to dashboard -->
              <%= link_to forms_path, class: "flex items-center space-x-2 text-gray-500 hover:text-gray-900 transition-colors" do %>
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                </svg>
                <span class="text-sm font-medium">Back to Forms</span>
              <% end %>
              
              <!-- Form title -->
              <div class="border-l border-gray-300 pl-4">
                <h1 class="text-lg font-semibold text-gray-900">
                  <%= @form&.name || "Untitled Form" %>
                </h1>
                <p class="text-sm text-gray-500">
                  <%= @form&.status&.humanize || "Draft" %>  
                  <%= pluralize(@form&.form_questions&.count || 0, 'question') %>
                </p>
              </div>
            </div>

            <!-- Center - View mode toggle -->
            <div class="flex items-center bg-gray-100 rounded-lg p-1">
              <button type="button" 
                      class="px-3 py-1 text-sm font-medium rounded-md transition-colors bg-white text-gray-900 shadow-sm"
                      data-action="click->form-builder#switchToBuilder">
                Builder
              </button>
              <button type="button" 
                      class="px-3 py-1 text-sm font-medium rounded-md transition-colors text-gray-500 hover:text-gray-900"
                      data-action="click->form-builder#switchToPreview">
                Preview
              </button>
            </div>

            <!-- Right side - Actions -->
            <div class="flex items-center space-x-3">
              <!-- Save status -->
              <div class="flex items-center space-x-2 text-sm text-gray-500">
                <div class="w-2 h-2 bg-green-400 rounded-full" data-form-builder-target="saveIndicator"></div>
                <span data-form-builder-target="saveStatus">Saved</span>
              </div>

              <!-- Action buttons -->
              <div class="flex items-center space-x-2">
                <%= link_to "Preview", "#", 
                    class: "px-3 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors",
                    data: { action: "click->form-builder#openPreview" } %>
                
                <% if @form&.persisted? %>
                  <%= link_to "Publish", publish_form_path(@form), method: :patch,
                      class: "px-4 py-2 text-sm font-medium text-white bg-gradient-to-r from-indigo-500 to-purple-600 rounded-lg hover:opacity-90 transition-opacity",
                      data: { confirm: "Are you sure you want to publish this form?" } %>
                <% else %>
                  <button type="button" 
                          class="px-4 py-2 text-sm font-medium text-white bg-gradient-to-r from-indigo-500 to-purple-600 rounded-lg hover:opacity-90 transition-opacity"
                          data-action="click->form-builder#saveAndPublish">
                    Save & Publish
                  </button>
                <% end %>
              </div>

              <!-- User menu -->
              <div class="relative" data-controller="dropdown">
                <button type="button" 
                        class="flex items-center space-x-2 text-sm rounded-full focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
                        data-action="click->dropdown#toggle">
                  <div class="w-8 h-8 bg-indigo-100 rounded-full flex items-center justify-center">
                    <span class="text-indigo-600 font-medium text-sm">
                      <%= current_user&.email&.first&.upcase || "U" %>
                    </span>
                  </div>
                </button>
                
                <!-- Dropdown menu -->
                <div class="hidden absolute right-0 mt-2 w-48 bg-white rounded-md shadow-lg py-1 z-50"
                     data-dropdown-target="menu">
                  <%= link_to "Dashboard", root_path, 
                      class: "block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" %>
                  <%= link_to "Settings", "#", 
                      class: "block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" %>
                  <div class="border-t border-gray-100"></div>
                  <%= link_to "Sign out", destroy_user_session_path, method: :delete,
                      class: "block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" %>
                </div>
              </div>
            </div>
          </div>
        </div>
      </header>

      <!-- Main content area -->
      <div class="flex-1 flex overflow-hidden">
        <!-- Sidebar - Question palette and configuration -->
        <aside class="w-80 bg-white border-r border-gray-200 flex flex-col">
          <%= yield :sidebar %>
        </aside>

        <!-- Main canvas area -->
        <main class="flex-1 bg-gray-50 overflow-auto">
          <div class="max-w-4xl mx-auto p-6">
            <%= yield %>
          </div>
        </main>

        <!-- Right panel - Question configuration (if needed) -->
        <% if content_for?(:right_panel) %>
          <aside class="w-80 bg-white border-l border-gray-200 flex flex-col">
            <%= yield :right_panel %>
          </aside>
        <% end %>
      </div>
    </div>

    <!-- Flash messages -->
    <div id="flash-messages">
      <% if flash.any? %>
        <div class="fixed top-20 right-4 z-50 space-y-2">
          <% flash.each do |type, message| %>
          <div class="bg-white border-l-4 <%= type.to_s == 'error' || type.to_s == 'alert' ? 'border-red-400' : 'border-green-400' %> p-4 shadow-lg rounded-r-lg max-w-sm animate-slide-in-up">
            <div class="flex">
              <div class="flex-shrink-0">
                <% if type.to_s == 'error' || type.to_s == 'alert' %>
                  <svg class="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
                  </svg>
                <% else %>
                  <svg class="h-5 w-5 text-green-400" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
                  </svg>
                <% end %>
              </div>
              <div class="ml-3">
                <p class="text-sm text-gray-700"><%= message %></p>
              </div>
              <div class="ml-auto pl-3">
                <button type="button" class="text-gray-400 hover:text-gray-600" onclick="this.parentElement.parentElement.parentElement.remove()">
                  <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                  </svg>
                </button>
              </div>
            </div>
          </div>
          <% end %>
        </div>
      <% end %>
    </div>

    <!-- Loading overlay -->
    <div id="loading-overlay" class="hidden fixed inset-0 bg-gray-900 bg-opacity-50 z-50 flex items-center justify-center">
      <div class="bg-white rounded-lg p-6 flex items-center space-x-3">
        <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-indigo-600"></div>
        <span class="text-gray-900">Building form...</span>
      </div>
    </div>

    <!-- AI Processing indicator -->
    <div id="ai-processing" class="hidden fixed bottom-4 right-4 bg-white border border-purple-200 rounded-lg p-4 shadow-lg z-40">
      <div class="flex items-center space-x-3">
        <div class="flex space-x-1">
          <div class="w-2 h-2 bg-purple-500 rounded-full animate-pulse"></div>
          <div class="w-2 h-2 bg-purple-500 rounded-full animate-pulse" style="animation-delay: 0.2s;"></div>
          <div class="w-2 h-2 bg-purple-500 rounded-full animate-pulse" style="animation-delay: 0.4s;"></div>
        </div>
        <span class="text-sm text-gray-700">AI is thinking...</span>
      </div>
    </div>
  </body>
</html>
</file>

<file path="views/layouts/form_response.html.erb">
<!DOCTYPE html>
<html lang="en" class="h-full">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title><%= @form&.name || "Form" %> | mydialogform</title>
    <meta name="description" content="<%= @form&.description %>">
    
    <%= csrf_meta_tags %>
    <%= csp_meta_tag %>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    
    <%= stylesheet_link_tag "application", "data-turbo-track": "reload" %>
    <%= javascript_importmap_tags %>
    
    <!-- Custom form styling -->
    <% if @form&.style_configuration.present? %>
      <style>
        :root {
          <% if @form.style_configuration['primary_color'] %>
            --primary-color: <%= @form.style_configuration['primary_color'] %>;
          <% end %>
          <% if @form.style_configuration['accent_color'] %>
            --accent-color: <%= @form.style_configuration['accent_color'] %>;
          <% end %>
          <% if @form.style_configuration['background_color'] %>
            --background-color: <%= @form.style_configuration['background_color'] %>;
          <% end %>
        }
        
        <% if @form.style_configuration['custom_css'] %>
          <%= raw @form.style_configuration['custom_css'] %>
        <% end %>
      </style>
    <% end %>
    
    <!-- Font loading -->
    <% if @form&.style_configuration&.dig('font_family') && @form.style_configuration['font_family'] != 'Inter' %>
      <link href="https://fonts.googleapis.com/css2?family=<%= @form.style_configuration['font_family'] %>:wght@300;400;500;600;700&display=swap" rel="stylesheet">
      <style>
        body { font-family: '<%= @form.style_configuration['font_family'] %>', 'Inter', sans-serif; }
      </style>
    <% end %>
  </head>

  <body class="h-full bg-gray-50 font-sans antialiased" 
        data-controller="form-response"
        data-form-response-form-id-value="<%= @form&.id %>"
        data-form-response-session-id-value="<%= session[:form_session_id] %>"
        style="<%= "background-color: var(--background-color);" if @form&.style_configuration&.dig('background_color') %>">
    
    <!-- Progress bar (if enabled and not in preview mode) -->
    <% unless @preview_mode || @form&.form_settings&.dig('hide_progress_bar') %>
      <div class="fixed top-0 left-0 right-0 z-50 bg-white border-b border-gray-200">
        <div class="h-1 bg-gray-200">
          <div class="h-full bg-gradient-to-r from-indigo-500 to-purple-600 transition-all duration-500 ease-out" 
               style="width: <%= @progress_percentage || 0 %>%"
               data-form-response-target="progressBar"></div>
        </div>
      </div>
    <% end %>
    
    <!-- Main content -->
    <div class="min-h-full flex flex-col justify-center py-12 sm:px-6 lg:px-8" 
         style="<%= 'padding-top: 4rem;' unless @preview_mode || @form&.form_settings&.dig('hide_progress_bar') %>">
      
      <!-- Form header (if logo or branding is configured) -->
      <% if @form&.style_configuration&.dig('show_logo') && @form.style_configuration['logo_url'] %>
        <div class="sm:mx-auto sm:w-full sm:max-w-md mb-8 animate-fade-in">
          <div class="text-center">
            <img class="mx-auto h-12 w-auto" 
                 src="<%= @form.style_configuration['logo_url'] %>" 
                 alt="<%= @form.name %>"
                 loading="lazy">
          </div>
        </div>
      <% end %>
      
      <!-- Main form container -->
      <div class="sm:mx-auto sm:w-full sm:max-w-2xl animate-slide-in-up">
        <div class="bg-white py-8 px-4 shadow-lg sm:rounded-xl sm:px-10 border border-gray-100">
          <%= yield %>
        </div>
      </div>
      
      <!-- Footer -->
      <div class="mt-8 text-center animate-fade-in">
        <% unless @form&.form_settings&.dig('hide_branding') %>
          <p class="text-sm text-gray-500">
            Powered by 
            <a href="https://mydialogform.com" 
               class="text-indigo-600 hover:text-indigo-500 transition-colors font-medium" 
               target="_blank">
              mydialogform
            </a>
          </p>
        <% end %>
      </div>
    </div>
    
    <!-- Loading overlay -->
    <div id="loading-overlay" 
         class="hidden fixed inset-0 bg-gray-900 bg-opacity-50 z-50 flex items-center justify-center"
         data-form-response-target="loadingOverlay">
      <div class="bg-white rounded-xl p-6 flex items-center space-x-3 shadow-2xl">
        <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-indigo-600"></div>
        <span class="text-gray-900 font-medium">Processing your response...</span>
      </div>
    </div>
    
    <!-- AI Processing indicator -->
    <div id="ai-processing" 
         class="hidden fixed bottom-4 right-4 bg-white border border-purple-200 rounded-xl p-4 shadow-lg z-40"
         data-form-response-target="aiProcessing">
      <div class="flex items-center space-x-3">
        <div class="flex space-x-1">
          <div class="w-2 h-2 bg-purple-500 rounded-full animate-pulse"></div>
          <div class="w-2 h-2 bg-purple-500 rounded-full animate-pulse" style="animation-delay: 0.2s;"></div>
          <div class="w-2 h-2 bg-purple-500 rounded-full animate-pulse" style="animation-delay: 0.4s;"></div>
        </div>
        <span class="text-sm text-gray-700 font-medium">AI is analyzing your response...</span>
      </div>
    </div>
    
    <!-- Flash messages -->
    <% if flash.any? %>
      <div class="fixed top-4 right-4 z-50 space-y-2">
        <% flash.each do |type, message| %>
          <div class="bg-white border-l-4 <%= type.to_s == 'error' || type.to_s == 'alert' ? 'border-red-400' : 'border-green-400' %> p-4 shadow-lg rounded-r-xl max-w-sm animate-slide-in-up">
            <div class="flex">
              <div class="flex-shrink-0">
                <% if type.to_s == 'error' || type.to_s == 'alert' %>
                  <svg class="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
                  </svg>
                <% else %>
                  <svg class="h-5 w-5 text-green-400" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
                  </svg>
                <% end %>
              </div>
              <div class="ml-3">
                <p class="text-sm text-gray-700"><%= message %></p>
              </div>
              <div class="ml-auto pl-3">
                <button type="button" 
                        class="text-gray-400 hover:text-gray-600 transition-colors" 
                        onclick="this.parentElement.parentElement.parentElement.remove()">
                  <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                  </svg>
                </button>
              </div>
            </div>
          </div>
        <% end %>
      </div>
    <% end %>

    <!-- Conversational bubbles container (for AI interactions) -->
    <div id="conversation-bubbles" 
         class="fixed bottom-4 left-4 space-y-3 max-w-sm z-30"
         data-form-response-target="conversationBubbles">
      <!-- AI and user response bubbles will be dynamically inserted here -->
    </div>
  </body>
</html>
</file>

<file path="views/layouts/landing.html.erb">
<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- SEO Meta Tags -->
    <title><%= content_for(:title) || "mydialogform - Build Forms That Think, Not Just Collect" %></title>
    <meta name="description" content="Create intelligent, AI-powered forms that adapt, analyze, and automate your business processes. Transform data collection into intelligent conversations.">
    <meta name="keywords" content="AI forms, intelligent forms, form builder, conversational forms, lead qualification, form automation">
    <meta name="author" content="mydialogform">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://mydialogform.com/">
    <meta property="og:title" content="mydialogform - Intelligent Form Builder">
    <meta property="og:description" content="Create intelligent, AI-powered forms that adapt, analyze, and automate your business processes.">
    <meta property="og:image" content="https://mydialogform.com/og-image.jpg">
    <meta property="og:site_name" content="mydialogform">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://mydialogform.com/">
    <meta property="twitter:title" content="mydialogform - Intelligent Form Builder">
    <meta property="twitter:description" content="Create intelligent, AI-powered forms that adapt, analyze, and automate your business processes.">
    <meta property="twitter:image" content="https://mydialogform.com/og-image.jpg">

    <!-- Rails Meta Tags -->
    <%= csrf_meta_tags %>
    <%= csp_meta_tag %>
    
    <!-- Stylesheets -->
    <%= stylesheet_link_tag "tailwind", "data-turbo-track": "reload" %>
    <%= stylesheet_link_tag "application", "data-turbo-track": "reload" %>
    
    <!-- JavaScript -->
    <%= javascript_importmap_tags %>
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="icon" href="/icon.png" type="image/png">
    <link rel="icon" href="/icon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="/icon.png">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    
    <!-- Tailwind CSS CDN for development -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Additional head content -->
    <%= yield :head %>
  </head>

  <body class="text-slate-800 antialiased">
    <!-- Flash messages -->
    <%= render 'shared/flash_message' if notice || alert %>
    
    <!-- Main content -->
    <main>
      <%= yield %>
    </main>
    
    <!-- Additional scripts -->
    <%= yield :scripts %>
  </body>
</html>
</file>

<file path="views/layouts/mailer.html.erb">
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <style>
      /* Email styles */
      body {
        font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        font-size: 16px;
        line-height: 1.6;
        color: #333333;
        background-color: #f8fafc;
        margin: 0;
        padding: 0;
      }
      
      .email-container {
        max-width: 600px;
        margin: 0 auto;
        background-color: #ffffff;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      
      .email-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 30px;
        text-align: center;
      }
      
      .email-header h1 {
        margin: 0;
        font-size: 28px;
        font-weight: 700;
      }
      
      .email-body {
        padding: 40px 30px;
      }
      
      .email-footer {
        background-color: #f1f5f9;
        padding: 20px 30px;
        text-align: center;
        font-size: 14px;
        color: #6b7280;
      }
      
      .btn {
        display: inline-block;
        padding: 12px 24px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        text-decoration: none;
        border-radius: 6px;
        font-weight: 600;
        margin: 20px 0;
      }
      
      .btn:hover {
        opacity: 0.9;
      }
      
      .highlight {
        background-color: #f0f9ff;
        border-left: 4px solid #3b82f6;
        padding: 16px;
        margin: 20px 0;
        border-radius: 4px;
      }
      
      .warning {
        background-color: #fef3c7;
        border-left: 4px solid #f59e0b;
        padding: 16px;
        margin: 20px 0;
        border-radius: 4px;
      }
    </style>
  </head>

  <body>
    <div class="email-container">
      <div class="email-header">
        <h1>mydialogform</h1>
      </div>
      
      <div class="email-body">
        <%= yield %>
      </div>
      
      <div class="email-footer">
        <p>
          Este email fue enviado por mydialogform<br>
          Si tienes preguntas, responde a este email o visita nuestro centro de ayuda.
        </p>
        <p>
          <small> <%= Date.current.year %> mydialogform. Todos los derechos reservados.</small>
        </p>
      </div>
    </div>
  </body>
</html>
</file>

<file path="views/layouts/mailer.text.erb">
AGENTFORM
========

<%= yield %>

---
Este email fue enviado por AgentForm
Si tienes preguntas, responde a este email o visita nuestro centro de ayuda.

 <%= Date.current.year %> AgentForm. Todos los derechos reservados.
</file>

<file path="views/layouts/public_form.html.erb">
<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-50">
  <head>
    <meta charset="utf-8">
    <title><%= content_for(:title) || "mydialogform" %></title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    
    <%= csrf_meta_tags %>
    <%= csp_meta_tag %>
    
    <%= stylesheet_link_tag "tailwind", "data-turbo-track": "reload" %>
    <%= stylesheet_link_tag "application", "data-turbo-track": "reload" %>
    <%= javascript_importmap_tags %>
    <%= yield :head %>

    <!-- Preconnect to external domains -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

    <style>
      .bg-ai-gradient {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      }
      
      .animate-slide-in-up {
        animation: slide-in-up 0.3s ease-out;
      }
      
      @keyframes slide-in-up {
        from {
          transform: translateY(-10px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }
    </style>
  </head>

  <body class="h-full bg-gray-50 font-sans antialiased">
    <!-- Clean, minimal layout for public forms -->
    <div class="min-h-full">
      <!-- Form header with branding -->
      <header class="bg-white shadow-sm border-b border-gray-200">
        <div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
          <div class="flex items-center justify-between">
            <div class="flex items-center space-x-2">
              <div class="w-8 h-8 bg-gradient-to-br from-indigo-500 to-purple-600 rounded-lg flex items-center justify-center">
                <span class="text-white font-bold text-sm">M</span>
              </div>
              <span class="text-xl font-bold text-gray-900">mydialogform</span>
            </div>
            <div class="text-sm text-gray-500">
              <%= "Powered by AI" if @form&.ai_enhanced? %>
            </div>
          </div>
        </div>
      </header>

      <!-- Main content -->
      <main class="py-8">
        <div class="max-w-2xl mx-auto px-4 sm:px-6 lg:px-8">
          <%= yield %>
        </div>
      </main>

      <!-- Footer -->
      <footer class="bg-white border-t border-gray-200 mt-16">
        <div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
          <div class="flex items-center justify-between text-sm text-gray-500">
            <span> <%= Date.current.year %> mydialogform. All rights reserved.</span>
            <span>Powered by SuperAgent AI</span>
          </div>
        </div>
      </footer>
    </div>

    <!-- Flash messages -->
    <% if flash.any? %>
      <div class="fixed top-20 right-4 z-50 space-y-2">
        <% flash.each do |type, message| %>
          <div class="bg-white border-l-4 <%= type.to_s == 'error' || type.to_s == 'alert' ? 'border-red-400' : 'border-green-400' %> p-4 shadow-lg rounded-r-lg max-w-sm animate-slide-in-up">
            <div class="flex">
              <div class="flex-shrink-0">
                <% if type.to_s == 'error' || type.to_s == 'alert' %>
                  <svg class="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
                  </svg>
                <% else %>
                  <svg class="h-5 w-5 text-green-400" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
                  </svg>
                <% end %>
              </div>
              <div class="ml-3">
                <p class="text-sm text-gray-700"><%= message %></p>
              </div>
              <div class="ml-auto pl-3">
                <button type="button" class="text-gray-400 hover:text-gray-600" onclick="this.parentElement.parentElement.parentElement.remove()">
                  <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                  </svg>
                </button>
              </div>
            </div>
          </div>
        <% end %>
      </div>
    <% end %>

    <!-- Loading overlay -->
    <div id="loading-overlay" class="hidden fixed inset-0 bg-gray-900 bg-opacity-50 z-50 flex items-center justify-center">
      <div class="bg-white rounded-lg p-6 flex items-center space-x-3">
        <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-indigo-600"></div>
        <span class="text-gray-900">Processing...</span>
      </div>
    </div>
  </body>
</html>
</file>

<file path="views/payment_setup/index.html.erb">
<%# Payment Setup Guide Page %>
<div class="min-h-screen bg-gray-50 py-8">
  <div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8">
    <!-- Header -->
    <div class="text-center mb-8">
      <div class="flex justify-center mb-4">
        <div class="w-16 h-16 bg-gradient-to-r from-purple-600 to-indigo-600 rounded-full flex items-center justify-center">
          <svg class="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 20 20">
            <path d="M4 4a2 2 0 00-2 2v1h16V6a2 2 0 00-2-2H4zM18 9H2v5a2 2 0 002 2h12a2 2 0 002-2V9zM4 13a1 1 0 011-1h1a1 1 0 110 2H5a1 1 0 01-1-1zm5-1a1 1 0 100 2h1a1 1 0 100-2H9z"></path>
          </svg>
        </div>
      </div>
      <h1 class="text-3xl font-bold text-gray-900 mb-2">Payment Setup</h1>
      <p class="text-lg text-gray-600">
        <% if @template %>
          Complete the setup to use the "<%= @template.name %>" template
        <% else %>
          Set up payment processing for your forms
        <% end %>
      </p>
    </div>

    <!-- Template Context (if applicable) -->
    <% if @template %>
      <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-6 mb-8">
        <div class="flex items-start space-x-4">
          <div class="flex-shrink-0 w-12 h-12 bg-gradient-to-br from-purple-500 to-indigo-600 rounded-lg flex items-center justify-center">
            <svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 20 20">
              <path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z"></path>
              <path fill-rule="evenodd" d="M4 5a2 2 0 012-2v1a1 1 0 001 1h6a1 1 0 001-1V3a2 2 0 012 2v6a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z" clip-rule="evenodd"></path>
            </svg>
          </div>
          <div class="flex-1">
            <h3 class="text-lg font-semibold text-gray-900 mb-1"><%= @template.name %></h3>
            <p class="text-gray-600 mb-3"><%= @template.description %></p>
            <div class="flex items-center space-x-4 text-sm text-gray-500">
              <span class="flex items-center">
                <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
                  <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd"></path>
                </svg>
                <%= @template.estimated_time_minutes %> minutes
              </span>
              <span class="px-2 py-1 bg-purple-100 text-purple-800 rounded-full text-xs font-medium">
                <%= @template.setup_complexity.humanize %> Setup
              </span>
            </div>
          </div>
        </div>
      </div>
    <% end %>

    <!-- Setup Progress -->
    <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-6 mb-8">
      <div class="flex items-center justify-between mb-4">
        <h2 class="text-xl font-semibold text-gray-900">Setup Progress</h2>
        <div class="flex items-center space-x-2">
          <div class="w-32 bg-gray-200 rounded-full h-2">
            <div class="bg-gradient-to-r from-purple-600 to-indigo-600 h-2 rounded-full transition-all duration-300" 
                 style="width: <%= @setup_status[:setup_completion_percentage] %>%"></div>
          </div>
          <span class="text-sm font-medium text-gray-600">
            <%= @setup_status[:setup_completion_percentage] %>%
          </span>
        </div>
      </div>

      <!-- Setup Steps -->
      <div class="space-y-4">
        <!-- Stripe Configuration -->
        <div class="flex items-start space-x-4 p-4 rounded-lg <%= @setup_status[:stripe_configured] ? 'bg-green-50 border border-green-200' : 'bg-gray-50 border border-gray-200' %>">
          <div class="flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center <%= @setup_status[:stripe_configured] ? 'bg-green-100' : 'bg-gray-100' %>">
            <% if @setup_status[:stripe_configured] %>
              <svg class="w-5 h-5 text-green-600" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
              </svg>
            <% else %>
              <span class="text-sm font-medium text-gray-600">1</span>
            <% end %>
          </div>
          <div class="flex-1">
            <h3 class="font-medium text-gray-900 mb-1">
              Stripe Payment Configuration
              <% if @setup_status[:stripe_configured] %>
                <span class="ml-2 inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-green-100 text-green-800">
                  Complete
                </span>
              <% end %>
            </h3>
            <p class="text-sm text-gray-600 mb-3">
              Connect your Stripe account to accept payments through forms
            </p>
            <% unless @setup_status[:stripe_configured] %>
              <%= link_to stripe_settings_path, 
                  class: "inline-flex items-center px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-transparent rounded-lg hover:bg-blue-700 transition-colors" do %>
                <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
                  <path fill-rule="evenodd" d="M10.293 3.293a1 1 0 011.414 0l6 6a1 1 0 010 1.414l-6 6a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-4.293-4.293a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                </svg>
                Configure Stripe
              <% end %>
            <% end %>
          </div>
        </div>

        <!-- Premium Subscription -->
        <div class="flex items-start space-x-4 p-4 rounded-lg <%= @setup_status[:premium_subscription] ? 'bg-green-50 border border-green-200' : 'bg-gray-50 border border-gray-200' %>">
          <div class="flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center <%= @setup_status[:premium_subscription] ? 'bg-green-100' : 'bg-gray-100' %>">
            <% if @setup_status[:premium_subscription] %>
              <svg class="w-5 h-5 text-green-600" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
              </svg>
            <% else %>
              <span class="text-sm font-medium text-gray-600">2</span>
            <% end %>
          </div>
          <div class="flex-1">
            <h3 class="font-medium text-gray-900 mb-1">
              Premium Subscription
              <% if @setup_status[:premium_subscription] %>
                <span class="ml-2 inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-green-100 text-green-800">
                  Active
                </span>
              <% end %>
            </h3>
            <p class="text-sm text-gray-600 mb-3">
              Upgrade to Premium to unlock payment features and advanced functionality
            </p>
            <% unless @setup_status[:premium_subscription] %>
              <%= link_to subscription_management_path, 
                  class: "inline-flex items-center px-4 py-2 text-sm font-medium text-white bg-purple-600 border border-transparent rounded-lg hover:bg-purple-700 transition-colors" do %>
                <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
                  <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path>
                </svg>
                Upgrade to Premium
              <% end %>
            <% end %>
          </div>
        </div>
      </div>
    </div>

    <!-- Benefits Section -->
    <div class="bg-gradient-to-r from-purple-50 to-indigo-50 rounded-xl border border-purple-200 p-8 mb-8">
      <h2 class="text-xl font-semibold text-gray-900 mb-4">What You'll Get</h2>
      <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div class="flex items-start space-x-3">
          <svg class="w-6 h-6 text-purple-600 flex-shrink-0 mt-1" fill="currentColor" viewBox="0 0 20 20">
            <path d="M4 4a2 2 0 00-2 2v1h16V6a2 2 0 00-2-2H4zM18 9H2v5a2 2 0 002 2h12a2 2 0 002-2V9zM4 13a1 1 0 011-1h1a1 1 0 110 2H5a1 1 0 01-1-1zm5-1a1 1 0 100 2h1a1 1 0 100-2H9z"></path>
          </svg>
          <div>
            <h3 class="font-medium text-gray-900 mb-1">Secure Payment Processing</h3>
            <p class="text-sm text-gray-600">Accept credit cards, digital wallets, and bank transfers securely</p>
          </div>
        </div>
        
        <div class="flex items-start space-x-3">
          <svg class="w-6 h-6 text-purple-600 flex-shrink-0 mt-1" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z" clip-rule="evenodd"></path>
          </svg>
          <div>
            <h3 class="font-medium text-gray-900 mb-1">Automatic Receipts</h3>
            <p class="text-sm text-gray-600">Professional receipts sent automatically to customers</p>
          </div>
        </div>
        
        <div class="flex items-start space-x-3">
          <svg class="w-6 h-6 text-purple-600 flex-shrink-0 mt-1" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M3 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path>
          </svg>
          <div>
            <h3 class="font-medium text-gray-900 mb-1">Real-time Tracking</h3>
            <p class="text-sm text-gray-600">Monitor payments and transactions in real-time</p>
          </div>
        </div>
        
        <div class="flex items-start space-x-3">
          <svg class="w-6 h-6 text-purple-600 flex-shrink-0 mt-1" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M2.166 4.999A11.954 11.954 0 0010 1.944 11.954 11.954 0 0017.834 5c.11.65.166 1.32.166 2.001 0 5.225-3.34 9.67-8 11.317C5.34 16.67 2 12.225 2 7c0-.682.057-1.35.166-2.001zm11.541 3.708a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
          </svg>
          <div>
            <h3 class="font-medium text-gray-900 mb-1">Enterprise Security</h3>
            <p class="text-sm text-gray-600">Bank-level security and PCI compliance included</p>
          </div>
        </div>
      </div>
    </div>

    <!-- Action Buttons -->
    <div class="flex flex-col sm:flex-row gap-4 justify-center">
      <% if @setup_status[:setup_completion_percentage] == 100 %>
        <%= form_with url: complete_payment_setup_path, method: :post, local: true do |form| %>
          <%= form.hidden_field :template_id, value: @template&.id %>
          <%= form.hidden_field :return_to, value: @return_to %>
          <%= form.submit "Continue with Template", 
              class: "inline-flex items-center px-6 py-3 text-base font-medium text-white bg-gradient-to-r from-purple-600 to-indigo-600 border border-transparent rounded-lg hover:from-purple-700 hover:to-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition-all duration-200" %>
        <% end %>
      <% else %>
        <div class="text-center">
          <p class="text-sm text-gray-600 mb-4">Complete the setup steps above to continue</p>
          <button disabled 
                  class="inline-flex items-center px-6 py-3 text-base font-medium text-gray-400 bg-gray-100 border border-gray-300 rounded-lg cursor-not-allowed">
            <svg class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clip-rule="evenodd"></path>
            </svg>
            Setup Required
          </button>
        </div>
      <% end %>
      
      <%= link_to @return_to, 
          class: "inline-flex items-center px-6 py-3 text-base font-medium text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors" do %>
        <svg class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z" clip-rule="evenodd"></path>
        </svg>
        Back to Templates
      <% end %>
    </div>
  </div>
</div>
</file>

<file path="views/profile/show.html.erb">
<% content_for :title, "Profile Settings" %>

<div class="max-w-4xl mx-auto py-8 px-4 sm:px-6 lg:px-8">
  <!-- Header -->
  <div class="mb-8">
    <h1 class="text-3xl font-bold text-gray-900">Profile Settings</h1>
    <p class="mt-2 text-gray-600">Manage your account information and preferences</p>
  </div>

  <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
    <!-- Main Profile Form -->
    <div class="lg:col-span-2">
      <div class="bg-white shadow rounded-lg">
        <div class="px-6 py-4 border-b border-gray-200">
          <h2 class="text-lg font-medium text-gray-900">Personal Information</h2>
          <p class="mt-1 text-sm text-gray-500">Update your personal details</p>
        </div>

        <%= form_with model: @user, url: profile_path, local: true, class: "space-y-6 p-6" do |form| %>
          <% if @user.errors.any? %>
            <div class="bg-red-50 border border-red-200 rounded-md p-4">
              <h3 class="text-sm font-medium text-red-800">
                <%= pluralize(@user.errors.count, "error") %> prohibited this profile from being saved:
              </h3>
              <ul class="mt-2 text-sm text-red-700 list-disc list-inside">
                <% @user.errors.full_messages.each do |message| %>
                  <li><%= message %></li>
                <% end %>
              </ul>
            </div>
          <% end %>

          <div class="grid grid-cols-1 sm:grid-cols-2 gap-6">
            <div>
              <%= form.label :first_name, class: "block text-sm font-medium text-gray-700" %>
              <%= form.text_field :first_name, 
                  class: "mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" %>
            </div>

            <div>
              <%= form.label :last_name, class: "block text-sm font-medium text-gray-700" %>
              <%= form.text_field :last_name, 
                  class: "mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" %>
            </div>
          </div>

          <div>
            <%= form.label :email, class: "block text-sm font-medium text-gray-700" %>
            <%= form.email_field :email, 
                class: "mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" %>
          </div>

          <div class="flex justify-end">
            <%= form.submit "Update Profile", 
                class: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" %>
          </div>
        <% end %>
      </div>
    </div>

    <!-- Sidebar with Account Info and Quick Actions -->
    <div class="space-y-6">
      <!-- Account Status -->
      <div class="bg-white shadow rounded-lg p-6">
        <h3 class="text-lg font-medium text-gray-900 mb-4">Account Status</h3>
        
        <div class="space-y-4">
          <!-- Subscription Tier -->
          <div class="flex items-center justify-between">
            <span class="text-sm text-gray-600">Subscription</span>
            <% if @user.premium? %>
              <div class="flex items-center space-x-2">
                <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-purple-100 text-purple-800">
                  <svg class="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M5 2a1 1 0 011 1v1h1v1a1 1 0 001 1h1a1 1 0 001-1V4h1V3a1 1 0 011-1H5zm4 5H7a1 1 0 01-1-1V6a1 1 0 011-1h2a1 1 0 011 1v1a1 1 0 01-1 1zM5 9a1 1 0 011-1h2a1 1 0 110 2H6a1 1 0 01-1-1zm1 4a1 1 0 100 2h2a1 1 0 100-2H6a1 1 0 00-1 1z" clip-rule="evenodd" />
                  </svg>
                  Premium
                </span>
                <% if @user.subscription_canceling? %>
                  <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800">
                    Canceling
                  </span>
                <% elsif @user.subscription_past_due? %>
                  <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800">
                    Past Due
                  </span>
                <% end %>
              </div>
            <% else %>
              <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800">
                Basic
              </span>
            <% end %>
          </div>

          <!-- Subscription Expiry (if applicable) -->
          <% if @user.subscription_expires_at.present? %>
            <div class="flex items-center justify-between">
              <span class="text-sm text-gray-600">
                <% if @user.subscription_canceling? %>
                  Expires
                <% else %>
                  Renews
                <% end %>
              </span>
              <span class="text-sm font-medium text-gray-900">
                <%= @user.subscription_expires_at.strftime('%b %d, %Y') %>
                <% if @user.subscription_expires_soon? %>
                  <span class="text-xs text-amber-600">(in <%= @user.days_until_subscription_expires %> days)</span>
                <% end %>
              </span>
            </div>
          <% end %>

          <!-- AI Credits -->
          <div class="flex items-center justify-between">
            <span class="text-sm text-gray-600">AI Credits</span>
            <span class="text-sm font-medium text-gray-900">
              <%= number_with_delimiter(@user.ai_credits_remaining.to_i) %> remaining
            </span>
          </div>

          <!-- Forms Count -->
          <div class="flex items-center justify-between">
            <span class="text-sm text-gray-600">Forms Created</span>
            <span class="text-sm font-medium text-gray-900">
              <%= @user.forms.count %>
            </span>
          </div>
        </div>
      </div>

      <!-- Payment Settings (Premium Only) -->
      <% if @user.premium? %>
        <div class="bg-white shadow rounded-lg p-6">
          <h3 class="text-lg font-medium text-gray-900 mb-4">Payment Settings</h3>
          
          <div class="space-y-4">
            <div class="flex items-center justify-between">
              <span class="text-sm text-gray-600">Stripe Status</span>
              <% if @user.stripe_configured? %>
                <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                  <svg class="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                  </svg>
                  Connected
                </span>
              <% else %>
                <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-amber-100 text-amber-800">
                  <svg class="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                  </svg>
                  Not Configured
                </span>
              <% end %>
            </div>

            <div class="pt-4 border-t border-gray-200 space-y-2">
              <%= link_to stripe_settings_path, 
                  class: "w-full inline-flex justify-center items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" do %>
                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h18M7 15h1m4 0h1m-7 4h12a3 3 0 003-3V8a3 3 0 00-3-3H6a3 3 0 00-3 3v8a3 3 0 003 3z"></path>
                </svg>
                <% if @user.stripe_configured? %>
                  Manage Payment Settings
                <% else %>
                  Configure Stripe
                <% end %>
              <% end %>
              
              <%= link_to subscription_management_path, 
                  class: "w-full inline-flex justify-center items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" do %>
                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                </svg>
                Manage Subscription
              <% end %>
            </div>

            <% unless @user.stripe_configured? %>
              <div class="bg-blue-50 border border-blue-200 rounded-md p-3">
                <div class="flex">
                  <div class="flex-shrink-0">
                    <svg class="h-5 w-5 text-blue-400" viewBox="0 0 20 20" fill="currentColor">
                      <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                    </svg>
                  </div>
                  <div class="ml-3">
                    <p class="text-sm text-blue-800">
                      Configure Stripe to start accepting payments through your forms.
                    </p>
                  </div>
                </div>
              </div>
            <% end %>
          </div>
        </div>
      <% else %>
        <!-- Upgrade Prompt for Non-Premium Users -->
        <div class="bg-white shadow rounded-lg p-6">
          <h3 class="text-lg font-medium text-gray-900 mb-4">Upgrade to Premium</h3>
          
          <div class="space-y-4">
            <p class="text-sm text-gray-600">
              Unlock payment processing and advanced features with a Premium subscription.
            </p>
            
            <ul class="text-sm text-gray-600 space-y-2">
              <li class="flex items-center">
                <svg class="w-4 h-4 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                  <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                </svg>
                Accept payments via Stripe
              </li>
              <li class="flex items-center">
                <svg class="w-4 h-4 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                  <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                </svg>
                Advanced AI features
              </li>
              <li class="flex items-center">
                <svg class="w-4 h-4 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                  <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                </svg>
                Priority support
              </li>
            </ul>

            <div class="pt-4">
              <a href="#" class="w-full inline-flex justify-center items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-purple-600 hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500">
                Upgrade to Premium
              </a>
            </div>
          </div>
        </div>
      <% end %>

      <!-- Google Sheets Integration -->
      <%= render 'shared/google_connection_status' %>

      <!-- Quick Actions -->
      <div class="bg-white shadow rounded-lg p-6">
        <h3 class="text-lg font-medium text-gray-900 mb-4">Quick Actions</h3>
        
        <div class="space-y-3">
          <%= link_to forms_path, 
              class: "w-full inline-flex items-center px-3 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" do %>
            <svg class="w-4 h-4 mr-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
            </svg>
            View My Forms
          <% end %>

          <%= link_to new_form_path, 
              class: "w-full inline-flex items-center px-3 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" do %>
            <svg class="w-4 h-4 mr-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
            </svg>
            Create New Form
          <% end %>
        </div>
      </div>
    </div>
  </div>
</div>
</file>

<file path="views/profiles/show.html.erb">
<div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
  <!-- Page Header -->
  <div class="mb-8">
    <h1 class="text-3xl font-bold text-gray-900">Profile Settings</h1>
    <p class="mt-2 text-gray-600">Manage your account information and preferences.</p>
  </div>

  <!-- Profile Content -->
  <div class="bg-white shadow overflow-hidden sm:rounded-lg">
    <!-- Account Status Bar -->
    <div class="bg-gray-50 px-6 py-4 border-b border-gray-200">
      <div class="flex items-center justify-between">
        <div class="flex items-center space-x-4">
          <div class="w-12 h-12 bg-indigo-100 rounded-full flex items-center justify-center">
            <span class="text-indigo-600 font-bold text-lg">
              <%= current_user.email.first.upcase %>
            </span>
          </div>
          <div>
            <p class="text-sm font-medium text-gray-900"><%= current_user.full_name %></p>
            <p class="text-sm text-gray-500"><%= current_user.email %></p>
          </div>
        </div>
        <div class="flex items-center space-x-2">
          <span class="text-sm text-gray-600">Plan:</span>
          <% if current_user.premium? %>
            <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-purple-100 text-purple-800">
              <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M5 2a1 1 0 011 1v1h1v1a1 1 0 001 1h1a1 1 0 001-1V4h1V3a1 1 0 011-1H5zm4 5H7a1 1 0 01-1-1V6a1 1 0 011-1h2a1 1 0 011 1v1a1 1 0 01-1 1zM5 9a1 1 0 011-1h2a1 1 0 110 2H6a1 1 0 01-1-1zm1 4a1 1 0 100 2h2a1 1 0 100-2H6a1 1 0 00-1 1z" clip-rule="evenodd" />
              </svg>
              Premium
            </span>
          <% else %>
            <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-100 text-gray-800">
              <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V7z" clip-rule="evenodd" />
              </svg>
              <%= current_user.subscription_tier.humanize %>
            </span>
          <% end %>
        </div>
      </div>
    </div>

    <!-- Profile Form -->
    <%= form_with model: current_user, url: profile_path, method: :patch, local: true, class: "divide-y divide-gray-200" do |form| %>
      
      <!-- Personal Information -->
      <div class="px-6 py-6">
        <h2 class="text-lg font-medium text-gray-900 mb-4">Personal Information</h2>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div>
            <%= form.label :first_name, class: "block text-sm font-medium text-gray-700" %>
            <%= form.text_field :first_name, class: "mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" %>
          </div>
          
          <div>
            <%= form.label :last_name, class: "block text-sm font-medium text-gray-700" %>
            <%= form.text_field :last_name, class: "mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" %>
          </div>
          
          <div class="md:col-span-2">
            <%= form.label :email, class: "block text-sm font-medium text-gray-700" %>
            <%= form.email_field :email, class: "mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" %>
          </div>
        </div>
      </div>

      <!-- Account Statistics -->
      <div class="px-6 py-6 bg-gray-50">
        <h2 class="text-lg font-medium text-gray-900 mb-4">Account Statistics</h2>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
          <div class="bg-white p-4 rounded-lg border">
            <p class="text-sm font-medium text-gray-500">Forms Created</p>
            <p class="text-2xl font-bold text-gray-900"><%= current_user.forms.count %></p>
          </div>
          
          <div class="bg-white p-4 rounded-lg border">
            <p class="text-sm font-medium text-gray-500">Total Responses</p>
            <p class="text-2xl font-bold text-gray-900"><%= current_user.form_responses.count %></p>
          </div>
          
          <div class="bg-white p-4 rounded-lg border">
            <p class="text-sm font-medium text-gray-500">AI Credits</p>
            <p class="text-2xl font-bold text-gray-900"><%= current_user.ai_credits_remaining %> / <%= current_user.ai_credits_limit %></p>
          </div>
        </div>
      </div>

      <!-- Preferences -->
      <div class="px-6 py-6">
        <h2 class="text-lg font-medium text-gray-900 mb-4">Preferences</h2>
        <div class="space-y-4">
          <div>
            <%= form.label :preferences_theme, "Theme", class: "block text-sm font-medium text-gray-700" %>
            <%= form.select :preferences_theme, 
                options_for_select([['Light', 'light'], ['Dark', 'dark']], current_user.preferences&.dig('theme') || 'light'),
                { include_blank: false }, 
                class: "mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" %>
          </div>
        </div>
      </div>

      <!-- Form Actions -->
      <div class="px-6 py-4 bg-gray-50 flex justify-end space-x-3">
        <%= link_to "Back to Dashboard", forms_path, class: "inline-flex justify-center py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50" %>
        <%= form.submit "Save Changes", class: "inline-flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" %>
      </div>
    <% end %>
  </div>

  <!-- Account Actions -->
  <div class="mt-6 bg-white shadow overflow-hidden sm:rounded-lg">
    <div class="px-6 py-4 border-b border-gray-200">
      <h3 class="text-lg font-medium text-gray-900">Account Actions</h3>
    </div>
    
    <div class="px-6 py-4 space-y-4">
      <div class="flex justify-between items-center">
        <div>
          <p class="text-sm font-medium text-gray-900">Change Password</p>
          <p class="text-sm text-gray-500">Update your account password</p>
        </div>
        <%= link_to "Change Password", edit_user_password_path, class: "text-sm text-indigo-600 hover:text-indigo-500" %>
      </div>
      
      <div class="flex justify-between items-center">
        <div>
          <p class="text-sm font-medium text-gray-900">Upgrade Plan</p>
          <p class="text-sm text-gray-500">Get more features with Premium</p>
        </div>
        <%= link_to "Upgrade", "#", class: "text-sm text-indigo-600 hover:text-indigo-500" %>
      </div>
    </div>
  </div>
</div>
</file>

<file path="views/pwa/manifest.json.erb">
{
  "name": "Agentform",
  "icons": [
    {
      "src": "/icon.png",
      "type": "image/png",
      "sizes": "512x512"
    },
    {
      "src": "/icon.png",
      "type": "image/png",
      "sizes": "512x512",
      "purpose": "maskable"
    }
  ],
  "start_url": "/",
  "display": "standalone",
  "scope": "/",
  "description": "Agentform.",
  "theme_color": "red",
  "background_color": "red"
}
</file>

<file path="views/pwa/service-worker.js">
// Add a service worker for processing Web Push notifications:
//
// self.addEventListener("push", async (event) => {
//   const { title, options } = await event.data.json()
//   event.waitUntil(self.registration.showNotification(title, options))
// })
//
// self.addEventListener("notificationclick", function(event) {
//   event.notification.close()
//   event.waitUntil(
//     clients.matchAll({ type: "window" }).then((clientList) => {
//       for (let i = 0; i < clientList.length; i++) {
//         let client = clientList[i]
//         let clientPath = (new URL(client.url)).pathname
//
//         if (clientPath == event.notification.data.path && "focus" in client) {
//           return client.focus()
//         }
//       }
//
//       if (clients.openWindow) {
//         return clients.openWindow(event.notification.data.path)
//       }
//     })
//   )
// })
</file>

<file path="views/question_types/_address.html.erb">
<div class="space-y-4">
  <% if config['single_field'] == true %>
    <!-- Single field address input -->
    <div class="space-y-2">
      <%= form.text_area "answer[value]", 
                         placeholder: config['placeholder'] || "Enter your full address...",
                         rows: 3,
                         required: question.required?,
                         class: "block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm",
                         data: { 
                           "question-response-target": "answerInput",
                           "action": "input->question-response#validateInput"
                         } %>
      
      <% if config['help_text'] %>
        <p class="text-xs text-gray-500"><%= config['help_text'] %></p>
      <% end %>
    </div>
  <% else %>
    <!-- Multi-field address input -->
    <div class="space-y-3">
      <div>
        <label class="block text-sm font-medium text-gray-700 mb-1">Street Address</label>
        <%= form.text_field "answer[street]", 
                           placeholder: "123 Main Street",
                           required: question.required?,
                           class: "block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm",
                           data: { 
                             "question-response-target": "addressField",
                             "action": "input->question-response#validateInput"
                           } %>
      </div>
      
      <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">City</label>
          <%= form.text_field "answer[city]", 
                             placeholder: "City",
                             required: question.required?,
                             class: "block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm",
                             data: { 
                               "question-response-target": "addressField",
                               "action": "input->question-response#validateInput"
                             } %>
        </div>
        
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">State/Province</label>
          <%= form.text_field "answer[state]", 
                             placeholder: "State",
                             required: question.required?,
                             class: "block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm",
                             data: { 
                               "question-response-target": "addressField",
                               "action": "input->question-response#validateInput"
                             } %>
        </div>
      </div>
      
      <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">ZIP/Postal Code</label>
          <%= form.text_field "answer[zip]", 
                             placeholder: "12345",
                             required: question.required?,
                             class: "block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm",
                             data: { 
                               "question-response-target": "addressField",
                               "action": "input->question-response#validateInput"
                             } %>
        </div>
        
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">Country</label>
          <% if config['countries']&.any? %>
            <%= form.select "answer[country]", 
                           options_for_select(config['countries'].map { |c| [c['name'], c['code']] }),
                           { prompt: "Select Country" },
                           { 
                             required: question.required?,
                             class: "block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm",
                             data: { 
                               "question-response-target": "addressField",
                               "action": "change->question-response#validateInput"
                             }
                           } %>
          <% else %>
            <%= form.text_field "answer[country]", 
                               placeholder: "Country",
                               required: question.required?,
                               class: "block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm",
                               data: { 
                                 "question-response-target": "addressField",
                                 "action": "input->question-response#validateInput"
                               } %>
          <% end %>
        </div>
      </div>
      
      <% if config['help_text'] %>
        <p class="text-xs text-gray-500"><%= config['help_text'] %></p>
      <% end %>
    </div>
  <% end %>
</div>
</file>

<file path="views/question_types/_boolean.html.erb">
<div class="space-y-3">
  <div class="flex items-center justify-center">
    <label class="flex items-center space-x-3 p-4 border-2 border-gray-200 rounded-lg hover:border-indigo-300 hover:bg-indigo-50 cursor-pointer transition-all duration-200 toggle-container">
      <%= form.check_box "answer[value]", 
                        { 
                          class: "sr-only",
                          data: { 
                            "question-response-target": "answerInput",
                            "action": "change->question-response#validateInput"
                          }
                        },
                        "true",
                        "false" %>
      
      <div class="flex items-center space-x-3">
        <div class="relative">
          <div class="w-12 h-6 bg-gray-300 rounded-full shadow-inner toggle-bg"></div>
          <div class="absolute top-0.5 left-0.5 w-5 h-5 bg-white rounded-full shadow transform transition-transform duration-200 toggle-dot"></div>
        </div>
        
        <span class="text-lg font-medium text-gray-900 toggle-label">
          <%= config['false_label'] || 'Off' %>
        </span>
      </div>
    </label>
  </div>
  
  <% if config['help_text'] %>
    <p class="text-xs text-gray-500 text-center"><%= config['help_text'] %></p>
  <% end %>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const checkbox = document.querySelector('input[type="checkbox"][name="answer[value]"]');
    const toggleBg = document.querySelector('.toggle-bg');
    const toggleDot = document.querySelector('.toggle-dot');
    const toggleLabel = document.querySelector('.toggle-label');
    const toggleContainer = document.querySelector('.toggle-container');
    
    const trueLabel = '<%= config['true_label'] || 'On' %>';
    const falseLabel = '<%= config['false_label'] || 'Off' %>';
    
    function updateToggle() {
      if (checkbox && checkbox.checked) {
        toggleBg.classList.remove('bg-gray-300');
        toggleBg.classList.add('bg-indigo-500');
        toggleDot.classList.add('translate-x-6');
        toggleLabel.textContent = trueLabel;
        toggleContainer.classList.add('border-indigo-500', 'bg-indigo-50');
        toggleContainer.classList.remove('border-gray-200');
      } else {
        toggleBg.classList.remove('bg-indigo-500');
        toggleBg.classList.add('bg-gray-300');
        toggleDot.classList.remove('translate-x-6');
        toggleLabel.textContent = falseLabel;
        toggleContainer.classList.remove('border-indigo-500', 'bg-indigo-50');
        toggleContainer.classList.add('border-gray-200');
      }
    }
    
    if (checkbox) {
      checkbox.addEventListener('change', updateToggle);
      updateToggle(); // Initialize state
    }
  });
</script>
</file>

<file path="views/question_types/_checkbox.html.erb">
<div class="space-y-3">
  <% choices = config['options'] || [] %>
  
  <div class="space-y-2">
    <% choices.each_with_index do |choice, index| %>
      <label class="flex items-start space-x-3 p-3 border border-gray-200 rounded-lg hover:bg-gray-50 cursor-pointer transition-colors">
        <%= form.check_box "answer[value][]", 
                          { 
                            multiple: true,
                            class: "mt-0.5 h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded",
                            data: { 
                              "question-response-target": "answerInput",
                              "action": "change->question-response#validateInput"
                            }
                          },
                          choice['value'] || choice,
                          "" %>
        
        <div class="flex-1">
          <span class="text-sm font-medium text-gray-900">
            <%= choice['label'] || choice %>
          </span>
          
          <% if choice.is_a?(Hash) && choice['description'] %>
            <p class="text-xs text-gray-500 mt-1"><%= choice['description'] %></p>
          <% end %>
        </div>
      </label>
    <% end %>
    
    <!-- Other option (if enabled) -->
    <% if config['allow_other'] %>
      <label class="flex items-start space-x-3 p-3 border border-gray-200 rounded-lg hover:bg-gray-50 cursor-pointer transition-colors">
        <%= form.check_box "answer[value][]", 
                          { 
                            class: "mt-0.5 h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded",
                            data: { 
                              "question-response-target": "otherCheckbox",
                              "action": "change->question-response#toggleOtherInput"
                            }
                          },
                          'other',
                          "" %>
        
        <div class="flex-1">
          <span class="text-sm font-medium text-gray-900">Other</span>
          
          <div class="mt-2 hidden" data-question-response-target="otherInputContainer">
            <%= form.text_field "answer[other_value]", 
                               placeholder: "Please specify...",
                               class: "block w-full text-sm border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500",
                               data: { 
                                 "question-response-target": "otherInput",
                                 "action": "input->question-response#validateInput"
                               } %>
          </div>
        </div>
      </label>
    <% end %>
  </div>
  
  <% if config['help_text'] %>
    <p class="text-xs text-gray-500"><%= config['help_text'] %></p>
  <% end %>
  
  <% if config['max_selections'] %>
    <p class="text-xs text-gray-500">
      Select up to <%= config['max_selections'] %> options
    </p>
  <% end %>
  
  <% if config['min_selections'] %>
    <p class="text-xs text-gray-500">
      Select at least <%= config['min_selections'] %> option<%= 's' if config['min_selections'] > 1 %>
    </p>
  <% end %>
</div>
</file>

<file path="views/question_types/_date.html.erb">
<div class="space-y-2">
  <%= form.date_field "answer[value]", 
                     min: config['min_date'],
                     max: config['max_date'],
                     required: question.required?,
                     class: "block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm",
                     data: { 
                       "question-response-target": "answerInput",
                       "action": "change->question-response#validateInput"
                     } %>
  
  <% if config['min_date'] || config['max_date'] %>
    <div class="flex justify-between text-xs text-gray-500">
      <% if config['min_date'] %>
        <span>From: <%= Date.parse(config['min_date']).strftime('%B %d, %Y') rescue config['min_date'] %></span>
      <% end %>
      <% if config['max_date'] %>
        <span>Until: <%= Date.parse(config['max_date']).strftime('%B %d, %Y') rescue config['max_date'] %></span>
      <% end %>
    </div>
  <% end %>
  
  <% if config['help_text'] %>
    <p class="text-xs text-gray-500"><%= config['help_text'] %></p>
  <% end %>
</div>
</file>

<file path="views/question_types/_datetime.html.erb">
<div class="space-y-2">
  <%= form.datetime_local_field "answer[value]", 
                               min: config['min_datetime'],
                               max: config['max_datetime'],
                               required: question.required?,
                               class: "block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm",
                               data: { 
                                 "question-response-target": "answerInput",
                                 "action": "change->question-response#validateInput"
                               } %>
  
  <% if config['min_datetime'] || config['max_datetime'] %>
    <div class="flex justify-between text-xs text-gray-500">
      <% if config['min_datetime'] %>
        <span>From: <%= DateTime.parse(config['min_datetime']).strftime('%B %d, %Y at %I:%M %p') rescue config['min_datetime'] %></span>
      <% end %>
      <% if config['max_datetime'] %>
        <span>Until: <%= DateTime.parse(config['max_datetime']).strftime('%B %d, %Y at %I:%M %p') rescue config['max_datetime'] %></span>
      <% end %>
    </div>
  <% end %>
  
  <% if config['timezone'] %>
    <p class="text-xs text-gray-500">Timezone: <%= config['timezone'] %></p>
  <% end %>
  
  <% if config['help_text'] %>
    <p class="text-xs text-gray-500"><%= config['help_text'] %></p>
  <% end %>
</div>
</file>

<file path="views/question_types/_drag_drop.html.erb">
<div class="space-y-4">
  <% items = config['items'] || [] %>
  <% categories = config['categories'] || [] %>
  
  <% if items.any? && categories.any? %>
    <div class="space-y-4">
      <p class="text-sm text-gray-600">
        Drag items from the list below and drop them into the appropriate categories.
      </p>
      
      <!-- Categories (Drop Zones) -->
      <div class="grid grid-cols-1 md:grid-cols-<%= [categories.length, 3].min %> gap-4">
        <% categories.each_with_index do |category, index| %>
          <div class="category-zone border-2 border-dashed border-gray-300 rounded-lg p-4 min-h-32 bg-gray-50"
               data-category-id="<%= category['id'] || index %>"
               data-question-response-target="dropZone">
            
            <h4 class="text-sm font-medium text-gray-900 mb-2 text-center">
              <%= category['label'] || category %>
            </h4>
            
            <% if category.is_a?(Hash) && category['description'] %>
              <p class="text-xs text-gray-500 text-center mb-3">
                <%= category['description'] %>
              </p>
            <% end %>
            
            <div class="space-y-2 dropped-items" data-category="<%= category['id'] || index %>">
              <!-- Dropped items will appear here -->
            </div>
          </div>
        <% end %>
      </div>
      
      <!-- Items to Drag -->
      <div class="border border-gray-200 rounded-lg p-4 bg-white">
        <h4 class="text-sm font-medium text-gray-900 mb-3">Items to categorize:</h4>
        
        <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-2 draggable-items" data-question-response-target="itemsContainer">
          <% items.each_with_index do |item, index| %>
            <div class="draggable-item bg-indigo-100 text-indigo-800 px-3 py-2 rounded-md text-sm font-medium cursor-move hover:bg-indigo-200 transition-colors"
                 data-item-id="<%= item['id'] || index %>"
                 draggable="true">
              <%= item['label'] || item %>
            </div>
          <% end %>
        </div>
      </div>
      
      <!-- Hidden field to store categorization data -->
      <%= form.hidden_field "answer[categorization]", 
                           data: { "question-response-target": "categorizationData" } %>
    </div>
  <% else %>
    <div class="text-center py-8 text-gray-500">
      <p class="text-sm">Drag and drop configuration is incomplete.</p>
      <p class="text-xs mt-1">Please configure items and categories in the question settings.</p>
    </div>
  <% end %>
  
  <% if config['help_text'] %>
    <p class="text-xs text-gray-500"><%= config['help_text'] %></p>
  <% end %>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const itemsContainer = document.querySelector('[data-question-response-target="itemsContainer"]');
    const dropZones = document.querySelectorAll('[data-question-response-target="dropZone"]');
    const categorizationData = document.querySelector('[data-question-response-target="categorizationData"]');
    
    if (!itemsContainer || !categorizationData) return;
    
    let draggedElement = null;
    
    // Make items draggable
    function setupDraggableItems() {
      const items = document.querySelectorAll('.draggable-item');
      items.forEach(item => {
        item.addEventListener('dragstart', function(e) {
          draggedElement = this;
          this.classList.add('opacity-50');
          e.dataTransfer.effectAllowed = 'move';
        });
        
        item.addEventListener('dragend', function(e) {
          this.classList.remove('opacity-50');
          draggedElement = null;
        });
      });
    }
    
    // Setup drop zones
    dropZones.forEach(zone => {
      zone.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
      });
      
      zone.addEventListener('dragenter', function(e) {
        e.preventDefault();
        this.classList.add('border-indigo-400', 'bg-indigo-50');
      });
      
      zone.addEventListener('dragleave', function(e) {
        // Only remove highlight if we're actually leaving the zone
        if (!this.contains(e.relatedTarget)) {
          this.classList.remove('border-indigo-400', 'bg-indigo-50');
        }
      });
      
      zone.addEventListener('drop', function(e) {
        e.preventDefault();
        this.classList.remove('border-indigo-400', 'bg-indigo-50');
        
        if (draggedElement) {
          const droppedItems = this.querySelector('.dropped-items');
          
          // Create a new item in the drop zone
          const newItem = draggedElement.cloneNode(true);
          newItem.classList.remove('cursor-move', 'hover:bg-indigo-200');
          newItem.classList.add('cursor-pointer', 'hover:bg-red-100');
          newItem.draggable = false;
          
          // Add remove functionality
          newItem.addEventListener('click', function() {
            // Move back to original container
            const originalItem = draggedElement.cloneNode(true);
            itemsContainer.appendChild(originalItem);
            setupDraggableItems();
            
            // Remove from drop zone
            this.remove();
            
            updateCategorizationData();
          });
          
          droppedItems.appendChild(newItem);
          
          // Remove from original container
          draggedElement.remove();
          
          updateCategorizationData();
        }
      });
    });
    
    // Setup items container as a drop zone (for returning items)
    itemsContainer.addEventListener('dragover', function(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
    });
    
    itemsContainer.addEventListener('dragenter', function(e) {
      e.preventDefault();
      this.classList.add('border-indigo-400', 'bg-indigo-50');
    });
    
    itemsContainer.addEventListener('dragleave', function(e) {
      if (!this.contains(e.relatedTarget)) {
        this.classList.remove('border-indigo-400', 'bg-indigo-50');
      }
    });
    
    itemsContainer.addEventListener('drop', function(e) {
      e.preventDefault();
      this.classList.remove('border-indigo-400', 'bg-indigo-50');
      
      if (draggedElement && !this.contains(draggedElement)) {
        // Return item to original container
        const returnedItem = draggedElement.cloneNode(true);
        returnedItem.classList.remove('cursor-pointer', 'hover:bg-red-100');
        returnedItem.classList.add('cursor-move', 'hover:bg-indigo-200');
        returnedItem.draggable = true;
        
        this.appendChild(returnedItem);
        draggedElement.remove();
        
        setupDraggableItems();
        updateCategorizationData();
      }
    });
    
    function updateCategorizationData() {
      const categorization = {};
      
      dropZones.forEach(zone => {
        const categoryId = zone.dataset.categoryId;
        const droppedItems = zone.querySelectorAll('.dropped-items .draggable-item');
        
        categorization[categoryId] = Array.from(droppedItems).map(item => ({
          id: item.dataset.itemId,
          label: item.textContent.trim()
        }));
      });
      
      categorizationData.value = JSON.stringify(categorization);
      
      // Trigger validation
      categorizationData.dispatchEvent(new Event('input'));
    }
    
    // Initialize
    setupDraggableItems();
    updateCategorizationData();
  });
</script>
</file>

<file path="views/question_types/_email.html.erb">
<div class="space-y-2">
  <%= form.email_field "answer[value]", 
                      placeholder: config['placeholder'] || "Enter your email address...",
                      required: question.required?,
                      class: "block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm",
                      data: { 
                        "question-response-target": "answerInput",
                        "action": "input->question-response#validateInput"
                      } %>
  
  <% if config['help_text'] %>
    <p class="text-xs text-gray-500"><%= config['help_text'] %></p>
  <% end %>
</div>
</file>

<file path="views/question_types/_file_upload.html.erb">
<div class="space-y-4">
  <div class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center hover:border-indigo-400 transition-colors file-drop-zone">
    <%= form.file_field "answer[value]", 
                       multiple: config['multiple'] == true,
                       accept: config['allowed_types']&.join(','),
                       required: question.required?,
                       class: "sr-only",
                       data: { 
                         "question-response-target": "answerInput",
                         "action": "change->question-response#validateInput change->question-response#handleFileUpload"
                       } %>
    
    <div class="space-y-2">
      <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48">
        <path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
      </svg>
      
      <div class="text-sm text-gray-600">
        <label for="<%= form.object_name %>_answer_value" class="cursor-pointer font-medium text-indigo-600 hover:text-indigo-500">
          Upload <%= config['multiple'] == true ? 'files' : 'a file' %>
        </label>
        <span> or drag and drop</span>
      </div>
      
      <% if config['accepted_types']&.any? %>
        <p class="text-xs text-gray-500">
          Accepted formats: <%= config['accepted_types'].join(', ') %>
        </p>
      <% end %>
      
      <% if config['max_size_mb'] %>
        <p class="text-xs text-gray-500">
          Maximum size: <%= config['max_size_mb'] %>MB per file
        </p>
      <% end %>
    </div>
  </div>
  
  <!-- File preview area -->
  <div class="hidden space-y-2" data-question-response-target="filePreview">
    <h4 class="text-sm font-medium text-gray-900">Selected files:</h4>
    <div class="space-y-1" data-question-response-target="fileList">
      <!-- Files will be listed here -->
    </div>
  </div>
  
  <% if config['help_text'] %>
    <p class="text-xs text-gray-500"><%= config['help_text'] %></p>
  <% end %>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const dropZone = document.querySelector('.file-drop-zone');
    const fileInput = document.querySelector('input[type="file"]');
    const filePreview = document.querySelector('[data-question-response-target="filePreview"]');
    const fileList = document.querySelector('[data-question-response-target="fileList"]');
    
    if (!dropZone || !fileInput) return;
    
    // Handle drag and drop
    dropZone.addEventListener('dragover', function(e) {
      e.preventDefault();
      dropZone.classList.add('border-indigo-500', 'bg-indigo-50');
    });
    
    dropZone.addEventListener('dragleave', function(e) {
      e.preventDefault();
      dropZone.classList.remove('border-indigo-500', 'bg-indigo-50');
    });
    
    dropZone.addEventListener('drop', function(e) {
      e.preventDefault();
      dropZone.classList.remove('border-indigo-500', 'bg-indigo-50');
      
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        fileInput.files = files;
        fileInput.dispatchEvent(new Event('change'));
      }
    });
    
    // Handle click to open file dialog
    dropZone.addEventListener('click', function() {
      fileInput.click();
    });
    
    // Handle file selection
    fileInput.addEventListener('change', function() {
      updateFilePreview();
    });
    
    function updateFilePreview() {
      if (fileInput.files.length === 0) {
        filePreview.classList.add('hidden');
        return;
      }
      
      filePreview.classList.remove('hidden');
      fileList.innerHTML = '';
      
      Array.from(fileInput.files).forEach(file => {
        const fileItem = document.createElement('div');
        fileItem.className = 'flex items-center space-x-2 text-sm text-gray-600';
        fileItem.innerHTML = `
          <svg class="h-4 w-4 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4z" clip-rule="evenodd" />
          </svg>
          <span>${file.name}</span>
          <span class="text-xs text-gray-400">(${formatFileSize(file.size)})</span>
        `;
        fileList.appendChild(fileItem);
      });
    }
    
    function formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
  });
</script>
</file>

<file path="views/question_types/_image_upload.html.erb">
<div class="space-y-4">
  <div class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center hover:border-indigo-400 transition-colors image-drop-zone">
    <%= form.file_field "answer[value]", 
                       multiple: config['multiple'] == true,
                       accept: "image/*",
                       required: question.required?,
                       class: "sr-only",
                       data: { 
                         "question-response-target": "answerInput",
                         "action": "change->question-response#validateInput change->question-response#handleImageUpload"
                       } %>
    
    <div class="space-y-2">
      <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 48 48">
        <path d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20v12a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2H8a2 2 0 00-2 2v12z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
      </svg>
      
      <div class="text-sm text-gray-600">
        <label for="<%= form.object_name %>_answer_value" class="cursor-pointer font-medium text-indigo-600 hover:text-indigo-500">
          Upload <%= config['multiple'] == true ? 'images' : 'an image' %>
        </label>
        <span> or drag and drop</span>
      </div>
      
      <p class="text-xs text-gray-500">
        PNG, JPG, GIF up to <%= config['max_size_mb'] || 10 %>MB
      </p>
    </div>
  </div>
  
  <!-- Image preview area -->
  <div class="hidden grid grid-cols-2 md:grid-cols-3 gap-4" data-question-response-target="imagePreview">
    <!-- Images will be previewed here -->
  </div>
  
  <% if config['help_text'] %>
    <p class="text-xs text-gray-500"><%= config['help_text'] %></p>
  <% end %>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const dropZone = document.querySelector('.image-drop-zone');
    const fileInput = document.querySelector('input[type="file"]');
    const imagePreview = document.querySelector('[data-question-response-target="imagePreview"]');
    
    if (!dropZone || !fileInput) return;
    
    // Handle drag and drop
    dropZone.addEventListener('dragover', function(e) {
      e.preventDefault();
      dropZone.classList.add('border-indigo-500', 'bg-indigo-50');
    });
    
    dropZone.addEventListener('dragleave', function(e) {
      e.preventDefault();
      dropZone.classList.remove('border-indigo-500', 'bg-indigo-50');
    });
    
    dropZone.addEventListener('drop', function(e) {
      e.preventDefault();
      dropZone.classList.remove('border-indigo-500', 'bg-indigo-50');
      
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        fileInput.files = files;
        fileInput.dispatchEvent(new Event('change'));
      }
    });
    
    // Handle click to open file dialog
    dropZone.addEventListener('click', function() {
      fileInput.click();
    });
    
    // Handle file selection
    fileInput.addEventListener('change', function() {
      updateImagePreview();
    });
    
    function updateImagePreview() {
      if (fileInput.files.length === 0) {
        imagePreview.classList.add('hidden');
        imagePreview.innerHTML = '';
        return;
      }
      
      imagePreview.classList.remove('hidden');
      imagePreview.innerHTML = '';
      
      Array.from(fileInput.files).forEach(file => {
        if (file.type.startsWith('image/')) {
          const reader = new FileReader();
          reader.onload = function(e) {
            const imageContainer = document.createElement('div');
            imageContainer.className = 'relative group';
            imageContainer.innerHTML = `
              <img src="${e.target.result}" alt="${file.name}" class="w-full h-32 object-cover rounded-lg border border-gray-200">
              <div class="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-20 transition-all duration-200 rounded-lg flex items-center justify-center">
                <span class="text-white text-xs opacity-0 group-hover:opacity-100 transition-opacity duration-200 text-center px-2">
                  ${file.name}<br>
                  ${formatFileSize(file.size)}
                </span>
              </div>
            `;
            imagePreview.appendChild(imageContainer);
          };
          reader.readAsDataURL(file);
        }
      });
    }
    
    function formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
  });
</script>
</file>

<file path="views/question_types/_location.html.erb">
<div class="space-y-4">
  <div class="space-y-3">
    <!-- Location input field -->
    <div>
      <%= form.text_field "answer[location]", 
                         placeholder: config['placeholder'] || "Enter a location or address...",
                         required: question.required?,
                         class: "block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm",
                         data: { 
                           "question-response-target": "answerInput",
                           "action": "input->question-response#validateInput"
                         } %>
    </div>
    
    <!-- Coordinates (hidden fields) -->
    <%= form.hidden_field "answer[latitude]", data: { "question-response-target": "latitude" } %>
    <%= form.hidden_field "answer[longitude]", data: { "question-response-target": "longitude" } %>
    
    <!-- Get current location button -->
    <div class="flex items-center space-x-3">
      <button type="button" 
              class="inline-flex items-center px-3 py-2 border border-gray-300 shadow-sm text-sm leading-4 font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
              data-action="click->question-response#getCurrentLocation">
        <svg class="h-4 w-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
        </svg>
        Use Current Location
      </button>
      
      <span class="text-xs text-gray-500" data-question-response-target="locationStatus"></span>
    </div>
    
    <!-- Map preview (if enabled) -->
    <% if config['show_map'] == true %>
      <div class="hidden border border-gray-300 rounded-lg overflow-hidden" data-question-response-target="mapContainer">
        <div id="location-map" class="w-full h-48 bg-gray-100"></div>
      </div>
    <% end %>
    
    <!-- Coordinates display -->
    <div class="hidden text-xs text-gray-500" data-question-response-target="coordinatesDisplay">
      <span>Coordinates: </span>
      <span data-question-response-target="coordinatesText"></span>
    </div>
  </div>
  
  <% if config['help_text'] %>
    <p class="text-xs text-gray-500"><%= config['help_text'] %></p>
  <% end %>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const locationInput = document.querySelector('input[name*="[location]"]');
    const latitudeInput = document.querySelector('input[name*="[latitude]"]');
    const longitudeInput = document.querySelector('input[name*="[longitude]"]');
    const locationStatus = document.querySelector('[data-question-response-target="locationStatus"]');
    const coordinatesDisplay = document.querySelector('[data-question-response-target="coordinatesDisplay"]');
    const coordinatesText = document.querySelector('[data-question-response-target="coordinatesText"]');
    const getCurrentLocationBtn = document.querySelector('[data-action*="getCurrentLocation"]');
    
    if (!locationInput || !getCurrentLocationBtn) return;
    
    getCurrentLocationBtn.addEventListener('click', function() {
      if (!navigator.geolocation) {
        locationStatus.textContent = 'Geolocation is not supported by this browser.';
        return;
      }
      
      locationStatus.textContent = 'Getting your location...';
      getCurrentLocationBtn.disabled = true;
      
      navigator.geolocation.getCurrentPosition(
        function(position) {
          const lat = position.coords.latitude;
          const lng = position.coords.longitude;
          
          latitudeInput.value = lat;
          longitudeInput.value = lng;
          
          // Reverse geocode to get address
          reverseGeocode(lat, lng);
          
          updateCoordinatesDisplay(lat, lng);
          locationStatus.textContent = 'Location found!';
          getCurrentLocationBtn.disabled = false;
          
          // Trigger validation
          locationInput.dispatchEvent(new Event('input'));
        },
        function(error) {
          let errorMessage = 'Unable to get your location.';
          switch(error.code) {
            case error.PERMISSION_DENIED:
              errorMessage = 'Location access denied by user.';
              break;
            case error.POSITION_UNAVAILABLE:
              errorMessage = 'Location information is unavailable.';
              break;
            case error.TIMEOUT:
              errorMessage = 'Location request timed out.';
              break;
          }
          locationStatus.textContent = errorMessage;
          getCurrentLocationBtn.disabled = false;
        },
        {
          enableHighAccuracy: true,
          timeout: 10000,
          maximumAge: 60000
        }
      );
    });
    
    function reverseGeocode(lat, lng) {
      // This is a simplified implementation
      // In a real app, you'd use a geocoding service like Google Maps API
      locationInput.value = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
    }
    
    function updateCoordinatesDisplay(lat, lng) {
      if (coordinatesDisplay && coordinatesText) {
        coordinatesText.textContent = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
        coordinatesDisplay.classList.remove('hidden');
      }
    }
  });
</script>
</file>

<file path="views/question_types/_matrix.html.erb">
<div class="space-y-4">
  <% rows = config['rows'] || [] %>
  <% columns = config['columns'] || [] %>
  <% input_type = config['multiple_selection'] == true ? 'checkbox' : 'radio' %>
  
  <% if rows.any? && columns.any? %>
    <div class="overflow-x-auto">
      <table class="min-w-full">
        <thead>
          <tr>
            <th class="text-left py-2 pr-4 text-sm font-medium text-gray-900"></th>
            <% columns.each do |column| %>
              <th class="text-center py-2 px-2 text-sm font-medium text-gray-900 min-w-20">
                <%= column['label'] || column %>
              </th>
            <% end %>
          </tr>
        </thead>
        <tbody class="space-y-2">
          <% rows.each_with_index do |row, row_index| %>
            <tr class="border-t border-gray-100">
              <td class="py-3 pr-4 text-sm text-gray-900 font-medium">
                <%= row['label'] || row %>
                <% if row.is_a?(Hash) && row['description'] %>
                  <div class="text-xs text-gray-500 mt-1"><%= row['description'] %></div>
                <% end %>
              </td>
              
              <% columns.each_with_index do |column, col_index| %>
                <td class="text-center py-3 px-2">
                  <% row_id = row['id'] || row_index %>
                  <% col_id = column['id'] || col_index %>
                  <% field_name = input_type == 'checkbox' ? "answer[#{row_id}][]" : "answer[#{row_id}]" %>
                  
                  <label class="inline-flex items-center justify-center cursor-pointer">
                    <% if input_type == 'checkbox' %>
                      <%= form.check_box field_name,
                                        { 
                                          multiple: true,
                                          class: "h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded",
                                          data: { 
                                            "question-response-target": "answerInput",
                                            "action": "change->question-response#validateInput"
                                          }
                                        },
                                        col_id,
                                        "" %>
                    <% else %>
                      <%= form.radio_button field_name,
                                          col_id,
                                          { 
                                            class: "h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300",
                                            data: { 
                                              "question-response-target": "answerInput",
                                              "action": "change->question-response#validateInput"
                                            }
                                          } %>
                    <% end %>
                  </label>
                </td>
              <% end %>
            </tr>
          <% end %>
        </tbody>
      </table>
    </div>
  <% else %>
    <div class="text-center py-8 text-gray-500">
      <p class="text-sm">Matrix configuration is incomplete.</p>
      <p class="text-xs mt-1">Please configure rows and columns in the question settings.</p>
    </div>
  <% end %>
  
  <% if config['help_text'] %>
    <p class="text-xs text-gray-500"><%= config['help_text'] %></p>
  <% end %>
  
  <% if config['multiple_selection'] == true %>
    <p class="text-xs text-gray-500">
      You can select multiple options for each row.
    </p>
  <% else %>
    <p class="text-xs text-gray-500">
      Select one option for each row.
    </p>
  <% end %>
</div>
</file>

<file path="views/question_types/_multiple_choice.html.erb">
<div class="space-y-3">
  <% choices = config['options'] || [] %>
  <% allow_multiple = config['allow_multiple'] == true %>
  <% input_type = allow_multiple ? 'checkbox' : 'radio' %>
  <% input_name = allow_multiple ? "answer[value][]" : "answer[value]" %>
  
  <div class="space-y-2">
    <% choices.each_with_index do |choice, index| %>
      <label class="flex items-start space-x-3 p-3 border border-gray-200 rounded-lg hover:bg-gray-50 cursor-pointer transition-colors">
        <%= form.send("#{input_type}_button", 
                     input_name, 
                     choice['value'] || choice,
                     { 
                       required: question.required? && !allow_multiple,
                       class: "mt-0.5 h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300",
                       data: { 
                         "question-response-target": "answerInput",
                         "action": "change->question-response#validateInput"
                       }
                     }) %>
        
        <div class="flex-1">
          <span class="text-sm font-medium text-gray-900">
            <%= choice['label'] || choice %>
          </span>
          
          <% if choice.is_a?(Hash) && choice['description'] %>
            <p class="text-xs text-gray-500 mt-1"><%= choice['description'] %></p>
          <% end %>
        </div>
      </label>
    <% end %>
    
    <!-- Other option (if enabled) -->
    <% if config['allow_other'] %>
      <label class="flex items-start space-x-3 p-3 border border-gray-200 rounded-lg hover:bg-gray-50 cursor-pointer transition-colors">
        <%= form.send("#{input_type}_button", 
                     input_name, 
                     'other',
                     { 
                       class: "mt-0.5 h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300",
                       data: { 
                         "question-response-target": "otherCheckbox",
                         "action": "change->question-response#toggleOtherInput"
                       }
                     }) %>
        
        <div class="flex-1">
          <span class="text-sm font-medium text-gray-900">Other</span>
          
          <div class="mt-2 hidden" data-question-response-target="otherInputContainer">
            <%= form.text_field "answer[other_value]", 
                               placeholder: "Please specify...",
                               class: "block w-full text-sm border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500",
                               data: { 
                                 "question-response-target": "otherInput",
                                 "action": "input->question-response#validateInput"
                               } %>
          </div>
        </div>
      </label>
    <% end %>
  </div>
  
  <% if config['help_text'] %>
    <p class="text-xs text-gray-500"><%= config['help_text'] %></p>
  <% end %>
  
  <% if allow_multiple && config['max_selections'] %>
    <p class="text-xs text-gray-500">
      Select up to <%= config['max_selections'] %> options
    </p>
  <% end %>
</div>
</file>

<file path="views/question_types/_nps_score.html.erb">
<div class="space-y-4">
  <div class="space-y-3">
    <div class="flex items-center justify-between text-sm text-gray-600">
      <span>Not at all likely</span>
      <span>Extremely likely</span>
    </div>
    
    <div class="flex items-center justify-between">
      <% (0..10).each do |score| %>
        <label class="flex flex-col items-center space-y-1 cursor-pointer group nps-option" data-score="<%= score %>">
          <%= form.radio_button "answer[value]", 
                               score,
                               { 
                                 required: question.required?,
                                 class: "sr-only",
                                 data: { 
                                   "question-response-target": "answerInput",
                                   "action": "change->question-response#validateInput"
                                 }
                               } %>
          
          <div class="w-10 h-10 rounded-full border-2 border-gray-300 flex items-center justify-center group-hover:border-indigo-400 transition-colors nps-circle">
            <span class="text-sm font-medium text-gray-600 group-hover:text-indigo-600"><%= score %></span>
          </div>
        </label>
      <% end %>
    </div>
    
    <div class="flex justify-between text-xs text-gray-500">
      <span>0</span>
      <span>5</span>
      <span>10</span>
    </div>
  </div>
  
  <!-- Score interpretation -->
  <div class="hidden text-center p-3 rounded-lg" data-question-response-target="npsInterpretation">
    <div class="text-sm font-medium" data-question-response-target="npsCategory"></div>
    <div class="text-xs text-gray-600 mt-1" data-question-response-target="npsDescription"></div>
  </div>
  
  <% if config['help_text'] %>
    <p class="text-xs text-gray-500 text-center"><%= config['help_text'] %></p>
  <% end %>
</div>

<style>
  .nps-circle.selected {
    @apply border-indigo-500 bg-indigo-500;
  }
  
  .nps-circle.selected span {
    @apply text-white;
  }
  
  .nps-circle.detractor {
    @apply border-red-500 bg-red-500;
  }
  
  .nps-circle.passive {
    @apply border-yellow-500 bg-yellow-500;
  }
  
  .nps-circle.promoter {
    @apply border-green-500 bg-green-500;
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const npsOptions = document.querySelectorAll('.nps-option');
    const radioButtons = document.querySelectorAll('input[type="radio"][name="answer[value]"]');
    const npsInterpretation = document.querySelector('[data-question-response-target="npsInterpretation"]');
    const npsCategory = document.querySelector('[data-question-response-target="npsCategory"]');
    const npsDescription = document.querySelector('[data-question-response-target="npsDescription"]');
    
    const interpretations = {
      detractor: {
        category: 'Detractor (0-6)',
        description: 'Unhappy customers who can damage your brand through negative word-of-mouth.',
        bgClass: 'bg-red-50',
        textClass: 'text-red-800'
      },
      passive: {
        category: 'Passive (7-8)',
        description: 'Satisfied but unenthusiastic customers who are vulnerable to competitive offerings.',
        bgClass: 'bg-yellow-50',
        textClass: 'text-yellow-800'
      },
      promoter: {
        category: 'Promoter (9-10)',
        description: 'Loyal enthusiasts who will keep buying and refer others, fueling growth.',
        bgClass: 'bg-green-50',
        textClass: 'text-green-800'
      }
    };
    
    function updateSelection() {
      const selectedRadio = document.querySelector('input[type="radio"][name="answer[value]"]:checked');
      
      // Reset all styles
      npsOptions.forEach(option => {
        const circle = option.querySelector('.nps-circle');
        circle.classList.remove('selected', 'detractor', 'passive', 'promoter');
      });
      
      if (selectedRadio) {
        const score = parseInt(selectedRadio.value);
        const selectedOption = document.querySelector(`.nps-option[data-score="${score}"]`);
        const circle = selectedOption.querySelector('.nps-circle');
        
        circle.classList.add('selected');
        
        // Add category-specific styling
        let category;
        if (score <= 6) {
          category = 'detractor';
          circle.classList.add('detractor');
        } else if (score <= 8) {
          category = 'passive';
          circle.classList.add('passive');
        } else {
          category = 'promoter';
          circle.classList.add('promoter');
        }
        
        // Show interpretation
        if (npsInterpretation && npsCategory && npsDescription) {
          const interpretation = interpretations[category];
          npsCategory.textContent = interpretation.category;
          npsDescription.textContent = interpretation.description;
          
          npsInterpretation.className = `text-center p-3 rounded-lg ${interpretation.bgClass} ${interpretation.textClass}`;
          npsInterpretation.classList.remove('hidden');
        }
      } else {
        if (npsInterpretation) {
          npsInterpretation.classList.add('hidden');
        }
      }
    }
    
    npsOptions.forEach(option => {
      option.addEventListener('click', function() {
        const score = this.dataset.score;
        const radio = document.querySelector(`input[type="radio"][value="${score}"]`);
        
        if (radio) {
          radio.checked = true;
          radio.dispatchEvent(new Event('change'));
          updateSelection();
        }
      });
    });
    
    radioButtons.forEach(radio => {
      radio.addEventListener('change', updateSelection);
    });
    
    // Handle pre-selected values
    updateSelection();
  });
</script>
</file>

<file path="views/question_types/_number.html.erb">
<div class="space-y-2">
  <%= form.number_field "answer[value]", 
                       placeholder: config['placeholder'] || "Enter a number...",
                       min: config['min_value'],
                       max: config['max_value'],
                       step: config['step'] || 'any',
                       required: question.required?,
                       class: "block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm",
                       data: { 
                         "question-response-target": "answerInput",
                         "action": "input->question-response#validateInput"
                       } %>
  
  <% if config['min_value'] || config['max_value'] %>
    <div class="flex justify-between text-xs text-gray-500">
      <% if config['min_value'] %>
        <span>Min: <%= config['min_value'] %></span>
      <% end %>
      <% if config['max_value'] %>
        <span>Max: <%= config['max_value'] %></span>
      <% end %>
    </div>
  <% end %>
  
  <% if config['help_text'] %>
    <p class="text-xs text-gray-500"><%= config['help_text'] %></p>
  <% end %>
</div>
</file>

<file path="views/question_types/_payment.html.erb">
<div class="space-y-4" data-payment-container="true">
  
  <!-- Premium and Configuration Check -->
  <% unless @form.user.can_accept_payments? %>
    <div class="bg-red-50 border border-red-200 rounded-lg p-4">
      <div class="flex items-start">
        <svg class="w-5 h-5 text-red-600 mt-0.5 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
        </svg>
        <div>
          <h4 class="text-sm font-medium text-red-900">Payment Processing Unavailable</h4>
          <p class="mt-1 text-sm text-red-700">
            <% unless @form.user.premium? %>
              The form owner needs a Premium subscription to accept payments.
            <% else %>
              The form owner has not configured payment processing yet.
            <% end %>
          </p>
        </div>
      </div>
    </div>
    
    <!-- Return early if payment processing is not available -->
    <% return %>
  <% end %>
  
  <!-- Test Mode Indicator -->
  <% if config['enable_test_mode'] %>
    <div class="bg-blue-50 border border-blue-200 rounded-md p-3">
      <div class="flex">
        <div class="flex-shrink-0">
          <svg class="h-5 w-5 text-blue-400" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
          </svg>
        </div>
        <div class="ml-3">
          <p class="text-sm text-blue-800">
            <strong>Test Mode:</strong> Use test card numbers for payments.
          </p>
        </div>
      </div>
    </div>
  <% end %>

  <!-- Amount Display -->
  <% if config['amount'] %>
    <div class="text-center p-4 bg-gray-50 rounded-lg">
      <div class="text-2xl font-bold text-gray-900">
        <%= config['currency_symbol'] || '$' %><%= config['amount'] %>
        <% if config['currency'] %>
          <span class="text-sm font-normal text-gray-500 uppercase"><%= config['currency'] %></span>
        <% end %>
      </div>
      <% if config['description'] %>
        <p class="text-sm text-gray-600 mt-1"><%= config['description'] %></p>
      <% end %>
    </div>
  <% end %>
  
  <!-- Payment Method Selection -->
  <div class="space-y-2">
    <label class="block text-sm font-medium text-gray-700">Payment Method</label>
    
    <% payment_methods = config['payment_methods'] || ['credit_card'] %>
    <% payment_methods.each do |method| %>
      <label class="flex items-center space-x-3 p-3 border border-gray-200 rounded-lg hover:bg-gray-50 cursor-pointer">
        <%= form.radio_button "answer[payment_method]", 
                             method,
                             { 
                               required: question.required?,
                               class: "h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300",
                               data: { 
                                 "question-response-target": "answerInput",
                                 "action": "change->question-response#validateInput"
                               }
                             } %>
        
        <div class="flex items-center space-x-2">
          <% case method %>
          <% when 'credit_card' %>
            <svg class="h-5 w-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h18M7 15h1m4 0h1m-7 4h12a3 3 0 003-3V8a3 3 0 00-3-3H6a3 3 0 00-3 3v8a3 3 0 003 3z" />
            </svg>
            <span class="text-sm font-medium text-gray-900">Credit Card</span>
          <% when 'paypal' %>
            <svg class="h-5 w-5 text-blue-600" viewBox="0 0 24 24" fill="currentColor">
              <path d="M7.076 21.337H2.47a.641.641 0 0 1-.633-.74L4.944.901C5.026.382 5.474 0 5.998 0h7.46c2.57 0 4.578.543 5.69 1.81 1.01 1.15 1.304 2.42 1.012 4.287-.023.143-.047.288-.077.437-.983 5.05-4.349 6.797-8.647 6.797h-2.19c-.524 0-.968.382-1.05.9l-1.12 7.106zm14.146-14.42a3.35 3.35 0 0 0-.607-.541c-.013.076-.026.175-.041.26-.93 4.778-4.005 7.201-9.138 7.201h-2.19a.9.9 0 0 0-.89.756l-.94 5.982a.424.424 0 0 0 .417.519h3.28c.456 0 .843-.334.917-.789l.038-.24.72-4.578.046-.248c.074-.455.462-.789.917-.789h.578c3.583 0 6.390-1.455 7.209-5.662.342-1.756.166-3.22-.777-4.35a2.75 2.75 0 0 0-.539-.421z"/>
            </svg>
            <span class="text-sm font-medium text-gray-900">PayPal</span>
          <% when 'apple_pay' %>
            <svg class="h-5 w-5 text-gray-900" viewBox="0 0 24 24" fill="currentColor">
              <path d="M18.71 19.5c-.83 1.24-1.71 2.45-3.05 2.47-1.34.03-1.77-.79-3.29-.79-1.53 0-2 .77-3.27.82-1.31.05-2.3-1.32-3.14-2.53C4.25 17 2.94 12.45 4.7 9.39c.87-1.52 2.43-2.48 4.12-2.51 1.28-.02 2.5.87 3.29.87.78 0 2.26-1.07 3.81-.91.65.03 2.47.26 3.64 1.98-.09.06-2.17 1.28-2.15 3.81.03 3.02 2.65 4.03 2.68 4.04-.03.07-.42 1.44-1.38 2.83M13 3.5c.73-.83 1.94-1.46 2.94-1.5.13 1.17-.34 2.35-1.04 3.19-.69.85-1.83 1.51-2.95 1.42-.15-1.15.41-2.35 1.05-3.11z"/>
            </svg>
            <span class="text-sm font-medium text-gray-900">Apple Pay</span>
          <% when 'google_pay' %>
            <svg class="h-5 w-5 text-blue-600" viewBox="0 0 24 24" fill="currentColor">
              <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
              <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
              <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
              <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
            </svg>
            <span class="text-sm font-medium text-gray-900">Google Pay</span>
          <% else %>
            <span class="text-sm font-medium text-gray-900 capitalize"><%= method.humanize %></span>
          <% end %>
        </div>
      </label>
    <% end %>
  </div>

  <!-- Payment Processing Area -->
  <div class="payment-processing-area mt-6">
    
    <!-- Stripe Card Element -->
    <div class="stripe-payment-container" data-payment-method="credit_card">
      <div class="border border-gray-200 rounded-lg p-4">
        <div class="text-sm font-medium text-gray-700 mb-2">Card Information</div>
        <div class="stripe-card-element" style="border: 1px solid #ccc; padding: 12px; border-radius: 4px; background: white;"></div>
        <div class="payment-error text-red-600 text-sm mt-2" style="display: none;"></div>
      </div>
    </div>

    <!-- PayPal Button -->
    <div class="paypal-payment-container" data-payment-method="paypal">
      <div class="paypal-button-container"></div>
    </div>

    <!-- Apple Pay Button -->
    <div class="apple-pay-payment-container" data-payment-method="apple_pay">
      <div class="border border-gray-200 rounded-lg p-4">
        <div class="apple-pay-button" style="background: black; color: white; padding: 12px; border-radius: 4px; text-align: center;">
          <strong>Pay with Apple Pay</strong>
        </div>
      </div>
    </div>

    <!-- Google Pay Button -->
    <div class="google-pay-payment-container" data-payment-method="google_pay">
      <div class="border border-gray-200 rounded-lg p-4">
        <div class="google-pay-button" style="background: #4285f4; color: white; padding: 12px; border-radius: 4px; text-align: center;">
          <strong>Pay with Google Pay</strong>
        </div>
      </div>
    </div>

  </div>
  
  <!-- Hidden Fields -->
  <%= form.hidden_field "answer[payment_amount]", value: config['amount'] %>
  <%= form.hidden_field "answer[payment_currency]", value: config['currency'] %>
  <%= form.hidden_field "answer[payment_status]", value: "pending" %>
  
  <% if config['help_text'] %>
    <p class="text-xs text-gray-500"><%= config['help_text'] %></p>
  <% end %>
</div>

<!-- Load Stripe and PayPal SDKs -->
<script src="https://js.stripe.com/v3/"></script>
<script src="https://www.paypal.com/sdk/js?client-id=<%= config['paypal_config']&.dig('client_id') || 'sb' %>&currency=<%= config['currency'] || 'USD' %>"></script>
</file>

<file path="views/question_types/_phone.html.erb">
<div class="space-y-2">
  <%= form.telephone_field "answer[value]", 
                          placeholder: config['placeholder'] || "Enter your phone number...",
                          required: question.required?,
                          pattern: config['pattern'] || "[0-9\s\-\+\(\)]+",
                          class: "block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm",
                          data: { 
                            "question-response-target": "answerInput",
                            "action": "input->question-response#validateInput"
                          } %>
  
  <% if config['help_text'] %>
    <p class="text-xs text-gray-500"><%= config['help_text'] %></p>
  <% end %>
  
  <% if config['format_hint'] %>
    <p class="text-xs text-gray-400">Format: <%= config['format_hint'] %></p>
  <% end %>
</div>
</file>

<file path="views/question_types/_ranking.html.erb">
<div class="space-y-4">
  <% items = config['items'] || [] %>
  
  <% if items.any? %>
    <div class="space-y-2">
      <p class="text-sm text-gray-600 mb-3">
        Drag and drop to rank the items from most important (top) to least important (bottom).
      </p>
      
      <div class="space-y-2 ranking-container" data-question-response-target="rankingContainer">
        <% items.each_with_index do |item, index| %>
          <div class="ranking-item flex items-center space-x-3 p-3 bg-white border border-gray-200 rounded-lg cursor-move hover:shadow-sm transition-shadow"
               data-item-id="<%= item['id'] || index %>"
               data-original-position="<%= index %>">
            
            <!-- Drag handle -->
            <div class="flex-shrink-0 text-gray-400 hover:text-gray-600">
              <svg class="h-5 w-5" fill="currentColor" viewBox="0 0 20 20">
                <path d="M10 6a2 2 0 110-4 2 2 0 010 4zM10 12a2 2 0 110-4 2 2 0 010 4zM10 18a2 2 0 110-4 2 2 0 010 4z" />
              </svg>
            </div>
            
            <!-- Rank number -->
            <div class="flex-shrink-0 w-8 h-8 bg-indigo-100 text-indigo-800 rounded-full flex items-center justify-center text-sm font-medium rank-number">
              <%= index + 1 %>
            </div>
            
            <!-- Item content -->
            <div class="flex-1">
              <div class="text-sm font-medium text-gray-900">
                <%= item['label'] || item %>
              </div>
              <% if item.is_a?(Hash) && item['description'] %>
                <div class="text-xs text-gray-500 mt-1">
                  <%= item['description'] %>
                </div>
              <% end %>
            </div>
          </div>
        <% end %>
      </div>
      
      <!-- Hidden field to store ranking data -->
      <%= form.hidden_field "answer[ranking]", 
                           data: { "question-response-target": "rankingData" } %>
    </div>
  <% else %>
    <div class="text-center py-8 text-gray-500">
      <p class="text-sm">No items to rank.</p>
      <p class="text-xs mt-1">Please configure ranking items in the question settings.</p>
    </div>
  <% end %>
  
  <% if config['help_text'] %>
    <p class="text-xs text-gray-500"><%= config['help_text'] %></p>
  <% end %>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const container = document.querySelector('.ranking-container');
    const rankingData = document.querySelector('[data-question-response-target="rankingData"]');
    
    if (!container || !rankingData) return;
    
    let draggedElement = null;
    
    // Make items draggable
    const items = container.querySelectorAll('.ranking-item');
    items.forEach(item => {
      item.draggable = true;
      
      item.addEventListener('dragstart', function(e) {
        draggedElement = this;
        this.classList.add('opacity-50');
        e.dataTransfer.effectAllowed = 'move';
      });
      
      item.addEventListener('dragend', function(e) {
        this.classList.remove('opacity-50');
        draggedElement = null;
      });
      
      item.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
      });
      
      item.addEventListener('dragenter', function(e) {
        e.preventDefault();
        this.classList.add('border-indigo-400', 'bg-indigo-50');
      });
      
      item.addEventListener('dragleave', function(e) {
        this.classList.remove('border-indigo-400', 'bg-indigo-50');
      });
      
      item.addEventListener('drop', function(e) {
        e.preventDefault();
        this.classList.remove('border-indigo-400', 'bg-indigo-50');
        
        if (draggedElement && draggedElement !== this) {
          // Get all items
          const allItems = Array.from(container.querySelectorAll('.ranking-item'));
          const draggedIndex = allItems.indexOf(draggedElement);
          const targetIndex = allItems.indexOf(this);
          
          // Reorder items
          if (draggedIndex < targetIndex) {
            this.parentNode.insertBefore(draggedElement, this.nextSibling);
          } else {
            this.parentNode.insertBefore(draggedElement, this);
          }
          
          updateRankNumbers();
          updateRankingData();
        }
      });
    });
    
    function updateRankNumbers() {
      const items = container.querySelectorAll('.ranking-item');
      items.forEach((item, index) => {
        const rankNumber = item.querySelector('.rank-number');
        if (rankNumber) {
          rankNumber.textContent = index + 1;
        }
      });
    }
    
    function updateRankingData() {
      const items = container.querySelectorAll('.ranking-item');
      const ranking = Array.from(items).map((item, index) => ({
        id: item.dataset.itemId,
        position: index + 1,
        original_position: parseInt(item.dataset.originalPosition)
      }));
      
      rankingData.value = JSON.stringify(ranking);
      
      // Trigger validation
      rankingData.dispatchEvent(new Event('input'));
    }
    
    // Initialize ranking data
    updateRankingData();
  });
</script>
</file>

<file path="views/question_types/_rating.html.erb">
<div class="space-y-4" data-controller="rating"
     data-rating-question-id-value="<%= question.id %>"
     data-rating-required-value="<%= question.required? %>">
  <% scale_min = config['min_value'] || 1 %>
  <% scale_max = config['max_value'] || 5 %>
  <% scale_labels = config['scale_labels'] || {} %>
  <% show_numbers = config['show_numbers'] != false %>
  
  <div class="flex items-center justify-between">
    <% if scale_labels['min_label'] %>
      <span class="text-sm text-gray-600"><%= scale_labels['min_label'] %></span>
    <% end %>
    
    <div class="flex items-center space-x-2" data-rating-target="container">
      <% (scale_min..scale_max).each do |value| %>
        <label class="flex flex-col items-center space-y-1 cursor-pointer group"
               onclick="handleRatingClick(this, '<%= value %>')"
               onmouseover="handleRatingHover(this, true)"
               onmouseout="handleRatingHover(this, false)">
          <%= form.radio_button "answer[value]", 
                               value,
                               required: question.required?,
                               class: "sr-only",
                               data: { 
                                 "question-response-target": "answerInput",
                                 "action": "change->question-response#validateInput"
                               },
                               onclick: "this.checked = true; this.dispatchEvent(new Event('change')); return true;" %>
          
          <div class="w-10 h-10 rounded-full border-2 border-gray-300 flex items-center justify-center transition-all duration-200 rating-option hover:scale-110"
               data-value="<%= value %>"
               data-rating-target="option">
            <% if show_numbers %>
              <span class="text-sm font-medium text-gray-600 group-hover:text-indigo-600"><%= value %></span>
            <% end %>
          </div>
          
          <% if scale_labels[value.to_s] %>
            <span class="text-xs text-gray-500 text-center max-w-16">
              <%= scale_labels[value.to_s] %>
            </span>
          <% end %>
        </label>
      <% end %>
    </div>
    
    <% if scale_labels['max_label'] %>
      <span class="text-sm text-gray-600"><%= scale_labels['max_label'] %></span>
    <% end %>
  </div>
  
  <% if config['help_text'] %>
    <p class="text-xs text-gray-500 text-center"><%= config['help_text'] %></p>
  <% end %>
</div>

<script>
  // Simple inline functions for rating interaction (fallback approach)
  function handleRatingClick(label, value) {
    // Find all rating options in this container
    const container = label.closest('[data-rating-target="container"]');
    if (!container) return;
    
    const allOptions = container.querySelectorAll('.rating-option');
    const clickedOption = label.querySelector('.rating-option');
    
    // Remove selected class from all options
    allOptions.forEach(option => {
      option.classList.remove('selected', 'border-indigo-500', 'bg-indigo-500', 'scale-110');
      option.classList.add('border-gray-300');
      
      // Reset text color
      const span = option.querySelector('span');
      if (span) {
        span.classList.remove('text-white', 'font-bold');
        span.classList.add('text-gray-600');
      }
    });
    
    // Add selected class to clicked option
    if (clickedOption) {
      clickedOption.classList.add('selected', 'border-indigo-500', 'bg-indigo-500', 'scale-110');
      clickedOption.classList.remove('border-gray-300');
      
      // Update text color
      const span = clickedOption.querySelector('span');
      if (span) {
        span.classList.add('text-white', 'font-bold');
        span.classList.remove('text-gray-600');
      }
      
      // Add animation
      clickedOption.style.animation = 'none';
      clickedOption.offsetHeight; // Trigger reflow
      clickedOption.style.animation = 'pulse 0.3s ease-in-out';
    }
  }
  
  function handleRatingHover(label, isHovering) {
    const option = label.querySelector('.rating-option');
    if (!option) return;
    
    // Don't apply hover effects if already selected
    if (option.classList.contains('selected')) return;
    
    if (isHovering) {
      option.classList.add('border-indigo-400', 'bg-indigo-50', 'scale-110');
      const span = option.querySelector('span');
      if (span) {
        span.classList.add('text-indigo-600');
        span.classList.remove('text-gray-600');
      }
    } else {
      option.classList.remove('border-indigo-400', 'bg-indigo-50', 'scale-110');
      const span = option.querySelector('span');
      if (span) {
        span.classList.remove('text-indigo-600');
        span.classList.add('text-gray-600');
      }
    }
  }
  
  // Initialize any pre-selected values when the page loads
  document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('.rating-option').forEach(option => {
      const value = option.dataset.value;
      const radio = option.closest('label').querySelector('input[type="radio"]');
      if (radio && radio.checked) {
        handleRatingClick(option.closest('label'), value);
      }
    });
  });
</script>

<style>
  .rating-option {
    transition: all 0.2s ease-in-out;
  }
  
  .rating-option.selected {
    @apply border-indigo-500 bg-indigo-500 scale-110;
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
  }
  
  .rating-option.selected span {
    @apply text-white font-bold;
  }
  
  /* Animation for selection */
  .rating-option.selected {
    animation: pulse 0.3s ease-in-out;
  }
  
  @keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.15); }
    100% { transform: scale(1.1); }
  }
</style>
</file>

<file path="views/question_types/_scale.html.erb">
<div class="space-y-4">
  <% scale_min = config['min_value'] || 0 %>
  <% scale_max = config['max_value'] || 10 %>
  <% scale_labels = config['scale_labels'] || {} %>
  <% show_numbers = config['show_numbers'] != false %>
  
  <div class="space-y-3">
    <div class="flex items-center justify-between">
      <% if scale_labels['min_label'] %>
        <span class="text-sm text-gray-600"><%= scale_labels['min_label'] %></span>
      <% end %>
      
      <% if scale_labels['max_label'] %>
        <span class="text-sm text-gray-600"><%= scale_labels['max_label'] %></span>
      <% end %>
    </div>
    
    <div class="relative">
      <%= form.range_field "answer[value]", 
                          min: scale_min,
                          max: scale_max,
                          step: config['step'] || 1,
                          value: config['default_value'] || scale_min,
                          required: question.required?,
                          class: "w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider",
                          data: { 
                            "question-response-target": "answerInput",
                            "action": "input->question-response#validateInput change->question-response#updateSliderValue"
                          } %>
      
      <% if show_numbers %>
        <div class="flex justify-between text-xs text-gray-500 mt-1">
          <span><%= scale_min %></span>
          <span><%= scale_max %></span>
        </div>
      <% end %>
    </div>
    
    <div class="text-center">
      <span class="text-lg font-medium text-gray-900" data-question-response-target="sliderValue">
        <%= config['default_value'] || scale_min %>
      </span>
    </div>
  </div>
  
  <% if config['help_text'] %>
    <p class="text-xs text-gray-500 text-center"><%= config['help_text'] %></p>
  <% end %>
</div>

<style>
  .slider::-webkit-slider-thumb {
    appearance: none;
    height: 20px;
    width: 20px;
    border-radius: 50%;
    background: #6366f1;
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }
  
  .slider::-moz-range-thumb {
    height: 20px;
    width: 20px;
    border-radius: 50%;
    background: #6366f1;
    cursor: pointer;
    border: none;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }
</style>
</file>

<file path="views/question_types/_signature.html.erb">
<div class="space-y-4">
  <div class="border-2 border-gray-300 rounded-lg p-4 bg-white">
    <div class="space-y-3">
      <div class="flex items-center justify-between">
        <label class="block text-sm font-medium text-gray-700">Digital Signature</label>
        <button type="button" 
                class="text-sm text-indigo-600 hover:text-indigo-500"
                data-action="click->question-response#clearSignature">
          Clear
        </button>
      </div>
      
      <!-- Signature canvas -->
      <div class="border border-gray-200 rounded-md bg-gray-50">
        <canvas 
          data-question-response-target="signatureCanvas"
          width="400" 
          height="200" 
          class="w-full h-48 cursor-crosshair rounded-md"
          data-action="mousedown->question-response#startSignature mousemove->question-response#drawSignature mouseup->question-response#endSignature touchstart->question-response#startSignature touchmove->question-response#drawSignature touchend->question-response#endSignature">
        </canvas>
      </div>
      
      <!-- Hidden field to store signature data -->
      <%= form.hidden_field "answer[signature_data]", 
                           data: { "question-response-target": "signatureData" } %>
      
      <div class="flex items-center justify-between text-xs text-gray-500">
        <span>Sign above using your mouse or finger</span>
        <span data-question-response-target="signatureStatus">No signature</span>
      </div>
    </div>
  </div>
  
  <% if config['help_text'] %>
    <p class="text-xs text-gray-500"><%= config['help_text'] %></p>
  <% end %>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const canvas = document.querySelector('[data-question-response-target="signatureCanvas"]');
    const signatureData = document.querySelector('[data-question-response-target="signatureData"]');
    const signatureStatus = document.querySelector('[data-question-response-target="signatureStatus"]');
    const clearButton = document.querySelector('[data-action*="clearSignature"]');
    
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    
    // Set up canvas
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    function getEventPos(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      
      let clientX, clientY;
      
      if (e.touches && e.touches[0]) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }
      
      return {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top) * scaleY
      };
    }
    
    function startSignature(e) {
      e.preventDefault();
      isDrawing = true;
      const pos = getEventPos(e);
      lastX = pos.x;
      lastY = pos.y;
    }
    
    function drawSignature(e) {
      if (!isDrawing) return;
      e.preventDefault();
      
      const pos = getEventPos(e);
      
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(pos.x, pos.y);
      ctx.stroke();
      
      lastX = pos.x;
      lastY = pos.y;
      
      updateSignatureData();
    }
    
    function endSignature(e) {
      if (!isDrawing) return;
      e.preventDefault();
      isDrawing = false;
      updateSignatureData();
    }
    
    function clearSignature() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      signatureData.value = '';
      signatureStatus.textContent = 'No signature';
      
      // Trigger validation
      signatureData.dispatchEvent(new Event('input'));
    }
    
    function updateSignatureData() {
      const dataURL = canvas.toDataURL('image/png');
      signatureData.value = dataURL;
      signatureStatus.textContent = 'Signature captured';
      
      // Trigger validation
      signatureData.dispatchEvent(new Event('input'));
    }
    
    // Event listeners
    canvas.addEventListener('mousedown', startSignature);
    canvas.addEventListener('mousemove', drawSignature);
    canvas.addEventListener('mouseup', endSignature);
    canvas.addEventListener('mouseout', endSignature);
    
    canvas.addEventListener('touchstart', startSignature);
    canvas.addEventListener('touchmove', drawSignature);
    canvas.addEventListener('touchend', endSignature);
    
    clearButton.addEventListener('click', clearSignature);
    
    // Prevent scrolling when touching the canvas
    canvas.addEventListener('touchstart', function(e) {
      e.preventDefault();
    }, { passive: false });
    
    canvas.addEventListener('touchend', function(e) {
      e.preventDefault();
    }, { passive: false });
    
    canvas.addEventListener('touchmove', function(e) {
      e.preventDefault();
    }, { passive: false });
  });
</script>
</file>

<file path="views/question_types/_single_choice.html.erb">
<div class="space-y-3">
  <% choices = config['options'] || [] %>
  
  <div class="space-y-2">
    <% choices.each_with_index do |choice, index| %>
      <label class="flex items-start space-x-3 p-3 border border-gray-200 rounded-lg hover:bg-gray-50 cursor-pointer transition-colors">
        <%= form.radio_button "answer[value]", 
                             choice['value'] || choice,
                             { 
                               required: question.required?,
                               class: "mt-0.5 h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300",
                               data: { 
                                 "question-response-target": "answerInput",
                                 "action": "change->question-response#validateInput"
                               }
                             } %>
        
        <div class="flex-1">
          <span class="text-sm font-medium text-gray-900">
            <%= choice['label'] || choice %>
          </span>
          
          <% if choice.is_a?(Hash) && choice['description'] %>
            <p class="text-xs text-gray-500 mt-1"><%= choice['description'] %></p>
          <% end %>
        </div>
      </label>
    <% end %>
    
    <!-- Other option (if enabled) -->
    <% if config['allow_other'] %>
      <label class="flex items-start space-x-3 p-3 border border-gray-200 rounded-lg hover:bg-gray-50 cursor-pointer transition-colors">
        <%= form.radio_button "answer[value]", 
                             'other',
                             { 
                               class: "mt-0.5 h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300",
                               data: { 
                                 "question-response-target": "otherRadio",
                                 "action": "change->question-response#toggleOtherInput"
                               }
                             } %>
        
        <div class="flex-1">
          <span class="text-sm font-medium text-gray-900">Other</span>
          
          <div class="mt-2 hidden" data-question-response-target="otherInputContainer">
            <%= form.text_field "answer[other_value]", 
                               placeholder: "Please specify...",
                               class: "block w-full text-sm border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500",
                               data: { 
                                 "question-response-target": "otherInput",
                                 "action": "input->question-response#validateInput"
                               } %>
          </div>
        </div>
      </label>
    <% end %>
  </div>
  
  <% if config['help_text'] %>
    <p class="text-xs text-gray-500"><%= config['help_text'] %></p>
  <% end %>
</div>
</file>

<file path="views/question_types/_slider.html.erb">
<div class="space-y-4">
  <% min_value = config['min_value'] || 0 %>
  <% max_value = config['max_value'] || 100 %>
  <% step_value = config['step'] || 1 %>
  <% default_value = config['default_value'] || min_value %>
  <% prefix = config['prefix'] || '' %>
  <% suffix = config['suffix'] || '' %>
  
  <div class="space-y-3">
    <div class="flex items-center justify-between text-sm text-gray-600">
      <span><%= prefix %><%= min_value %><%= suffix %></span>
      <span><%= prefix %><%= max_value %><%= suffix %></span>
    </div>
    
    <div class="relative">
      <%= form.range_field "answer[value]", 
                          min: min_value,
                          max: max_value,
                          step: step_value,
                          value: default_value,
                          required: question.required?,
                          class: "w-full h-3 bg-gray-200 rounded-lg appearance-none cursor-pointer slider-custom",
                          data: { 
                            "question-response-target": "answerInput",
                            "action": "input->question-response#validateInput change->question-response#updateSliderValue",
                            "prefix": prefix,
                            "suffix": suffix
                          } %>
    </div>
    
    <div class="text-center">
      <span class="text-xl font-semibold text-indigo-600" data-question-response-target="sliderValue">
        <%= prefix %><%= default_value %><%= suffix %>
      </span>
    </div>
  </div>
  
  <% if config['help_text'] %>
    <p class="text-xs text-gray-500 text-center"><%= config['help_text'] %></p>
  <% end %>
</div>

<style>
  .slider-custom {
    background: linear-gradient(to right, #e5e7eb 0%, #e5e7eb 100%);
  }
  
  .slider-custom::-webkit-slider-thumb {
    appearance: none;
    height: 24px;
    width: 24px;
    border-radius: 50%;
    background: #6366f1;
    cursor: pointer;
    box-shadow: 0 4px 8px rgba(99, 102, 241, 0.3);
    transition: all 0.2s ease;
  }
  
  .slider-custom::-webkit-slider-thumb:hover {
    transform: scale(1.1);
    box-shadow: 0 6px 12px rgba(99, 102, 241, 0.4);
  }
  
  .slider-custom::-moz-range-thumb {
    height: 24px;
    width: 24px;
    border-radius: 50%;
    background: #6366f1;
    cursor: pointer;
    border: none;
    box-shadow: 0 4px 8px rgba(99, 102, 241, 0.3);
    transition: all 0.2s ease;
  }
  
  .slider-custom::-moz-range-thumb:hover {
    transform: scale(1.1);
    box-shadow: 0 6px 12px rgba(99, 102, 241, 0.4);
  }
</style>
</file>

<file path="views/question_types/_text_long.html.erb">
<div class="space-y-2">
  <%= form.text_area "answer[value]", 
                     placeholder: config['placeholder'] || "Enter your answer...",
                     maxlength: config['max_length'],
                     minlength: config['min_length'],
                     required: question.required?,
                     rows: config['rows'] || 4,
                     class: "block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm resize-y",
                     data: { 
                       "question-response-target": "answerInput",
                       "action": "input->question-response#validateInput"
                     } %>
  
  <% if config['max_length'] %>
    <div class="flex justify-end">
      <span class="text-xs text-gray-500">
        <span data-question-response-target="charCount">0</span> / <%= config['max_length'] %> characters
      </span>
    </div>
  <% end %>
  
  <% if config['help_text'] %>
    <p class="text-xs text-gray-500"><%= config['help_text'] %></p>
  <% end %>
</div>
</file>

<file path="views/question_types/_text_short.html.erb">
<div class="space-y-2">
  <%= form.text_field "answer[value]", 
                     placeholder: config['placeholder'] || "Enter your answer...",
                     maxlength: config['max_length'],
                     minlength: config['min_length'],
                     required: question.required?,
                     class: "block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm",
                     data: { 
                       "question-response-target": "answerInput",
                       "action": "input->question-response#validateInput"
                     } %>
  
  <% if config['max_length'] %>
    <div class="flex justify-end">
      <span class="text-xs text-gray-500">
        <span data-question-response-target="charCount">0</span> / <%= config['max_length'] %> characters
      </span>
    </div>
  <% end %>
  
  <% if config['help_text'] %>
    <p class="text-xs text-gray-500"><%= config['help_text'] %></p>
  <% end %>
</div>
</file>

<file path="views/question_types/_time.html.erb">
<div class="space-y-2">
  <%= form.time_field "answer[value]", 
                     min: config['min_time'],
                     max: config['max_time'],
                     step: config['step'] || 60,
                     required: question.required?,
                     class: "block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm",
                     data: { 
                       "question-response-target": "answerInput",
                       "action": "change->question-response#validateInput"
                     } %>
  
  <% if config['min_time'] || config['max_time'] %>
    <div class="flex justify-between text-xs text-gray-500">
      <% if config['min_time'] %>
        <span>From: <%= config['min_time'] %></span>
      <% end %>
      <% if config['max_time'] %>
        <span>Until: <%= config['max_time'] %></span>
      <% end %>
    </div>
  <% end %>
  
  <% if config['help_text'] %>
    <p class="text-xs text-gray-500"><%= config['help_text'] %></p>
  <% end %>
</div>
</file>

<file path="views/question_types/_url.html.erb">
<div class="space-y-2">
  <%= form.url_field "answer[value]", 
                     placeholder: config['placeholder'] || "Enter a URL...",
                     required: question.required?,
                     class: "block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm",
                     data: { 
                       "question-response-target": "answerInput",
                       "action": "input->question-response#validateInput"
                     } %>
  
  <% if config['help_text'] %>
    <p class="text-xs text-gray-500"><%= config['help_text'] %></p>
  <% end %>
</div>
</file>

<file path="views/question_types/_yes_no.html.erb">
<div class="space-y-3">
  <div class="flex items-center justify-center space-x-4">
    <label class="flex items-center space-x-3 p-4 border-2 border-gray-200 rounded-lg hover:border-green-300 hover:bg-green-50 cursor-pointer transition-all duration-200 yes-option">
      <%= form.radio_button "answer[value]", 
                           "yes",
                           { 
                             required: question.required?,
                             class: "sr-only",
                             data: { 
                               "question-response-target": "answerInput",
                               "action": "change->question-response#validateInput"
                             }
                           } %>
      
      <div class="flex items-center space-x-2">
        <div class="w-6 h-6 rounded-full border-2 border-green-500 flex items-center justify-center bg-white">
          <div class="w-3 h-3 rounded-full bg-green-500 hidden check-indicator"></div>
        </div>
        <span class="text-lg font-medium text-gray-900">Yes</span>
      </div>
    </label>
    
    <label class="flex items-center space-x-3 p-4 border-2 border-gray-200 rounded-lg hover:border-red-300 hover:bg-red-50 cursor-pointer transition-all duration-200 no-option">
      <%= form.radio_button "answer[value]", 
                           "no",
                           { 
                             required: question.required?,
                             class: "sr-only",
                             data: { 
                               "question-response-target": "answerInput",
                               "action": "change->question-response#validateInput"
                             }
                           } %>
      
      <div class="flex items-center space-x-2">
        <div class="w-6 h-6 rounded-full border-2 border-red-500 flex items-center justify-center bg-white">
          <div class="w-3 h-3 rounded-full bg-red-500 hidden check-indicator"></div>
        </div>
        <span class="text-lg font-medium text-gray-900">No</span>
      </div>
    </label>
  </div>
  
  <% if config['help_text'] %>
    <p class="text-xs text-gray-500 text-center"><%= config['help_text'] %></p>
  <% end %>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const yesOption = document.querySelector('.yes-option');
    const noOption = document.querySelector('.no-option');
    const radioButtons = document.querySelectorAll('input[type="radio"][name="answer[value]"]');
    
    function updateSelection() {
      const yesRadio = document.querySelector('input[type="radio"][value="yes"]');
      const noRadio = document.querySelector('input[type="radio"][value="no"]');
      
      // Reset all styles
      yesOption.classList.remove('border-green-500', 'bg-green-50');
      noOption.classList.remove('border-red-500', 'bg-red-50');
      document.querySelectorAll('.check-indicator').forEach(el => el.classList.add('hidden'));
      
      if (yesRadio && yesRadio.checked) {
        yesOption.classList.add('border-green-500', 'bg-green-50');
        yesOption.querySelector('.check-indicator').classList.remove('hidden');
      } else if (noRadio && noRadio.checked) {
        noOption.classList.add('border-red-500', 'bg-red-50');
        noOption.querySelector('.check-indicator').classList.remove('hidden');
      }
    }
    
    radioButtons.forEach(radio => {
      radio.addEventListener('change', updateSelection);
    });
    
    // Handle pre-selected values
    updateSelection();
  });
</script>
</file>

<file path="views/reports/show.html.erb">
<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
  <!-- Header with report information -->
  <div class="bg-white shadow-sm rounded-lg mb-8">
    <div class="px-6 py-4 border-b border-gray-200">
      <div class="flex items-center justify-between">
        <div>
          <h1 class="text-2xl font-bold text-gray-900">
            Strategic Analysis Report
          </h1>
          <p class="text-gray-600 mt-1">
            Generated for <%= @analysis_report.form_response.form.name %>
          </p>
        </div>
        
        <div class="flex space-x-3">
          <% if @analysis_report.completed? %>
            <%= link_to download_analysis_report_path(@analysis_report),
                        class: "inline-flex items-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700" do %>
              <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
              </svg>
              Download Report
            <% end %>
          <% end %>
          
          <%= link_to responses_form_path(@analysis_report.form_response.form),
                      class: "inline-flex items-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50" do %>
            Back to Responses
          <% end %>
        </div>
      </div>
    </div>
    
    <!-- Report Status and Metadata -->
    <div class="px-6 py-4">
      <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
        <div class="flex items-center">
          <div class="flex-shrink-0">
            <% case @analysis_report.status %>
            <% when 'completed' %>
              <div class="w-8 h-8 bg-green-100 rounded-full flex items-center justify-center">
                <svg class="w-5 h-5 text-green-600" fill="currentColor" viewBox="0 0 20 20">
                  <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" />
                </svg>
              </div>
            <% when 'generating' %>
              <div class="w-8 h-8 bg-yellow-100 rounded-full flex items-center justify-center">
                <svg class="w-5 h-5 text-yellow-600 animate-spin" fill="none" viewBox="0 0 24 24">
                  <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                  <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
              </div>
            <% when 'failed' %>
              <div class="w-8 h-8 bg-red-100 rounded-full flex items-center justify-center">
                <svg class="w-5 h-5 text-red-600" fill="currentColor" viewBox="0 0 20 20">
                  <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                </svg>
              </div>
            <% end %>
          </div>
          <div class="ml-3">
            <p class="text-sm font-medium text-gray-900">Status</p>
            <p class="text-sm text-gray-600 capitalize"><%= @analysis_report.status %></p>
          </div>
        </div>
        
        <div>
          <p class="text-sm font-medium text-gray-900">File Size</p>
          <p class="text-sm text-gray-600"><%= @analysis_report.respond_to?(:formatted_file_size) ? @analysis_report.formatted_file_size : 'N/A' %></p>
        </div>
        
        <div>
          <p class="text-sm font-medium text-gray-900">AI Cost</p>
          <p class="text-sm text-gray-600">$<%= @analysis_report.ai_cost || '0.00' %></p>
        </div>
        
        <div>
          <p class="text-sm font-medium text-gray-900">Generated</p>
          <p class="text-sm text-gray-600">
            <%= @analysis_report.generated_at&.strftime('%B %d, %Y at %I:%M %p') || 'In progress...' %>
          </p>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Report Content -->
  <% if @analysis_report.completed? %>
    <div class="bg-white shadow-sm rounded-lg">
      <div class="px-6 py-4 border-b border-gray-200">
        <h2 class="text-lg font-medium text-gray-900">Report Content</h2>
        <p class="text-sm text-gray-600 mt-1">
          AI-generated strategic analysis based on form responses
        </p>
      </div>
      
      <div class="px-6 py-6">
        <div class="prose prose-lg max-w-none">
          <%= simple_format(@analysis_report.markdown_content) %>
        </div>
      </div>
    </div>
    
  <% elsif @analysis_report.generating? %>
    <!-- Loading State -->
    <div class="bg-white shadow-sm rounded-lg" id="generating-report">
      <div class="px-6 py-12 text-center">
        <div class="inline-flex items-center justify-center w-16 h-16 bg-blue-100 rounded-full mb-4">
          <svg class="w-8 h-8 text-blue-600 animate-spin" fill="none" viewBox="0 0 24 24">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
        </div>
        
        <h3 class="text-lg font-medium text-gray-900 mb-2">
          Generating Strategic Analysis Report
        </h3>
        
        <p class="text-gray-600 mb-6">
          Our AI is analyzing your responses and generating a comprehensive strategic report.
          This usually takes 3-5 minutes.
        </p>
        
        <!-- Progress Bar -->
        <div class="max-w-md mx-auto">
          <div class="bg-gray-200 rounded-full h-2">
            <div class="bg-blue-600 h-2 rounded-full transition-all duration-500" 
                 id="progress-bar"
                 style="width: 10%"></div>
          </div>
          <p class="text-sm text-gray-500 mt-2" id="progress-text">
            Starting analysis...
          </p>
        </div>
        
        <!-- What's being analyzed -->
        <div class="mt-8 text-left max-w-2xl mx-auto">
          <h4 class="text-sm font-medium text-gray-900 mb-3">Analysis Includes:</h4>
          <div class="grid grid-cols-1 md:grid-cols-2 gap-3 text-sm text-gray-600">
            <div class="flex items-center">
              <svg class="w-4 h-4 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" />
              </svg>
              Strategic positioning analysis
            </div>
            <div class="flex items-center">
              <svg class="w-4 h-4 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" />
              </svg>
              Technical recommendations
            </div>
            <div class="flex items-center">
              <svg class="w-4 h-4 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" />
              </svg>
              Risk assessment & mitigation
            </div>
            <div class="flex items-center">
              <svg class="w-4 h-4 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" />
              </svg>
              Implementation roadmap
            </div>
            <div class="flex items-center">
              <svg class="w-4 h-4 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" />
              </svg>
              Financial projections
            </div>
            <div class="flex items-center">
              <svg class="w-4 h-4 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" />
              </svg>
              Next steps recommendations
            </div>
          </div>
        </div>
      </div>
    </div>
    
  <% elsif @analysis_report.failed? %>
    <!-- Error State -->
    <div class="bg-white shadow-sm rounded-lg">
      <div class="px-6 py-12 text-center">
        <div class="inline-flex items-center justify-center w-16 h-16 bg-red-100 rounded-full mb-4">
          <svg class="w-8 h-8 text-red-600" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
          </svg>
        </div>
        
        <h3 class="text-lg font-medium text-gray-900 mb-2">
          Report Generation Failed
        </h3>
        
        <p class="text-gray-600 mb-6">
          Unfortunately, there was an error generating your strategic analysis report.
          Please try again or contact support if the problem persists.
        </p>
        
        <%= button_to "Try Again",
                    generate_reports_path,
                    params: { form_response_id: @analysis_report.form_response.id },
                    class: "inline-flex items-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700" %>
      </div>
    </div>
  <% end %>
</div>

<!-- JavaScript for Real-time Updates -->
<% if @analysis_report.generating? %>
<script>
(function() {
  const statusUrl = '<%= status_analysis_report_path(@analysis_report) %>';
  const progressBar = document.getElementById('progress-bar');
  const progressText = document.getElementById('progress-text');
  let pollCount = 0;
  const maxPolls = 120; // 10 minutes at 5-second intervals

  function updateProgress(progress) {
    if (progressBar) {
      progressBar.style.width = progress + '%';
    }
    if (progressText) {
      progressText.textContent = progress + '% complete...';
    }
  }

  function pollStatus() {
    if (pollCount >= maxPolls) {
      if (progressText) {
        progressText.textContent = 'Taking longer than expected. Please refresh the page.';
      }
      return;
    }

    fetch(statusUrl, {
      method: 'GET',
      headers: {
        'Accept': 'application/json',
        'X-Requested-With': 'XMLHttpRequest'
      }
    })
    .then(response => response.json())
    .then(data => {
      if (data.status === 'completed' || data.status === 'failed') {
        // Reload the page to show the updated state
        window.location.reload();
      } else if (data.status === 'generating') {
        updateProgress(data.progress || 50);
        pollCount++;
        setTimeout(pollStatus, 5000); // Poll every 5 seconds
      }
    })
    .catch(error => {
      console.error('Polling error:', error);
      pollCount++;
      if (pollCount < maxPolls) {
        setTimeout(pollStatus, 5000); // Continue polling despite errors
      }
    });
  }

  // Start polling after a short delay
  setTimeout(pollStatus, 2000);
})();
</script>
<% end %>
</file>

<file path="views/responses/_budget_adaptation_question.html.erb">
<!-- app/views/responses/_budget_adaptation_question.html.erb -->

<div class="dynamic-question-container bg-blue-50 border-l-4 border-blue-400 p-6 rounded-lg shadow-sm mb-6" 
     id="dynamic_question_<%= dynamic_question.id %>"
     data-dynamic-question-id="<%= dynamic_question.id %>">
  
  <div class="flex items-start space-x-4">
    <!-- AI Icon -->
    <div class="flex-shrink-0">
      <div class="w-10 h-10 bg-blue-500 rounded-full flex items-center justify-center shadow-sm">
        <svg class="w-5 h-5 text-white" fill="currentColor" viewBox="0 0 20 20">
          <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
        </svg>
      </div>
    </div>
    
    <!-- Content -->
    <div class="flex-1 min-w-0">
      <!-- Header -->
      <div class="mb-3">
        <div class="flex items-center space-x-2">
          <h3 class="text-sm font-medium text-blue-700">Pregunta de Seguimiento</h3>
          <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800">
            Opcional
          </span>
        </div>
        <p class="text-xs text-blue-600 mt-1">Based on your response about budget, I''d like to better understand your priorities.</p>
      </div>
      
      <!-- Question Title -->
      <h4 class="text-lg font-medium text-gray-900 mb-2">
        <%= dynamic_question.title %>
      </h4>
      
      <!-- Question Description -->
      <% if dynamic_question.description.present? %>
        <p class="text-sm text-gray-600 mb-4 leading-relaxed">
          <%= simple_format(dynamic_question.description) %>
        </p>
      <% end %>
      
      <!-- Form -->
      <%= form_with url: answer_dynamic_question_path(form_response.form.share_token, dynamic_question), 
                    method: :post,
                    local: false, 
                    class: "space-y-4",
                    data: { 
                      turbo_stream: true
                    } do |form| %>
        
        <div>
          <%= form.text_area "answer[value]", 
                            placeholder: "Por favor comparte tus pensamientos en detalle...", 
                            rows: 4,
                            class: "block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm" %>
        </div>
        
        <!-- Buttons -->
        <div class="flex items-center justify-end space-x-3">
          <button type="button" 
                  class="inline-flex items-center px-3 py-2 border border-gray-300 shadow-sm text-sm leading-4 font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors duration-200"
                  id="skip-question-<%= dynamic_question.id %>"
                  onclick="this.closest('.dynamic-question-container').remove()">
            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
            </svg>
            Omit
          </button>
          
          <%= form.submit "Submit", 
                         class: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors duration-200" %>
        </div>
      <% end %>
    </div>
  </div>
</div>
</file>

<file path="views/responses/_dynamic_question_error.html.erb">
<div class="dynamic-question-error bg-red-50 border-l-4 border-red-400 p-6 rounded-lg shadow-sm mb-6" 
     id="dynamic_question_error_<%= dynamic_question.id %>">
  
  <div class="flex items-start space-x-4">
    <!-- Error Icon -->
    <div class="flex-shrink-0">
      <div class="w-10 h-10 bg-red-500 rounded-full flex items-center justify-center shadow-sm">
        <svg class="w-5 h-5 text-white" fill="currentColor" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
        </svg>
      </div>
    </div>
    
    <!-- Content -->
    <div class="flex-1 min-w-0">
      <h3 class="text-sm font-medium text-red-700">Error al enviar respuesta</h3>
      <p class="text-xs text-red-600 mt-1 mb-3">Hubo un problema al procesar tu respuesta.</p>
      
      <% if errors.any? %>
        <div class="bg-red-100 border border-red-200 rounded-md p-3 mb-3">
          <ul class="text-sm text-red-700 space-y-1">
            <% errors.each do |error| %>
              <li><%= error %></li>
            <% end %>
          </ul>
        </div>
      <% end %>
      
      <div class="flex items-center space-x-3">
        <button type="button" 
                onclick="this.closest('.dynamic-question-error').style.display='none'; this.closest('.dynamic-question-error').previousElementSibling.style.display='block'"
                class="inline-flex items-center px-3 py-2 border border-gray-300 shadow-sm text-sm leading-4 font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors duration-200">
          Intentar de nuevo
        </button>
      </div>
    </div>
  </div>
</div>
</file>

<file path="views/responses/_dynamic_question_success.html.erb">
<div class="dynamic-question-success bg-green-50 border-l-4 border-green-400 p-6 rounded-lg shadow-sm mb-6" 
     id="dynamic_question_success_<%= dynamic_question.id %>">
  
  <div class="flex items-start space-x-4">
    <!-- Success Icon -->
    <div class="flex-shrink-0">
      <div class="w-10 h-10 bg-green-500 rounded-full flex items-center justify-center shadow-sm">
        <svg class="w-5 h-5 text-white" fill="currentColor" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
        </svg>
      </div>
    </div>
    
    <!-- Content -->
    <div class="flex-1 min-w-0">
      <div class="mb-2">
        <h3 class="text-sm font-medium text-green-700">Respuesta Recibida</h3>
        <p class="text-xs text-green-600 mt-1">Tu informacin adicional ha sido registrada exitosamente.</p>
      </div>
      
      <h4 class="text-base font-medium text-gray-900 mb-2">
        <%= dynamic_question.title %>
      </h4>
      
      <div class="bg-white border border-green-200 rounded-md p-3">
        <p class="text-sm text-gray-700">
          <strong>Tu respuesta:</strong> "<%= truncate(answer_value, length: 150) %>"
        </p>
      </div>
      
      <div class="mt-3 text-xs text-gray-500">
        <span>Respondida el <%= Time.current.strftime("%d/%m/%Y a las %H:%M") %></span>
      </div>
    </div>
  </div>
</div>
</file>

<file path="views/responses/_dynamic_question.html.erb">
<%# app/views/responses/_dynamic_question.html.erb %>
<%# Displays a dynamically generated follow-up question %>

<div class="bg-gradient-to-r from-indigo-50 to-blue-50 border border-indigo-200 rounded-lg p-4 mb-4" 
     id="dynamic_question_<%= dynamic_question.id %>"
     data-dynamic-question-id="<%= dynamic_question.id %>"
     data-source-question-id="<%= dynamic_question.generated_from_question_id %>">
  
  <div class="flex items-center justify-between mb-3">
    <div class="flex items-center">
      <svg class="w-5 h-5 text-indigo-600 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
      </svg>
      <h4 class="text-sm font-medium text-indigo-800">Follow-up Question</h4>
    </div>
    
    <div class="flex items-center space-x-2">
      <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-indigo-100 text-indigo-800">
        AI Generated
      </span>
      
      <% if generation_metadata&.dig(:ai_confidence) %>
        <span class="text-xs text-indigo-600">
          Confidence: <%= (generation_metadata[:ai_confidence] * 100).round %>%>%
        </span>
      <% end %
    </div>
  </div>

  <%# Question Title %>
  <div class="mb-3">
    <h5 class="text-base font-medium text-gray-900 mb-1">
      <%= dynamic_question.title %>
    </h5>
    
    <% if dynamic_question.description.present? %>
      <p class="text-sm text-gray-600"><%= dynamic_question.description %></p>
    <% end %
  </div>

  <%# Dynamic Question Form %>
  <div class="space-y-3">
    <%= form_with url: response_dynamic_question_path(form_response, dynamic_question), 
                  method: :post,
                  data: { 
                    turbo: true,
                    controller: "dynamic-question",
                    action: "turbo:submit-end->dynamic-question#handleResponse"
                  } do |f| %>

      <% case dynamic_question.question_type %>
      
      <% when 'text_short' %>
        <div class="relative">
          <%= f.text_area :answer, 
                        rows: 2, 
                        class: "w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 text-sm",
                        placeholder: dynamic_question.configuration&.dig('placeholder') || "Share your thoughts...",
                        data: { 
                          dynamic_question_target: "answer",
                          action: "input->dynamic-question#validate"
                        } %>
          <div class="absolute bottom-2 right-2 text-xs text-gray-500" 
               data-dynamic-question-target="counter">0/<%= dynamic_question.configuration&.dig('max_length') || 255 %></div>
        </div>

      <% when 'text_long' %>
        <div class="relative">
          <%= f.text_area :answer, 
                        rows: 4, 
                        class: "w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 text-sm",
                        placeholder: dynamic_question.configuration&.dig('placeholder') || "Tell us more...",
                        data: { 
                          dynamic_question_target: "answer",
                          action: "input->dynamic-question#validate"
                        } %>
          <div class="absolute bottom-2 right-2 text-xs text-gray-500" 
               data-dynamic-question-target="counter">0/<%= dynamic_question.configuration&.dig('max_length') || 2000 %></div>
        </div>

      <% when 'multiple_choice', 'single_choice' %>
        <div class="space-y-2">
          <% options = dynamic_question.configuration&.dig('options') || [] %>
          <% options.each do |option| %>
            <label class="flex items-center p-3 bg-white border border-gray-200 rounded-md hover:bg-gray-50 cursor-pointer transition-colors"
                   data-action="click->dynamic-question#selectOption"
                   data-value="<%= option['value'] %>">
              <input type="<%= dynamic_question.question_type == 'multiple_choice' ? 'checkbox' : 'radio' %>"
                     name="answer"
                     value="<%= option['value'] %>"
                     class="mr-3 h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500"
                     data-dynamic-question-target="input"
                     <%= 'required' if dynamic_question.required? %>>
              <span class="text-sm text-gray-900"><%= option['label'] %></span>
            </label>
          <% end %
        </div>

      <% when 'rating' %>
        <div class="space-y-3">
          <% min_val = dynamic_question.configuration&.dig('min_value') || 1 %>
          <% max_val = dynamic_question.configuration&.dig('max_value') || 5 %>
          
          <div class="flex items-center justify-center space-x-2">
            <% (min_val..max_val).each do |value| %>
              <label class="flex flex-col items-center cursor-pointer"
                     data-value="<%= value %>"
                     data-action="click->dynamic-question#selectRating">
                <input type="radio" 
                       name="answer" 
                       value="<%= value %>" 
                       class="sr-only"
                       data-dynamic-question-target="input"
                       <%= 'required' if dynamic_question.required? %>>
                <div class="w-8 h-8 flex items-center justify-center rounded-full border-2 border-gray-300 hover:border-indigo-500 transition-colors"
                     data-dynamic-question-target="rating">
                  <span class="text-sm font-medium"><%= value %></span>
                </div>
                <span class="text-xs text-gray-600 mt-1">
                  <%= value == min_val ? dynamic_question.configuration&.dig('labels', 'min') : value == max_val ? dynamic_question.configuration&.dig('labels', 'max') : '' %>
                </span>
              </label>
            <% end %
          </div>
        </div>

      <% when 'yes_no' %>
        <div class="flex space-x-4">
          <label class="flex items-center cursor-pointer"
                 data-action="click->dynamic-question#selectYesNo"
                 data-value="true">
            <input type="radio" name="answer" value="true" class="mr-2" data-dynamic-question-target="input"
                   <%= 'required' if dynamic_question.required? %>>
            <span class="text-sm"><%= dynamic_question.configuration&.dig('true_label') || 'Yes' %></span>
          </label>
          
          <label class="flex items-center cursor-pointer"
                 data-action="click->dynamic-question#selectYesNo"
                 data-value="false">
            <input type="radio" name="answer" value="false" class="mr-2" data-dynamic-question-target="input"
                   <%= 'required' if dynamic_question.required? %>>
            <span class="text-sm"><%= dynamic_question.configuration&.dig('false_label') || 'No' %></span>
          </label>
        </div>

      <% else %>
        <div class="text-sm text-gray-600">
          <p>Unsupported question type: <%= dynamic_question.question_type %></p>
        </div>
      <% end %>

      <div class="flex items-center justify-end space-x-3 pt-3">
        <button type="submit"
                class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed"
                data-dynamic-question-target="submit"
                disabled="true">
          <span class="flex items-center">
            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
            </svg>
            Submit Answer
          </span>
        </button>

        <button type="button"
                class="text-sm text-gray-500 hover:text-gray-700"
                data-action="click->dynamic-question#skip"
                data-dynamic-question-target="skip">
          Skip
        </button>
      </div>

    <% end %>
  </div>

  <%# Generation Metadata (for debugging/admin view) %>
  <% if current_user&.admin? || Rails.env.development? %>
    <div class="mt-4 pt-3 border-t border-indigo-200">
      <div class="text-xs text-indigo-700 space-y-1"
           data-controller="tooltip"
           data-tooltip-content="<%= JSON.pretty_generate(dynamic_question.generation_context) %>">
        <div>
          <strong>Strategy:</strong> <%= generation_metadata&.dig(:strategy, :type) || 'unknown' %>
        </div>
        <div>
          <strong>Priority:</strong> <%= generation_metadata&.dig(:strategy, :focus) || 'general' %>
        </div>
        <div>
          <strong>Generated:</strong> <%= dynamic_question.created_at.strftime('%H:%M') %>
        </div>
      </div>
    </div>
  <% end %

</div>

<%# Add JavaScript for dynamic question interactions %>
<% content_for :javascript do %>
  <script>
    // Dynamic question controller will be initialized via Stimulus
    // This ensures proper handling of form submission and validation
  </script>
<% end %>
</file>

<file path="views/responses/_enrichment_data.html.erb">
<%# app/views/responses/_enrichment_data.html.erb %>
<%# Displays company enrichment data for a form response %>

<% if company_data.present? %>
  <div class="bg-white border border-gray-200 rounded-lg p-4 mb-4" id="enrichment_<%= form_response_id %>">
    <div class="flex items-center justify-between mb-3">
      <h4 class="text-sm font-medium text-gray-900">Company Information</h4>
      <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
        <svg class="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
        </svg>
        Enriched
      </span>
    </div>

    <div class="space-y-3">
      <% if company_data[:company_name].present? %>
        <div>
          <span class="text-xs font-medium text-gray-500 uppercase tracking-wider">Company</span>
          <p class="text-sm text-gray-900 mt-1"><%= company_data[:company_name] %></p>
        </div>
      <% end %>

      <% if company_data[:industry].present? %>
        <div>
          <span class="text-xs font-medium text-gray-500 uppercase tracking-wider">Industry</span>
          <p class="text-sm text-gray-900 mt-1"><%= company_data[:industry] %></p>
        </div>
      <% end %>

      <% if company_data[:company_size].present? %>
        <div>
          <span class="text-xs font-medium text-gray-500 uppercase tracking-wider">Company Size</span>
          <p class="text-sm text-gray-900 mt-1"><%= company_data[:company_size] %></p>
        </div>
      <% end %>

      <% if company_data[:location].present? %>
        <div>
          <span class="text-xs font-medium text-gray-500 uppercase tracking-wider">Location</span>
          <p class="text-sm text-gray-900 mt-1"><%= company_data[:location] %></p>
        </div>
      <% end %>

      <% if company_data[:website].present? %>
        <div>
          <span class="text-xs font-medium text-gray-500 uppercase tracking-wider">Website</span>
          <p class="text-sm text-gray-900 mt-1">
            <a href="https://<%= company_data[:website] %>" target="_blank" rel="noopener noreferrer" class="text-indigo-600 hover:text-indigo-500">
              <%= company_data[:website] %>
            </a>
          </p>
        </div>
      <% end %>

      <% if company_data[:description].present? %>
        <div>
          <span class="text-xs font-medium text-gray-500 uppercase tracking-wider">Description</span>
          <p class="text-sm text-gray-900 mt-1"><%= company_data[:description] %></p>
        </div>
      <% end %>

      <% if company_data[:technologies].present? %>
        <div>
          <span class="text-xs font-medium text-gray-500 uppercase tracking-wider">Technologies</span>
          <div class="flex flex-wrap gap-1 mt-1">
            <% company_data[:technologies].each do |tech| %>
              <span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-gray-100 text-gray-700">
                <%= tech %>
              </span>
            <% end %>
          </div>
        </div>
      <% end %>

      <% if company_data[:social_profiles].present? %>
        <div>
          <span class="text-xs font-medium text-gray-500 uppercase tracking-wider">Social Profiles</span>
          <div class="flex space-x-3 mt-1">
            <% company_data[:social_profiles].each do |platform, url| %>
              <% if url.present? %>
                <a href="<%= url %>" target="_blank" rel="noopener noreferrer" class="text-gray-500 hover:text-gray-700">
                  <span class="sr-only"><%= platform.capitalize %></span>
                  <% case platform.to_s %>
                  <% when 'linkedin' %>
                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                      <path fill-rule="evenodd" d="M16.338 16.338H13.67V12.16c0-.995-.017-2.277-1.387-2.277-1.39 0-1.601 1.086-1.601 2.207v4.248H8.014v-8.59h2.559v1.174h.037c.356-.675 1.227-1.387 2.526-1.387 2.703 0 3.203 1.778 3.203 4.092v4.711zM5.005 6.575a1.548 1.548 0 11-.003-3.096 1.548 1.548 0 01.003 3.096zm-1.337 9.763H6.34v-8.59H3.667v8.59zM17.668 1H2.328C1.595 1 1 1.581 1 2.298v15.403C1 18.418 1.595 19 2.328 19h15.34c.734 0 1.332-.582 1.332-1.299V2.298C19 1.581 18.402 1 17.668 1z" clip-rule="evenodd"></path>
                    </svg>
                  <% when 'twitter' %>
                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                      <path d="M6.29 18.251c7.547 0 11.675-6.253 11.675-11.675 0-.178 0-.355-.012-.53A8.348 8.348 0 0020 3.92a8.19 8.19 0 01-2.357.646 4.118 4.118 0 001.804-2.27 8.224 8.224 0 01-2.605.996 4.107 4.107 0 00-6.993 3.743 11.65 11.65 0 01-8.457-4.287 4.106 4.106 0 001.27 5.477A4.073 4.073 0 01.8 7.713v.052a4.105 4.105 0 003.292 4.022 4.095 4.095 0 01-1.853.07 4.108 4.108 0 003.834 2.85A8.233 8.233 0 010 16.407a11.616 11.616 0 006.29 1.84"></path>
                    </svg>
                  <% else %>
                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                      <path d="M11 3a1 1 0 100 2h2.586l-6.293 6.293a1 1 0 101.414 1.414L15 6.414V9a1 1 0 102 0V4a1 1 0 00-1-1h-5z"></path>
                      <path d="M5 5a2 2 0 00-2 2v8a2 2 0 002 2h8a2 2 0 002-2v-3a1 1 0 10-2 0v3H5V7h3a1 1 0 000-2H5z"></path>
                    </svg>
                  <% end %>
                </a>
              <% end %>
            <% end %>
          </div>
        </div>
      <% end %>
    </div>

    <div class="mt-4 pt-3 border-t border-gray-200">
      <p class="text-xs text-gray-500">
        Enriched on <%= Time.current.strftime('%B %d, %Y at %I:%M %p') %>
      </p>
    </div>
  </div>
<% else %>
  <div id="enrichment_<%= form_response_id %>" class="bg-gray-50 border border-gray-200 rounded-lg p-4 mb-4">
    <div class="flex items-center justify-center">
      <div class="text-center">
        <svg class="mx-auto h-8 w-8 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path>
        </svg>
        <p class="mt-2 text-sm text-gray-500">Enriching company data...</p>
      </div>
    </div>
  </div>
<% end %>
</file>

<file path="views/responses/show.html.erb">
<% content_for :title, @form.name %>

<div data-controller="question-response form-animation" 
     data-question-response-question-id-value="<%= @current_question&.id %>"
     data-question-response-form-token-value="<%= @form.share_token %>"
     data-question-response-required-value="<%= @current_question&.required? %>"
     data-form-animation-current-step-value="<%= @form_response.current_question_position %>"
     data-form-animation-total-steps-value="<%= @total_questions %>"
     class="min-h-screen bg-gradient-to-br from-gray-50 to-gray-100 py-8 px-4 max-w-2xl mx-auto"
     data-form-animation-target="questionContainer">
  
  <!-- Form header -->
  <div class="mb-8">
    <% if @form.name.present? %>
      <h1 class="text-2xl font-bold text-gray-900 mb-2"><%= @form.name %></h1>
    <% end %>
    
    <% if @form.description.present? %>
      <p class="text-gray-600 leading-relaxed"><%= simple_format(@form.description) %></p>
    <% end %>
    
    <!-- Progress indicator -->
    <% if @total_questions > 1 %>
      <div class="mt-6" data-form-animation-target="progressBar">
        <div class="flex items-center justify-between text-sm text-gray-600 mb-2">
          <span class="font-medium">Question <%= @form_response.current_question_position %> of <%= @total_questions %></span>
          <span class="text-indigo-600 font-semibold"><%= @progress_percentage.round %>% complete</span>
        </div>
        <div class="w-full bg-gray-200 rounded-full h-2 overflow-hidden">
          <div class="bg-gradient-to-r from-indigo-500 to-purple-600 h-2 rounded-full transition-all duration-500 ease-out" 
               style="width: <%= @progress_percentage %>%"
               data-form-animation-target="progressFill">
          </div>
        </div>
      </div>
    <% end %>
  </div>
  
  <!-- Question content -->
  <% if @current_question %>
    <%= form_with url: form_answer_path(@form.share_token), 
                  method: :post, 
                  local: false,
                  data: { 
                    action: "submit->question-response#submitAnswer",
                    turbo_frame: "question-frame"
                  },
                  class: "space-y-6" do |form| %>
      
      <%= hidden_field_tag :question_id, @current_question.id %>
      <%= hidden_field_tag "answer[started_at]", Time.current.iso8601, 
                          data: { "question-response-target": "startedAt" } %>
      
      <!-- Question -->
      <div class="space-y-4">
        <div class="flex items-start space-x-2">
          <% if @current_question.required? %>
            <span class="text-red-500 text-lg leading-6">*</span>
          <% end %>
          
          <div class="flex-1">
            <label class="block text-lg font-medium text-gray-900 leading-relaxed">
              <%= @current_question.title %>
            </label>
            
            <% if @current_question.description.present? %>
              <p class="mt-2 text-sm text-gray-600">
                <%= simple_format(@current_question.description) %>
              </p>
            <% end %>
            
            <!-- AI Enhancement indicator -->
            <% if @current_question.ai_enhanced? %>
              <div class="mt-2 flex items-center space-x-1 text-xs text-purple-600">
                <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
                  <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
                </svg>
                <span>AI Enhanced</span>
              </div>
            <% end %>
          </div>
        </div>
        
        <!-- Question input based on type -->
        <div class="mt-6 p-6 bg-white rounded-xl shadow-sm border border-gray-100 hover:shadow-md transition-shadow duration-300" 
             data-form-animation-target="questionInput">
          <%= render "question_types/#{@current_question.question_type}", 
                     question: @current_question, 
                     form: form,
                     config: @question_config %>
        </div>
        
        <!-- Validation errors display -->
        <div id="validation-errors" class="hidden">
          <div class="bg-red-50 border border-red-200 rounded-md p-3">
            <div class="flex">
              <div class="flex-shrink-0">
                <svg class="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                  <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
                </svg>
              </div>
              <div class="ml-3">
                <h3 class="text-sm font-medium text-red-800">Please correct the following:</h3>
                <div class="mt-2 text-sm text-red-700">
                  <ul id="error-list" class="list-disc list-inside space-y-1"></ul>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Navigation buttons -->
      <div class="flex items-center justify-between pt-6 mt-6 border-t border-gray-200" 
           data-form-animation-target="navigationButtons">
        <div>
          <% if @form_response.current_question_position > 1 %>
            <%= link_to "#", 
                       class: "inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-lg text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors duration-200",
                       data: { action: "click->question-response#goToPrevious" } do %>
              <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
              </svg>
              Previous
            <% end %>
          <% end %>
        </div>
        
        <div class="flex items-center space-x-3">
          <!-- Save draft button (if enabled) -->
          <% if @form.form_settings.dig('allow_save_draft') %>
            <%= button_tag type: :button,
                          class: "inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-lg text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors duration-200",
                          data: { action: "click->question-response#saveDraft" } do %>
              <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3-3m0 0l-3 3m3-3v12"></path>
              </svg>
              Save Draft
            <% end %>
          <% end %>
          
          <!-- Continue/Submit button -->
          <%= button_tag class: "inline-flex items-center px-6 py-3 border border-transparent text-base font-medium rounded-lg text-white bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-700 hover:to-purple-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 shadow-lg hover:shadow-xl transform hover:-translate-y-0.5",
                        data: { "question-response-target": "submitButton" } do %>
            <span data-question-response-target="submitText">
              <%= @form_response.current_question_position == @total_questions ? "Complete Form" : "Continue" %>
            </span>
            
            <% if @form_response.current_question_position < @total_questions %>
              <svg class="w-5 h-5 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
              </svg>
            <% else %>
              <svg class="w-5 h-5 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
              </svg>
            <% end %>
            
            <!-- Loading spinner -->
            <svg class="hidden animate-spin -mr-1 ml-2 h-5 w-5 text-white" 
                 data-question-response-target="loadingSpinner"
                 fill="none" viewBox="0 0 24 24">
              <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
              <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
          <% end %>
        </div>
      </div>
    <% end %>
  <% else %>
    <!-- No more questions - this shouldn't normally be reached -->
    <div class="text-center py-12">
      <h2 class="text-xl font-semibold text-gray-900 mb-4">Form Complete</h2>
      <p class="text-gray-600 mb-6">Thank you for your responses!</p>
      <%= link_to "View Results", thank_you_form_path(@form.share_token), 
                 class: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700" %>
    </div>
  <% end %>
</div>

<!-- Dynamic questions container -->
<div id="budget_adaptation_<%= @form_response.id %>" 
     class="mt-6 space-y-4">
  <!-- Dynamic budget adaptation questions will appear here -->
</div>

<%= turbo_stream_from @form_response %>

<!-- Auto-save functionality (if enabled) -->
<% if @form.form_settings.dig('auto_save') %>
  <script>
    // Auto-save draft every 30 seconds
    setInterval(function() {
      const controller = document.querySelector('[data-controller="question-response"]');
      if (controller && controller.questionResponseController) {
        controller.questionResponseController.autoSaveDraft();
      }
    }, 30000);
  </script>
<% end %>
<!-- Add this script to the end of your app/views/responses/show.html.erb -->

<script>
// Ensure WebSocket is connected before allowing form submission
document.addEventListener('DOMContentLoaded', function() {
  console.log('Waiting for Turbo Stream connection...');
  
  // Check if we're connected to Turbo Streams
  function isTurboStreamConnected() {
    // Look for the turbo cable element or connection indicator
    return document.querySelector('[data-turbo-cable-url]') && 
           window.Turbo && 
           document.body.hasAttribute('data-turbo-cable-connected');
  }
  
  // Wait for connection before enabling form
  let connectionCheckInterval = setInterval(function() {
    const isConnected = isTurboStreamConnected();
    console.log('Turbo Stream connected:', isConnected);
    
    if (isConnected) {
      console.log(' Turbo Stream connection established');
      clearInterval(connectionCheckInterval);
      
      // Mark as ready for dynamic questions
      document.body.setAttribute('data-websocket-ready', 'true');
      
      // If there are any pending broadcasts, they should work now
      console.log('Ready to receive dynamic questions');
    }
  }, 100);
  
  // Stop checking after 10 seconds
  setTimeout(function() {
    clearInterval(connectionCheckInterval);
    console.log('Connection check timeout - proceeding anyway');
    document.body.setAttribute('data-websocket-ready', 'true');
  }, 10000);
  
  // Monitor for incoming Turbo Streams
  document.addEventListener('turbo:before-stream-render', function(event) {
    console.log('=== Turbo Stream received ===');
    console.log('Action:', event.detail.newStream.action);
    console.log('Target:', event.detail.newStream.target);
    
    // Check if it's our budget adaptation target
    if (event.detail.newStream.target.includes('budget_adaptation_')) {
      console.log(' Budget adaptation question received!');
    }
  });
  
  // Also listen for successful rendering
  document.addEventListener('turbo:stream-render', function(event) {
    console.log(' Turbo Stream rendered successfully');
    
    // Check if our target now has content
    const budgetTarget = document.querySelector('[id^="budget_adaptation_"]');
    if (budgetTarget && budgetTarget.innerHTML.trim()) {
      console.log(' Budget adaptation content is now visible');
    }
  });
});
</script>
</file>

<file path="views/responses/thank_you.html.erb">
<% content_for :title, "Gracias por tu respuesta!" %>

<div class="min-h-screen bg-gradient-to-br from-green-50 to-blue-50 py-12 px-4 sm:px-6 lg:px-8"
     data-controller="form-animation"
     data-form-animation-animation-type-value="slide-up-elegant">
  
  <div class="max-w-2xl mx-auto">
    <div class="text-center mb-8" 
         data-form-animation-target="questionContainer"
         style="opacity: 0; transform: translateY(40px) scale(0.95); filter: blur(2px);">
      
      <!-- Success Icon -->
      <div class="mx-auto flex items-center justify-center h-16 w-16 rounded-full bg-gradient-to-r from-green-400 to-green-600 mb-6 shadow-lg animate-gentle-bounce">
        <svg class="h-8 w-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"></path>
        </svg>
      </div>
    
      <h1 class="text-4xl font-extrabold bg-gradient-to-r from-green-600 to-blue-600 bg-clip-text text-transparent mb-4">
        Formulario Completado!
      </h1>
      
      <p class="text-xl text-gray-700 mb-6 leading-relaxed">
        <%= @form.form_settings.dig('thank_you_message') || "Gracias por tomarte el tiempo de responder nuestro formulario." %>
      </p>
    </div>

    <!-- Response Summary -->
    <% if @form_response %>
      <div class="bg-white shadow-lg rounded-xl p-8 mb-8 border border-gray-100"
           data-form-animation-target="progressBar"
           style="opacity: 0; transform: translateY(30px);">
        <h2 class="text-xl font-semibold text-gray-900 mb-6 flex items-center">
          <svg class="w-6 h-6 mr-3 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
          </svg>
          Resumen de tu respuesta
        </h2>
      
        <% summary = @form_response.thank_you_summary %>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
          <div class="text-center p-4 bg-gradient-to-br from-blue-50 to-indigo-50 rounded-lg border border-blue-100">
            <div class="text-3xl font-bold text-blue-600 mb-2"><%= summary[:total_questions_answered] %></div>
            <div class="text-sm font-medium text-blue-700">Preguntas respondidas</div>
          </div>
          
          <% if summary[:dynamic_questions_answered] > 0 %>
            <div class="text-center p-4 bg-gradient-to-br from-purple-50 to-pink-50 rounded-lg border border-purple-100">
              <div class="text-3xl font-bold text-purple-600 mb-2"><%= summary[:dynamic_questions_answered] %></div>
              <div class="text-sm font-medium text-purple-700">Preguntas adicionales</div>
            </div>
          <% end %>
          
          <div class="text-center p-4 bg-gradient-to-br from-green-50 to-emerald-50 rounded-lg border border-green-100">
            <div class="text-3xl font-bold text-green-600 mb-2"><%= summary[:completion_time] %>m</div>
            <div class="text-sm font-medium text-green-700">Tiempo total</div>
          </div>
        </div>

      <!-- Show dynamic question responses if any -->
      <% if @form_response.has_answered_dynamic_questions? %>
        <div class="border-t border-gray-200 pt-4">
          <h3 class="text-md font-medium text-gray-900 mb-3">Informacin adicional proporcionada</h3>
          
          <% @form_response.dynamic_question_responses.each do |question_title, response_data| %>
            <div class="bg-purple-50 border border-purple-200 rounded-lg p-4 mb-3">
              <h4 class="text-sm font-medium text-purple-900 mb-2"><%= question_title %></h4>
              <p class="text-sm text-purple-700 leading-relaxed">
                "<%= truncate(response_data[:answer], length: 200) %>"
              </p>
              <div class="mt-2 text-xs text-purple-600">
                Respondida el <%= response_data[:answered_at].is_a?(String) ? Time.parse(response_data[:answered_at]).strftime("%d/%m/%Y a las %H:%M") : response_data[:answered_at].strftime("%d/%m/%Y a las %H:%M") %>
              </div>
            </div>
          <% end %>
        </div>
      <% end %>
      
      <!-- Quality Score -->
      <% if summary[:quality_score] > 0 %>
        <div class="bg-gray-50 rounded-lg p-4 mt-4">
          <div class="flex items-center justify-between">
            <span class="text-sm font-medium text-gray-700">Puntuacin de completitud</span>
            <span class="text-lg font-bold text-indigo-600"><%= summary[:quality_score] %>/100</span>
          </div>
          <div class="mt-2 bg-gray-200 rounded-full h-2">
            <div class="bg-indigo-600 h-2 rounded-full" style="width: <%= summary[:quality_score] %>%"></div>
          </div>
        </div>
      <% end %>
    </div>
  <% end %>

    <!-- Next Steps -->
    <div class="bg-gradient-to-r from-blue-50 to-indigo-50 rounded-xl p-8 mb-8 border border-blue-100"
         data-form-animation-target="navigationButtons"
         style="opacity: 0; transform: translateY(30px);">
      <h2 class="text-xl font-semibold text-blue-900 mb-4 flex items-center">
        <svg class="w-6 h-6 mr-3 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
        </svg>
        Qu sigue?
      </h2>
      <div class="text-blue-800 space-y-3">
        <div class="flex items-start">
          <svg class="w-5 h-5 mr-3 mt-0.5 text-blue-600 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
          </svg>
          <p>Hemos recibido todas tus respuestas, incluyendo la informacin adicional</p>
        </div>
        <div class="flex items-start">
          <svg class="w-5 h-5 mr-3 mt-0.5 text-blue-600 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd"></path>
          </svg>
          <p>Nuestro equipo revisar tu informacin en las prximas 24 horas</p>
        </div>
        <div class="flex items-start">
          <svg class="w-5 h-5 mr-3 mt-0.5 text-blue-600 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
            <path d="M2.003 5.884L10 9.882l7.997-3.998A2 2 0 0016 4H4a2 2 0 00-1.997 1.884z"></path>
            <path d="M18 8.118l-8 4-8-4V14a2 2 0 002 2h12a2 2 0 002-2V8.118z"></path>
          </svg>
          <p>Te contactaremos por email con recomendaciones personalizadas</p>
        </div>
        <% if @form_response && @form_response.dynamic_question_responses.any? %>
          <div class="flex items-start">
            <svg class="w-5 h-5 mr-3 mt-0.5 text-purple-600 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
              <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
            </svg>
            <p class="text-purple-800 font-medium">Consideraremos especialmente tu informacin sobre prioridades presupuestarias</p>
          </div>
        <% end %>
      </div>
    </div>

    <!-- CTA buttons -->
    <div class="text-center space-y-4"
         data-form-animation-target="navigationButtons"
         style="opacity: 0; transform: translateY(20px);">
      <% if @form.form_settings.dig('redirect_url').present? %>
        <%= link_to @form.form_settings['redirect_url'], 
                   class: "inline-flex items-center px-8 py-4 border border-transparent text-lg font-semibold rounded-xl shadow-lg text-white bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-700 hover:to-purple-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all duration-200 transform hover:-translate-y-1 hover:shadow-xl" do %>
          <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7l5 5m0 0l-5 5m5-5H6"></path>
          </svg>
          Continuar
        <% end %>
      <% end %>
      
      <div class="pt-4">
        <%= link_to new_form_path, 
                   class: "inline-flex items-center text-indigo-600 hover:text-indigo-500 text-base font-medium transition-colors duration-200 group" do %>
          <svg class="w-5 h-5 mr-2 group-hover:animate-gentle-bounce" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
          </svg>
          Crear mi propio formulario
        <% end %>
      </div>
    </div>
  </div>
</div>

<!-- Clear any stored session data -->
<script>
// Clear form session data since form is completed
sessionStorage.removeItem('form_draft_<%= @form.id %>');
console.log('Form completion recorded. Session data cleared.');

// Track completion analytics if you have analytics
if (typeof gtag !== 'undefined') {
  gtag('event', 'form_completed', {
    'form_id': '<%= @form.id %>',
    'form_name': '<%= @form.name %>',
    'has_dynamic_questions': <%= @form_response&.has_answered_dynamic_questions? || false %>
  });
}
</script>
</file>

<file path="views/shared/_flash_message.html.erb">
<% if message.present? %>
  <div class="fixed top-20 right-4 z-50">
    <div class="bg-white border-l-4 <%= type == 'notice' ? 'border-green-400' : 'border-red-400' %> p-4 shadow-lg rounded-r-lg max-w-sm animate-slide-in-up">
      <div class="flex">
        <div class="flex-shrink-0">
          <% if type == 'notice' %>
            <svg class="h-5 w-5 text-green-400" viewBox="0 0 20 20" fill="currentColor">
              <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
            </svg>
          <% else %>
            <svg class="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
              <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
            </svg>
          <% end %>
        </div>
        <div class="ml-3">
          <p class="text-sm text-gray-700"><%= message %></p>
        </div>
        <div class="ml-auto pl-3">
          <button type="button" class="text-gray-400 hover:text-gray-600" onclick="this.parentElement.parentElement.parentElement.remove()">
            <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
            </svg>
          </button>
        </div>
      </div>
    </div>
  </div>
<% end %>
</file>

<file path="views/shared/_google_connection_status.html.erb">
<div class="bg-white rounded-lg border border-gray-200 p-4" data-controller="google-connection">
  <div class="flex items-center justify-between mb-3">
    <div class="flex items-center space-x-3">
      <div class="w-10 h-10 bg-blue-100 rounded-lg flex items-center justify-center">
        <svg class="w-6 h-6 text-blue-600" viewBox="0 0 24 24" fill="currentColor">
          <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
          <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
          <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
          <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
        </svg>
      </div>
      <div>
        <h3 class="text-lg font-semibold text-gray-900">Google Sheets Connection</h3>
        <p class="text-sm text-gray-500">Connect your Google account to enable Sheets integration</p>
      </div>
    </div>
    
    <div data-google-connection-target="status">
      <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium <%= google_oauth_status_class(status) %>">
        <div class="w-2 h-2 <%= status == :connected ? 'bg-green-400' : 'bg-gray-400' %> rounded-full mr-2"></div>
        <%= status == :connected ? 'Connected' : 'Not Connected' %>
      </span>
    </div>
  </div>

  <% status = google_oauth_status_for_user(current_user) %>

  <% if status == :not_configured %>
    <!-- OAuth Not Configured -->
    <%= render 'shared/google_setup_instructions' %>
  <% elsif status == :connected %>
    <!-- Connected State -->
    <div class="space-y-3">
      <div class="bg-green-50 border border-green-200 rounded-lg p-3">
        <div class="flex items-center">
          <svg class="w-5 h-5 text-green-600 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
          </svg>
          <div>
            <p class="text-sm font-medium text-green-800">
              Connected as <%= current_user.google_integration.user_info['email'] %>
            </p>
            <% if current_user.google_integration.last_used_at %>
              <p class="text-xs text-green-600">
                Last used: <%= time_ago_in_words(current_user.google_integration.last_used_at) %> ago
              </p>
            <% end %>
          </div>
        </div>
      </div>

      <div class="flex space-x-3">
        <button type="button" 
                class="flex-1 inline-flex items-center justify-center px-4 py-2 border border-gray-300 shadow-sm text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50"
                data-action="click->google-connection#testConnection">
          <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
          </svg>
          Test Connection
        </button>
        
        <%= link_to google_oauth_disconnect_path, 
              method: :delete,
              data: { confirm: 'Are you sure you want to disconnect from Google? This will disable all Google Sheets integrations.' },
              class: "inline-flex items-center px-4 py-2 border border-red-300 shadow-sm text-sm font-medium rounded-md text-red-700 bg-white hover:bg-red-50" do %>
          <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
          Disconnect
        <% end %>
      </div>
    </div>
  <% else %>
    <!-- Not Connected State -->
    <div class="space-y-3">
      <div class="bg-blue-50 border border-blue-200 rounded-lg p-3">
        <h4 class="text-sm font-medium text-blue-800 mb-2">What you can do with Google Sheets:</h4>
        <ul class="text-sm text-blue-700 space-y-1">
          <li class="flex items-center">
            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
            </svg>
            Auto-export form responses to your Google Sheets
          </li>
          <li class="flex items-center">
            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
            </svg>
            Create new spreadsheets or use existing ones
          </li>
          <li class="flex items-center">
            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
            </svg>
            Real-time sync when responses are submitted
          </li>
        </ul>
      </div>

      <div class="flex space-x-3">
        <%= link_to google_oauth_connect_path, 
              data: { turbo: false },
              class: "flex-1 inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700" do %>
          <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path>
          </svg>
          Connect to Google
        <% end %>
        
        <button type="button" 
                class="inline-flex items-center px-4 py-2 border border-gray-300 shadow-sm text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50"
                data-action="click->google-connection#showHelp">
          <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
          </svg>
          Help
        </button>
      </div>
    </div>
  <% end %>

  <% if current_user.google_integration&.error_log&.any? %>
    <!-- Error State -->
    <div class="mt-3 p-3 bg-red-50 border border-red-200 rounded-lg">
      <div class="flex">
        <svg class="w-5 h-5 text-red-400 mr-2" fill="currentColor" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"></path>
        </svg>
        <div>
          <h4 class="text-sm font-medium text-red-800">Connection Issue</h4>
          <p class="text-sm text-red-700 mt-1">
            <%= current_user.google_integration.error_log.last['error'] %>
          </p>
          <p class="text-xs text-red-600 mt-1">
            Try reconnecting to resolve this issue.
          </p>
        </div>
      </div>
    </div>
  <% end %>
</div>
</file>

<file path="views/shared/_google_setup_instructions.html.erb">
<div class="bg-white rounded-lg border border-gray-200 p-6">
  <div class="flex items-center space-x-3 mb-4">
    <div class="w-10 h-10 bg-blue-100 rounded-lg flex items-center justify-center">
      <svg class="w-6 h-6 text-blue-600" viewBox="0 0 24 24" fill="currentColor">
        <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
        <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
        <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
        <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
      </svg>
    </div>
    <div>
      <h3 class="text-lg font-semibold text-gray-900">Google Sheets Setup Required</h3>
      <p class="text-sm text-gray-500">Configure Google OAuth credentials to enable Sheets integration</p>
    </div>
  </div>

  <div class="bg-amber-50 border border-amber-200 rounded-lg p-4 mb-4">
    <div class="flex">
      <svg class="w-5 h-5 text-amber-400 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
      </svg>
      <div>
        <h4 class="text-sm font-medium text-amber-800">Configuration Required</h4>
        <p class="text-sm text-amber-700 mt-1">
          Google OAuth credentials need to be configured before users can connect their Google accounts.
        </p>
      </div>
    </div>
  </div>

  <div class="space-y-4">
    <div>
      <h4 class="text-sm font-semibold text-gray-900 mb-2">Step 1: Google Cloud Console Setup</h4>
      <ol class="text-sm text-gray-600 space-y-1 ml-4 list-decimal">
        <li>Go to <a href="https://console.cloud.google.com" target="_blank" class="text-blue-600 hover:underline">Google Cloud Console</a></li>
        <li>Create a new project or select an existing one</li>
        <li>Enable the Google Sheets API</li>
        <li>Go to "Credentials"  "Create Credentials"  "OAuth 2.0 Client IDs"</li>
        <li>Set Application type to "Web application"</li>
        <li>Add authorized redirect URI: <code class="bg-gray-100 px-1 rounded">https://yourdomain.com/google_oauth/callback</code></li>
        <li>Copy the Client ID and Client Secret</li>
      </ol>
    </div>

    <div>
      <h4 class="text-sm font-semibold text-gray-900 mb-2">Step 2: Configure Rails Credentials</h4>
      <div class="bg-gray-900 text-gray-100 p-3 rounded-lg text-xs font-mono">
        <div class="text-green-400 mb-2"># Run this command:</div>
        <div class="text-white">EDITOR="nano" rails credentials:edit</div>
        
        <div class="text-green-400 mt-4 mb-2"># Add this configuration:</div>
        <div class="text-white">
google_sheets_integration:<br>
&nbsp;&nbsp;development:<br>
&nbsp;&nbsp;&nbsp;&nbsp;client_id: "your-client-id.googleusercontent.com"<br>
&nbsp;&nbsp;&nbsp;&nbsp;client_secret: "your-client-secret"<br>
&nbsp;&nbsp;production:<br>
&nbsp;&nbsp;&nbsp;&nbsp;client_id: "your-prod-client-id.googleusercontent.com"<br>
&nbsp;&nbsp;&nbsp;&nbsp;client_secret: "your-prod-client-secret"
        </div>
      </div>
    </div>

    <div>
      <h4 class="text-sm font-semibold text-gray-900 mb-2">Step 3: Restart Server</h4>
      <p class="text-sm text-gray-600">After updating credentials, restart your Rails server for changes to take effect.</p>
    </div>

    <div class="bg-blue-50 border border-blue-200 rounded-lg p-3">
      <div class="flex">
        <svg class="w-5 h-5 text-blue-400 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
        </svg>
        <div>
          <h4 class="text-sm font-medium text-blue-800">Need Help?</h4>
          <p class="text-sm text-blue-700 mt-1">
            Check the <a href="https://developers.google.com/sheets/api/quickstart" target="_blank" class="underline">Google Sheets API documentation</a> for detailed setup instructions.
          </p>
        </div>
      </div>
    </div>
  </div>
</div>
</file>

<file path="views/shared/_payment_badge.html.erb">
<%# Payment Badge Component for Templates %>
<% 
  # Default values
  has_payment_questions ||= false
  required_features ||= []
  size ||= 'sm' # sm, md, lg
  clickable ||= true
%>

<% if has_payment_questions %>
  <% 
    badge_classes = case size
                   when 'lg'
                     "inline-flex items-center px-3 py-1.5 text-sm font-medium"
                   when 'md'
                     "inline-flex items-center px-2.5 py-1 text-xs font-medium"
                   else
                     "inline-flex items-center px-2 py-0.5 text-xs font-medium"
                   end
    
    badge_classes += " bg-purple-100 text-purple-800 rounded-full border border-purple-200"
    badge_classes += " hover:bg-purple-200 cursor-pointer transition-colors duration-200" if clickable
    badge_classes += " select-none"
  %>

  <span data-template-preview-target="paymentBadge" 
        class="<%= badge_classes %>"
        <% if clickable %>data-action="click->template-preview#showPaymentRequirements"<% end %>
        title="This template includes payment questions">
    
    <!-- Payment Icon -->
    <svg class="<%= size == 'lg' ? 'w-4 h-4' : 'w-3 h-3' %> mr-1.5" 
         fill="currentColor" 
         viewBox="0 0 20 20">
      <path d="M4 4a2 2 0 00-2 2v1h16V6a2 2 0 00-2-2H4zM18 9H2v5a2 2 0 002 2h12a2 2 0 002-2V9zM4 13a1 1 0 011-1h1a1 1 0 110 2H5a1 1 0 01-1-1zm5-1a1 1 0 100 2h1a1 1 0 100-2H9z"></path>
    </svg>
    
    <!-- Badge Text -->
    <span>
      <% if size == 'lg' %>
        Payment Features
      <% else %>
        Payment
      <% end %>
    </span>
    
    <!-- Setup Required Indicator -->
    <% if required_features.any? %>
      <span class="ml-1.5 flex-shrink-0 w-1.5 h-1.5 bg-amber-400 rounded-full" 
            title="Setup required"></span>
    <% end %>
  </span>
<% end %>
</file>

<file path="views/shared/_payment_error_education.html.erb">
<% content ||= {} %>

<div class="payment-error-education bg-gradient-to-br from-indigo-50 via-white to-purple-50 border border-indigo-200 rounded-xl p-6 mb-6">
  <div class="flex items-start">
    <div class="flex-shrink-0">
      <div class="flex items-center justify-center h-10 w-10 rounded-full bg-indigo-100">
        <svg class="h-6 w-6 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
        </svg>
      </div>
    </div>
    
    <div class="ml-4 flex-1">
      <h3 class="text-lg font-semibold text-indigo-900 mb-2">
        <%= content[:title] || 'Payment Features' %>
      </h3>
      
      <p class="text-sm text-indigo-800 mb-4">
        <%= content[:description] || 'Learn about payment features and setup requirements.' %>
      </p>
      
      <% if content[:benefits].present? %>
        <div class="mb-4">
          <h4 class="text-sm font-medium text-indigo-900 mb-2">Key Benefits:</h4>
          <ul class="space-y-1">
            <% content[:benefits].each do |benefit| %>
              <li class="flex items-start text-sm text-indigo-700">
                <svg class="mr-2 mt-0.5 h-4 w-4 text-indigo-500 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                  <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
                </svg>
                <span><%= benefit %></span>
              </li>
            <% end %>
          </ul>
        </div>
      <% end %>
      
      <% if content[:setup_time].present? %>
        <div class="flex items-center text-sm text-indigo-600 bg-indigo-50 rounded-lg px-3 py-2">
          <svg class="mr-2 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          <span><strong>Setup Time:</strong> <%= content[:setup_time] %></span>
        </div>
      <% end %>
    </div>
  </div>
</div>
</file>

<file path="views/shared/_payment_error_flash.html.erb">
<% if error.present? %>
  <div class="payment-error-flash bg-red-50 border border-red-200 rounded-lg p-4 mb-4" 
       data-controller="payment-error-flash" 
       data-payment-error-flash-error-type-value="<%= error.error_type %>"
       data-payment-error-flash-dismissible-value="true">
    
    <div class="flex items-start">
      <div class="flex-shrink-0">
        <svg class="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
          <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
        </svg>
      </div>
      
      <div class="ml-3 flex-1">
        <h3 class="text-sm font-medium text-red-800">
          <%= error.user_guidance[:message] || error.message %>
        </h3>
        
        <% if error.user_guidance[:description].present? %>
          <div class="mt-2 text-sm text-red-700">
            <%= error.user_guidance[:description] %>
          </div>
        <% end %>
        
        <% if error.user_guidance[:details].present? %>
          <div class="mt-2">
            <ul class="text-sm text-red-700 list-disc list-inside space-y-1">
              <% error.user_guidance[:details].each do |detail| %>
                <li><%= detail %></li>
              <% end %>
            </ul>
          </div>
        <% end %>
        
        <% if error.actionable? %>
          <div class="mt-4 flex flex-wrap gap-2">
            <% if error.primary_action_url.present? %>
              <%= link_to error.primary_action_text || 'Take Action',
                          error.primary_action_url,
                          class: "inline-flex items-center px-3 py-2 border border-transparent text-sm leading-4 font-medium rounded-md text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition-colors duration-200",
                          data: { 
                            action: "click->payment-error-flash#trackAction",
                            payment_error_flash_action_type_param: "primary"
                          } %>
            <% end %>
            
            <button type="button" 
                    class="inline-flex items-center px-3 py-2 border border-red-300 text-sm leading-4 font-medium rounded-md text-red-700 bg-white hover:bg-red-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition-colors duration-200"
                    data-action="click->payment-error-flash#showHelp">
              <svg class="mr-1 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
              Get Help
            </button>
            
            <% if error.user_guidance[:missing_requirements].present? %>
              <button type="button" 
                      class="inline-flex items-center px-3 py-2 border border-red-300 text-sm leading-4 font-medium rounded-md text-red-700 bg-white hover:bg-red-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition-colors duration-200"
                      data-action="click->payment-error-flash#showChecklist">
                <svg class="mr-1 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4" />
                </svg>
                Setup Checklist
              </button>
            <% end %>
          </div>
        <% end %>
      </div>
      
      <div class="ml-auto pl-3">
        <div class="-mx-1.5 -my-1.5">
          <button type="button" 
                  class="inline-flex bg-red-50 rounded-md p-1.5 text-red-400 hover:bg-red-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-red-50 focus:ring-red-600 transition-colors duration-200"
                  data-action="click->payment-error-flash#dismiss">
            <span class="sr-only">Dismiss</span>
            <svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
              <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
            </svg>
          </button>
        </div>
      </div>
    </div>
  </div>
<% end %>
</file>

<file path="views/shared/_payment_requirements_modal.html.erb">
<%# Payment Requirements Modal Component %>
<div data-template-preview-target="setupModal" class="hidden fixed inset-0 z-50 overflow-y-auto">
  <!-- Modal backdrop -->
  <div class="flex items-center justify-center min-h-screen px-4 pt-4 pb-20 text-center sm:block sm:p-0">
    <div class="fixed inset-0 transition-opacity bg-gray-500 bg-opacity-75" 
         data-action="click->template-preview#closeModal"></div>

    <!-- Modal content -->
    <div class="inline-block w-full max-w-md p-6 my-8 overflow-hidden text-left align-middle transition-all transform bg-white shadow-xl rounded-2xl sm:max-w-lg">
      <!-- Header -->
      <div class="flex items-center justify-between mb-4">
        <div class="flex items-center space-x-2">
          <div class="flex-shrink-0 w-8 h-8 bg-purple-100 rounded-full flex items-center justify-center">
            <svg class="w-4 h-4 text-purple-600" fill="currentColor" viewBox="0 0 20 20">
              <path d="M4 4a2 2 0 00-2 2v1h16V6a2 2 0 00-2-2H4zM18 9H2v5a2 2 0 002 2h12a2 2 0 002-2V9zM4 13a1 1 0 011-1h1a1 1 0 110 2H5a1 1 0 01-1-1zm5-1a1 1 0 100 2h1a1 1 0 100-2H9z"></path>
            </svg>
          </div>
          <h3 class="text-lg font-semibold text-gray-900">Payment Setup Required</h3>
        </div>
        <button data-action="click->template-preview#closeModal" 
                class="text-gray-400 hover:text-gray-600 transition-colors">
          <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path>
          </svg>
        </button>
      </div>

      <!-- Description -->
      <div class="mb-6">
        <p class="text-sm text-gray-600">
          This template includes payment questions that require additional setup to function properly. 
          Complete the setup now for the best experience, or proceed with reminders to set up later.
        </p>
      </div>

      <!-- Requirements List -->
      <div class="mb-6">
        <h4 class="text-sm font-medium text-gray-900 mb-3">Required Setup:</h4>
        <div data-template-preview-target="requirementsList" class="space-y-2">
          <!-- Requirements will be populated by JavaScript -->
        </div>
      </div>

      <!-- Estimated Setup Time -->
      <div class="mb-6 p-3 bg-blue-50 rounded-lg border border-blue-200">
        <div class="flex items-center space-x-2">
          <svg class="w-4 h-4 text-blue-600" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd"></path>
          </svg>
          <span class="text-sm font-medium text-blue-900">Estimated setup time: 5-10 minutes</span>
        </div>
      </div>

      <!-- Action Buttons -->
      <div class="flex flex-col sm:flex-row gap-3" data-template-preview-target="actionButtons">
        <button data-action="click->template-preview#proceedWithSetup"
                class="flex-1 inline-flex justify-center items-center px-4 py-2 text-sm font-medium text-white bg-gradient-to-r from-purple-600 to-indigo-600 border border-transparent rounded-lg hover:from-purple-700 hover:to-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition-all duration-200"
                data-template-preview-target="setupButton">
          <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M10.293 3.293a1 1 0 011.414 0l6 6a1 1 0 010 1.414l-6 6a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-4.293-4.293a1 1 0 010-1.414z" clip-rule="evenodd"></path>
          </svg>
          Complete Setup Now
        </button>
        
        <button data-action="click->template-preview#proceedWithoutSetup"
                class="flex-1 inline-flex justify-center items-center px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors duration-200"
                data-template-preview-target="continueButton">
          Continue with Reminders
        </button>
      </div>

      <!-- Help Text -->
      <div class="mt-4 text-center">
        <p class="text-xs text-gray-500">
          You can complete the setup later from your form settings
        </p>
      </div>
    </div>
  </div>
</div>
</file>

<file path="views/shared/_payment_setup_guidance.html.erb">
<% 
  error ||= nil
  show_actions ||= true
  context ||= 'general'
  compact ||= false
%>

<div class="payment-setup-guidance bg-gradient-to-r from-indigo-50 to-purple-50 border border-indigo-200 rounded-lg <%= compact ? 'p-3' : 'p-6' %>" 
     data-controller="payment-setup-guidance" 
     data-payment-setup-guidance-context-value="<%= context %>"
     data-payment-setup-guidance-error-type-value="<%= error&.error_type %>">
  
  <div class="flex items-start">
    <div class="flex-shrink-0">
      <div class="flex items-center justify-center h-8 w-8 rounded-full bg-indigo-100">
        <svg class="h-5 w-5 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
      </div>
    </div>
    
    <div class="ml-4 flex-1">
      <h3 class="<%= compact ? 'text-sm' : 'text-lg' %> font-semibold text-indigo-900 mb-2">
        Payment Setup Required
      </h3>
      
      <div class="text-sm text-indigo-800 mb-4">
        <% if error.present? %>
          <%= error.user_guidance[:description] || error.message %>
        <% else %>
          Your form contains payment questions that require additional setup to function properly.
        <% end %>
      </div>
      
      <% if error&.user_guidance&.dig(:missing_requirements).present? %>
        <div class="mb-4">
          <h4 class="text-sm font-medium text-indigo-900 mb-2">Required Setup Steps:</h4>
          <div class="space-y-2">
            <% error.user_guidance[:missing_requirements].each do |requirement| %>
              <div class="flex items-center text-sm text-indigo-700">
                <svg class="mr-2 h-4 w-4 text-indigo-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                <%= humanize_requirement(requirement) %>
              </div>
            <% end %>
          </div>
        </div>
      <% end %>
      
      <% if show_actions %>
        <div class="flex flex-wrap gap-3">
          <% if error&.primary_action_url.present? %>
            <%= link_to error.primary_action_text || 'Complete Setup',
                        error.primary_action_url,
                        class: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors duration-200",
                        data: { 
                          action: "click->payment-setup-guidance#trackSetupStart",
                          payment_setup_guidance_action_type_param: "primary"
                        } %>
          <% else %>
            <%= link_to 'Start Setup Guide',
                        payment_setup_path,
                        class: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors duration-200",
                        data: { 
                          action: "click->payment-setup-guidance#trackSetupStart",
                          payment_setup_guidance_action_type_param: "guide"
                        } %>
          <% end %>
          
          <button type="button" 
                  class="inline-flex items-center px-4 py-2 border border-indigo-300 text-sm font-medium rounded-md text-indigo-700 bg-white hover:bg-indigo-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors duration-200"
                  data-action="click->payment-setup-guidance#showEducationalContent">
            <svg class="mr-2 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
            </svg>
            Learn More
          </button>
          
          <% unless compact %>
            <button type="button" 
                    class="inline-flex items-center px-4 py-2 border border-indigo-300 text-sm font-medium rounded-md text-indigo-700 bg-white hover:bg-indigo-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors duration-200"
                    data-action="click->payment-setup-guidance#contactSupport">
              <svg class="mr-2 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.364 5.636l-3.536 3.536m0 5.656l3.536 3.536M9.172 9.172L5.636 5.636m3.536 9.192L5.636 18.364M12 2.25a9.75 9.75 0 109.75 9.75A9.75 9.75 0 0012 2.25z" />
              </svg>
              Contact Support
            </button>
          <% end %>
        </div>
      <% end %>
    </div>
  </div>
</div>

<% content_for :helpers do %>
  <% unless defined?(@payment_guidance_helpers_loaded) %>
    <% @payment_guidance_helpers_loaded = true %>
    <script>
      window.PaymentGuidanceHelpers = {
        humanizeRequirement: function(requirement) {
          const requirements = {
            'stripe_configuration': 'Configure Stripe for payment processing',
            'premium_subscription': 'Upgrade to Premium subscription',
            'payment_setup': 'Complete payment setup',
            'stripe_config': 'Set up Stripe integration',
            'premium': 'Premium subscription required'
          };
          return requirements[requirement] || requirement.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        }
      };
    </script>
  <% end %>
<% end %>

<%# Helper method for requirement humanization %>
<% 
  def humanize_requirement(requirement)
    case requirement.to_s
    when 'stripe_configuration', 'stripe_config'
      'Configure Stripe for payment processing'
    when 'premium_subscription', 'premium'
      'Upgrade to Premium subscription'
    when 'payment_setup'
      'Complete payment setup'
    else
      requirement.to_s.humanize
    end
  end
%>
</file>

<file path="views/shared/_payment_setup_required_button.html.erb">
<% 
  error ||= nil
  button_text ||= 'Complete Setup to Publish'
  button_class ||= 'btn-primary'
  show_icon ||= true
%>

<div class="payment-setup-required-button" 
     data-controller="payment-setup-required-button"
     data-payment-setup-required-button-error-type-value="<%= error&.error_type %>">
  
  <% if error.present? %>
    <div class="flex flex-col space-y-3">
      <!-- Disabled publish button with explanation -->
      <button type="button" 
              class="inline-flex items-center justify-center px-6 py-3 border border-gray-300 text-sm font-medium rounded-md text-gray-500 bg-gray-100 cursor-not-allowed opacity-75"
              disabled
              title="<%= error.message %>">
        <% if show_icon %>
          <svg class="mr-2 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
          </svg>
        <% end %>
        Publish Form (Setup Required)
      </button>
      
      <!-- Setup action button -->
      <% if error.primary_action_url.present? %>
        <%= link_to error.primary_action_url,
                    class: "inline-flex items-center justify-center px-6 py-3 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors duration-200",
                    data: { 
                      action: "click->payment-setup-required-button#trackSetupClick",
                      payment_setup_required_button_action_type_param: "setup"
                    } do %>
          <% if show_icon %>
            <svg class="mr-2 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
            </svg>
          <% end %>
          <%= error.primary_action_text || button_text %>
        <% end %>
      <% else %>
        <%= link_to payment_setup_path,
                    class: "inline-flex items-center justify-center px-6 py-3 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors duration-200",
                    data: { 
                      action: "click->payment-setup-required-button#trackSetupClick",
                      payment_setup_required_button_action_type_param: "guide"
                    } do %>
          <% if show_icon %>
            <svg class="mr-2 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
            </svg>
          <% end %>
          <%= button_text %>
        <% end %>
      <% end %>
      
      <!-- Quick help text -->
      <p class="text-xs text-gray-600 text-center">
        <% if error.user_guidance[:description].present? %>
          <%= error.user_guidance[:description] %>
        <% else %>
          Complete the required setup steps to publish your form with payment functionality.
        <% end %>
      </p>
    </div>
  <% else %>
    <!-- Normal publish button when no errors -->
    <button type="submit" 
            class="inline-flex items-center justify-center px-6 py-3 border border-transparent text-sm font-medium rounded-md text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-colors duration-200"
            data-action="click->payment-setup-required-button#trackPublishClick">
      <% if show_icon %>
        <svg class="mr-2 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
      <% end %>
      Publish Form
    </button>
  <% end %>
</div>
</file>

<file path="views/shared/_payment_setup_status.html.erb">
<div class="payment-setup-status-indicator">
  <% if validation_result[:valid] %>
    <div class="flex items-center space-x-2 text-green-600">
      <svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
      </svg>
      <span class="text-sm font-medium">Payment setup complete</span>
    </div>
  <% else %>
    <div class="flex items-center space-x-2 text-amber-600">
      <svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
        <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
      </svg>
      <span class="text-sm font-medium">
        Payment setup incomplete 
        (<%= validation_result[:setup_completion_percentage] || 0 %>% complete)
      </span>
    </div>
    
    <% if validation_result[:missing_requirements].present? %>
      <div class="mt-2 text-sm text-gray-600">
        <p class="font-medium">Required actions:</p>
        <ul class="list-disc list-inside mt-1 space-y-1">
          <% validation_result[:missing_requirements].each do |requirement| %>
            <li><%= requirement.humanize %></li>
          <% end %>
        </ul>
      </div>
    <% end %>
  <% end %>
</div>
</file>

<file path="views/shared/_payment_validation_error.html.erb">
<div class="bg-red-50 border border-red-200 rounded-lg p-4 mb-4" data-controller="auto-dismiss" data-auto-dismiss-delay-value="10000">
  <div class="flex items-start">
    <div class="flex-shrink-0">
      <svg class="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
      </svg>
    </div>
    <div class="ml-3 flex-1">
      <h3 class="text-sm font-medium text-red-800">
        Payment Setup Validation Failed
      </h3>
      <div class="mt-2 text-sm text-red-700">
        <p>Unable to validate your payment setup configuration.</p>
        <p class="mt-1 text-red-600">Error: <%= error %></p>
        <div class="mt-3">
          <button type="button" 
                  class="bg-red-100 px-3 py-1 rounded text-sm font-medium text-red-800 hover:bg-red-200 focus:outline-none focus:ring-2 focus:ring-red-500"
                  data-action="click->payment-setup-status#retryValidation">
            Retry Validation
          </button>
        </div>
      </div>
    </div>
    <div class="ml-4 flex-shrink-0">
      <button type="button" class="bg-red-50 rounded-md inline-flex text-red-400 hover:text-red-500 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500" data-action="click->auto-dismiss#dismiss">
        <span class="sr-only">Close</span>
        <svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
          <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
        </svg>
      </button>
    </div>
  </div>
</div>
</file>

<file path="views/shared/_setup_completion_notification.html.erb">
<div class="bg-green-50 border border-green-200 rounded-lg p-4 mb-4" data-controller="auto-dismiss" data-auto-dismiss-delay-value="7000">
  <div class="flex items-start">
    <div class="flex-shrink-0">
      <svg class="h-5 w-5 text-green-400" viewBox="0 0 20 20" fill="currentColor">
        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
      </svg>
    </div>
    <div class="ml-3 flex-1">
      <h3 class="text-sm font-medium text-green-800">
         Payment Setup Complete!
      </h3>
      <div class="mt-2 text-sm text-green-700">
        <p>Your payment configuration is now complete. You can publish forms with payment questions.</p>
        <div class="mt-3 flex space-x-3">
          <%= link_to "View Forms", forms_path, 
                      class: "bg-green-100 px-3 py-1 rounded text-sm font-medium text-green-800 hover:bg-green-200 focus:outline-none focus:ring-2 focus:ring-green-500" %>
          <%= link_to "Create New Form", new_form_path, 
                      class: "bg-green-600 px-3 py-1 rounded text-sm font-medium text-white hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500" %>
        </div>
      </div>
    </div>
    <div class="ml-4 flex-shrink-0">
      <button type="button" class="bg-green-50 rounded-md inline-flex text-green-400 hover:text-green-500 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500" data-action="click->auto-dismiss#dismiss">
        <span class="sr-only">Close</span>
        <svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
          <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
        </svg>
      </button>
    </div>
  </div>
</div>
</file>

<file path="views/shared/_template_analysis_complete.html.erb">
<div class="bg-green-50 border border-green-200 rounded-lg p-4 mb-4" data-controller="auto-dismiss" data-auto-dismiss-delay-value="5000">
  <div class="flex items-start">
    <div class="flex-shrink-0">
      <svg class="h-5 w-5 text-green-400" viewBox="0 0 20 20" fill="currentColor">
        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
      </svg>
    </div>
    <div class="ml-3 flex-1">
      <h3 class="text-sm font-medium text-green-800">
        Template Analysis Complete
      </h3>
      <div class="mt-2 text-sm text-green-700">
        <p>Payment requirements analysis completed for "<%= template.name %>"</p>
        <% if analysis_result[:has_payment_questions] %>
          <div class="mt-2">
            <p class="font-medium">Payment Features Required:</p>
            <ul class="list-disc list-inside mt-1">
              <% analysis_result[:required_features].each do |feature| %>
                <li><%= feature.humanize %></li>
              <% end %>
            </ul>
            <p class="mt-1">Setup Complexity: <span class="font-medium"><%= analysis_result[:setup_complexity].humanize %></span></p>
          </div>
        <% else %>
          <p class="text-green-600">No payment setup required for this template.</p>
        <% end %>
      </div>
    </div>
    <div class="ml-4 flex-shrink-0">
      <button type="button" class="bg-green-50 rounded-md inline-flex text-green-400 hover:text-green-500 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500" data-action="click->auto-dismiss#dismiss">
        <span class="sr-only">Close</span>
        <svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
          <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
        </svg>
      </button>
    </div>
  </div>
</div>
</file>

<file path="views/shared/_template_analysis_error.html.erb">
<div class="bg-red-50 border border-red-200 rounded-lg p-4 mb-4" data-controller="auto-dismiss" data-auto-dismiss-delay-value="8000">
  <div class="flex items-start">
    <div class="flex-shrink-0">
      <svg class="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
      </svg>
    </div>
    <div class="ml-3 flex-1">
      <h3 class="text-sm font-medium text-red-800">
        Template Analysis Failed
      </h3>
      <div class="mt-2 text-sm text-red-700">
        <p>Failed to analyze payment requirements for "<%= template.name %>"</p>
        <p class="mt-1 text-red-600">Error: <%= error %></p>
        <div class="mt-3">
          <button type="button" 
                  class="bg-red-100 px-3 py-1 rounded text-sm font-medium text-red-800 hover:bg-red-200 focus:outline-none focus:ring-2 focus:ring-red-500"
                  data-action="click->template-gallery#retryAnalysis"
                  data-template-id="<%= template.id %>">
            Retry Analysis
          </button>
        </div>
      </div>
    </div>
    <div class="ml-4 flex-shrink-0">
      <button type="button" class="bg-red-50 rounded-md inline-flex text-red-400 hover:text-red-500 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500" data-action="click->auto-dismiss#dismiss">
        <span class="sr-only">Close</span>
        <svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
          <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
        </svg>
      </button>
    </div>
  </div>
</div>
</file>

<file path="views/stripe_settings/show.html.erb">
<% content_for :title, "Stripe Payment Settings" %>

<div class="max-w-4xl mx-auto py-8 px-4 sm:px-6 lg:px-8">
  <!-- Header -->
  <div class="mb-8">
    <div class="flex items-center justify-between">
      <div>
        <h1 class="text-3xl font-bold text-gray-900">Payment Settings</h1>
        <p class="mt-2 text-gray-600">Configure Stripe to accept payments directly to your account</p>
      </div>
      
      <% if @stripe_configured %>
        <div class="flex items-center space-x-3">
          <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-green-100 text-green-800">
            <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
            </svg>
            Connected
          </span>
          
          <% if @test_mode %>
            <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-yellow-100 text-yellow-800">
              Test Mode
            </span>
          <% end %>
        </div>
      <% end %>
    </div>
  </div>

  <!-- Status Card -->
  <% if @stripe_configured %>
    <div class="bg-green-50 border border-green-200 rounded-lg p-6 mb-8">
      <div class="flex items-start">
        <svg class="w-6 h-6 text-green-600 mt-0.5 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
        </svg>
        <div class="flex-1">
          <h3 class="text-lg font-medium text-green-900">Stripe Connected Successfully</h3>
          <p class="mt-1 text-green-700">Your forms can now accept payments directly to your Stripe account.</p>
          
          <div class="mt-4 flex items-center space-x-4">
            <button type="button" 
                    class="inline-flex items-center px-4 py-2 border border-green-300 text-sm font-medium rounded-md text-green-700 bg-white hover:bg-green-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500"
                    data-action="click->stripe-settings#testConnection">
              <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
              </svg>
              Test Connection
            </button>
            
            <%= link_to "Disable Stripe", 
                       disable_stripe_settings_path, 
                       method: :delete,
                       class: "inline-flex items-center px-4 py-2 border border-red-300 text-sm font-medium rounded-md text-red-700 bg-white hover:bg-red-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500",
                       confirm: "Are you sure? This will disable payment processing for all your forms." %>
          </div>
        </div>
      </div>
    </div>
  <% else %>
    <div class="bg-blue-50 border border-blue-200 rounded-lg p-6 mb-8">
      <div class="flex items-start">
        <svg class="w-6 h-6 text-blue-600 mt-0.5 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
        </svg>
        <div>
          <h3 class="text-lg font-medium text-blue-900">Connect Your Stripe Account</h3>
          <p class="mt-1 text-blue-700">Add payment questions to your forms and receive payments directly to your Stripe account.</p>
        </div>
      </div>
    </div>
  <% end %>

  <!-- Configuration Form -->
  <div class="bg-white shadow rounded-lg" data-controller="stripe-settings">
    <div class="px-6 py-4 border-b border-gray-200">
      <h2 class="text-lg font-medium text-gray-900">Stripe Configuration</h2>
      <p class="mt-1 text-sm text-gray-500">Enter your Stripe API keys to enable payment processing</p>
    </div>

    <%= form_with model: current_user, url: stripe_settings_path, local: true, class: "space-y-6 p-6" do |form| %>
      <!-- Stripe Enabled Toggle -->
      <div class="flex items-center justify-between">
        <div>
          <label class="text-base font-medium text-gray-900">Enable Stripe Payments</label>
          <p class="text-sm text-gray-500">Allow your forms to accept payments</p>
        </div>
        <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
          <%= form.check_box :stripe_enabled, 
                            { checked: current_user.stripe_enabled? || !current_user.stripe_publishable_key.present? },
                            { class: "toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer",
                              data: { action: "change->stripe-settings#toggleEnabled" } } %>
          <label for="user_stripe_enabled" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
        </div>
      </div>

      <div id="stripe-fields">
        <!-- Publishable Key -->
        <div>
          <%= form.label :stripe_publishable_key, class: "block text-sm font-medium text-gray-700 mb-2" do %>
            Publishable Key
            <span class="text-red-500">*</span>
          <% end %>
          <%= form.text_field :stripe_publishable_key, 
                             class: "block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm",
                             placeholder: "pk_test_... or pk_live_...",
                             data: { "stripe-settings-target": "publishableKey" } %>
          <p class="mt-1 text-xs text-gray-500">Your Stripe publishable key (starts with pk_)</p>
        </div>

        <!-- Secret Key -->
        <div>
          <%= form.label :stripe_secret_key, class: "block text-sm font-medium text-gray-700 mb-2" do %>
            Secret Key
            <span class="text-red-500">*</span>
          <% end %>
          <%= form.password_field :stripe_secret_key, 
                                 class: "block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm",
                                 placeholder: "sk_test_... or sk_live_...",
                                 data: { "stripe-settings-target": "secretKey" } %>
          <p class="mt-1 text-xs text-gray-500">Your Stripe secret key (starts with sk_) - will be encrypted</p>
        </div>

        <!-- Webhook Secret (Optional) -->
        <div>
          <%= form.label :stripe_webhook_secret, class: "block text-sm font-medium text-gray-700 mb-2" do %>
            Webhook Secret
            <span class="text-gray-400">(Optional)</span>
          <% end %>
          <%= form.password_field :stripe_webhook_secret, 
                                 class: "block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm",
                                 placeholder: "whsec_...",
                                 data: { "stripe-settings-target": "webhookSecret" } %>
          <p class="mt-1 text-xs text-gray-500">Webhook endpoint secret for secure event handling</p>
        </div>
      </div>

      <!-- Form Actions -->
      <div class="flex items-center justify-between pt-6 border-t border-gray-200">
        <div>
          <% if current_user.errors.any? %>
            <div class="text-sm text-red-600">
              <% current_user.errors.full_messages.each do |message| %>
                <p><%= message %></p>
              <% end %>
            </div>
          <% end %>
        </div>
        
        <div class="flex items-center space-x-3">
          <%= link_to "Cancel", root_path, class: "inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" %>
          
          <%= form.submit "Save Settings", 
                         class: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500",
                         data: { "stripe-settings-target": "submitButton" } %>
        </div>
      </div>
    <% end %>
  </div>

  <!-- Help Section -->
  <div class="mt-8 bg-gray-50 rounded-lg p-6">
    <h3 class="text-lg font-medium text-gray-900 mb-4">How to Get Your Stripe Keys</h3>
    
    <div class="space-y-4 text-sm text-gray-600">
      <div class="flex items-start">
        <span class="flex-shrink-0 w-6 h-6 bg-indigo-100 text-indigo-600 rounded-full flex items-center justify-center text-xs font-medium mr-3 mt-0.5">1</span>
        <div>
          <p class="font-medium text-gray-900">Create a Stripe Account</p>
          <p>Visit <a href="https://stripe.com" target="_blank" class="text-indigo-600 hover:text-indigo-500">stripe.com</a> and create an account if you don't have one.</p>
        </div>
      </div>
      
      <div class="flex items-start">
        <span class="flex-shrink-0 w-6 h-6 bg-indigo-100 text-indigo-600 rounded-full flex items-center justify-center text-xs font-medium mr-3 mt-0.5">2</span>
        <div>
          <p class="font-medium text-gray-900">Get Your API Keys</p>
          <p>Go to your Stripe Dashboard  Developers  API Keys to find your publishable and secret keys.</p>
        </div>
      </div>
      
      <div class="flex items-start">
        <span class="flex-shrink-0 w-6 h-6 bg-indigo-100 text-indigo-600 rounded-full flex items-center justify-center text-xs font-medium mr-3 mt-0.5">3</span>
        <div>
          <p class="font-medium text-gray-900">Test vs Live Mode</p>
          <p>Use test keys (pk_test_/sk_test_) for testing, and live keys (pk_live_/sk_live_) for production.</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Connection Status -->
  <div id="connection-status" class="hidden mt-4 p-4 rounded-md" data-stripe-settings-target="status"></div>
</div>

<style>
.toggle-checkbox:checked {
  right: 0;
  border-color: #4F46E5;
}
.toggle-checkbox:checked + .toggle-label {
  background-color: #4F46E5;
}
</style>
</file>

<file path="views/subscription_management/show.html.erb">
<% content_for :title, "Subscription Management" %>

<div class="max-w-4xl mx-auto py-8 px-4 sm:px-6 lg:px-8">
  <!-- Header -->
  <div class="mb-8">
    <h1 class="text-3xl font-bold text-gray-900">Subscription Management</h1>
    <p class="mt-2 text-gray-600">Manage your AgentForm subscription and billing</p>
  </div>

  <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
    <!-- Current Subscription Status -->
    <div class="lg:col-span-2 space-y-6">
      <!-- Subscription Status Card -->
      <div class="bg-white shadow rounded-lg">
        <div class="px-6 py-4 border-b border-gray-200">
          <h2 class="text-lg font-medium text-gray-900">Current Subscription</h2>
        </div>
        
        <div class="p-6">
          <% if current_user.subscription_status == 'trialing' %>
            <!-- Trial Status Section -->
            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
              <div class="flex items-start">
                <div class="flex-shrink-0">
                  <svg class="h-5 w-5 text-blue-400" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd" />
                  </svg>
                </div>
                <div class="ml-3 flex-1">
                  <h3 class="text-sm font-medium text-blue-800">
                    <%= current_user.trial_status_message %>
                  </h3>
                  <div class="mt-2 text-sm text-blue-700">
                    <% if current_user.trial_days_remaining <= 3 && current_user.trial_days_remaining > 0 %>
                      <p class="font-medium text-red-700"> Your trial expires very soon! Upgrade now to continue using all features without interruption.</p>
                    <% elsif current_user.trial_expires_soon? %>
                      <p class="font-medium">Upgrade now to continue using all features without interruption.</p>
                    <% elsif current_user.trial_expired? %>
                      <p class="font-medium text-red-700">Please upgrade to continue using AgentForm.</p>
                    <% else %>
                      <p>Enjoy full access to all features during your trial period.</p>
                    <% end %>
                  </div>
                  <% unless current_user.trial_expired? %>
                    <div class="mt-3">
                      <div class="bg-blue-200 rounded-full h-2">
                        <% progress = [(TrialConfig.trial_period_days - current_user.trial_days_remaining).to_f / TrialConfig.trial_period_days * 100, 100].min %>
                        <div class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: <%= progress %>%"></div>
                      </div>
                      <p class="text-xs text-blue-600 mt-1">
                        Day <%= TrialConfig.trial_period_days - current_user.trial_days_remaining + 1 %> of <%= TrialConfig.trial_period_days %>
                      </p>
                    </div>
                  <% end %>
                </div>
              </div>
            </div>

            <!-- Trial Subscription Details -->
            <div class="flex items-center justify-between mb-6">
              <div class="flex items-center">
                <div class="flex-shrink-0">
                  <div class="w-12 h-12 bg-blue-100 rounded-full flex items-center justify-center">
                    <svg class="w-6 h-6 text-blue-600" fill="currentColor" viewBox="0 0 20 20">
                      <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd" />
                    </svg>
                  </div>
                </div>
                <div class="ml-4">
                  <h3 class="text-xl font-semibold text-gray-900">
                    Premium Trial
                  </h3>
                  <p class="text-gray-600">
                    Status: 
                    <% if current_user.trial_expired? %>
                      <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800">Trial Expired</span>
                    <% elsif current_user.trial_days_remaining <= 3 %>
                      <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800">Trial (Expires Soon)</span>
                    <% elsif current_user.trial_expires_soon? %>
                      <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800">Trial (Expires Soon)</span>
                    <% else %>
                      <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800">Trial Active</span>
                    <% end %>
                  </p>
                </div>
              </div>
              
              <div class="text-right">
                <p class="text-2xl font-bold text-blue-600">
                  FREE
                </p>
                <p class="text-sm text-gray-500">
                  <% if current_user.trial_expired? %>
                    Trial Expired
                  <% else %>
                    <%= pluralize(current_user.trial_days_remaining, 'day') %> remaining
                  <% end %>
                </p>
              </div>
            </div>

            <!-- Trial Period Details -->
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6">
              <div class="bg-gray-50 rounded-lg p-4">
                <dt class="text-sm font-medium text-gray-500">Trial Started</dt>
                <dd class="mt-1 text-sm text-gray-900">
                  <%= (current_user.trial_ends_at - TrialConfig.trial_period_days.days).strftime('%b %d, %Y') %>
                </dd>
              </div>
              
              <div class="bg-gray-50 rounded-lg p-4">
                <dt class="text-sm font-medium text-gray-500">
                  <% if current_user.trial_expired? %>
                    Trial Expired
                  <% else %>
                    Trial Expires
                  <% end %>
                </dt>
                <dd class="mt-1 text-sm <%= current_user.trial_expired? ? 'text-red-600' : (current_user.trial_days_remaining <= 3 ? 'text-red-600' : (current_user.trial_expires_soon? ? 'text-yellow-600' : 'text-gray-900')) %>">
                  <%= current_user.trial_ends_at.strftime('%b %d, %Y') %>
                  <% unless current_user.trial_expired? %>
                    <span class="text-xs text-gray-500">
                      (<%= pluralize(current_user.trial_days_remaining, 'day') %> remaining)
                    </span>
                  <% end %>
                </dd>
              </div>
            </div>

            <!-- Upgrade Call to Action -->
            <div class="bg-gradient-to-r from-indigo-50 to-purple-50 rounded-lg p-6 mb-6">
              <div class="text-center">
                <h4 class="text-lg font-semibold text-gray-900 mb-2">
                  <% if current_user.trial_expired? %>
                    Your trial has ended
                  <% elsif current_user.trial_days_remaining <= 3 %>
                    Don't lose access!
                  <% else %>
                    Enjoying your trial?
                  <% end %>
                </h4>
                <p class="text-gray-600 mb-4">
                  <% if current_user.trial_expired? %>
                    Upgrade now to regain access to all premium features.
                  <% elsif current_user.trial_days_remaining <= 3 %>
                    Upgrade now to ensure uninterrupted access to all features.
                  <% else %>
                    Upgrade to premium to continue enjoying all features after your trial ends.
                  <% end %>
                </p>
                
                <!-- Discount Code Section -->
                <div class="max-w-md mx-auto mb-6" 
                     data-controller="discount-code" 
                     data-discount-code-billing-cycle-value="monthly"
                     data-discount-code-validate-url-value="<%= api_v1_discount_codes_validate_path %>">
                  
                  <div class="bg-white rounded-lg p-4 mb-4 border border-gray-200">
                    <label for="discount_code" class="block text-sm font-medium text-gray-700 mb-2">
                      Have a discount code?
                    </label>
                    
                    <div class="flex space-x-2">
                      <input type="text" 
                             id="discount_code"
                             data-discount-code-target="input"
                             data-action="input->discount-code#inputChanged"
                             placeholder="Enter discount code"
                             class="flex-1 min-w-0 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                      
                      <button type="button"
                              data-discount-code-target="applyButton"
                              data-action="click->discount-code#applyDiscount"
                              disabled
                              class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed">
                        Apply
                      </button>
                      
                      <button type="button"
                              data-discount-code-target="clearButton"
                              data-action="click->discount-code#clearDiscount"
                              class="hidden inline-flex items-center px-3 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                      </button>
                    </div>
                    
                    <!-- Feedback Messages -->
                    <div data-discount-code-target="feedback" class="mt-2 hidden"></div>
                  </div>
                  
                  <!-- Pricing Details (shown when discount is applied) -->
                  <div data-discount-code-target="pricingDetails" class="hidden bg-blue-50 rounded-lg p-4 mb-4 border border-blue-200">
                    <h4 class="text-sm font-medium text-blue-900 mb-2">Pricing Breakdown</h4>
                    <div class="space-y-1 text-sm">
                      <div class="flex justify-between text-gray-600">
                        <span>Original Price:</span>
                        <span data-discount-code-target="originalPrice">$29.00</span>
                      </div>
                      <div class="flex justify-between text-green-600">
                        <span>Discount (<span data-discount-code-target="discountPercentage">0%</span>):</span>
                        <span data-discount-code-target="discountAmount">-$0.00</span>
                      </div>
                      <div class="flex justify-between font-medium text-blue-900 pt-1 border-t border-blue-200">
                        <span>Final Price:</span>
                        <span data-discount-code-target="finalPrice">$29.00</span>
                      </div>
                    </div>
                  </div>
                </div>
                
                <!-- Subscription Buttons -->
                <div id="subscription-buttons" 
                     data-controller="subscription-checkout"
                     data-action="discount-code:applied->subscription-checkout#updateDiscount discount-code:cleared->subscription-checkout#clearDiscount">
                  
                  <div class="flex justify-center space-x-4">
                    <%= form_with url: subscription_management_path, method: :post, local: true, 
                        class: "inline-block",
                        data: { 
                          "subscription-checkout-target": "monthlyForm",
                          "billing-cycle": "monthly"
                        } do |form| %>
                      <%= form.hidden_field :billing_cycle, value: 'monthly' %>
                      <%= form.hidden_field :discount_code, value: '', data: { "subscription-checkout-target": "monthlyDiscountField" } %>
                      <%= form.submit "Upgrade Monthly ($29/month)", 
                          data: { "subscription-checkout-target": "monthlyButton" },
                          class: "inline-flex items-center px-6 py-3 border border-transparent text-base font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" %>
                    <% end %>
                    
                    <%= form_with url: subscription_management_path, method: :post, local: true, 
                        class: "inline-block",
                        data: { 
                          "subscription-checkout-target": "yearlyForm",
                          "billing-cycle": "yearly"
                        } do |form| %>
                      <%= form.hidden_field :billing_cycle, value: 'yearly' %>
                      <%= form.hidden_field :discount_code, value: '', data: { "subscription-checkout-target": "yearlyDiscountField" } %>
                      <%= form.submit "Upgrade Yearly ($290/year)", 
                          data: { "subscription-checkout-target": "yearlyButton" },
                          class: "inline-flex items-center px-6 py-3 border border-indigo-300 text-base font-medium rounded-md text-indigo-700 bg-white hover:bg-indigo-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" %>
                    <% end %>
                  </div>
                  
                  <p class="text-sm text-gray-500 mt-4">Save 2 months with yearly billing</p>
                </div>
              </div>
            </div>

          <% elsif current_user.premium? && @subscription_service.user_has_active_subscription? %>
            <!-- Active Premium Subscription -->
            <div class="flex items-center justify-between mb-6">
              <div class="flex items-center">
                <div class="flex-shrink-0">
                  <div class="w-12 h-12 bg-purple-100 rounded-full flex items-center justify-center">
                    <svg class="w-6 h-6 text-purple-600" fill="currentColor" viewBox="0 0 20 20">
                      <path fill-rule="evenodd" d="M5 2a1 1 0 011 1v1h1v1a1 1 0 001 1h1a1 1 0 001-1V4h1V3a1 1 0 011-1H5zm4 5H7a1 1 0 01-1-1V6a1 1 0 011-1h2a1 1 0 011 1v1a1 1 0 01-1 1zM5 9a1 1 0 011-1h2a1 1 0 110 2H6a1 1 0 01-1-1zm1 4a1 1 0 100 2h2a1 1 0 100-2H6a1 1 0 00-1 1z" clip-rule="evenodd" />
                    </svg>
                  </div>
                </div>
                <div class="ml-4">
                  <h3 class="text-xl font-semibold text-gray-900">
                    <% if current_user.subscription_status == 'trialing' %>
                      Premium Trial
                    <% else %>
                      Premium Plan
                    <% end %>
                  </h3>
                  <p class="text-gray-600">
                    Status: 
                    <% case current_user.subscription_status %>
                    <% when 'active' %>
                      <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">Active</span>
                    <% when 'canceling' %>
                      <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800">Canceling</span>
                    <% when 'trialing' %>
                      <% if current_user.trial_expired? %>
                        <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800">Trial Expired</span>
                      <% elsif current_user.trial_days_remaining <= 3 %>
                        <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800">Trial (Expires Soon)</span>
                      <% elsif current_user.trial_expires_soon? %>
                        <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800">Trial (Expires Soon)</span>
                      <% else %>
                        <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800">Trial Active</span>
                      <% end %>
                    <% when 'free', nil, '' %>
                      <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">Active (Complimentary)</span>
                    <% else %>
                      <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800"><%= current_user.subscription_status.humanize %></span>
                    <% end %>
                  </p>
                </div>
              </div>
              
              <% if @subscription_details.present? %>
                <div class="text-right">
                  <p class="text-2xl font-bold text-gray-900">
                    $<%= (@subscription_details[:amount] / 100.0).to_i %>
                    <span class="text-sm font-normal text-gray-500">/<%= @subscription_details[:interval] %></span>
                  </p>
                  <p class="text-sm text-gray-500"><%= @subscription_details[:currency] %></p>
                </div>
              <% elsif current_user.subscription_status == 'trialing' %>
                <div class="text-right">
                  <p class="text-2xl font-bold text-blue-600">
                    FREE
                  </p>
                  <p class="text-sm text-gray-500">
                    <% if current_user.trial_expired? %>
                      Trial Expired
                    <% else %>
                      <%= pluralize(current_user.trial_days_remaining, 'day') %> remaining
                    <% end %>
                  </p>
                </div>
              <% elsif current_user.subscription_status.in?(['free', nil, '']) %>
                <div class="text-right">
                  <p class="text-2xl font-bold text-gray-900">
                    $0
                    <span class="text-sm font-normal text-gray-500">/month</span>
                  </p>
                  <p class="text-sm text-gray-500">Complimentary</p>
                </div>
              <% end %>
            </div>

            <!-- Subscription Details -->
            <% if @subscription_details.present? %>
              <% if @subscription_details[:source] == 'stripe' %>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6">
                  <div class="bg-gray-50 rounded-lg p-4">
                    <dt class="text-sm font-medium text-gray-500">Current Period</dt>
                    <dd class="mt-1 text-sm text-gray-900">
                      <%= @subscription_details[:current_period_start]&.strftime('%b %d, %Y') %> - 
                      <%= @subscription_details[:current_period_end]&.strftime('%b %d, %Y') %>
                    </dd>
                  </div>
                  
                  <div class="bg-gray-50 rounded-lg p-4">
                    <dt class="text-sm font-medium text-gray-500">Next Billing Date</dt>
                    <dd class="mt-1 text-sm text-gray-900">
                      <% if @subscription_details[:cancel_at_period_end] %>
                        <span class="text-red-600">Canceled - expires <%= @subscription_details[:current_period_end]&.strftime('%b %d, %Y') %></span>
                      <% else %>
                        <%= @subscription_details[:current_period_end]&.strftime('%b %d, %Y') %>
                      <% end %>
                    </dd>
                  </div>
                </div>
              <% else %>
                <div class="bg-blue-50 rounded-lg p-4 mb-6">
                  <div class="flex items-center">
                    <svg class="w-5 h-5 text-blue-400 mr-2" fill="currentColor" viewBox="0 0 20 20">
                      <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path>
                    </svg>
                    <p class="text-sm text-blue-700">
                      This is a complimentary premium account. No billing information required.
                    </p>
                  </div>
                </div>
              <% end %>
            <% end %>

            <!-- Action Buttons (only for Stripe subscriptions) -->
            <% if @subscription_details[:source] == 'stripe' %>
              <div class="flex flex-wrap gap-3">
                <%= link_to update_payment_method_subscription_management_path, 
                    method: :post,
                    class: "inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" do %>
                  <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h18M7 15h1m4 0h1m-7 4h12a3 3 0 003-3V8a3 3 0 00-3-3H6a3 3 0 00-3 3v8a3 3 0 003 3z"></path>
                  </svg>
                  Update Payment Method
                <% end %>

                <% if current_user.subscription_status == 'canceling' %>
                  <%= link_to reactivate_subscription_management_path, 
                      method: :post,
                      class: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500",
                      confirm: "Are you sure you want to reactivate your subscription?" do %>
                    <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                    </svg>
                    Reactivate Subscription
                  <% end %>
                <% else %>
                  <%= link_to cancel_subscription_management_path, 
                      method: :delete,
                      class: "inline-flex items-center px-4 py-2 border border-red-300 text-sm font-medium rounded-md text-red-700 bg-white hover:bg-red-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500",
                      confirm: "Are you sure you want to cancel your subscription? You'll keep access until the end of your billing period." do %>
                    <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                    Cancel Subscription
                  <% end %>
                <% end %>
              </div>
            <% end %>

          <% else %>
            <!-- No Active Subscription -->
            <div class="text-center py-8">
              <div class="w-16 h-16 bg-gray-100 rounded-full flex items-center justify-center mx-auto mb-4">
                <svg class="w-8 h-8 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1"></path>
                </svg>
              </div>
              <h3 class="text-lg font-medium text-gray-900 mb-2">No Active Subscription</h3>
              <p class="text-gray-600 mb-6">Upgrade to Premium to unlock all features</p>
              
              <!-- Discount Code Section -->
              <div class="max-w-md mx-auto mb-8" 
                   data-controller="discount-code" 
                   data-discount-code-billing-cycle-value="monthly"
                   data-discount-code-validate-url-value="<%= api_v1_discount_codes_validate_path %>">
                
                <div class="bg-gray-50 rounded-lg p-4 mb-4">
                  <label for="discount_code" class="block text-sm font-medium text-gray-700 mb-2">
                    Have a discount code?
                  </label>
                  
                  <div class="flex space-x-2">
                    <input type="text" 
                           id="discount_code"
                           data-discount-code-target="input"
                           data-action="input->discount-code#inputChanged"
                           placeholder="Enter discount code"
                           class="flex-1 min-w-0 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                    
                    <button type="button"
                            data-discount-code-target="applyButton"
                            data-action="click->discount-code#applyDiscount"
                            disabled
                            class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed">
                      Apply
                    </button>
                    
                    <button type="button"
                            data-discount-code-target="clearButton"
                            data-action="click->discount-code#clearDiscount"
                            class="hidden inline-flex items-center px-3 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                      <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                      </svg>
                    </button>
                  </div>
                  
                  <!-- Feedback Messages -->
                  <div data-discount-code-target="feedback" class="mt-2 hidden"></div>
                </div>
                
                <!-- Pricing Details (shown when discount is applied) -->
                <div data-discount-code-target="pricingDetails" class="hidden bg-blue-50 rounded-lg p-4 mb-4 border border-blue-200">
                  <h4 class="text-sm font-medium text-blue-900 mb-2">Pricing Breakdown</h4>
                  <div class="space-y-1 text-sm">
                    <div class="flex justify-between text-gray-600">
                      <span>Original Price:</span>
                      <span data-discount-code-target="originalPrice">$29.00</span>
                    </div>
                    <div class="flex justify-between text-green-600">
                      <span>Discount (<span data-discount-code-target="discountPercentage">0%</span>):</span>
                      <span data-discount-code-target="discountAmount">-$0.00</span>
                    </div>
                    <div class="flex justify-between font-medium text-blue-900 pt-1 border-t border-blue-200">
                      <span>Final Price:</span>
                      <span data-discount-code-target="finalPrice">$29.00</span>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Subscription Buttons -->
              <div id="subscription-buttons" 
                   data-controller="subscription-checkout"
                   data-action="discount-code:applied->subscription-checkout#updateDiscount discount-code:cleared->subscription-checkout#clearDiscount">
                
                <div class="flex justify-center space-x-4">
                  <%= form_with url: subscription_management_path, method: :post, local: true, 
                      class: "inline-block",
                      data: { 
                        "subscription-checkout-target": "monthlyForm",
                        "billing-cycle": "monthly"
                      } do |form| %>
                    <%= form.hidden_field :billing_cycle, value: 'monthly' %>
                    <%= form.hidden_field :discount_code, value: '', data: { "subscription-checkout-target": "monthlyDiscountField" } %>
                    <%= form.submit "Subscribe Monthly ($29/month)", 
                        data: { "subscription-checkout-target": "monthlyButton" },
                        class: "inline-flex items-center px-6 py-3 border border-transparent text-base font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" %>
                  <% end %>
                  
                  <%= form_with url: subscription_management_path, method: :post, local: true, 
                      class: "inline-block",
                      data: { 
                        "subscription-checkout-target": "yearlyForm",
                        "billing-cycle": "yearly"
                      } do |form| %>
                    <%= form.hidden_field :billing_cycle, value: 'yearly' %>
                    <%= form.hidden_field :discount_code, value: '', data: { "subscription-checkout-target": "yearlyDiscountField" } %>
                    <%= form.submit "Subscribe Yearly ($290/year)", 
                        data: { "subscription-checkout-target": "yearlyButton" },
                        class: "inline-flex items-center px-6 py-3 border border-indigo-300 text-base font-medium rounded-md text-indigo-700 bg-white hover:bg-indigo-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" %>
                  <% end %>
                </div>
                
                <p class="text-sm text-gray-500 mt-4">Save 2 months with yearly billing</p>
              </div>
            </div>
          <% end %>
        </div>
      </div>

      <!-- Billing History -->
      <div class="bg-white shadow rounded-lg">
        <div class="px-6 py-4 border-b border-gray-200">
          <h2 class="text-lg font-medium text-gray-900">Billing History</h2>
        </div>
        
        <div class="p-6">
          <p class="text-gray-500 text-center py-8">
            Billing history will be available once you have an active subscription.
          </p>
        </div>
      </div>
    </div>

    <!-- Sidebar -->
    <div class="space-y-6">
      <!-- Plan Features -->
      <div class="bg-white shadow rounded-lg p-6">
        <h3 class="text-lg font-medium text-gray-900 mb-4">Premium Features</h3>
        
        <ul class="space-y-3">
          <% SubscriptionManagementService.plans['premium'][:features].each do |feature| %>
            <li class="flex items-start">
              <svg class="w-5 h-5 text-green-500 mt-0.5 mr-3 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
              </svg>
              <span class="text-sm text-gray-700"><%= feature %></span>
            </li>
          <% end %>
        </ul>
      </div>

      <!-- Support -->
      <div class="bg-white shadow rounded-lg p-6">
        <h3 class="text-lg font-medium text-gray-900 mb-4">Need Help?</h3>
        
        <div class="space-y-3">
          <a href="mailto:support@agentform.com" class="flex items-center text-sm text-indigo-600 hover:text-indigo-500">
            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 8l7.89 4.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"></path>
            </svg>
            Contact Support
          </a>
          
          <a href="#" class="flex items-center text-sm text-indigo-600 hover:text-indigo-500">
            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
            FAQ & Documentation
          </a>
        </div>
      </div>
    </div>
  </div>
</div>
</file>

<file path="views/subscription_upgrades/new.html.erb">
<div class="min-h-screen bg-gray-50 flex flex-col justify-center py-12 sm:px-6 lg:px-8">
  <div class="sm:mx-auto sm:w-full sm:max-w-md">
    <h2 class="mt-6 text-center text-3xl font-extrabold text-gray-900">
      Tu perodo de prueba ha terminado
    </h2>
    <p class="mt-2 text-center text-sm text-gray-600">
      Contina disfrutando de todas las funciones premium
    </p>
  </div>

  <div class="mt-8 sm:mx-auto sm:w-full sm:max-w-md">
    <div class="bg-white py-8 px-4 shadow sm:rounded-lg sm:px-10">
      <%= form_with url: subscription_upgrade_path, method: :post, local: true, class: "space-y-6" do |form| %>
        
        <!-- Plan Selection -->
        <div>
          <label class="text-base font-medium text-gray-900">Selecciona tu plan</label>
          <p class="text-sm leading-5 text-gray-500">Elige la opcin que mejor se adapte a tus necesidades</p>
          <fieldset class="mt-4">
            <legend class="sr-only">Pricing plans</legend>
            <div class="relative -space-y-px rounded-md bg-white">
              <!-- Monthly Plan -->
              <div class="relative border rounded-tl-md rounded-tr-md p-4 flex cursor-pointer focus:outline-none">
                <%= form.radio_button :billing_cycle, 'monthly', 
                    class: "h-4 w-4 mt-0.5 cursor-pointer shrink-0 text-indigo-600 border-gray-300 focus:ring-indigo-500",
                    checked: true %>
                <div class="ml-3 flex flex-col">
                  <label class="block text-sm font-medium text-gray-900 cursor-pointer">
                    Plan Mensual
                  </label>
                  <span class="block text-sm text-gray-500">$29/mes</span>
                </div>
              </div>
              
              <!-- Yearly Plan -->
              <div class="relative border border-t-0 rounded-bl-md rounded-br-md p-4 flex cursor-pointer focus:outline-none">
                <%= form.radio_button :billing_cycle, 'yearly', 
                    class: "h-4 w-4 mt-0.5 cursor-pointer shrink-0 text-indigo-600 border-gray-300 focus:ring-indigo-500" %>
                <div class="ml-3 flex flex-col">
                  <label class="block text-sm font-medium text-gray-900 cursor-pointer">
                    Plan Anual
                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800 ml-2">
                      Ahorra 2 meses
                    </span>
                  </label>
                  <span class="block text-sm text-gray-500">$290/ao (equivale a $24.17/mes)</span>
                </div>
              </div>
            </div>
          </fieldset>
        </div>

        <!-- Discount Code -->
        <div>
          <%= form.label :discount_code, "Cdigo de descuento (opcional)", class: "block text-sm font-medium text-gray-700" %>
          <div class="mt-1">
            <%= form.text_field :discount_code, 
                class: "appearance-none block w-full px-3 py-2 border border-gray-300 rounded-md placeholder-gray-400 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm",
                placeholder: "Ingresa tu cdigo" %>
          </div>
        </div>

        <!-- Features List -->
        <div class="bg-gray-50 rounded-lg p-4">
          <h4 class="text-sm font-medium text-gray-900 mb-3">Incluye todas las funciones premium:</h4>
          <ul class="text-sm text-gray-600 space-y-2">
            <li class="flex items-center">
              <svg class="h-4 w-4 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
              </svg>
              Formularios y respuestas ilimitadas
            </li>
            <li class="flex items-center">
              <svg class="h-4 w-4 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
              </svg>
              Procesamiento de pagos via Stripe
            </li>
            <li class="flex items-center">
              <svg class="h-4 w-4 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
              </svg>
              Funciones avanzadas de IA
            </li>
            <li class="flex items-center">
              <svg class="h-4 w-4 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
              </svg>
              Soporte prioritario
            </li>
            <li class="flex items-center">
              <svg class="h-4 w-4 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
              </svg>
              Eliminacin de marca mydialogform
            </li>
            <li class="flex items-center">
              <svg class="h-4 w-4 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
              </svg>
              Analticas avanzadas
            </li>
          </ul>
        </div>

        <div>
          <%= form.submit "Continuar con el pago", 
              class: "w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" %>
        </div>
      <% end %>

      <div class="mt-6">
        <div class="relative">
          <div class="absolute inset-0 flex items-center">
            <div class="w-full border-t border-gray-300"></div>
          </div>
          <div class="relative flex justify-center text-sm">
            <span class="px-2 bg-white text-gray-500">Necesitas ms tiempo?</span>
          </div>
        </div>

        <div class="mt-6 text-center">
          <p class="text-sm text-gray-600">
            Puedes continuar usando la versin bsica gratuita o 
            <%= link_to "contactarnos", "#", class: "font-medium text-indigo-600 hover:text-indigo-500" %> 
            si tienes preguntas.
          </p>
        </div>
      </div>
    </div>
  </div>
</div>
</file>

<file path="views/subscriptions/new.html.erb">
<div class="flex items-center justify-center min-h-screen bg-gray-50">
  <div class="max-w-md w-full space-y-8 p-10 bg-white shadow-lg rounded-xl">
    <div>
      <h2 class="mt-6 text-center text-3xl font-extrabold text-gray-900">
        nete al Plan Premium
      </h2>
      <p class="mt-2 text-center text-sm text-gray-600">
        Crea tu cuenta y obtn acceso a todas las funcionalidades avanzadas.
      </p>
    </div>
    <%= form_for @user, url: subscriptions_path, data: { turbo: false } do |f| %>
      <% if @user.errors.any? %>
        <div class="bg-red-50 text-red-700 p-3 rounded-md mb-4">
          <ul>
            <% @user.errors.full_messages.each do |message| %>
              <li><%= message %></li>
            <% end %>
          </ul>
        </div>
      <% end %>
      <div class="space-y-4">
        <div class="grid grid-cols-2 gap-4">
          <div>
            <%= f.label :first_name, class: "block text-sm font-medium text-gray-700" %>
            <%= f.text_field :first_name, required: true, class: "mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" %>
          </div>
          <div>
            <%= f.label :last_name, class: "block text-sm font-medium text-gray-700" %>
            <%= f.text_field :last_name, required: true, class: "mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" %>
          </div>
        </div>
        <div>
          <%= f.label :email, class: "block text-sm font-medium text-gray-700" %>
          <%= f.email_field :email, required: true, autocomplete: "email", class: "mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" %>
        </div>
        <div>
          <%= f.label :password, class: "block text-sm font-medium text-gray-700" %>
          <%= f.password_field :password, required: true, autocomplete: "new-password", class: "mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" %>
        </div>
        <div>
          <%= f.label :password_confirmation, class: "block text-sm font-medium text-gray-700" %>
          <%= f.password_field :password_confirmation, required: true, autocomplete: "new-password", class: "mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" %>
        </div>
      </div>

      <div class="mt-6">
        <%= f.submit "Proceder al Pago", class: "w-full flex justify-center py-3 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 cursor-pointer" %>
      </div>
    <% end %>
  </div>
</div>
</file>

<file path="views/templates/_template_card.html.erb">
<%# Template Card Component with Payment Preview Integration %>
<% 
  # Extract payment requirements from template
  has_payment_questions = template.has_payment_questions?
  required_features = template.required_features
%>

<div class="bg-white rounded-xl shadow-sm border border-gray-200 hover:shadow-md transition-all duration-200 group"
     data-controller="template-preview"
     data-template-preview-template-id-value="<%= template.id %>"
     data-template-preview-has-payment-questions-value="<%= has_payment_questions %>"
     data-template-preview-required-features-value="<%= required_features.to_json %>"
     data-template-id="<%= template.id %>">
  
  <!-- Template Header -->
  <div class="p-6">
    <div class="flex items-start justify-between mb-4">
      <div class="flex items-center space-x-3">
        <!-- Template Icon -->
        <div class="flex-shrink-0 w-12 h-12 bg-gradient-to-br from-purple-500 to-indigo-600 rounded-lg flex items-center justify-center">
          <svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 20 20">
            <path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z"></path>
            <path fill-rule="evenodd" d="M4 5a2 2 0 012-2v1a1 1 0 001 1h6a1 1 0 001-1V3a2 2 0 012 2v6a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z" clip-rule="evenodd"></path>
          </svg>
        </div>
        
        <!-- Template Info -->
        <div class="flex-1">
          <h3 class="text-lg font-semibold text-gray-900 group-hover:text-purple-600 transition-colors">
            <%= template.name %>
          </h3>
          <p class="text-sm text-gray-600 mt-1">
            <%= template.description %>
          </p>
        </div>
      </div>

      <!-- Payment Badge -->
      <%= render 'shared/payment_badge', 
          has_payment_questions: has_payment_questions,
          required_features: required_features,
          size: 'md' %>
    </div>

    <!-- Template Metadata -->
    <div class="flex items-center justify-between text-sm text-gray-500 mb-4">
      <div class="flex items-center space-x-4">
        <span class="flex items-center">
          <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd"></path>
          </svg>
          <%= template.estimated_time_minutes %> min
        </span>
        
        <span class="flex items-center">
          <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
            <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
          </svg>
          <%= template.usage_count %> uses
        </span>
      </div>

      <span class="px-2 py-1 bg-gray-100 text-gray-700 rounded-full text-xs font-medium">
        <%= template.category.humanize %>
      </span>
    </div>

    <!-- Template Features and Payment Info -->
    <div class="space-y-3 mb-4">
      <!-- Features -->
      <div class="flex flex-wrap gap-2">
        <% template.features_list.first(3).each do |feature| %>
          <span class="inline-flex items-center px-2 py-1 bg-blue-50 text-blue-700 text-xs font-medium rounded-md">
            <%= feature.humanize %>
          </span>
        <% end %>
        
        <% if template.features_list.length > 3 %>
          <span class="inline-flex items-center px-2 py-1 bg-gray-50 text-gray-600 text-xs font-medium rounded-md">
            +<%= template.features_list.length - 3 %> more
          </span>
        <% end %>
      </div>

      <!-- Payment Requirements Details -->
      <% if has_payment_questions %>
        <div class="p-3 bg-purple-50 rounded-lg border border-purple-200">
          <div class="flex items-start justify-between">
            <div class="flex-1">
              <h4 class="text-xs font-medium text-purple-900 mb-1">Payment Setup Required</h4>
              <div class="space-y-1">
                <% required_features.each do |feature| %>
                  <div class="flex items-center text-xs text-purple-700">
                    <svg class="w-3 h-3 mr-1.5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                      <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                    </svg>
                    <%= feature.humanize %>
                  </div>
                <% end %>
              </div>
            </div>
            <div class="flex-shrink-0 ml-2">
              <span class="inline-flex items-center px-2 py-1 bg-purple-100 text-purple-800 text-xs font-medium rounded-full">
                <%= template.setup_complexity.humanize %>
              </span>
            </div>
          </div>
        </div>
      <% end %>
    </div>

    <!-- Action Buttons -->
    <div class="flex space-x-3">
      <%= link_to template_path(template), 
          class: "flex-1 inline-flex justify-center items-center px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors" do %>
        <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
          <path d="M10 12a2 2 0 100-4 2 2 0 000 4z"></path>
          <path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd"></path>
        </svg>
        Preview
      <% end %>
      
      <% if has_payment_questions %>
        <button class="flex-1 inline-flex justify-center items-center px-4 py-2 text-sm font-medium text-white bg-gradient-to-r from-purple-600 to-indigo-600 border border-transparent rounded-lg hover:from-purple-700 hover:to-indigo-700 transition-all duration-200"
                data-action="click->template-preview#showPaymentRequirements">
          <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clip-rule="evenodd"></path>
          </svg>
          Use This Template
        </button>
      <% else %>
        <%= link_to instantiate_template_path(template), 
            data: { turbo_method: :post },
            class: "flex-1 inline-flex justify-center items-center px-4 py-2 text-sm font-medium text-white bg-gradient-to-r from-purple-600 to-indigo-600 border border-transparent rounded-lg hover:from-purple-700 hover:to-indigo-700 transition-all duration-200" do %>
          <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clip-rule="evenodd"></path>
          </svg>
          Use This Template
        <% end %>
      <% end %>
    </div>
  </div>

  <!-- Payment Requirements Modal -->
  <%= render 'shared/payment_requirements_modal' %>
</div>
</file>

<file path="views/templates/index.html.erb">
<%# Templates Index Page with Enhanced Filtering %>
<div class="min-h-screen bg-gray-50 py-8" data-controller="template-gallery">
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
    <!-- Page Header -->
    <div class="mb-8">
      <h1 class="text-3xl font-bold text-gray-900 mb-2">Form Templates</h1>
      <p class="text-lg text-gray-600">Choose from our collection of professionally designed form templates</p>
    </div>

    <!-- Search and Filters -->
    <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-6 mb-8">
      <%= form_with url: templates_path, method: :get, local: true, class: "space-y-4" do |form| %>
        <!-- Search Bar -->
        <div class="flex flex-col sm:flex-row gap-4">
          <div class="flex-1">
            <%= form.text_field :search, 
                placeholder: "Search templates...", 
                value: params[:search],
                class: "w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent" %>
          </div>
          <button type="submit" 
                  class="inline-flex items-center px-6 py-2 text-sm font-medium text-white bg-gradient-to-r from-purple-600 to-indigo-600 border border-transparent rounded-lg hover:from-purple-700 hover:to-indigo-700 transition-all duration-200">
            <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd"></path>
            </svg>
            Search
          </button>
        </div>

        <!-- Filter Controls -->
        <div class="flex flex-wrap gap-4 items-center">
          <!-- Category Filter -->
          <div class="flex items-center space-x-2">
            <label class="text-sm font-medium text-gray-700">Category:</label>
            <%= form.select :category, 
                options_for_select([
                  ['All Categories', 'all'],
                  ['General', 'general'],
                  ['Lead Qualification', 'lead_qualification'],
                  ['Customer Feedback', 'customer_feedback'],
                  ['Job Application', 'job_application'],
                  ['Event Registration', 'event_registration'],
                  ['Survey', 'survey'],
                  ['Contact Form', 'contact_form']
                ], @category_filter || 'all'),
                {},
                { class: "px-3 py-1.5 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent" } %>
          </div>

          <!-- Payment Features Filter -->
          <div class="flex items-center space-x-2">
            <label class="text-sm font-medium text-gray-700">Payment Features:</label>
            <%= form.select :payment_features, 
                options_for_select([
                  ['All Templates', ''],
                  ['With Payment Features', 'with_payments'],
                  ['Without Payment Features', 'without_payments']
                ], params[:payment_features]),
                {},
                { class: "px-3 py-1.5 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent" } %>
          </div>

          <!-- Sort By -->
          <div class="flex items-center space-x-2">
            <label class="text-sm font-medium text-gray-700">Sort by:</label>
            <%= form.select :sort_by, 
                options_for_select([
                  ['Name', 'name'],
                  ['Most Popular', 'popular'],
                  ['Most Recent', 'recent'],
                  ['Most Used', 'usage'],
                  ['Completion Time', 'time']
                ], @sort_by),
                {},
                { class: "px-3 py-1.5 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent" } %>
          </div>

          <!-- Clear Filters -->
          <% if @filter_params.values.any?(&:present?) %>
            <%= link_to templates_path, 
                class: "inline-flex items-center px-3 py-1.5 text-sm font-medium text-gray-600 bg-gray-100 border border-gray-300 rounded-lg hover:bg-gray-200 transition-colors" do %>
              <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path>
              </svg>
              Clear Filters
            <% end %>
          <% end %>
        </div>
      <% end %>
    </div>

    <!-- Filter Results Summary -->
    <% if @filter_params.values.any?(&:present?) %>
      <div class="mb-6">
        <div class="flex items-center justify-between">
          <div class="flex items-center space-x-2 text-sm text-gray-600">
            <span>Showing <%= @templates.count %> template<%= 's' if @templates.count != 1 %></span>
            <% if @has_payment_filter %>
              <span class="inline-flex items-center px-2 py-1 bg-purple-100 text-purple-800 text-xs font-medium rounded-full">
                <svg class="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
                  <path d="M4 4a2 2 0 00-2 2v1h16V6a2 2 0 00-2-2H4zM18 9H2v5a2 2 0 002 2h12a2 2 0 002-2V9zM4 13a1 1 0 011-1h1a1 1 0 110 2H5a1 1 0 01-1-1zm5-1a1 1 0 100 2h1a1 1 0 100-2H9z"></path>
                </svg>
                Payment Features
              </span>
            <% end %>
          </div>
        </div>
      </div>
    <% end %>

    <!-- Templates Grid -->
    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
      <% @templates.each do |template| %>
        <%= render 'templates/template_card', template: template %>
      <% end %>
    </div>

    <!-- Empty State -->
    <% if @templates.empty? %>
      <div class="text-center py-12">
        <% if @filter_params.values.any?(&:present?) %>
          <!-- Filtered Empty State -->
          <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
          </svg>
          <h3 class="mt-2 text-sm font-medium text-gray-900">No templates match your filters</h3>
          <p class="mt-1 text-sm text-gray-500">Try adjusting your search criteria or clearing filters.</p>
          <div class="mt-4">
            <%= link_to templates_path, 
                class: "inline-flex items-center px-4 py-2 text-sm font-medium text-purple-600 bg-purple-50 border border-purple-200 rounded-lg hover:bg-purple-100 transition-colors" do %>
              Clear All Filters
            <% end %>
          </div>
        <% else %>
          <!-- Default Empty State -->
          <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
          </svg>
          <h3 class="mt-2 text-sm font-medium text-gray-900">No templates available</h3>
          <p class="mt-1 text-sm text-gray-500">Get started by creating your first form template.</p>
        <% end %>
      </div>
    <% end %>

    <!-- Educational Content for Payment Features -->
    <% if @has_payment_filter && params[:payment_features] == 'with_payments' %>
      <div class="mt-12 bg-gradient-to-r from-purple-50 to-indigo-50 rounded-xl border border-purple-200 p-8">
        <div class="max-w-3xl">
          <div class="flex items-start space-x-4">
            <div class="flex-shrink-0 w-12 h-12 bg-purple-100 rounded-lg flex items-center justify-center">
              <svg class="w-6 h-6 text-purple-600" fill="currentColor" viewBox="0 0 20 20">
                <path d="M4 4a2 2 0 00-2 2v1h16V6a2 2 0 00-2-2H4zM18 9H2v5a2 2 0 002 2h12a2 2 0 002-2V9zM4 13a1 1 0 011-1h1a1 1 0 110 2H5a1 1 0 01-1-1zm5-1a1 1 0 100 2h1a1 1 0 100-2H9z"></path>
              </svg>
            </div>
            <div class="flex-1">
              <h3 class="text-lg font-semibold text-gray-900 mb-2">About Payment-Enabled Templates</h3>
              <p class="text-gray-600 mb-4">
                These templates include payment questions that allow you to collect payments directly through your forms. 
                Perfect for event registrations, product orders, service bookings, and donation campaigns.
              </p>
              <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                <div class="flex items-start space-x-2">
                  <svg class="w-4 h-4 text-green-600 mt-0.5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                  </svg>
                  <span class="text-gray-700">Secure Stripe integration</span>
                </div>
                <div class="flex items-start space-x-2">
                  <svg class="w-4 h-4 text-green-600 mt-0.5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                  </svg>
                  <span class="text-gray-700">Automatic receipt generation</span>
                </div>
                <div class="flex items-start space-x-2">
                  <svg class="w-4 h-4 text-green-600 mt-0.5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                  </svg>
                  <span class="text-gray-700">Real-time payment tracking</span>
                </div>
                <div class="flex items-start space-x-2">
                  <svg class="w-4 h-4 text-green-600 mt-0.5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                  </svg>
                  <span class="text-gray-700">Premium subscription required</span>
                </div>
              </div>
              <div class="mt-4">
                <%= link_to "/subscription_management", 
                    class: "inline-flex items-center px-4 py-2 text-sm font-medium text-purple-600 bg-white border border-purple-300 rounded-lg hover:bg-purple-50 transition-colors" do %>
                  <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
                    <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path>
                  </svg>
                  Learn About Premium Features
                <% end %>
              </div>
            </div>
          </div>
        </div>
      </div>
    <% end %>
  </div>
</div>
</file>

<file path="views/templates/show.html.erb">
<%# Template Show Page %>
<div class="min-h-screen bg-gray-50 py-8">
  <div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8">
    <!-- Template Header -->
    <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-8 mb-8"
         data-controller="template-preview"
         data-template-preview-template-id-value="<%= @template.id %>"
         data-template-preview-has-payment-questions-value="<%= @template.has_payment_questions? %>"
         data-template-preview-required-features-value="<%= @template.required_features.to_json %>">
      
      <div class="flex items-start justify-between mb-6">
        <div class="flex-1">
          <h1 class="text-3xl font-bold text-gray-900 mb-2"><%= @template.name %></h1>
          <p class="text-lg text-gray-600 mb-4"><%= @template.description %></p>
          
          <!-- Template Metadata -->
          <div class="flex items-center space-x-6 text-sm text-gray-500">
            <span class="flex items-center">
              <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd"></path>
              </svg>
              <%= @template.estimated_time_minutes %> minutes
            </span>
            
            <span class="flex items-center">
              <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
                <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
              </svg>
              <%= @template.usage_count %> uses
            </span>
            
            <span class="px-2 py-1 bg-gray-100 text-gray-700 rounded-full text-xs font-medium">
              <%= @template.category.humanize %>
            </span>
          </div>
        </div>

        <!-- Payment Badge -->
        <%= render 'shared/payment_badge', 
            has_payment_questions: @template.has_payment_questions?,
            required_features: @template.required_features,
            size: 'lg' %>
      </div>

      <!-- Action Buttons -->
      <div class="flex space-x-4">
        <%= link_to templates_path, 
            class: "inline-flex items-center px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors" do %>
          <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z" clip-rule="evenodd"></path>
          </svg>
          Back to Templates
        <% end %>
        
        <% if @template.has_payment_questions? && !current_user.payment_setup_complete_for?(@template.required_features) %>
          <button class="inline-flex items-center px-6 py-2 text-sm font-medium text-white bg-gradient-to-r from-purple-600 to-indigo-600 border border-transparent rounded-lg hover:from-purple-700 hover:to-indigo-700 transition-all duration-200"
                  data-action="click->template-preview#showPaymentRequirements">
            <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clip-rule="evenodd"></path>
            </svg>
            Use This Template
          </button>
        <% else %>
          <%= form_with url: instantiate_template_path(@template), method: :post, local: true, class: "inline-block" do |form| %>
            <%= form.submit "Use This Template", 
                class: "inline-flex items-center px-6 py-2 text-sm font-medium text-white bg-gradient-to-r from-purple-600 to-indigo-600 border border-transparent rounded-lg hover:from-purple-700 hover:to-indigo-700 transition-all duration-200 cursor-pointer" %>
          <% end %>
        <% end %>
      </div>
    </div>

    <!-- Template Preview -->
    <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-8">
      <h2 class="text-xl font-semibold text-gray-900 mb-6">Template Preview</h2>
      
      <!-- Sample Questions -->
      <div class="space-y-4">
        <% @template.sample_questions_preview(5).each_with_index do |question, index| %>
          <div class="p-4 bg-gray-50 rounded-lg border border-gray-200">
            <div class="flex items-start justify-between">
              <div class="flex-1">
                <h3 class="font-medium text-gray-900 mb-1">
                  <%= index + 1 %>. <%= question[:title] %>
                </h3>
                <div class="flex items-center space-x-2 text-sm text-gray-500">
                  <span class="px-2 py-1 bg-blue-100 text-blue-700 rounded text-xs font-medium">
                    <%= question[:type].humanize %>
                  </span>
                  <% if question[:required] %>
                    <span class="text-red-600 font-medium">Required</span>
                  <% end %>
                  <% if question[:ai_enhanced] %>
                    <span class="flex items-center text-purple-600">
                      <svg class="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path>
                      </svg>
                      AI Enhanced
                    </span>
                  <% end %>
                </div>
              </div>
            </div>
          </div>
        <% end %>
        
        <% if @template.questions_config.length > 5 %>
          <div class="text-center py-4">
            <span class="text-sm text-gray-500">
              + <%= @template.questions_config.length - 5 %> more questions
            </span>
          </div>
        <% end %>
      </div>
    </div>

    <!-- Payment Requirements Modal -->
    <%= render 'shared/payment_requirements_modal' %>
  </div>
</div>
</file>

<file path="views/user_mailer/account_confirmation.html.erb">
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Confirma tu cuenta de mydialogform</title>
    <style>
      body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
      .container { max-width: 600px; margin: 0 auto; padding: 20px; }
      .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; border-radius: 8px 8px 0 0; }
      .content { background: #f8f9fa; padding: 30px; border-radius: 0 0 8px 8px; }
      .confirmation-info { background: #e3f2fd; border-left: 4px solid #2196f3; padding: 20px; margin: 20px 0; border-radius: 4px; }
      .cta-button { display: inline-block; background: #667eea; color: white; padding: 15px 30px; text-decoration: none; border-radius: 5px; margin: 20px 0; font-weight: bold; }
      .footer { text-align: center; color: #666; font-size: 14px; margin-top: 30px; }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1> Confirma tu cuenta!</h1>
        <p>Solo falta un paso para comenzar</p>
      </div>
      <div class="content">
        <p>Hola <%= @user.first_name %>,</p>
        <p>Gracias por registrarte en mydialogform! Para completar tu registro y comenzar a usar todas nuestras funciones, necesitamos que confirmes tu direccin de correo electrnico.</p>
        
        <div class="confirmation-info">
          <h3> Confirmacin requerida</h3>
          <p>Haz clic en el botn de abajo para confirmar tu cuenta y activar tu acceso completo a mydialogform.</p>
        </div>
        
        <div style="text-align: center;">
          <a href="<%= @confirmation_url %>" class="cta-button">Confirmar mi cuenta</a>
        </div>
        
        <p>Si el botn no funciona, puedes copiar y pegar este enlace en tu navegador:</p>
        <p style="word-break: break-all; background: #f0f0f0; padding: 10px; border-radius: 4px; font-family: monospace;">
          <%= @confirmation_url %>
        </p>
        
        <p><strong>Por qu necesitamos confirmar tu correo?</strong></p>
        <ul>
          <li>Para asegurar que puedas recibir notificaciones importantes</li>
          <li>Para proteger tu cuenta de accesos no autorizados</li>
          <li>Para enviarte actualizaciones sobre tus formularios</li>
        </ul>
        
        <p>Si no creaste esta cuenta, puedes ignorar este correo de forma segura.</p>
        
        <p>Esperamos verte pronto en mydialogform!</p>
        <p>Saludos,<br>El equipo de mydialogform</p>
      </div>
      <div class="footer">
        <p>Este correo fue enviado a <%= @user.email %></p>
        <p>mydialogform - Creando formularios inteligentes</p>
      </div>
    </div>
  </body>
</html>
</file>

<file path="views/user_mailer/account_confirmation.text.erb">
Confirma tu cuenta de mydialogform!

Hola <%= @user.first_name %>,

Gracias por registrarte en mydialogform! Para completar tu registro y comenzar a usar todas nuestras funciones, necesitamos que confirmes tu direccin de correo electrnico.

 CONFIRMACIN REQUERIDA
Haz clic en el siguiente enlace para confirmar tu cuenta y activar tu acceso completo a mydialogform:

<%= @confirmation_url %>

Por qu necesitamos confirmar tu correo?
- Para asegurar que puedas recibir notificaciones importantes
- Para proteger tu cuenta de accesos no autorizados  
- Para enviarte actualizaciones sobre tus formularios

Si no creaste esta cuenta, puedes ignorar este correo de forma segura.

Esperamos verte pronto en mydialogform!

Saludos,
El equipo de mydialogform

---
Este correo fue enviado a <%= @user.email %>
mydialogform - Creando formularios inteligentes
</file>

<file path="views/user_mailer/account_reactivated.html.erb">
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Account Reactivated - AgentForm</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        line-height: 1.6;
        color: #333;
        max-width: 600px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f8fafc;
      }
      .container {
        background-color: white;
        border-radius: 8px;
        padding: 40px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .header {
        text-align: center;
        margin-bottom: 30px;
      }
      .logo {
        font-size: 24px;
        font-weight: bold;
        color: #6366f1;
        margin-bottom: 10px;
      }
      .title {
        font-size: 28px;
        font-weight: bold;
        color: #059669;
        margin-bottom: 10px;
      }
      .subtitle {
        font-size: 16px;
        color: #6b7280;
      }
      .content {
        margin-bottom: 30px;
      }
      .success-box {
        background-color: #f0fdf4;
        border: 1px solid #bbf7d0;
        border-radius: 6px;
        padding: 20px;
        margin: 20px 0;
      }
      .success-title {
        font-weight: 600;
        color: #059669;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
      }
      .success-text {
        color: #065f46;
      }
      .button {
        display: inline-block;
        background-color: #059669;
        color: white;
        text-decoration: none;
        padding: 12px 24px;
        border-radius: 6px;
        font-weight: 600;
        text-align: center;
        margin: 20px 0;
      }
      .button:hover {
        background-color: #047857;
      }
      .info-box {
        background-color: #eff6ff;
        border: 1px solid #bfdbfe;
        border-radius: 6px;
        padding: 20px;
        margin: 20px 0;
      }
      .info-title {
        font-weight: 600;
        color: #1e40af;
        margin-bottom: 10px;
      }
      .info-text {
        color: #1e3a8a;
      }
      .footer {
        text-align: center;
        margin-top: 40px;
        padding-top: 20px;
        border-top: 1px solid #e5e7eb;
        color: #6b7280;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <div class="logo">AgentForm</div>
        <h1 class="title">Welcome Back!</h1>
        <p class="subtitle">Your AgentForm account has been reactivated</p>
      </div>

      <div class="content">
        <p>Hello <%= @user.first_name %>,</p>
        
        <div class="success-box">
          <div class="success-title">
             Account Successfully Reactivated
          </div>
          <div class="success-text">
            Great news! Your AgentForm account (<%= @user.email %>) has been reactivated 
            by an administrator. You now have full access to all your forms and features.
          </div>
        </div>

        <p>
          You can now:
        </p>
        <ul>
          <li>Log in to your AgentForm account</li>
          <li>Access all your existing forms</li>
          <li>Create new forms and collect responses</li>
          <li>Use all premium features (if applicable)</li>
          <li>Access the API and integrations</li>
        </ul>

        <div style="text-align: center;">
          <a href="<%= @login_url %>" class="button">Log In to AgentForm</a>
        </div>

        <div class="info-box">
          <div class="info-title"> What's Next?</div>
          <div class="info-text">
            All your forms and data have been preserved during the suspension period. 
            You can continue where you left off. If you have any questions about your 
            account or need assistance, our support team is here to help.
          </div>
        </div>

        <p>
          Thank you for your patience during the suspension period. We're glad to have you back!
        </p>
      </div>

      <div class="footer">
        <p>
          This is an automated notification from AgentForm.<br>
          Please do not reply to this email.
        </p>
        <p>
           <%= Date.current.year %> AgentForm. All rights reserved.
        </p>
      </div>
    </div>
  </body>
</html>
</file>

<file path="views/user_mailer/account_reactivated.text.erb">
AgentForm Account Reactivated - Welcome Back!

Hello <%= @user.first_name %>,

Great news! Your AgentForm account (<%= @user.email %>) has been reactivated by an administrator. You now have full access to all your forms and features.

You can now:
- Log in to your AgentForm account
- Access all your existing forms
- Create new forms and collect responses
- Use all premium features (if applicable)
- Access the API and integrations

Log in here: <%= @login_url %>

What's Next?
All your forms and data have been preserved during the suspension period. You can continue where you left off. If you have any questions about your account or need assistance, our support team is here to help.

Thank you for your patience during the suspension period. We're glad to have you back!

---
This is an automated notification from AgentForm.
Please do not reply to this email.

 <%= Date.current.year %> AgentForm. All rights reserved.
</file>

<file path="views/user_mailer/account_suspended.html.erb">
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Account Suspended - mydialogform</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        line-height: 1.6;
        color: #333;
        max-width: 600px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f8fafc;
      }
      .container {
        background-color: white;
        border-radius: 8px;
        padding: 40px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .header {
        text-align: center;
        margin-bottom: 30px;
      }
      .logo {
        font-size: 24px;
        font-weight: bold;
        color: #6366f1;
        margin-bottom: 10px;
      }
      .title {
        font-size: 28px;
        font-weight: bold;
        color: #dc2626;
        margin-bottom: 10px;
      }
      .subtitle {
        font-size: 16px;
        color: #6b7280;
      }
      .content {
        margin-bottom: 30px;
      }
      .alert-box {
        background-color: #fef2f2;
        border: 1px solid #fecaca;
        border-radius: 6px;
        padding: 20px;
        margin: 20px 0;
      }
      .alert-title {
        font-weight: 600;
        color: #dc2626;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
      }
      .alert-text {
        color: #7f1d1d;
      }
      .reason-box {
        background-color: #f9fafb;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        padding: 15px;
        margin: 15px 0;
      }
      .reason-label {
        font-weight: 600;
        color: #374151;
        margin-bottom: 5px;
      }
      .reason-text {
        color: #4b5563;
        font-style: italic;
      }
      .contact-box {
        background-color: #eff6ff;
        border: 1px solid #bfdbfe;
        border-radius: 6px;
        padding: 20px;
        margin: 20px 0;
      }
      .contact-title {
        font-weight: 600;
        color: #1e40af;
        margin-bottom: 10px;
      }
      .contact-text {
        color: #1e3a8a;
      }
      .footer {
        text-align: center;
        margin-top: 40px;
        padding-top: 20px;
        border-top: 1px solid #e5e7eb;
        color: #6b7280;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <div class="logo">mydialogform</div>
        <h1 class="title">Account Suspended</h1>
        <p class="subtitle">Your mydialogform account has been temporarily suspended</p>
      </div>

      <div class="content">
        <p>Hello <%= @user.first_name %>,</p>
        
        <div class="alert-box">
          <div class="alert-title">
             Account Access Suspended
          </div>
          <div class="alert-text">
            Your mydialogform account (<%= @user.email %>) has been suspended by an administrator. 
            You will not be able to log in or access your forms until this suspension is lifted.
          </div>
        </div>

        <% if @suspension_reason.present? %>
          <div class="reason-box">
            <div class="reason-label">Reason for Suspension:</div>
            <div class="reason-text"><%= @suspension_reason %></div>
          </div>
        <% end %>

        <p>
          During the suspension period:
        </p>
        <ul>
          <li>You cannot log in to your mydialogform account</li>
          <li>Your forms are temporarily inaccessible</li>
          <li>Form responses will not be collected</li>
          <li>API access is disabled</li>
        </ul>

        <div class="contact-box">
          <div class="contact-title"> Need to Appeal or Get More Information?</div>
          <div class="contact-text">
            If you believe this suspension was made in error or if you'd like to discuss 
            the situation, please contact our support team at 
            <strong><%= @contact_email %></strong>. 
            <br><br>
            Please include your account email (<%= @user.email %>) in your message 
            for faster assistance.
          </div>
        </div>

        <p>
          We appreciate your understanding and look forward to resolving this matter promptly.
        </p>
      </div>

      <div class="footer">
        <p>
          This is an automated notification from mydialogform.<br>
          Please do not reply to this email.
        </p>
        <p>
           <%= Date.current.year %> mydialogform. All rights reserved.
        </p>
      </div>
    </div>
  </body>
</html>
</file>

<file path="views/user_mailer/account_suspended.text.erb">
mydialogform Account Suspended

Hello <%= @user.first_name %>,

Your mydialogform account (<%= @user.email %>) has been suspended by an administrator. You will not be able to log in or access your forms until this suspension is lifted.

<% if @suspension_reason.present? %>
Reason for Suspension:
<%= @suspension_reason %>
<% end %>

During the suspension period:
- You cannot log in to your mydialogform account
- Your forms are temporarily inaccessible
- Form responses will not be collected
- API access is disabled

Need to Appeal or Get More Information?
If you believe this suspension was made in error or if you'd like to discuss the situation, please contact our support team at <%= @contact_email %>.

Please include your account email (<%= @user.email %>) in your message for faster assistance.

We appreciate your understanding and look forward to resolving this matter promptly.

---
This is an automated notification from mydialogform.
Please do not reply to this email.

 <%= Date.current.year %> mydialogform. All rights reserved.
</file>

<file path="views/user_mailer/admin_invitation.html.erb">
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Welcome to AgentForm</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        line-height: 1.6;
        color: #333;
        max-width: 600px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f8fafc;
      }
      .container {
        background-color: white;
        border-radius: 8px;
        padding: 40px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .header {
        text-align: center;
        margin-bottom: 30px;
      }
      .logo {
        font-size: 24px;
        font-weight: bold;
        color: #6366f1;
        margin-bottom: 10px;
      }
      .title {
        font-size: 28px;
        font-weight: bold;
        color: #1f2937;
        margin-bottom: 10px;
      }
      .subtitle {
        font-size: 16px;
        color: #6b7280;
      }
      .content {
        margin-bottom: 30px;
      }
      .credentials-box {
        background-color: #f3f4f6;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        padding: 20px;
        margin: 20px 0;
      }
      .credential-item {
        margin-bottom: 10px;
      }
      .credential-label {
        font-weight: 600;
        color: #374151;
      }
      .credential-value {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        background-color: white;
        padding: 8px 12px;
        border-radius: 4px;
        border: 1px solid #d1d5db;
        display: inline-block;
        margin-left: 10px;
      }
      .button {
        display: inline-block;
        background-color: #6366f1;
        color: white;
        text-decoration: none;
        padding: 12px 24px;
        border-radius: 6px;
        font-weight: 600;
        text-align: center;
        margin: 20px 0;
      }
      .button:hover {
        background-color: #4f46e5;
      }
      .warning {
        background-color: #fef3c7;
        border: 1px solid #f59e0b;
        border-radius: 6px;
        padding: 15px;
        margin: 20px 0;
      }
      .warning-title {
        font-weight: 600;
        color: #92400e;
        margin-bottom: 5px;
      }
      .warning-text {
        color: #92400e;
        font-size: 14px;
      }
      .footer {
        text-align: center;
        margin-top: 40px;
        padding-top: 20px;
        border-top: 1px solid #e5e7eb;
        color: #6b7280;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <div class="logo">AgentForm</div>
        <h1 class="title">Welcome to AgentForm!</h1>
        <p class="subtitle">Your account has been created by an administrator</p>
      </div>

      <div class="content">
        <p>Hello <%= @user.first_name %>,</p>
        
        <p>
          An administrator has created an AgentForm account for you. You can now access 
          the platform to create intelligent forms and manage your data collection workflows.
        </p>

        <div class="credentials-box">
          <h3 style="margin-top: 0; color: #374151;">Your Login Credentials</h3>
          
          <div class="credential-item">
            <span class="credential-label">Email:</span>
            <span class="credential-value"><%= @user.email %></span>
          </div>
          
          <div class="credential-item">
            <span class="credential-label">Temporary Password:</span>
            <span class="credential-value"><%= @temporary_password %></span>
          </div>
        </div>

        <div class="warning">
          <div class="warning-title"> Important Security Notice</div>
          <div class="warning-text">
            This is a temporary password. You will be required to change it when you first log in. 
            Please keep this email secure and delete it after you've successfully logged in and 
            changed your password.
          </div>
        </div>

        <div style="text-align: center;">
          <a href="<%= @login_url %>" class="button">Log In to AgentForm</a>
        </div>

        <h3>What you can do with AgentForm:</h3>
        <ul>
          <li>Create intelligent, conversational forms</li>
          <li>Analyze responses with AI-powered insights</li>
          <li>Integrate with your existing workflows</li>
          <li>Access comprehensive analytics and reporting</li>
        </ul>

        <p>
          If you have any questions or need assistance getting started, please don't hesitate 
          to contact our support team.
        </p>
      </div>

      <div class="footer">
        <p>
          This email was sent because an administrator created an account for you.<br>
          If you believe this was sent in error, please contact support immediately.
        </p>
        <p>
           <%= Date.current.year %> AgentForm. All rights reserved.
        </p>
      </div>
    </div>
  </body>
</html>
</file>

<file path="views/user_mailer/admin_invitation.text.erb">
Welcome to mydialogform!

Hello <%= @user.first_name %>,

An administrator has created a mydialogform account for you. You can now access the platform to create intelligent forms and manage your data collection workflows.

Your Login Credentials:
Email: <%= @user.email %>
Temporary Password: <%= @temporary_password %>

IMPORTANT SECURITY NOTICE:
This is a temporary password. You will be required to change it when you first log in. Please keep this email secure and delete it after you've successfully logged in and changed your password.

Log in here: <%= @login_url %>

What you can do with AgentForm:
- Create intelligent, conversational forms
- Analyze responses with AI-powered insights
- Integrate with your existing workflows
- Access comprehensive analytics and reporting

If you have any questions or need assistance getting started, please don't hesitate to contact our support team.

---
This email was sent because an administrator created an account for you.
If you believe this was sent in error, please contact support immediately.

 <%= Date.current.year %> AgentForm. All rights reserved.
</file>

<file path="views/user_mailer/premium_welcome.html.erb">
<h2>Bienvenido a mydialogform Premium, <%= @user.first_name %>!</h2>

<p>Gracias por suscribirte! Tu cuenta premium est ahora activa y tienes acceso completo a todas nuestras funciones avanzadas.</p>

<div class="highlight">
  <h3> Tu cuenta premium incluye:</h3>
  <ul>
    <li><strong>Formularios y respuestas ilimitadas</strong></li>
    <li><strong>Procesamiento de pagos via Stripe</strong></li>
    <li><strong>Funciones avanzadas de IA</strong></li>
    <li><strong>Soporte prioritario</strong></li>
    <li><strong>Eliminacin de marca mydialogform</strong></li>
    <li><strong>Analticas avanzadas</strong></li>
    <li><strong>Integraciones premium</strong></li>
  </ul>
</div>

<div style="text-align: center;">
  <a href="<%= @login_url %>" class="btn">Acceder a tu cuenta</a>
</div>

<h3>Qu sigue?</h3>
<p>
  Ahora puedes crear formularios profesionales, procesar pagos, y aprovechar todas las funciones premium que mydialogform tiene para ofrecer.
</p>

<h3>Necesitas ayuda?</h3>
<p>Como usuario premium, tienes acceso a soporte prioritario. Simplemente responde a este email con cualquier pregunta.</p>

<p>
  Gracias por confiar en mydialogform!<br>
  <strong>El equipo de mydialogform</strong>
</p>
</file>

<file path="views/user_mailer/premium_welcome.text.erb">
Bienvenido a mydialogform Premium, <%= @user.first_name %>!

Gracias por suscribirte! Tu cuenta premium est ahora activa y tienes acceso completo a todas nuestras funciones avanzadas.

Tu cuenta premium incluye:
- Formularios y respuestas ilimitadas
- Procesamiento de pagos via Stripe
- Funciones avanzadas de IA
- Soporte prioritario
- Eliminacin de marca mydialogform
- Analticas avanzadas
- Integraciones premium

Acceder a tu cuenta: <%= @login_url %>

Qu sigue?
Ahora puedes crear formularios profesionales, procesar pagos, y aprovechar todas las funciones premium que mydialogform tiene para ofrecer.

Necesitas ayuda?
Como usuario premium, tienes acceso a soporte prioritario. Simplemente responde a este email con cualquier pregunta.

Gracias por confiar en mydialogform!
El equipo de mydialogform
</file>

<file path="views/user_mailer/trial_welcome.html.erb">
<h2>Bienvenido a mydialogform, <%= @user.first_name %>!</h2>

<p>Excelente! Tu perodo de prueba de <strong><%= @trial_days %> das</strong> ha comenzado y ya tienes acceso completo a todas las funciones premium de mydialogform.</p>

<div class="highlight">
  <h3> Qu puedes hacer ahora?</h3>
  <ul>
    <li><strong>Crear formularios ilimitados</strong> con nuestro editor intuitivo</li>
    <li><strong>Usar IA avanzada</strong> para generar formularios automticamente</li>
    <li><strong>Procesar pagos</strong> directamente en tus formularios</li>
    <li><strong>Acceder a analticas avanzadas</strong> y reportes detallados</li>
    <li><strong>Integrar con Google Sheets</strong> y otras herramientas</li>
    <li><strong>Remover la marca mydialogform</strong> de tus formularios</li>
  </ul>
</div>

<div style="text-align: center;">
  <a href="<%= @login_url %>" class="btn">Comenzar ahora</a>
</div>

<div class="warning">
  <h4> Informacin importante sobre tu trial</h4>
  <p>
    <% if @trial_end_date %>
      Tu perodo de prueba expira el <strong><%= @trial_end_date %></strong>. 
      Te enviaremos recordatorios antes de que expire para que puedas continuar sin interrupciones.
    <% else %>
      Tu perodo de prueba de <strong><%= @trial_days %> das</strong> est activo.
      Te enviaremos recordatorios antes de que expire para que puedas continuar sin interrupciones.
    <% end %>
  </p>
</div>

<h3>Necesitas ayuda para comenzar?</h3>
<p>Nuestro equipo est aqu para ayudarte. Simplemente responde a este email con cualquier pregunta que tengas.</p>

<p>
  Gracias por elegir mydialogform!<br>
  <strong>El equipo de mydialogform</strong>
</p>
</file>

<file path="views/user_mailer/trial_welcome.text.erb">
Bienvenido a mydialogform, <%= @user.first_name %>!

Excelente! Tu perodo de prueba de <%= @trial_days %> das ha comenzado y ya tienes acceso completo a todas las funciones premium de mydialogform.

Qu puedes hacer ahora?
- Crear formularios ilimitados con nuestro editor intuitivo
- Usar IA avanzada para generar formularios automticamente  
- Procesar pagos directamente en tus formularios
- Acceder a analticas avanzadas y reportes detallados
- Integrar con Google Sheets y otras herramientas
- Remover la marca mydialogform de tus formularios

Comenzar ahora: <%= @login_url %>

INFORMACIN IMPORTANTE SOBRE TU TRIAL
<% if @trial_end_date %>
Tu perodo de prueba expira el <%= @trial_end_date %>. 
<% else %>
Tu perodo de prueba de <%= @trial_days %> das est activo.
<% end %>
Te enviaremos recordatorios antes de que expire para que puedas continuar sin interrupciones.

Necesitas ayuda para comenzar?
Nuestro equipo est aqu para ayudarte. Simplemente responde a este email con cualquier pregunta que tengas.

Gracias por elegir mydialogform!
El equipo de mydialogform
</file>

<file path="workflows/forms/ai_form_generation_workflow.rb">
# frozen_string_literal: true

module Forms
  class AiFormGenerationWorkflow < ApplicationWorkflow
    
    workflow do
      # Step 1: Validate and prepare content for AI processing
      task :validate_and_prepare_content do
        process do |context|
          user_id = context.get(:user_id)
          content_input = context.get(:content_input)
          input_type = context.get(:input_type)
          metadata = context.get(:metadata) || {}
          Rails.logger.info "Starting AI form generation for user_id: #{user_id}, input_type: #{input_type}"
          
          # Validate required inputs
          if user_id.blank? || content_input.blank? || input_type.blank?
            missing = []
            missing << 'user_id' if user_id.blank?
            missing << 'content_input' if content_input.blank?
            missing << 'input_type' if input_type.blank?
            Rails.logger.warn "[validate_and_prepare_content] Missing inputs: #{missing}"
            raise "Missing required inputs: #{missing.join(', ')}"
          end
          
          # Load and validate user
          user = User.find_by(id: user_id)
          unless user
            raise "User not found"
          end
          
          # Check AI credits
          unless user.can_use_ai_features?
            raise "AI features require a premium subscription"
          end
          
          if user.ai_credits_remaining <= 0
            raise "Monthly AI usage limit exceeded"
          end
          
          # Process content
          if input_type == 'prompt'
            content = content_input.to_s.strip
            word_count = content.split(/\s+/).length
          elsif input_type == 'document'
            # Process uploaded document
            content = Forms::AiFormGenerationWorkflow.new.send(:process_document, content_input)
            word_count = content.split(/\s+/).length
          else
            raise "Unsupported input type: #{input_type}"
          end
          
          # Validate content length
          if word_count < 10
            raise "Content must be at least 10 words long"
          elsif word_count > 5000
            raise "Content is too long (maximum 5000 words)"
          end
          
          Rails.logger.info "Content validation successful - #{word_count} words processed"
          
          {
            user: user,
            content: content,
            word_count: word_count,
            estimated_cost: 0.05
          }
        end
      end

      # Step 2: Generate form using AI
      llm :generate_form do
        model "gpt-4o-mini"
        temperature 0.3
        max_tokens 2000
        
        system_prompt "You are an expert form designer. Generate a complete form structure based on the user's requirements. Return valid JSON only."
        
        prompt <<~PROMPT
          Create a form based on this request: {{validate_and_prepare_content.content}}
          
          Generate a JSON response with this exact structure:
          {
            "form_name": "Form title",
            "description": "Brief description", 
            "questions": [
              {
                "title": "Question text",
                "type": "text_short",
                "required": true,
                "config": {}
              }
            ]
          }
          
          Available question types and their config formats:
          - text_short, text_long, email, phone, date: config = {}
          - multiple_choice, single_choice: config = {"options": ["Option 1", "Option 2"]}
          - rating: config = {"min_value": 1, "max_value": 5, "labels": ["Poor", "Excellent"]}
          
          IMPORTANT: 
          - Use proper JSON format with quoted strings
          - For rating questions, use "min_value" and "max_value" as numbers
          - Always include at least 2 options for choice questions
          - Create 5-10 relevant questions for this form
          - Return ONLY valid JSON, no markdown formatting
        PROMPT
      end

      # Step 3: Create form in database
      task :create_form do
        process do |context|
          validation_result = context.get(:validate_and_prepare_content)
          form_data = context.get(:generate_form)
          user = validation_result[:user]
          
          # The LLM task already returns the response string directly
          Rails.logger.info "LLM task result type: #{form_data.class}"
          Rails.logger.info "LLM response length: #{form_data.length} characters" if form_data.is_a?(String)
          
          # Parse the AI response
          begin
            # Force conversion to string to avoid any metaprogramming issues
            form_data_str = form_data.to_s
            Rails.logger.info "Converted to string: #{form_data_str.class} - length: #{form_data_str.length}"
            
            if form_data_str.is_a?(String) && form_data_str.length > 0
              # Extract JSON from the response (handle various formats)
              json_match = form_data_str.match(/```json\s*\n?(.*?)\n?```/m) || 
                          form_data_str.match(/\{.*\}/m)
              
              if json_match
                cleaned_data = (json_match[1] || json_match[0]).to_s
                Rails.logger.info "Extracted JSON match: #{cleaned_data.class} - #{cleaned_data[0..100]}..."
                
                # Clean up common AI formatting issues - bypass method call for now
                cleaned_data = cleaned_data.strip
                Rails.logger.info "After cleaning: #{cleaned_data.class} - #{cleaned_data[0..100]}..."
                
                Rails.logger.info "About to parse JSON with: #{cleaned_data.class}"
                form_structure = JSON.parse(cleaned_data)
              else
                Rails.logger.error "No JSON found in AI response: #{form_data_str}"
                raise "No valid JSON found in AI response"
              end
            else
              Rails.logger.error "Invalid form_data type or empty: #{form_data.class}"
              raise "Invalid AI response format"
            end
          rescue JSON::ParserError => e
            Rails.logger.error "Failed to parse AI response: #{e.message}"
            Rails.logger.error "Raw response: #{form_data}"
            raise "Invalid AI response format"
          end
          
          # Create the form
          begin
            ActiveRecord::Base.transaction do
              form = user.forms.create!(
                name: form_structure['form_name'] || 'AI Generated Form',
                description: form_structure['description'] || 'Generated by AI',
                category: 'general',
                ai_enabled: true,
                status: 'draft'
              )
              
              # Create questions
              questions = form_structure['questions'] || []
              questions.each_with_index do |question_data, index|
                question_type = question_data['type'] || 'text_short'
                config = question_data['config'] || {}
                
                # Validate and fix config based on question type - inline to avoid method interception
                case question_type
                when 'multiple_choice', 'single_choice'
                  # Ensure options exist
                  if config['options'].blank? || !config['options'].is_a?(Array)
                    config['options'] = ['Option 1', 'Option 2']
                  end
                when 'rating'
                  # Ensure min_value and max_value exist
                  config['min_value'] = config['min_value'] || 1
                  config['max_value'] = config['max_value'] || 5
                  
                  # Convert to integers if they're strings
                  config['min_value'] = config['min_value'].to_i
                  config['max_value'] = config['max_value'].to_i
                  
                  # Ensure max > min
                  if config['max_value'] <= config['min_value']
                    config['min_value'] = 1
                    config['max_value'] = 5
                  end
                when 'scale'
                  # Similar to rating
                  config['min_value'] = config['min_value'] || 1
                  config['max_value'] = config['max_value'] || 10
                  config['min_value'] = config['min_value'].to_i
                  config['max_value'] = config['max_value'].to_i
                  
                  if config['max_value'] <= config['min_value']
                    config['min_value'] = 1
                    config['max_value'] = 10
                  end
                end
                
                form.form_questions.create!(
                  title: question_data['title'],
                  question_type: question_type,
                  required: question_data['required'] || false,
                  position: index + 1,
                  question_config: config
                )
              end
              
              # Update user's AI credits
              user.increment!(:ai_credits_used, validation_result[:estimated_cost])
              
              Rails.logger.info "Successfully created form with ID: #{form.id} (#{questions.length} questions)"
              
              {
                form: form,
                questions_count: questions.length,
                generation_cost: validation_result[:estimated_cost]
              }
            end
          rescue ActiveRecord::RecordInvalid => e
            Rails.logger.error "Failed to create form: #{e.message}"
            raise "Failed to create form: #{e.message}"
          rescue StandardError => e
            Rails.logger.error "Unexpected error creating form: #{e.message}"
            Rails.logger.error "Backtrace: #{e.backtrace.first(5).join("\n")}"
            raise "An unexpected error occurred: #{e.message}"
          end
        end
      end
    end

    private

    def clean_ai_json_response(json_string)
      # Fix common AI JSON formatting issues
      cleaned = json_string.dup
      
      # Fix scale format like "scale": 1-5 to "min_value": 1, "max_value": 5
      cleaned = cleaned.gsub(/"scale":\s*(\d+)-(\d+)/) do |match|
        min_val = $1
        max_val = $2
        "\"min_value\": #{min_val}, \"max_value\": #{max_val}"
      end
      
      # Fix unquoted values in config
      cleaned = cleaned.gsub(/:\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*([,}])/) do |match|
        value = $1
        ending = $2
        # Don't quote if it's already a number, boolean, or null
        if value.match?(/^(true|false|null|\d+)$/)
          match
        else
          ": \"#{value}\"#{ending}"
        end
      end
      
      # Remove trailing commas before closing brackets/braces
      cleaned = cleaned.gsub(/,(\s*[}\]])/, '\1')
      
      Rails.logger.debug "Cleaned JSON: #{cleaned}"
      cleaned
    end

    def validate_and_fix_question_config(question_type, config)
      case question_type
      when 'multiple_choice', 'single_choice'
        # Ensure options exist
        if config['options'].blank? || !config['options'].is_a?(Array)
          config['options'] = ['Option 1', 'Option 2']
        end
      when 'rating'
        # Ensure min_value and max_value exist
        config['min_value'] = config['min_value'] || 1
        config['max_value'] = config['max_value'] || 5
        
        # Convert to integers if they're strings
        config['min_value'] = config['min_value'].to_i
        config['max_value'] = config['max_value'].to_i
        
        # Ensure max > min
        if config['max_value'] <= config['min_value']
          config['min_value'] = 1
          config['max_value'] = 5
        end
      when 'scale'
        # Similar to rating
        config['min_value'] = config['min_value'] || 1
        config['max_value'] = config['max_value'] || 10
        config['min_value'] = config['min_value'].to_i
        config['max_value'] = config['max_value'].to_i
        
        if config['max_value'] <= config['min_value']
          config['min_value'] = 1
          config['max_value'] = 10
        end
      end
      
      config
    end

    def process_document(uploaded_file)
      Rails.logger.info "Processing document: #{uploaded_file.original_filename}"
      
      # Validate file type
      allowed_types = ['application/pdf', 'text/plain', 'text/markdown']
      unless allowed_types.include?(uploaded_file.content_type)
        raise "Unsupported file type: #{uploaded_file.content_type}"
      end
      
      # Validate file size (10MB limit)
      if uploaded_file.size > 10.megabytes
        raise "File too large: #{uploaded_file.size} bytes (max 10MB)"
      end
      
      case uploaded_file.content_type
      when 'application/pdf'
        extract_text_from_pdf(uploaded_file)
      when 'text/plain', 'text/markdown'
        uploaded_file.read.force_encoding('UTF-8')
      else
        raise "Unsupported file type: #{uploaded_file.content_type}"
      end
    end

    def extract_text_from_pdf(uploaded_file)
      begin
        # Try to use pdf-reader gem if available
        if defined?(PDF::Reader)
          reader = PDF::Reader.new(uploaded_file.tempfile)
          text = reader.pages.map(&:text).join("\n")
          
          # Clean up the text
          text = text.gsub(/\s+/, ' ').strip
          
          if text.blank?
            raise "Could not extract text from PDF - file may be image-based or corrupted"
          end
          
          Rails.logger.info "Successfully extracted #{text.length} characters from PDF"
          return text
        else
          # Fallback: try to read as plain text (won't work for most PDFs)
          Rails.logger.warn "PDF::Reader gem not available, attempting fallback text extraction"
          content = uploaded_file.read.force_encoding('UTF-8')
          
          # Basic cleanup for text that might have been extracted
          if content.length > 100 && content.include?('PDF')
            # This is likely a PDF header, not actual content
            raise "PDF text extraction requires the pdf-reader gem. Please install it or upload a text file instead."
          end
          
          return content
        end
      rescue => e
        Rails.logger.error "PDF processing failed: #{e.message}"
        raise "Failed to process PDF: #{e.message}. Please try uploading a text or markdown file instead."
      end
    end
  end
end
</file>

<file path="workflows/forms/analysis_workflow.rb">
# frozen_string_literal: true

module Forms
  class AnalysisWorkflow < ApplicationWorkflow
    workflow do
      timeout 120
      
      # Step 1: Gather form data
      task :collect_form_data do
        input :form_id
        description "Collect all form responses and questions for analysis"
        
        process do |form_id|
          Rails.logger.info "Collecting form data for analysis: form_id=#{form_id}"
          
          # Validate required inputs
          validate_required_inputs(context, :form_id)
          
          # Execute data collection safely
          result = safe_db_operation do
            # Load form with associations
            form = Form.includes(
              :form_questions, 
              :form_responses, 
              :form_analytics,
              form_responses: :question_responses
            ).find(form_id)
            
            # Get form responses with completed status
            completed_responses = form.form_responses.completed
            total_responses = form.form_responses.count
            
            # Calculate basic metrics
            completion_rate = total_responses > 0 ? (completed_responses.count.to_f / total_responses * 100).round(2) : 0
            
            # Get question-level data
            questions_data = form.form_questions.order(:position).map do |question|
              question_responses = question.question_responses.joins(:form_response)
                                         .where(form_responses: { status: 'completed' })
              
              {
                question_id: question.id,
                title: question.title,
                question_type: question.question_type,
                position: question.position,
                required: question.required?,
                ai_enhanced: question.ai_enhanced?,
                responses_count: question_responses.count,
                completion_rate: total_responses > 0 ? (question_responses.count.to_f / total_responses * 100).round(2) : 0,
                avg_response_time: question_responses.average(:response_time_ms)&.to_f || 0,
                responses_data: question_responses.limit(100).pluck(:answer_data, :response_time_ms, :ai_analysis_results)
              }
            end
            
            # Get time-based analytics
            analytics_data = form.form_analytics.for_period(30.days.ago, Date.current)
                                .group(:date)
                                .sum(:completions_count, :views_count, :abandons_count)
            
            # Prepare comprehensive data structure
            {
              form: form,
              total_responses: total_responses,
              completed_responses_count: completed_responses.count,
              completion_rate: completion_rate,
              questions_data: questions_data,
              analytics_data: analytics_data,
              form_settings: form.form_settings,
              ai_configuration: form.ai_configuration,
              created_at: form.created_at,
              last_response_at: form.last_response_at
            }
          end
          
          # Handle database operation result
          if result[:error]
            Rails.logger.error "Failed to collect form data: #{result[:message]}"
            return format_error_result("Failed to collect form data", result[:type], result)
          end
          
          # Check if form has sufficient data for analysis
          if result[:total_responses] < 5
            Rails.logger.info "Insufficient responses for meaningful analysis: #{result[:total_responses]} responses"
            return format_success_result({
              insufficient_data: true,
              total_responses: result[:total_responses],
              minimum_required: 5,
              message: "Need at least 5 responses for meaningful analysis"
            })
          end
          
          Rails.logger.info "Successfully collected data for #{result[:total_responses]} responses across #{result[:questions_data].length} questions"
          
          format_success_result({
            form_data: result,
            has_sufficient_data: true,
            analysis_ready: true
          })
        end
      end
      
      # Step 2: Performance analysis
      llm :analyze_form_performance do
        input :collect_form_data
        run_if { |ctx| 
          form_data_result = ctx.get(:collect_form_data)
          form_data_result&.dig(:has_sufficient_data) && 
          form_data_result&.dig(:form_data, :total_responses) >= 10 
        }
        
        model "gpt-4o"
        temperature 0.2
        max_tokens 1000
        response_format :json
        
        system_prompt "You are an expert in form optimization and user experience analysis with deep knowledge of conversion optimization, user psychology, and data analysis."
        
        prompt do |context|
          form_data_result = context.get(:collect_form_data)
          form_data = form_data_result[:form_data]
          
          format_performance_analysis_prompt(form_data)
        end
      end
      
      # Step 3: Question-level analysis
      task :analyze_question_performance do
        input :collect_form_data
        run_if { |ctx| 
          form_data_result = ctx.get(:collect_form_data)
          form_data_result&.dig(:has_sufficient_data) && 
          form_data_result&.dig(:form_data, :total_responses) >= 10 
        }
        
        process do |form_data_result|
          Rails.logger.info "Analyzing individual question performance"
          
          form_data = form_data_result[:form_data]
          questions_data = form_data[:questions_data]
          
          # Analyze each question's performance
          question_analysis = questions_data.map do |question_data|
            analyze_single_question_performance(question_data, form_data)
          end
          
          # Identify bottlenecks and high performers
          bottlenecks = identify_bottlenecks(question_analysis)
          high_performers = identify_high_performers(question_analysis)
          
          # Calculate overall question flow metrics
          flow_metrics = calculate_flow_metrics(questions_data)
          
          Rails.logger.info "Question analysis complete: #{bottlenecks.length} bottlenecks, #{high_performers.length} high performers identified"
          
          format_success_result({
            question_analysis: question_analysis,
            bottlenecks: bottlenecks,
            high_performers: high_performers,
            flow_metrics: flow_metrics,
            total_questions_analyzed: question_analysis.length
          })
        end
      end
      
      # Step 4: Generate actionable insights
      llm :generate_optimization_plan do
        input :analyze_form_performance, :analyze_question_performance
        run_when :analyze_form_performance
        
        model "gpt-4o"
        temperature 0.3
        max_tokens 800
        response_format :json
        
        system_prompt "You are a conversion optimization expert who creates actionable, prioritized improvement plans for forms based on data analysis."
        
        prompt do |context|
          performance_analysis = context.get(:analyze_form_performance)
          question_analysis = context.get(:analyze_question_performance)
          form_data_result = context.get(:collect_form_data)
          
          format_optimization_plan_prompt(performance_analysis, question_analysis, form_data_result[:form_data])
        end
      end
      
      # Step 5: Save analysis results
      task :save_analysis_results do
        input :analyze_form_performance, :analyze_question_performance, :generate_optimization_plan
        
        process do |performance, questions, optimization|
          Rails.logger.info "Saving comprehensive analysis results"
          
          form_data_result = context.get(:collect_form_data)
          form = form_data_result[:form_data][:form]
          
          # Track AI usage for analysis
          ai_cost = 0.08 # Estimated cost for comprehensive analysis
          track_ai_usage(context, ai_cost, 'form_analysis')
          
          # Execute database operation safely
          result = safe_db_operation do
            # Create or update form analytics record
            analytics_record = FormAnalytic.find_or_create_by(
              form: form,
              date: Date.current,
              metric_type: 'comprehensive_analysis'
            )
            
            # Prepare analysis data
            analysis_data = {
              performance_analysis: performance,
              question_analysis: questions,
              optimization_plan: optimization,
              analysis_metadata: {
                analyzed_at: Time.current.iso8601,
                total_responses: form_data_result[:form_data][:total_responses],
                completion_rate: form_data_result[:form_data][:completion_rate],
                ai_cost: ai_cost,
                workflow_id: context.get(:workflow_id)
              }
            }
            
            # Update analytics record
            analytics_record.update!(
              ai_insights: analysis_data,
              optimization_suggestions: optimization.dig('recommendations') || [],
              behavioral_patterns: performance.dig('behavioral_patterns') || {},
              avg_quality_score: questions.dig('flow_metrics', 'avg_quality_score') || 0,
              updated_at: Time.current
            )
            
            # Update user's AI credit usage
            user = form.user
            user.consume_ai_credit(ai_cost) if user.respond_to?(:consume_ai_credit)
            
            {
              analytics_record: analytics_record,
              analysis_data: analysis_data,
              ai_cost: ai_cost
            }
          end
          
          if result[:error]
            Rails.logger.error "Failed to save analysis results: #{result[:message]}"
            return format_error_result("Failed to save analysis results", result[:type], result)
          end
          
          Rails.logger.info "Successfully saved analysis results for form #{form.name}"
          
          format_success_result({
            analytics_record_id: result[:analytics_record].id,
            analysis_data: result[:analysis_data],
            ai_cost: result[:ai_cost],
            saved_at: Time.current.iso8601
          })
        end
      end
    end
    
    private
    
    # Analyze individual question performance metrics
    def analyze_single_question_performance(question_data, form_data)
      total_form_responses = form_data[:total_responses]
      
      # Calculate drop-off rate for this question
      drop_off_rate = calculate_drop_off_rate(question_data, form_data)
      
      # Analyze response patterns
      answer_distribution = calculate_answer_distribution(question_data[:responses_data])
      
      # Calculate quality metrics
      avg_response_time = question_data[:avg_response_time] || 0
      response_time_category = categorize_response_time(avg_response_time, question_data[:question_type])
      
      # Determine performance indicators
      performance_score = calculate_question_performance_score(question_data, drop_off_rate, answer_distribution)
      
      # Identify specific issues
      issues = identify_question_issues(question_data, drop_off_rate, avg_response_time, answer_distribution)
      
      # Identify success factors
      success_factors = identify_question_success_factors(question_data, performance_score, answer_distribution)
      
      {
        question_id: question_data[:question_id],
        title: question_data[:title],
        position: question_data[:position],
        question_type: question_data[:question_type],
        completion_rate: question_data[:completion_rate],
        drop_off_rate: drop_off_rate,
        performance_score: performance_score,
        avg_response_time: avg_response_time,
        response_time_category: response_time_category,
        answer_distribution: answer_distribution,
        issues: issues,
        success_factors: success_factors,
        recommendations: generate_question_recommendations(question_data, issues, success_factors)
      }
    end
    
    # Identify questions that are causing significant user drop-off
    def identify_bottlenecks(question_analysis)
      bottlenecks = []
      
      question_analysis.each do |analysis|
        # High drop-off rate indicates a bottleneck
        if analysis[:drop_off_rate] > 15.0
          bottlenecks << {
            question_id: analysis[:question_id],
            title: analysis[:title],
            position: analysis[:position],
            drop_off_rate: analysis[:drop_off_rate],
            issue_type: 'high_drop_off',
            severity: analysis[:drop_off_rate] > 30.0 ? 'critical' : 'high',
            primary_issues: analysis[:issues].select { |issue| issue[:severity] == 'high' }
          }
        end
        
        # Low completion rate compared to previous questions
        if analysis[:completion_rate] < 70.0 && analysis[:position] > 1
          bottlenecks << {
            question_id: analysis[:question_id],
            title: analysis[:title],
            position: analysis[:position],
            completion_rate: analysis[:completion_rate],
            issue_type: 'low_completion',
            severity: analysis[:completion_rate] < 50.0 ? 'critical' : 'medium',
            primary_issues: analysis[:issues]
          }
        end
        
        # Unusually long response times
        if analysis[:response_time_category] == 'very_slow'
          bottlenecks << {
            question_id: analysis[:question_id],
            title: analysis[:title],
            position: analysis[:position],
            avg_response_time: analysis[:avg_response_time],
            issue_type: 'slow_response',
            severity: 'medium',
            primary_issues: analysis[:issues].select { |issue| issue[:type] == 'response_time' }
          }
        end
      end
      
      # Remove duplicates and sort by severity
      bottlenecks.uniq { |b| b[:question_id] }
                .sort_by { |b| [b[:severity] == 'critical' ? 0 : 1, -b[:drop_off_rate].to_f] }
    end
    
    # Identify questions that are performing exceptionally well
    def identify_high_performers(question_analysis)
      high_performers = []
      
      question_analysis.each do |analysis|
        # High completion rate with low drop-off
        if analysis[:completion_rate] > 85.0 && analysis[:drop_off_rate] < 5.0
          high_performers << {
            question_id: analysis[:question_id],
            title: analysis[:title],
            position: analysis[:position],
            completion_rate: analysis[:completion_rate],
            drop_off_rate: analysis[:drop_off_rate],
            success_factor: 'high_engagement',
            performance_score: analysis[:performance_score],
            key_strengths: analysis[:success_factors]
          }
        end
        
        # Fast response times with good completion
        if analysis[:response_time_category] == 'fast' && analysis[:completion_rate] > 80.0
          high_performers << {
            question_id: analysis[:question_id],
            title: analysis[:title],
            position: analysis[:position],
            avg_response_time: analysis[:avg_response_time],
            completion_rate: analysis[:completion_rate],
            success_factor: 'efficient_design',
            performance_score: analysis[:performance_score],
            key_strengths: analysis[:success_factors]
          }
        end
        
        # High performance score overall
        if analysis[:performance_score] > 85.0
          high_performers << {
            question_id: analysis[:question_id],
            title: analysis[:title],
            position: analysis[:position],
            performance_score: analysis[:performance_score],
            success_factor: 'overall_excellence',
            key_strengths: analysis[:success_factors]
          }
        end
      end
      
      # Remove duplicates and sort by performance score
      high_performers.uniq { |hp| hp[:question_id] }
                    .sort_by { |hp| -hp[:performance_score] }
    end
    
    # Calculate overall flow and user experience metrics
    def calculate_flow_metrics(questions_data)
      return {} if questions_data.empty?
      
      # Calculate completion rate progression
      completion_rates = questions_data.map { |q| q[:completion_rate] }
      avg_completion_rate = completion_rates.sum / completion_rates.length
      
      # Calculate drop-off progression
      drop_offs = questions_data.each_cons(2).map do |current, next_q|
        current[:completion_rate] - next_q[:completion_rate]
      end
      
      # Calculate response time metrics
      response_times = questions_data.map { |q| q[:avg_response_time] }.compact
      avg_response_time = response_times.empty? ? 0 : response_times.sum / response_times.length
      
      # Calculate quality indicators
      required_questions = questions_data.count { |q| q[:required] }
      ai_enhanced_questions = questions_data.count { |q| q[:ai_enhanced] }
      
      # Identify flow issues
      flow_issues = []
      
      # Check for steep drop-offs
      drop_offs.each_with_index do |drop_off, index|
        if drop_off > 20.0
          flow_issues << {
            type: 'steep_drop_off',
            location: "Between Q#{index + 1} and Q#{index + 2}",
            severity: drop_off > 35.0 ? 'critical' : 'high',
            drop_off_rate: drop_off
          }
        end
      end
      
      # Check for length issues
      if questions_data.length > 15
        flow_issues << {
          type: 'form_too_long',
          severity: 'medium',
          question_count: questions_data.length,
          recommendation: 'Consider breaking into multiple forms or removing non-essential questions'
        }
      end
      
      # Check for response time issues
      slow_questions = questions_data.select { |q| (q[:avg_response_time] || 0) > 60000 } # > 1 minute
      if slow_questions.any?
        flow_issues << {
          type: 'slow_response_times',
          severity: 'medium',
          affected_questions: slow_questions.length,
          avg_slow_time: slow_questions.sum { |q| q[:avg_response_time] } / slow_questions.length
        }
      end
      
      {
        total_questions: questions_data.length,
        avg_completion_rate: avg_completion_rate.round(2),
        avg_response_time: avg_response_time.round(2),
        total_drop_off: completion_rates.first - completion_rates.last,
        steepest_drop_off: drop_offs.max || 0,
        required_questions_count: required_questions,
        ai_enhanced_questions_count: ai_enhanced_questions,
        flow_issues: flow_issues,
        flow_quality_score: calculate_flow_quality_score(completion_rates, drop_offs, flow_issues),
        avg_quality_score: calculate_average_quality_score(questions_data)
      }
    end
    
    # Calculate drop-off rate for a specific question
    def calculate_drop_off_rate(question_data, form_data)
      current_position = question_data[:position]
      return 0.0 if current_position == 1 # First question has no drop-off
      
      # Find previous question
      previous_question = form_data[:questions_data].find { |q| q[:position] == current_position - 1 }
      return 0.0 unless previous_question
      
      # Calculate drop-off rate
      previous_completion = previous_question[:completion_rate]
      current_completion = question_data[:completion_rate]
      
      [previous_completion - current_completion, 0.0].max
    end
    
    # Analyze answer distribution patterns
    def calculate_answer_distribution(responses_data)
      return {} if responses_data.empty?
      
      # Extract answer values
      answers = responses_data.map { |response| response[0] } # answer_data is first element
      
      # Calculate distribution based on answer types
      distribution = {}
      
      # Count unique answers
      answer_counts = answers.compact.tally
      total_answers = answers.compact.length
      
      return {} if total_answers == 0
      
      # Calculate percentages
      answer_counts.each do |answer, count|
        percentage = (count.to_f / total_answers * 100).round(2)
        distribution[answer.to_s] = {
          count: count,
          percentage: percentage
        }
      end
      
      # Add summary statistics
      distribution[:summary] = {
        total_responses: total_answers,
        unique_answers: answer_counts.keys.length,
        most_common: answer_counts.max_by { |_, count| count }&.first,
        diversity_score: calculate_diversity_score(answer_counts, total_answers)
      }
      
      distribution
    end
    
    # Helper method to calculate diversity score for answers
    def calculate_diversity_score(answer_counts, total_answers)
      return 0.0 if total_answers == 0 || answer_counts.empty?
      
      # Calculate entropy-based diversity score
      entropy = answer_counts.values.sum do |count|
        probability = count.to_f / total_answers
        -probability * Math.log2(probability)
      end
      
      # Normalize to 0-100 scale
      max_entropy = Math.log2(answer_counts.keys.length)
      max_entropy > 0 ? (entropy / max_entropy * 100).round(2) : 0.0
    end
    
    # Categorize response time performance
    def categorize_response_time(avg_time_ms, question_type)
      return 'unknown' if avg_time_ms.nil? || avg_time_ms <= 0
      
      # Define thresholds based on question type (in milliseconds)
      thresholds = case question_type
                   when 'text_short', 'email', 'phone'
                     { fast: 15000, normal: 45000, slow: 90000 } # 15s, 45s, 90s
                   when 'text_long'
                     { fast: 30000, normal: 120000, slow: 300000 } # 30s, 2m, 5m
                   when 'multiple_choice', 'single_choice', 'rating'
                     { fast: 8000, normal: 25000, slow: 60000 } # 8s, 25s, 60s
                   when 'file_upload'
                     { fast: 45000, normal: 180000, slow: 600000 } # 45s, 3m, 10m
                   else
                     { fast: 20000, normal: 60000, slow: 120000 } # 20s, 60s, 2m
                   end
      
      case avg_time_ms
      when 0..thresholds[:fast]
        'fast'
      when thresholds[:fast]..thresholds[:normal]
        'normal'
      when thresholds[:normal]..thresholds[:slow]
        'slow'
      else
        'very_slow'
      end
    end
    
    # Calculate overall performance score for a question
    def calculate_question_performance_score(question_data, drop_off_rate, answer_distribution)
      # Base score from completion rate
      completion_score = question_data[:completion_rate]
      
      # Penalty for high drop-off rate
      drop_off_penalty = [drop_off_rate * 2, 30].min # Max 30 point penalty
      
      # Bonus for good response time
      time_bonus = case categorize_response_time(question_data[:avg_response_time], question_data[:question_type])
                   when 'fast' then 5
                   when 'normal' then 0
                   when 'slow' then -5
                   when 'very_slow' then -15
                   else 0
                   end
      
      # Bonus for answer diversity (indicates engagement)
      diversity_bonus = if answer_distribution.dig(:summary, :diversity_score)
                          [answer_distribution[:summary][:diversity_score] / 10, 10].min
                        else
                          0
                        end
      
      # Calculate final score
      score = completion_score - drop_off_penalty + time_bonus + diversity_bonus
      
      # Ensure score is between 0 and 100
      [[score, 0].max, 100].min.round(2)
    end
    
    # Identify specific issues with a question
    def identify_question_issues(question_data, drop_off_rate, avg_response_time, answer_distribution)
      issues = []
      
      # High drop-off rate
      if drop_off_rate > 15.0
        issues << {
          type: 'high_drop_off',
          severity: drop_off_rate > 30.0 ? 'high' : 'medium',
          description: "#{drop_off_rate.round(1)}% of users abandon the form at this question",
          impact: 'conversion_rate'
        }
      end
      
      # Slow response time
      time_category = categorize_response_time(avg_response_time, question_data[:question_type])
      if time_category == 'slow' || time_category == 'very_slow'
        issues << {
          type: 'response_time',
          severity: time_category == 'very_slow' ? 'high' : 'medium',
          description: "Average response time of #{(avg_response_time / 1000).round(1)}s is #{time_category}",
          impact: 'user_experience'
        }
      end
      
      # Low answer diversity (may indicate confusion or poor options)
      if answer_distribution.dig(:summary, :diversity_score) && answer_distribution[:summary][:diversity_score] < 20
        issues << {
          type: 'low_diversity',
          severity: 'low',
          description: "Low answer diversity may indicate limited options or user confusion",
          impact: 'data_quality'
        }
      end
      
      # Low completion rate for non-first questions
      if question_data[:position] > 1 && question_data[:completion_rate] < 60.0
        issues << {
          type: 'low_completion',
          severity: question_data[:completion_rate] < 40.0 ? 'high' : 'medium',
          description: "Only #{question_data[:completion_rate]}% of users complete this question",
          impact: 'data_collection'
        }
      end
      
      issues
    end
    
    # Identify success factors for high-performing questions
    def identify_question_success_factors(question_data, performance_score, answer_distribution)
      factors = []
      
      # High completion rate
      if question_data[:completion_rate] > 85.0
        factors << {
          type: 'high_completion',
          description: "Excellent completion rate of #{question_data[:completion_rate]}%",
          strength: 'user_engagement'
        }
      end
      
      # Fast response time
      time_category = categorize_response_time(question_data[:avg_response_time], question_data[:question_type])
      if time_category == 'fast'
        factors << {
          type: 'fast_response',
          description: "Users respond quickly (#{(question_data[:avg_response_time] / 1000).round(1)}s average)",
          strength: 'question_clarity'
        }
      end
      
      # Good answer diversity
      if answer_distribution.dig(:summary, :diversity_score) && answer_distribution[:summary][:diversity_score] > 70
        factors << {
          type: 'high_diversity',
          description: "High answer diversity indicates good engagement and clear options",
          strength: 'question_design'
        }
      end
      
      # AI enhancement success
      if question_data[:ai_enhanced] && performance_score > 80.0
        factors << {
          type: 'ai_enhancement',
          description: "AI enhancement contributes to strong performance",
          strength: 'technology_integration'
        }
      end
      
      factors
    end
    
    # Generate specific recommendations for question improvement
    def generate_question_recommendations(question_data, issues, success_factors)
      recommendations = []
      
      issues.each do |issue|
        case issue[:type]
        when 'high_drop_off'
          recommendations << {
            type: 'reduce_drop_off',
            priority: issue[:severity] == 'high' ? 'critical' : 'high',
            action: 'Simplify question wording and reduce cognitive load',
            details: 'Consider breaking complex questions into simpler parts or providing better context'
          }
        when 'response_time'
          recommendations << {
            type: 'improve_response_time',
            priority: 'medium',
            action: 'Optimize question design for faster completion',
            details: 'Consider using choice-based questions, better UI, or clearer instructions'
          }
        when 'low_completion'
          recommendations << {
            type: 'increase_completion',
            priority: 'high',
            action: 'Review question necessity and positioning',
            details: 'Consider making optional, moving earlier in form, or improving motivation'
          }
        end
      end
      
      # Add recommendations based on success factors from other questions
      if success_factors.any? { |f| f[:type] == 'ai_enhancement' } && !question_data[:ai_enhanced]
        recommendations << {
          type: 'add_ai_enhancement',
          priority: 'medium',
          action: 'Consider adding AI enhancement to this question',
          details: 'AI-enhanced questions show better performance in this form'
        }
      end
      
      recommendations
    end
    
    # Calculate overall flow quality score
    def calculate_flow_quality_score(completion_rates, drop_offs, flow_issues)
      return 0.0 if completion_rates.empty?
      
      # Base score from average completion rate
      base_score = completion_rates.sum / completion_rates.length
      
      # Penalty for steep drop-offs
      drop_off_penalty = drop_offs.sum { |drop| drop > 15.0 ? drop * 0.5 : 0 }
      
      # Penalty for flow issues
      issue_penalty = flow_issues.sum do |issue|
        case issue[:severity]
        when 'critical' then 20
        when 'high' then 10
        when 'medium' then 5
        else 2
        end
      end
      
      # Calculate final score
      score = base_score - drop_off_penalty - issue_penalty
      
      # Ensure score is between 0 and 100
      [[score, 0].max, 100].min.round(2)
    end
    
    # Calculate average quality score across all questions
    def calculate_average_quality_score(questions_data)
      return 0.0 if questions_data.empty?
      
      quality_scores = questions_data.map do |question|
        # Simple quality calculation based on completion rate and response count
        completion_weight = question[:completion_rate] || 0
        response_weight = question[:responses_count] > 10 ? 10 : (question[:responses_count] * 5)
        
        (completion_weight + response_weight) / 2
      end
      
      (quality_scores.sum / quality_scores.length).round(2)
    end
    
    def format_performance_analysis_prompt(form_data)
      form = form_data[:form]
      questions_data = form_data[:questions_data]
      
      # Prepare question summary for analysis
      questions_summary = questions_data.map do |q|
        "#{q[:position]}. #{q[:title]} (#{q[:question_type]}) - #{q[:completion_rate]}% completion, #{q[:responses_count]} responses"
      end.join("\n")
      
      # Calculate drop-off points
      drop_off_analysis = questions_data.each_cons(2).map do |current, next_q|
        drop_off = current[:completion_rate] - next_q[:completion_rate]
        "Q#{current[:position]}  Q#{next_q[:position]}: #{drop_off.round(1)}% drop-off"
      end.join("\n")
      
      <<~PROMPT
        Analyze this form's performance and provide comprehensive insights in JSON format.

        **Form Overview:**
        - Name: "#{form.name}"
        - Category: #{form.category}
        - Total Responses: #{form_data[:total_responses]}
        - Completion Rate: #{form_data[:completion_rate]}%
        - Created: #{form_data[:created_at].strftime('%Y-%m-%d')}
        - Last Response: #{form_data[:last_response_at]&.strftime('%Y-%m-%d') || 'Never'}

        **Questions Performance:**
        #{questions_summary}

        **Drop-off Analysis:**
        #{drop_off_analysis}

        **Form Configuration:**
        - AI Enhanced: #{form.ai_enhanced?}
        - Question Count: #{questions_data.length}
        - Required Questions: #{questions_data.count { |q| q[:required] }}

        **Analysis Required:**
        Please analyze this form's performance and return a JSON object with the following structure:

        {
          "overall_performance": {
            "score": 0-100,
            "grade": "A|B|C|D|F",
            "summary": "Brief overall assessment"
          },
          "completion_analysis": {
            "completion_rate_assessment": "excellent|good|average|poor|critical",
            "benchmark_comparison": "above_average|average|below_average",
            "completion_factors": ["factor1", "factor2", "factor3"]
          },
          "user_experience": {
            "flow_quality": 0-100,
            "question_clarity": 0-100,
            "length_appropriateness": 0-100,
            "mobile_friendliness": 0-100
          },
          "behavioral_patterns": {
            "common_drop_off_points": [
              {
                "question_position": 3,
                "drop_off_rate": 25.5,
                "likely_reasons": ["reason1", "reason2"]
              }
            ],
            "engagement_indicators": {
              "high_engagement_questions": [1, 2, 5],
              "low_engagement_questions": [3, 7],
              "avg_time_per_question": 45.2
            }
          },
          "conversion_insights": {
            "strengths": ["strength1", "strength2"],
            "weaknesses": ["weakness1", "weakness2"],
            "quick_wins": ["improvement1", "improvement2"],
            "major_improvements": ["major_change1", "major_change2"]
          },
          "technical_performance": {
            "response_time_analysis": "fast|average|slow",
            "error_indicators": ["indicator1", "indicator2"],
            "data_quality_score": 0-100
          }
        }

        **Guidelines:**
        - Be specific and actionable in your recommendations
        - Consider industry benchmarks for form performance
        - Focus on user experience and conversion optimization
        - Identify both quick wins and strategic improvements
        - Consider the form's purpose and target audience
        - Provide data-driven insights based on the metrics provided
      PROMPT
    end
    
    def format_optimization_plan_prompt(performance_analysis, question_analysis, form_data)
      form = form_data[:form]
      bottlenecks = question_analysis[:bottlenecks] || []
      high_performers = question_analysis[:high_performers] || []
      
      # Prepare bottleneck summary
      bottleneck_summary = bottlenecks.map do |b|
        "- Q#{b[:position]}: #{b[:title]} (#{b[:issue_type]}: #{b[:severity]})"
      end.join("\n")
      
      # Prepare high performer summary
      high_performer_summary = high_performers.map do |hp|
        "- Q#{hp[:position]}: #{hp[:title]} (#{hp[:success_factor]})"
      end.join("\n")
      
      <<~PROMPT
        Create a prioritized optimization plan based on the form analysis results.

        **Form Context:**
        - Name: "#{form.name}"
        - Category: #{form.category}
        - Overall Performance Score: #{performance_analysis.dig('overall_performance', 'score') || 'N/A'}
        - Completion Rate: #{form_data[:completion_rate]}%

        **Performance Analysis Summary:**
        - Overall Grade: #{performance_analysis.dig('overall_performance', 'grade') || 'N/A'}
        - Flow Quality: #{performance_analysis.dig('user_experience', 'flow_quality') || 'N/A'}/100
        - Main Strengths: #{performance_analysis.dig('conversion_insights', 'strengths')&.join(', ') || 'None identified'}
        - Main Weaknesses: #{performance_analysis.dig('conversion_insights', 'weaknesses')&.join(', ') || 'None identified'}

        **Identified Bottlenecks:**
        #{bottleneck_summary.present? ? bottleneck_summary : "No major bottlenecks identified"}

        **High-Performing Elements:**
        #{high_performer_summary.present? ? high_performer_summary : "No standout performers identified"}

        **Quick Wins Identified:**
        #{performance_analysis.dig('conversion_insights', 'quick_wins')&.join(', ') || 'None identified'}

        **Instructions:**
        Create a comprehensive, prioritized optimization plan that addresses the identified issues and leverages successful elements.

        **Response Format (JSON):**
        {
          "executive_summary": {
            "current_state": "Brief assessment of current performance",
            "improvement_potential": "Estimated improvement potential",
            "priority_focus": "Primary area to focus optimization efforts"
          },
          "recommendations": [
            {
              "id": "rec_001",
              "title": "Clear, actionable recommendation title",
              "description": "Detailed explanation of the recommendation",
              "category": "question_optimization|flow_improvement|ux_enhancement|technical_fix",
              "priority": "critical|high|medium|low",
              "effort": "low|medium|high",
              "impact": "low|medium|high",
              "estimated_improvement": "5-15% completion rate increase",
              "implementation_steps": [
                "Step 1: Specific action",
                "Step 2: Specific action"
              ],
              "success_metrics": ["metric1", "metric2"],
              "timeline": "immediate|1-2_weeks|1_month|ongoing"
            }
          ],
          "implementation_roadmap": {
            "phase_1_immediate": ["rec_001", "rec_003"],
            "phase_2_short_term": ["rec_002", "rec_005"],
            "phase_3_long_term": ["rec_004", "rec_006"]
          },
          "success_tracking": {
            "key_metrics": ["completion_rate", "avg_time_per_response", "user_satisfaction"],
            "measurement_plan": "How to track improvement success",
            "review_schedule": "When to review and adjust the plan"
          },
          "risk_assessment": {
            "implementation_risks": ["risk1", "risk2"],
            "mitigation_strategies": ["strategy1", "strategy2"]
          }
        }

        **Guidelines:**
        - Prioritize recommendations by impact vs effort
        - Provide specific, actionable steps
        - Consider the form's business purpose and user context
        - Balance quick wins with strategic improvements
        - Include measurable success criteria
        - Consider technical feasibility and resource requirements
        - Focus on user experience and conversion optimization
      PROMPT
    end
  end
end
</file>

<file path="workflows/forms/budget_adaptation_workflow.rb">
# app/workflows/forms/budget_adaptation_workflow.rb
# frozen_string_literal: true

module Forms
  class BudgetAdaptationWorkflow < ApplicationWorkflow
    # Use the syntax that works with your existing workflow engine
    steps do
      
      step :analyze_budget, uses: :direct_handler, with: {
        handler: ->(context) {
          budget_answer = context.get(:budget_answer).to_s
          budget_amount = budget_answer.gsub(/[^0-9.]/, '').to_f
          Rails.logger.info "Budget analysis - Amount: #{budget_amount}, Is low budget: #{budget_amount > 0 && budget_amount < 1500}"
          { is_low_budget: budget_amount > 0 && budget_amount < 1500, budget_amount: budget_amount }
        }
      }
      
      step :generate_budget_question, uses: :llm,
        if: ->(context) { context.get(:analyze_budget)&.dig(:is_low_budget) },
        model: "gpt-4o-mini",
        temperature: 0.5,
        response_format: { type: "json_object" },
        system_prompt: "You are an AI that only returns valid JSON. Do not add any conversational text or markdown formatting. Your entire response must be a single, valid JSON object.",
        prompt: <<~PROMPT
          A prospect has a budget of {{analyze_budget.budget_amount}} USD.
          Generate an empathetic follow-up question in English to understand their priorities.
          Return a single JSON object with the keys "title", "question_type", and "description".
          The "question_type" must be "text_long".
        PROMPT
      
      step :save_and_stream_question, uses: :direct_handler, with: {
        if: ->(context) { context.get(:generate_budget_question).present? },
        handler: ->(context) {
          begin
            llm_output = context.get(:generate_budget_question)
            form_response_id = context.get(:form_response_id)
            
            Rails.logger.info "Processing LLM output: #{llm_output.inspect}"
            Rails.logger.info "Form response ID: #{form_response_id}"
            
            unless llm_output.is_a?(Hash) && llm_output['title'].present?
              Rails.logger.error "Invalid LLM output: #{llm_output}"
              return { success: false, reason: "Invalid LLM output", llm_output: llm_output }
            end

            form_response = FormResponse.find(form_response_id)
            Rails.logger.info "Found form response: #{form_response.id}, Session: #{form_response.session_id}"
            
            # 1. Save the question to database
            dynamic_question = DynamicQuestion.create!(
              form_response: form_response,
              generated_from_question: form_response.question_responses.last&.form_question,
              question_type: llm_output['question_type'] || 'text_long',
              title: llm_output['title'],
              description: llm_output['description'],
              generation_context: { trigger: 'budget_adaptation', llm_output: llm_output }
            )
            
            Rails.logger.info "Created dynamic question: #{dynamic_question.id}"
            
            # 2. Use Turbo::StreamsChannel.broadcast_append_to
            begin
              Turbo::StreamsChannel.broadcast_append_to(
                form_response, # Pass the FormResponse object
                target: "budget_adaptation_#{form_response.id}",
                partial: "responses/budget_adaptation_question",
                locals: {
                  dynamic_question: dynamic_question,
                  form_response: form_response
                }
              )
              
              Rails.logger.info "Turbo Stream broadcast sent for FormResponse: #{form_response.id}"
            rescue => broadcast_error
              Rails.logger.error "Broadcast failed: #{broadcast_error.message}"
              # Don't fail the whole workflow if broadcast fails
            end
            
            { success: true, streamed: true, dynamic_question_id: dynamic_question.id }
            
          rescue => error
            Rails.logger.error "Error in save_and_stream_question: #{error.message}"
            Rails.logger.error error.backtrace.first(5).join("\n")
            { success: false, error: error.message }
          end
        }
      }
    end

    # Add a run method that works with your job
    def run(context_data = {})
      Rails.logger.info "Running BudgetAdaptationWorkflow with context: #{context_data.keys}"
      
      begin
        # Set context
        context_data.each do |key, value|
          context.set(key, value)
        end
        
        # Execute the workflow using whatever method your engine provides
        if respond_to?(:execute)
          result = execute
        elsif respond_to?(:call)
          result = call
        else
          # Try to run the steps manually
          result = run_steps_manually(context_data)
        end
        
        Rails.logger.info "Workflow execution completed with result: #{result.inspect}"
        result
        
      rescue => error
        Rails.logger.error "Workflow execution failed: #{error.message}"
        { success: false, error: error.message }
      end
    end

    private

    def run_steps_manually(context_data)
      Rails.logger.info "Running steps manually"
      
      # Step 1: Analyze budget
      analyze_result = analyze_budget_step(context_data[:budget_answer])
      return analyze_result unless analyze_result[:is_low_budget]
      
      Rails.logger.info "Budget is low, generating question"
      
      # Step 2: Generate question
      question_result = generate_question_step(analyze_result[:budget_amount])
      return { success: false, reason: "Question generation failed" } unless question_result
      
      # Step 3: Save and stream
      save_result = save_and_stream_step(context_data[:form_response_id], question_result)
      
      save_result
    end

    def analyze_budget_step(budget_answer)
      budget_amount = budget_answer.to_s.gsub(/[^0-9.]/, '').to_f
      is_low_budget = budget_amount > 0 && budget_amount < 1500
      
      Rails.logger.info "Budget analysis - Amount: #{budget_amount}, Is low budget: #{is_low_budget}"
      
      { is_low_budget: is_low_budget, budget_amount: budget_amount }
    end

    def generate_question_step(budget_amount)
      # Simple fallback question generation
      {
        'title' => "Help us understand your priorities",
        'question_type' => 'text_long',
        'description' => "I understand you're working with a budget of $#{budget_amount}. Could you share what your main priorities are when allocating this budget? This will help us better understand how we can work together to achieve your goals."
      }
    end

    def save_and_stream_step(form_response_id, question_data)
      form_response = FormResponse.find(form_response_id)
      
      # Create dynamic question
      dynamic_question = DynamicQuestion.create!(
        form_response: form_response,
        generated_from_question: form_response.question_responses.last&.form_question,
        question_type: question_data['question_type'],
        title: question_data['title'],
        description: question_data['description'],
        generation_context: { trigger: 'budget_adaptation', manual: true }
      )
      
      Rails.logger.info "Created dynamic question: #{dynamic_question.id}"
      
      # Broadcast
      begin
        Turbo::StreamsChannel.broadcast_append_to(
          form_response,
          target: "budget_adaptation_#{form_response.id}",
          partial: "responses/budget_adaptation_question",
          locals: {
            dynamic_question: dynamic_question,
            form_response: form_response
          }
        )
        
        Rails.logger.info "Manual Turbo Stream broadcast sent"
      rescue => error
        Rails.logger.error "Manual broadcast failed: #{error.message}"
      end
      
      { success: true, dynamic_question_id: dynamic_question.id }
    end
  end
end
</file>

<file path="workflows/forms/dynamic_question_workflow.rb">
# frozen_string_literal: true

module Forms
  class DynamicQuestionWorkflow < ApplicationWorkflow
    workflow do
      # Step 1: Validate context and determine if dynamic question should be generated
      validate :validate_generation_context do
        input :form_response_id, :source_question_id, :source_answer_data, :generation_trigger
        description "Validate context and determine if dynamic question generation is appropriate"
        
        process do |response_id, question_id, answer_data, trigger = 'ai_analysis'|
          Rails.logger.info "Validating dynamic question generation context for response_id: #{response_id}, question_id: #{question_id}"
          
          # Validate required inputs
          validate_required_inputs(context, :form_response_id, :source_question_id, :source_answer_data)
          
          # Load and validate form response
          form_response = FormResponse.find(response_id)
          unless form_response
            return format_error_result("FormResponse not found", 'not_found_error', { response_id: response_id })
          end
          
          # Load and validate source question
          source_question = FormQuestion.find(question_id)
          unless source_question
            return format_error_result("FormQuestion not found", 'not_found_error', { question_id: question_id })
          end
          
          # Verify question belongs to the form
          unless source_question.form_id == form_response.form_id
            return format_error_result("Question does not belong to this form", 'validation_error')
          end
          
          # Check if form and question support dynamic questions
          form = source_question.form
          unless form.ai_enhanced?
            return format_error_result("Form does not have AI features enabled", 'configuration_error')
          end
          
          unless source_question.generates_followups?
            return format_error_result("Source question is not configured for follow-ups", 'configuration_error')
          end
          
          # Check user's AI capabilities
          user = form.user
          unless user.can_use_ai_features?
            return format_error_result("User does not have AI features available", 'permission_error')
          end
          
          # Check if we've already generated too many dynamic questions for this response
          existing_dynamic_questions = form_response.dynamic_questions.count
          max_dynamic_questions = form.ai_configuration&.dig('max_dynamic_questions') || 3
          
          if existing_dynamic_questions >= max_dynamic_questions
            return format_error_result("Maximum dynamic questions limit reached", 'limit_error', {
              existing_count: existing_dynamic_questions,
              max_allowed: max_dynamic_questions
            })
          end
          
          # Prepare context data for generation
          context_data = {
            form_response: form_response,
            source_question: source_question,
            form: form,
            user: user,
            answer_data: answer_data,
            generation_trigger: trigger,
            existing_dynamic_count: existing_dynamic_questions,
            form_context: get_form_context(form.id),
            response_context: get_response_context(response_id),
            previous_responses: form_response.answers_hash
          }
          
          Rails.logger.info "Dynamic question generation context validated successfully"
          
          format_success_result({
            valid: true,
            context_data: context_data,
            can_generate: true,
            estimated_cost: 0.025 # Estimated cost for dynamic question generation
          })
        end
      end      

      # Step 2: Analyze source answer to determine follow-up strategy
      task :analyze_followup_strategy do
        input :validate_generation_context
        description "Analyze the source answer to determine the best follow-up strategy"
        
        process do |validation_result|
          Rails.logger.info "Analyzing follow-up strategy for dynamic question generation"
          
          context_data = validation_result[:context_data]
          source_question = context_data[:source_question]
          answer_data = context_data[:answer_data]
          previous_responses = context_data[:previous_responses]
          
          # Analyze the answer to determine follow-up strategy
          strategy = determine_followup_strategy(source_question, answer_data, previous_responses)
          
          # Calculate priority and confidence for generation
          generation_priority = calculate_generation_priority(source_question, answer_data, strategy)
          
          # Determine question type for the follow-up
          suggested_question_type = suggest_question_type(source_question, answer_data, strategy)
          
          # Check if strategy suggests generation should proceed
          unless strategy[:should_generate]
            return format_success_result({
              should_generate: false,
              reason: strategy[:skip_reason],
              strategy: strategy
            })
          end
          
          Rails.logger.info "Follow-up strategy determined: #{strategy[:type]} with priority #{generation_priority}"
          
          format_success_result({
            should_generate: true,
            strategy: strategy,
            generation_priority: generation_priority,
            suggested_question_type: suggested_question_type,
            context_data: context_data
          })
        end
      end
      
      # Step 3: Generate dynamic question using LLM
      llm :generate_dynamic_question do
        input :analyze_followup_strategy, :validate_generation_context
        run_if do |context|
          strategy_result = context.get(:analyze_followup_strategy)
          validation_result = context.get(:validate_generation_context)
          
          # Check if previous steps were successful
          return false unless validation_result&.dig(:valid) && strategy_result&.dig(:should_generate)
          
          # Check AI budget
          estimated_cost = validation_result[:estimated_cost]
          return false unless ai_budget_available?(context, estimated_cost)
          
          Rails.logger.info "LLM generation conditions met for dynamic question"
          true
        end
        
        model { |ctx| 
          validation_result = ctx.get(:validate_generation_context)
          validation_result[:context_data][:form].ai_model || 'gpt-4o-mini' 
        }
        temperature 0.7
        max_tokens 400
        response_format :json
        
        system_prompt "You are an expert at generating contextual follow-up questions that feel natural and gather valuable information. Create questions that enhance the conversation flow and provide actionable insights."
        
        prompt do |context|
          validation_result = context.get(:validate_generation_context)
          strategy_result = context.get(:analyze_followup_strategy)
          
          context_data = validation_result[:context_data]
          strategy = strategy_result[:strategy]
          suggested_type = strategy_result[:suggested_question_type]
          
          format_dynamic_question_prompt(context_data, strategy, suggested_type)
        end
      end   
   
      # Step 4: Create and persist dynamic question record
      task :create_dynamic_question_record do
        input :generate_dynamic_question, :validate_generation_context, :analyze_followup_strategy
        run_when :generate_dynamic_question
        description "Create and persist the dynamic question record in the database"
        
        process do |llm_result, validation_result, strategy_result|
          Rails.logger.info "Creating dynamic question record from LLM generation"
          
          context_data = validation_result[:context_data]
          form_response = context_data[:form_response]
          source_question = context_data[:source_question]
          strategy = strategy_result[:strategy]
          
          # Track AI usage
          ai_cost = validation_result[:estimated_cost]
          track_ai_usage(context, ai_cost, 'dynamic_question_generation')
          
          # Execute database operation safely
          result = safe_db_operation do
            # Extract question data from LLM response
            question_data = llm_result.dig('question') || {}
            
            # Validate LLM response structure
            unless question_data['title'].present?
              raise ArgumentError, "LLM did not provide a valid question title"
            end
            
            # Create dynamic question record
            dynamic_question = DynamicQuestion.create!(
              form_response: form_response,
              generated_from_question: source_question,
              question_type: question_data['question_type'] || strategy_result[:suggested_question_type] || 'text_short',
              title: question_data['title'],
              description: question_data['description'],
              configuration: question_data['configuration'] || {},
              generation_context: {
                source_question_id: source_question.id,
                source_answer: context_data[:answer_data],
                strategy_type: strategy[:type],
                strategy_reasoning: strategy[:reasoning],
                llm_reasoning: llm_result['reasoning'],
                confidence: llm_result['confidence'],
                priority: strategy_result[:generation_priority],
                generation_trigger: context_data[:generation_trigger],
                generated_at: Time.current.iso8601,
                form_context_snapshot: context_data[:previous_responses]
              },
              generation_prompt: "AI-generated follow-up based on #{strategy[:type]} strategy",
              generation_model: context_data[:form].ai_model || 'gpt-4o-mini',
              ai_confidence: llm_result['confidence'] || 0.8
            )
            
            # Update user's AI credit usage
            user = context_data[:user]
            user.consume_ai_credit(ai_cost) if user.respond_to?(:consume_ai_credit)
            
            {
              dynamic_question: dynamic_question,
              llm_result: llm_result,
              ai_cost: ai_cost,
              strategy: strategy
            }
          end
          
          if result[:error]
            Rails.logger.error "Failed to create dynamic question: #{result[:message]}"
            return format_error_result("Failed to create dynamic question", result[:type], result)
          end
          
          Rails.logger.info "Successfully created dynamic question with ID: #{result[:dynamic_question].id}"
          
          format_success_result({
            dynamic_question_id: result[:dynamic_question].id,
            dynamic_question: result[:dynamic_question],
            llm_result: result[:llm_result],
            ai_cost: result[:ai_cost],
            strategy: result[:strategy],
            created_at: Time.current.iso8601
          })
        end
      end
      
      # Step 5: Update form UI with new dynamic question
      stream :update_form_with_dynamic_question do
        input :create_dynamic_question_record, :validate_generation_context
        description "Update the form UI in real-time with the new dynamic question"
        
        target { |ctx| 
          validation_result = ctx.get(:validate_generation_context)
          form = validation_result[:context_data][:form]
          "form_#{form.share_token}_dynamic_questions" 
        }
        turbo_action :append
        partial "responses/dynamic_question"
        
        locals do |ctx|
          validation_result = ctx.get(:validate_generation_context)
          creation_result = ctx.get(:create_dynamic_question_record)
          
          {
            dynamic_question: creation_result[:dynamic_question],
            form_response: validation_result[:context_data][:form_response],
            form: validation_result[:context_data][:form],
            source_question: validation_result[:context_data][:source_question],
            generation_metadata: {
              strategy: creation_result[:strategy],
              ai_confidence: creation_result[:dynamic_question].ai_confidence,
              created_at: creation_result[:created_at]
            }
          }
        end
      end
    end    
 
   private
    
    # Determine the best follow-up strategy based on the source question and answer
    def determine_followup_strategy(source_question, answer_data, previous_responses)
      answer_value = answer_data.is_a?(Hash) ? answer_data['value'] : answer_data
      
      # Default strategy
      strategy = {
        type: 'general_followup',
        should_generate: true,
        reasoning: 'Standard follow-up generation',
        confidence: 0.6
      }
      
      # Analyze based on question type
      case source_question.question_type
      when 'rating', 'scale', 'nps_score'
        rating_value = answer_value.to_f
        max_rating = source_question.question_config&.dig('max_value') || 5
        
        if rating_value <= (max_rating * 0.4) # Low rating (40% or below)
          strategy = {
            type: 'low_rating_investigation',
            should_generate: true,
            reasoning: "Low rating (#{rating_value}/#{max_rating}) suggests issues that need investigation",
            confidence: 0.9,
            focus: 'problem_identification'
          }
        elsif rating_value >= (max_rating * 0.8) # High rating (80% or above)
          strategy = {
            type: 'high_rating_amplification',
            should_generate: true,
            reasoning: "High rating (#{rating_value}/#{max_rating}) presents opportunity to understand success factors",
            confidence: 0.7,
            focus: 'success_factors'
          }
        else
          strategy = {
            type: 'neutral_rating_clarification',
            should_generate: true,
            reasoning: "Neutral rating suggests room for improvement understanding",
            confidence: 0.6,
            focus: 'improvement_opportunities'
          }
        end
        
      when 'multiple_choice', 'single_choice'
        # Check if "Other" was selected or if answer suggests elaboration
        if answer_value.to_s.downcase.include?('other')
          strategy = {
            type: 'other_option_elaboration',
            should_generate: true,
            reasoning: "User selected 'Other' option, needs elaboration",
            confidence: 0.95,
            focus: 'specification'
          }
        elsif source_question.question_config&.dig('allow_elaboration')
          strategy = {
            type: 'choice_elaboration',
            should_generate: true,
            reasoning: "Choice question configured for elaboration",
            confidence: 0.7,
            focus: 'reasoning'
          }
        else
          # Check if this choice typically leads to follow-ups
          strategy = analyze_choice_patterns(source_question, answer_value, previous_responses)
        end
        
      when 'text_short', 'text_long'
        text_analysis = analyze_text_answer(answer_value.to_s)
        
        if text_analysis[:suggests_issues]
          strategy = {
            type: 'issue_investigation',
            should_generate: true,
            reasoning: "Text response suggests issues or concerns that need follow-up",
            confidence: 0.8,
            focus: 'problem_solving'
          }
        elsif text_analysis[:suggests_enthusiasm]
          strategy = {
            type: 'enthusiasm_exploration',
            should_generate: true,
            reasoning: "Positive response suggests opportunity for deeper engagement",
            confidence: 0.7,
            focus: 'opportunity_exploration'
          }
        elsif text_analysis[:too_brief]
          strategy = {
            type: 'elaboration_request',
            should_generate: true,
            reasoning: "Brief response suggests more information could be gathered",
            confidence: 0.6,
            focus: 'detail_gathering'
          }
        else
          strategy = {
            type: 'contextual_followup',
            should_generate: true,
            reasoning: "Standard contextual follow-up based on text content",
            confidence: 0.5,
            focus: 'context_building'
          }
        end
        
      when 'yes_no', 'boolean'
        bool_value = ['yes', 'true', '1', 'y'].include?(answer_value.to_s.downcase)
        
        if bool_value
          strategy = {
            type: 'positive_response_exploration',
            should_generate: true,
            reasoning: "Positive response opens opportunity for deeper exploration",
            confidence: 0.8,
            focus: 'elaboration'
          }
        else
          strategy = {
            type: 'negative_response_investigation',
            should_generate: true,
            reasoning: "Negative response may indicate barriers or issues to explore",
            confidence: 0.8,
            focus: 'barrier_identification'
          }
        end
        
      else
        # For other question types, use general strategy
        strategy = {
          type: 'general_followup',
          should_generate: true,
          reasoning: "General follow-up for #{source_question.question_type} question type",
          confidence: 0.5,
          focus: 'general_information'
        }
      end
      
      # Check if we should skip generation based on form context
      if should_skip_generation?(source_question, answer_data, previous_responses)
        strategy[:should_generate] = false
        strategy[:skip_reason] = determine_skip_reason(source_question, answer_data, previous_responses)
      end
      
      strategy
    end
    
    # Calculate priority for generating this dynamic question
    def calculate_generation_priority(source_question, answer_data, strategy)
      base_priority = case strategy[:type]
                      when 'low_rating_investigation', 'issue_investigation', 'other_option_elaboration'
                        'high'
                      when 'high_rating_amplification', 'negative_response_investigation', 'positive_response_exploration'
                        'medium'
                      else
                        'low'
                      end
      
      # Adjust based on question position (earlier questions get higher priority)
      if source_question.position <= 3
        base_priority = upgrade_priority(base_priority)
      end
      
      # Adjust based on strategy confidence
      if strategy[:confidence] >= 0.8
        base_priority = upgrade_priority(base_priority)
      elsif strategy[:confidence] <= 0.4
        base_priority = downgrade_priority(base_priority)
      end
      
      base_priority
    end
    
    # Suggest the most appropriate question type for the follow-up
    def suggest_question_type(source_question, answer_data, strategy)
      case strategy[:focus]
      when 'problem_identification', 'barrier_identification', 'issue_investigation'
        'text_short' # Allow open-ended explanation of problems
      when 'success_factors', 'opportunity_exploration'
        'multiple_choice' # Provide structured options for success factors
      when 'specification', 'elaboration', 'detail_gathering'
        'text_long' # Allow detailed explanation
      when 'reasoning'
        'text_short' # Brief explanation of reasoning
      when 'improvement_opportunities'
        'rating' # Rate specific improvement areas
      else
        'text_short' # Default to short text for general follow-ups
      end
    end  
  
    # Analyze choice patterns to determine follow-up strategy
    def analyze_choice_patterns(source_question, answer_value, previous_responses)
      # This could be enhanced with ML in the future
      # For now, use rule-based analysis
      
      choice_config = source_question.question_config || {}
      options = choice_config['options'] || []
      
      # Find the selected option details
      selected_option = options.find { |opt| opt['value'] == answer_value || opt['label'] == answer_value }
      
      if selected_option&.dig('triggers_followup')
        {
          type: 'configured_choice_followup',
          should_generate: true,
          reasoning: "Choice option is configured to trigger follow-up questions",
          confidence: 0.8,
          focus: 'choice_elaboration'
        }
      else
        {
          type: 'standard_choice_followup',
          should_generate: false,
          reasoning: "Choice does not typically require follow-up",
          confidence: 0.3,
          skip_reason: 'choice_sufficient'
        }
      end
    end
    
    # Analyze text answers for sentiment and content indicators
    def analyze_text_answer(text)
      return { suggests_issues: false, suggests_enthusiasm: false, too_brief: true } if text.blank?
      
      text_lower = text.downcase
      word_count = text.split.length
      
      # Issue indicators
      issue_keywords = [
        'problem', 'issue', 'difficult', 'hard', 'confusing', 'unclear', 'frustrated',
        'annoying', 'slow', 'broken', 'error', 'fail', 'wrong', 'bad', 'terrible',
        'hate', 'dislike', 'disappointed', 'concern', 'worry', 'trouble'
      ]
      
      # Enthusiasm indicators
      enthusiasm_keywords = [
        'love', 'great', 'excellent', 'amazing', 'fantastic', 'wonderful', 'perfect',
        'awesome', 'brilliant', 'outstanding', 'impressed', 'excited', 'thrilled',
        'delighted', 'satisfied', 'happy', 'pleased', 'enjoy', 'like'
      ]
      
      suggests_issues = issue_keywords.any? { |keyword| text_lower.include?(keyword) }
      suggests_enthusiasm = enthusiasm_keywords.any? { |keyword| text_lower.include?(keyword) }
      too_brief = word_count < 3
      
      {
        suggests_issues: suggests_issues,
        suggests_enthusiasm: suggests_enthusiasm,
        too_brief: too_brief,
        word_count: word_count,
        sentiment_indicators: {
          negative_keywords: issue_keywords.select { |k| text_lower.include?(k) },
          positive_keywords: enthusiasm_keywords.select { |k| text_lower.include?(k) }
        }
      }
    end
    
    # Determine if generation should be skipped
    def should_skip_generation?(source_question, answer_data, previous_responses)
      # Skip if too many questions already answered
      return true if previous_responses.keys.length > 10
      
      # Skip if answer is too brief or empty
      answer_value = answer_data.is_a?(Hash) ? answer_data['value'] : answer_data
      return true if answer_value.blank? || answer_value.to_s.length < 2
      
      # Skip if this is a sensitive question type that shouldn't have follow-ups
      sensitive_types = ['email', 'phone', 'password', 'payment']
      return true if sensitive_types.include?(source_question.question_type)
      
      false
    end
    
    # Determine the reason for skipping generation
    def determine_skip_reason(source_question, answer_data, previous_responses)
      answer_value = answer_data.is_a?(Hash) ? answer_data['value'] : answer_data
      
      if previous_responses.keys.length > 10
        'form_too_long'
      elsif answer_value.blank?
        'empty_answer'
      elsif answer_value.to_s.length < 2
        'insufficient_content'
      elsif ['email', 'phone', 'password', 'payment'].include?(source_question.question_type)
        'sensitive_question_type'
      else
        'general_skip'
      end
    end
    
    # Helper methods for priority adjustment
    def upgrade_priority(current_priority)
      case current_priority
      when 'low' then 'medium'
      when 'medium' then 'high'
      else current_priority
      end
    end
    
    def downgrade_priority(current_priority)
      case current_priority
      when 'high' then 'medium'
      when 'medium' then 'low'
      else current_priority
      end
    end    

    # Format the LLM prompt for dynamic question generation
    def format_dynamic_question_prompt(context_data, strategy, suggested_question_type)
      form = context_data[:form]
      source_question = context_data[:source_question]
      answer_data = context_data[:answer_data]
      previous_responses = context_data[:previous_responses]
      form_response = context_data[:form_response]
      
      answer_value = answer_data.is_a?(Hash) ? answer_data['value'] : answer_data
      
      <<~PROMPT
        Generate a contextual follow-up question based on the user's response to enhance data collection and user engagement.

        **Form Context:**
        - Form Name: "#{form.name}"
        - Form Category: #{form.category || 'General'}
        - Form Purpose: #{form.form_settings&.dig('purpose') || 'Information collection'}
        - Total Questions in Form: #{form.form_questions.count}
        - AI Enhancement Level: #{form.ai_configuration&.dig('enhancement_level') || 'standard'}

        **Original Question Context:**
        - Question: "#{source_question.title}"
        - Type: #{source_question.question_type}
        - Position: #{source_question.position} of #{form.form_questions.count}
        - Required: #{source_question.required? ? 'Yes' : 'No'}
        - Description: #{source_question.description || 'None provided'}

        **User's Response:**
        "#{answer_value}"

        **Follow-up Strategy:**
        - Strategy Type: #{strategy[:type]}
        - Focus Area: #{strategy[:focus]}
        - Reasoning: #{strategy[:reasoning]}
        - Confidence Level: #{strategy[:confidence]}

        **Previous Form Responses (for context):**
        #{format_previous_responses_for_prompt(previous_responses)}

        **Response Progress:**
        - Questions Answered: #{previous_responses.keys.length}
        - Form Completion: #{form_response.progress_percentage}%
        - Session Duration: #{calculate_session_duration(form_response)}

        **Generation Guidelines:**
        1. **Natural Flow**: The follow-up should feel like a natural continuation of the conversation
        2. **Value Addition**: Only generate if it will gather genuinely useful information
        3. **User Experience**: Keep the question engaging and not burdensome
        4. **Contextual Relevance**: Build directly on their specific response
        5. **Strategic Focus**: Align with the #{strategy[:focus]} focus area

        **Question Type Guidance:**
        - Suggested Type: #{suggested_question_type}
        - Consider: #{get_question_type_guidance(suggested_question_type)}

        **Response Format (JSON):**
        {
          "question": {
            "title": "The follow-up question text (clear, conversational, specific)",
            "description": "Optional helpful context or instructions for the user",
            "question_type": "#{suggested_question_type}",
            "configuration": {
              #{get_configuration_template(suggested_question_type)}
            },
            "required": false,
            "placeholder": "Optional placeholder text for input fields"
          },
          "reasoning": "Detailed explanation of why this follow-up adds value and how it builds on their response",
          "confidence": 0.0-1.0,
          "priority": "high|medium|low",
          "expected_insights": [
            "List of specific insights this question could reveal"
          ],
          "conversation_flow": "Brief description of how this maintains natural conversation flow"
        }

        **Quality Standards:**
        - Question must be directly related to their response: "#{answer_value}"
        - Avoid generic or obvious questions
        - Focus on gathering actionable insights
        - Maintain conversational tone
        - Consider user's emotional state and engagement level
        - Ensure the question feels valuable, not intrusive

        **Specific Instructions for #{strategy[:type]}:**
        #{get_strategy_specific_instructions(strategy)}

        Generate a follow-up question that enhances the form's value while respecting the user's time and engagement.
      PROMPT
    end
    
    # Format previous responses for the prompt context
    def format_previous_responses_for_prompt(previous_responses)
      return "No previous responses" if previous_responses.empty?
      
      formatted = previous_responses.map do |question_title, answer|
        "- #{question_title}: #{answer}"
      end.join("\n")
      
      # Limit to last 5 responses to keep prompt manageable
      lines = formatted.split("\n")
      if lines.length > 5
        recent_lines = lines.last(5)
        "#{recent_lines.join("\n")}\n(... #{lines.length - 5} earlier responses)"
      else
        formatted
      end
    end
    
    # Calculate session duration for context
    def calculate_session_duration(form_response)
      return "Unknown" unless form_response.created_at
      
      duration_seconds = Time.current - form_response.created_at
      
      if duration_seconds < 60
        "#{duration_seconds.to_i} seconds"
      elsif duration_seconds < 3600
        "#{(duration_seconds / 60).to_i} minutes"
      else
        "#{(duration_seconds / 3600).round(1)} hours"
      end
    end
    
    # Get question type specific guidance
    def get_question_type_guidance(question_type)
      case question_type
      when 'text_short'
        'Brief, focused responses (1-2 sentences). Good for specific details or clarifications.'
      when 'text_long'
        'Detailed explanations or stories. Use when you need comprehensive information.'
      when 'multiple_choice'
        'Structured options when you can predict likely responses. Faster for users.'
      when 'single_choice'
        'One selection from predefined options. Good for categorization.'
      when 'rating'
        'Numerical scale for measuring satisfaction, likelihood, or intensity.'
      when 'yes_no'
        'Simple binary choice. Use for clear yes/no decisions.'
      when 'scale'
        'Numerical scale (0-10) for more granular measurement than rating.'
      else
        'Choose the type that best matches the expected response format.'
      end
    end
    
    # Get configuration template for question type
    def get_configuration_template(question_type)
      case question_type
      when 'text_short'
        '"max_length": 255'
      when 'text_long'
        '"max_length": 2000'
      when 'multiple_choice'
        '"options": [{"label": "Option 1", "value": "option1"}, {"label": "Option 2", "value": "option2"}], "allow_multiple": false'
      when 'single_choice'
        '"options": [{"label": "Option 1", "value": "option1"}, {"label": "Option 2", "value": "option2"}]'
      when 'rating'
        '"min_value": 1, "max_value": 5, "labels": {"min": "Poor", "max": "Excellent"}'
      when 'scale'
        '"min_value": 0, "max_value": 10, "labels": {"min": "Not at all", "max": "Extremely"}'
      when 'yes_no'
        '"true_label": "Yes", "false_label": "No"'
      else
        '// Configuration specific to question type'
      end
    end
    
    # Get strategy-specific instructions
    def get_strategy_specific_instructions(strategy)
      case strategy[:type]
      when 'low_rating_investigation'
        "Focus on understanding the specific issues behind the low rating. Ask about particular pain points, what could be improved, or what caused the dissatisfaction. Be empathetic and solution-oriented."
        
      when 'high_rating_amplification'
        "Explore what made the experience positive. Ask about specific features, moments, or aspects they valued most. This helps identify success factors and potential testimonial content."
        
      when 'other_option_elaboration'
        "The user selected 'Other' - ask them to specify what they meant. Keep it open-ended but focused on getting the specific information that wasn't covered by the provided options."
        
      when 'issue_investigation'
        "Their response suggests problems or concerns. Ask for specific details about the issues, their impact, or potential solutions. Be supportive and focused on problem-solving."
        
      when 'enthusiasm_exploration'
        "They seem positive or excited. Ask what specifically they're enthusiastic about, or how they envision using/benefiting from what you're discussing."
        
      when 'elaboration_request'
        "Their response was brief. Ask for more details, examples, or context. Make it feel like you're genuinely interested in their perspective, not just collecting data."
        
      when 'positive_response_exploration'
        "They answered positively. Dig deeper into their experience, preferences, or how this positive aspect could be enhanced or expanded."
        
      when 'negative_response_investigation'
        "They answered negatively. Understand the barriers, concerns, or reasons behind their response. Focus on what might change their perspective."
        
      else
        "Generate a natural follow-up that builds on their specific response and gathers valuable additional information."
      end
    end
  end
end
</file>

<file path="workflows/forms/enrichment_workflow.rb">
# frozen_string_literal: true

module Forms
  # Workflow for enriching form response data with external company information
  # Uses email domain to fetch company data and enhance lead profiles
  class EnrichmentWorkflow < ApplicationWorkflow
    
    workflow do
      # Validate that the form belongs to a premium user
      validate :check_premium_access do
        input :form_response_id
        process do |id|
          form_response = FormResponse.find(id)
          form = form_response.form
          
          # Check if user has premium access for AI features
          unless FormPolicy.new(form.user, form).ai_features?
            raise Pundit::NotAuthorizedError, "AI enrichment requires premium subscription"
          end
          
          email = form_response.get_answer('email')
          domain = email&.split('@')&.last
          
          unless domain.present?
            raise ArgumentError, "Invalid email address provided"
          end
          
          { domain: domain, form_response_id: id }
        end
      end

      # Fetch company information from external API
      task :fetch_company_info do
        input :domain
        output :company_data
        process do |domain|
          begin
            company_info = fetch_company_data(domain)
            company_info || {}
          rescue StandardError => e
            Rails.logger.error "Failed to fetch company data for #{domain}: #{e.message}"
            {} # Return empty hash on failure
          end
        end
      end

      # Process and structure the company data
      task :process_company_data do
        input :company_data, :form_response_id
        output :processed_data
        process do |company_data, form_response_id|
          next {} if company_data.empty?
          
          processed = {
            company_name: company_data['name'],
            industry: company_data['industry'],
            company_size: company_data['employees'],
            location: company_data['location'],
            website: company_data['domain'],
            description: company_data['description'],
            founded_year: company_data['founded'],
            technologies: company_data['tech'] || [],
            social_profiles: company_data['social_profiles'] || {}
          }
          
          # Filter out nil/empty values
          processed.compact.reject { |_, v| v.blank? }
        end
      end

      # Update form response with enrichment data
      task :update_response_with_enrichment do
        input :processed_data, :form_response_id
        process do |processed_data, form_response_id|
          next if processed_data.empty?
          
          form_response = FormResponse.find(form_response_id)
          
          # Store enrichment data
          form_response.update!(
            enrichment_data: processed_data,
            enriched_at: Time.current
          )
          
          # Also store as metadata for easy access
          current_metadata = form_response.metadata || {}
          current_metadata[:company_enrichment] = processed_data
          form_response.update!(metadata: current_metadata)
          
          { success: true, enrichment_data: processed_data }
        end
      end

      # Update UI with enrichment results via Turbo Streams
      stream :update_ui_with_enrichment do
        target { |ctx| "enrichment_#{ctx.get(:form_response_id)}" }
        partial "responses/enrichment_data"
        locals { |ctx| 
          { 
            company_data: ctx.get(:processed_data),
            form_response_id: ctx.get(:form_response_id)
          } 
        }
      end
    end

    private

    # Fetch company data from external enrichment service
    # In a real implementation, this would call Clearbit, FullContact, or similar service
    def fetch_company_data(domain)
      # Mock implementation - replace with actual API call
      Rails.logger.info "Fetching company data for domain: #{domain}"
      
      # This is a placeholder - in production, integrate with:
      # - Clearbit Enrichment API
      # - FullContact Company API
      # - Hunter.io Company API
      # - Or similar service
      
      mock_data = {
        'name' => domain.split('.').first.capitalize + ' Inc.',
        'industry' => 'Technology',
        'employees' => '51-200',
        'location' => 'San Francisco, CA',
        'domain' => domain,
        'description' => "A leading technology company in the #{domain.split('.').first} space.",
        'founded' => 2015,
        'tech' => ['JavaScript', 'Ruby', 'AWS'],
        'social_profiles' => {
          'linkedin' => "https://linkedin.com/company/#{domain.split('.').first}",
          'twitter' => "https://twitter.com/#{domain.split('.').first}"
        }
      }
      
      # Return mock data for development
      mock_data
    end
  end
end
</file>

<file path="workflows/forms/lead_scoring_workflow.rb">
# frozen_string_literal: true

module Forms
  class LeadScoringWorkflow < ApplicationWorkflow
    workflow do
      timeout 180
      
      # Step 1: Collect and validate response data
      task :collect_response_data do
        input :form_response_id
        description "Collect all response data for lead scoring analysis"
        
        process do |response_id|
          Rails.logger.info "Collecting response data for lead scoring: response_id=#{response_id}"
          
          validate_required_inputs(context, :form_response_id)
          
          result = safe_db_operation do
            form_response = FormResponse.includes(
              :form,
              :question_responses,
              :dynamic_questions,
              form: :user,
              question_responses: :form_question
            ).find(response_id)
            
            unless form_response.completed?
              raise ArgumentError, "Form response #{response_id} must be completed for lead scoring"
            end
            
            # Verify user has AI capabilities
            form = form_response.form
            unless form.user.can_use_ai_features?
              raise Pundit::NotAuthorizedError, "User does not have AI features available"
            end
            
            # Collect all response data
            answers_hash = form_response.answers_hash
            ai_analysis_data = form_response.ai_analysis_results || {}
            
            # Collect enriched data
            enriched_data = form_response.enriched_data || {}
            
            # Collect dynamic question responses
            dynamic_responses = form_response.dynamic_questions.includes(:responses).map do |dq|
              {
                question: dq.title,
                response: dq.responses.first&.answer_data,
                generation_context: dq.generation_context
              }
            end
            
            completion_time = nil
            if form_response.started_at && form_response.completed_at
              completion_time = ((form_response.completed_at - form_response.started_at) / 1.minute).round(2)
            end
            
            {
              form_response: form_response,
              form: form,
              user: form.user,
              answers: answers_hash,
              ai_analysis: ai_analysis_data,
              enriched_data: enriched_data,
              dynamic_responses: dynamic_responses,
              completion_time: completion_time,
              response_metadata: {
                user_agent: form_response.user_agent,
                referrer: form_response.referrer_url,
                ip_address: form_response.ip_address,
                submitted_at: form_response.created_at,
                completed_at: form_response.completed_at
              }
            }
          end
          
          if result[:error]
            Rails.logger.error "Failed to collect response data: #{result[:message]}"
            return format_error_result("Failed to collect response data", result[:type], result)
          end
          
          format_success_result({
            response_data: result,
            ready_for_scoring: true
          })
        end
      end
      
      # Step 2: Analyze lead quality indicators
      llm :analyze_lead_quality do
        input :collect_response_data
        run_if { |ctx| ctx.get(:collect_response_data)&.dig(:ready_for_scoring) }
        
        model "gpt-4o-mini"
        temperature 0.3
        max_tokens 800
        response_format :json
        
        system_prompt "You are an expert lead qualification specialist with deep knowledge of B2B and B2C sales processes. Analyze form responses to determine lead quality, intent, and readiness to purchase."
        
        prompt do |context|
          data_result = context.get(:collect_response_data)
          response_data = data_result[:response_data]
          
          # Format the prompt inline instead of using a separate method
          form = response_data[:form]
          answers = response_data[:answers]
          enriched_data = response_data[:enriched_data]
          ai_analysis = response_data[:ai_analysis]
          
          <<~PROMPT
            Analyze this form response as a lead qualification specialist. Score the lead quality from 0-100 and provide detailed insights.

            **Form Information:**
            - Name: "#{form.name}"
            - Category: #{form.category}
            - Purpose: #{form.form_settings&.dig('purpose') || 'Lead generation'}

            **Response Data:**
            #{answers.map { |k, v| "- #{k}: #{v}" }.join("\n")}

            **Enriched Data:**
            #{enriched_data.map { |k, v| "- #{k}: #{v}" }.join("\n") if enriched_data.present?}

            **AI Analysis:**
            #{ai_analysis.map { |k, v| "- #{k}: #{v}" }.join("\n") if ai_analysis.present?}

            **Analysis Requirements:**
            Return a JSON object with:
            {
              "quality_score": 0-100,
              "lead_tier": "hot|warm|lukewarm|cold",
              "quality_factors": [
                {
                  "factor": "specific quality indicator",
                  "score": 0-25,
                  "reasoning": "why this contributes to quality"
                }
              ],
              "risk_factors": [
                {
                  "factor": "potential concern",
                  "impact": "low|medium|high",
                  "reasoning": "why this might be a risk"
                }
              ],
              "qualification_notes": "detailed assessment of lead quality",
              "recommended_actions": [
                "specific action 1",
                "specific action 2"
              ],
              "estimated_value": "estimated deal value or importance",
              "confidence_level": 0-1.0,
              "buying_signals": [
                "specific indicators of purchase intent"
              ],
              "timing_indicators": {
                "urgency": "immediate|short_term|long_term",
                "budget_availability": "confirmed|likely|unknown",
                "decision_maker": "yes|no|influencer"
              },
              "next_best_action": "specific recommendation for follow-up"
            }

            **Scoring Guidelines:**
            - 80-100: Hot lead - immediate follow-up required
            - 60-79: Warm lead - follow-up within 24 hours
            - 40-59: Lukewarm lead - nurture campaign
            - 0-39: Cold lead - long-term nurture

            Consider:
            - Company size and industry (if enriched)
            - Response quality and detail level
            - Specific pain points mentioned
            - Timeline indicators
            - Budget indicators
            - Decision-making authority signals
            - Engagement level throughout form
          PROMPT
        end
      end
      
      # Step 3: Calculate lead score
      task :calculate_lead_score do
        input :analyze_lead_quality, :collect_response_data
        run_when :analyze_lead_quality
        
        process do |quality_analysis, data_result|
          Rails.logger.info "Calculating lead score based on quality analysis"
          
          response_data = data_result[:response_data]
          form_response = response_data[:form_response]
          
          # Track AI usage
          ai_cost = 0.035 # Estimated cost for lead scoring analysis
          track_ai_usage(context, ai_cost, 'lead_scoring')
          
          result = safe_db_operation do
            # Parse quality analysis
            lead_analysis = quality_analysis.is_a?(String) ? JSON.parse(quality_analysis) : quality_analysis
            
            # Calculate numerical score inline
            lead_score = if response_data[:form].ai_enhanced? && response_data[:form].ai_configuration&.dig('lead_scoring', 'enabled') == true
              # Multi-dimensional scoring
              dimensions = {
                technical_readiness: LeadScoringCalculator.calculate_technical_score(response_data),
                business_impact: LeadScoringCalculator.calculate_business_impact_score(lead_analysis, response_data),
                financial_capacity: LeadScoringCalculator.calculate_financial_score(response_data),
                urgency_factor: LeadScoringCalculator.calculate_urgency_score(lead_analysis, response_data),
                decision_authority: LeadScoringCalculator.calculate_authority_score(response_data),
                implementation_complexity: LeadScoringCalculator.calculate_complexity_score(response_data)
              }
              
              # Get industry-specific weights
              industry = response_data[:enriched_data]&.[](:industry)
              weights = LeadScoringCalculator.get_industry_weights(industry)
              
              # Calculate weighted score
              weighted_score = dimensions.sum { |dim, score| score * (weights[dim] || 1.0) }
              
              # Ensure score is between 0-100
              [[weighted_score, 0].max, 100].min.round
            else
              # Simple scoring
              base_score = 0
              
              # Score based on quality factors
              quality_score = lead_analysis['quality_score'] || 50
              base_score += quality_score
              
              # Bonus for company data enrichment
              base_score += 15 if response_data[:enriched_data].present?
              
              # Bonus for detailed responses
              detailed_responses = response_data[:answers].values.count { |ans| ans.to_s.length > 50 }
              base_score += [detailed_responses * 5, 20].min
              
              # Bonus for completion time (faster = better)
              completion_time = response_data[:completion_time]
              if completion_time && completion_time < 10
                base_score += 10
              elsif completion_time && completion_time > 30
                base_score -= 5
              end
              
              # Ensure score is between 0-100
              [[base_score, 0].max, 100].min.round
            end
            
            # Determine lead tier based on score
            lead_tier = case lead_score
            when 80..100 then 'hot'
            when 60..79 then 'warm'
            when 40..59 then 'lukewarm'
            else 'cold'
            end
            
            # Create lead scoring record
            lead_scoring = LeadScoring.create!(
              form_response: form_response,
              score: lead_score,
              tier: lead_tier,
              analysis_data: lead_analysis,
              quality_factors: lead_analysis['quality_factors'],
              risk_factors: lead_analysis['risk_factors'],
              qualification_notes: lead_analysis['qualification_notes'],
              recommended_actions: lead_analysis['recommended_actions'],
              estimated_value: lead_analysis['estimated_value'],
              confidence_level: lead_analysis['confidence_level'],
              scored_at: Time.current,
              ai_cost: ai_cost
            )
            
            # Update form response with scoring data
            form_response.update!(
              lead_score: lead_score,
              lead_tier: lead_tier,
              lead_scoring_id: lead_scoring.id
            )
            
            # Update user's AI credit usage
            user = response_data[:user]
            user.consume_ai_credit(ai_cost) if user.respond_to?(:consume_ai_credit)
            
            {
              lead_scoring: lead_scoring,
              score: lead_score,
              tier: lead_tier,
              analysis: lead_analysis,
              ai_cost: ai_cost
            }
          end
          
          if result[:error]
            Rails.logger.error "Failed to calculate lead score: #{result[:message]}"
            return format_error_result("Failed to calculate lead score", result[:type], result)
          end
          
          format_success_result({
            lead_scoring_id: result[:lead_scoring].id,
            score: result[:score],
            tier: result[:tier],
            analysis: result[:analysis],
            ai_cost: result[:ai_cost],
            scored_at: Time.current.iso8601
          })
        end
      end
      
      # Step 4: Route lead based on score
      task :route_lead do
        input :calculate_lead_score, :collect_response_data
        run_when :calculate_lead_score
        
        process do |scoring_result, data_result|
          Rails.logger.info "Routing lead based on score: #{scoring_result[:score]}"
          
          response_data = data_result[:response_data]
          form_response = response_data[:form_response]
          form = response_data[:form]
          
          # Get routing configuration
          routing_config = form.ai_configuration&.dig('lead_routing') || {}
          
          routing_actions = []
          
          # Route based on tier and score
          case scoring_result[:tier]
          when 'hot'
            routing_actions << {
              action: 'immediate_followup',
              priority: 'high',
              sla_hours: 1,
              assign_to: routing_config['hot_lead_assignee'] || 'sales_team',
              channels: ['email', 'phone', 'slack']
            }
          when 'warm'
            routing_actions << {
              action: 'scheduled_followup',
              priority: 'medium',
              sla_hours: 24,
              assign_to: routing_config['warm_lead_assignee'] || 'marketing_team',
              channels: ['email', 'slack']
            }
          when 'cold'
            routing_actions << {
              action: 'nurture_campaign',
              priority: 'low',
              sla_hours: 72,
              assign_to: routing_config['cold_lead_assignee'] || 'nurture_team',
              channels: ['email']
            }
          end
          
          # Check for specific routing rules - inline implementation
          custom_actions = []
          
          # Check for specific industry routing
          industry = response_data[:answers]['industry'] || response_data[:enriched_data]&.[](:industry)
          if industry
            industry_config = routing_config['industry_routing']&.[](industry)
            if industry_config
              custom_actions << {
                action: 'industry_specialist',
                priority: 'high',
                assign_to: industry_config['assignee'],
                channels: industry_config['channels'] || ['email']
              }
            end
          end
          
          # Check for high-value company routing
          company_size = response_data[:enriched_data]&.[](:company_size)
          if company_size && company_size > 1000
            custom_actions << {
              action: 'enterprise_specialist',
              priority: 'high',
              assign_to: routing_config['enterprise_assignee'] || 'enterprise_sales',
              channels: ['email', 'phone', 'slack']
            }
          end
          
          routing_actions.concat(custom_actions) if custom_actions.any?
          
          # Create routing record
          lead_routing = LeadRouting.create!(
            form_response: form_response,
            lead_scoring_id: scoring_result[:lead_scoring_id],
            routing_actions: routing_actions,
            status: 'pending',
            scheduled_at: Time.current,
            priority: routing_actions.first&.dig(:priority) || 'medium'
          )
          
          # Queue integration triggers for each routing action - inline implementation
          routing_actions.each do |action|
            case action[:action]
            when 'immediate_followup', 'scheduled_followup'
              Forms::IntegrationTriggerJob.perform_later(
                form_response.id,
                'lead_qualified',
                {
                  score: scoring_result[:score],
                  tier: scoring_result[:tier],
                  routing_action: action,
                  priority: action[:priority],
                  assign_to: action[:assign_to]
                }
              )
            when 'nurture_campaign'
              Forms::IntegrationTriggerJob.perform_later(
                form_response.id,
                'lead_nurture',
                {
                  score: scoring_result[:score],
                  tier: scoring_result[:tier],
                  campaign_type: 'nurture',
                  priority: action[:priority]
                }
              )
            end
          end
          
          {
            lead_routing: lead_routing,
            routing_actions: routing_actions,
            routing_config: routing_config
          }
        end
      end
      
      # Step 5: Trigger integrations based on routing
      stream :trigger_routing_integrations do
        input :route_lead, :calculate_lead_score, :collect_response_data
        run_when :route_lead
        
        target { |ctx| 
          data_result = ctx.get(:collect_response_data)
          form = data_result[:response_data][:form]
          "form_#{form.share_token}_lead_routing"
        }
        turbo_action :append
        partial "forms/lead_routing_status"
        
        locals do |ctx|
          routing_result = ctx.get(:route_lead)
          scoring_result = ctx.get(:calculate_lead_score)
          data_result = ctx.get(:collect_response_data)
          
          {
            lead_routing: routing_result[:lead_routing],
            routing_actions: routing_result[:routing_actions],
            score: scoring_result[:score],
            tier: scoring_result[:tier],
            form: data_result[:response_data][:form]
          }
        end
      end
    end
  end
end
</file>

<file path="workflows/forms/report_generation_workflow.rb">
# frozen_string_literal: true

module Forms
  class ReportGenerationWorkflow < ApplicationWorkflow
    workflow do
      # Step 1: Collect and structure all data
      task :collect_comprehensive_data do
        input :form_response_id
        description "Collect all response data, AI analysis, and context"
        
        process do |response_id|
          Rails.logger.info "Collecting comprehensive data for report generation: #{response_id}"
          
          result = safe_db_operation do
            form_response = FormResponse.includes(
              :form,
              :question_responses,
              :dynamic_questions,
              :lead_scoring,
              form: [:user, :form_questions],
              question_responses: :form_question
            ).find(response_id)
            
            # Collect basic data
            basic_data = {
              form: {
                name: form_response.form.name,
                category: form_response.form.category,
                created_at: form_response.form.created_at
              },
              response: {
                id: form_response.id,
                session_id: form_response.session_id,
                completed_at: form_response.completed_at,
                duration_minutes: calculate_completion_duration(form_response),
                ip_address: form_response.ip_address&.slice(0, 3) + ".*.*.*" # Privacy
              }
            }
            
            # Collect structured responses
            structured_responses = build_structured_responses(form_response)
            
            # Collect existing AI analyses
            ai_analyses = collect_ai_analyses(form_response)
            
            # Collect enrichment data
            enrichment_data = form_response.enrichment_data || {}
            
            # Collect lead scoring
            lead_scoring = form_response.lead_scoring
            scoring_data = lead_scoring ? {
              overall_score: lead_scoring.score,
              tier: lead_scoring.tier,
              quality_factors: lead_scoring.quality_factors,
              risk_factors: lead_scoring.risk_factors,
              estimated_value: lead_scoring.estimated_value,
              confidence_level: lead_scoring.confidence_level
            } : nil
            
            # Recopilar preguntas dinmicas
            dynamic_questions_data = collect_dynamic_questions_data(form_response)
            
            {
              basic_data: basic_data,
              structured_responses: structured_responses,
              ai_analyses: ai_analyses,
              enrichment_data: enrichment_data,
              scoring_data: scoring_data,
              dynamic_questions: dynamic_questions_data,
              metadata: {
                total_questions: form_response.form.form_questions.count,
                answered_questions: form_response.question_responses.count,
                completion_rate: calculate_completion_percentage(form_response),
                quality_indicators: calculate_response_quality_indicators(form_response)
              }
            }
          end
          
          if result[:error]
            return format_error_result("Failed to collect comprehensive data", result[:type], result)
          end
          
          format_success_result({
            comprehensive_data: result,
            ready_for_analysis: true
          })
        end
      end
      
      # Step 2: Anlisis estratgico con IA
      llm :strategic_analysis do
        input :collect_comprehensive_data
        run_if { |ctx| ctx.get(:collect_comprehensive_data)&.dig(:ready_for_analysis) }
        
        model "gpt-4o"
        temperature 0.2
        max_tokens 1500
        response_format :json
        
        system_prompt "You are a senior strategic consultant specializing in digital transformation with AI. Your task is to analyze business evaluation data and generate deep strategic insights, actionable recommendations, and an implementation roadmap."
        
        prompt do |context|
          data_result = context.get(:collect_comprehensive_data)
          comprehensive_data = data_result[:comprehensive_data]
          
          format_strategic_analysis_prompt(comprehensive_data)
        end
      end
      
      # Step 3: Generar recomendaciones tcnicas
      llm :technical_recommendations do
        input :collect_comprehensive_data, :strategic_analysis
        run_when :strategic_analysis
        
        model "gpt-4o"
        temperature 0.3
        max_tokens 1200
        response_format :json
        
        system_prompt "You are an AI solutions architect with enterprise implementation experience. Analyze technical and business data to generate specific recommendations for architecture, technologies, and implementation."
        
        prompt do |context|
          data_result = context.get(:collect_comprehensive_data)
          strategic_result = context.get(:strategic_analysis)
          
          format_technical_recommendations_prompt(
            data_result[:comprehensive_data], 
            strategic_result
          )
        end
      end
      
      # Step 4: Anlisis de riesgos y mitigacin
      llm :risk_analysis do
        input :collect_comprehensive_data, :strategic_analysis, :technical_recommendations
        run_when :technical_recommendations
        
        model "gpt-4o-mini"
        temperature 0.4
        max_tokens 800
        response_format :json
        
        system_prompt "You are a specialist in technology risk management and digital transformation. Identify potential risks, adoption barriers, and mitigation strategies."
        
        prompt do |context|
          data_result = context.get(:collect_comprehensive_data)
          strategic_result = context.get(:strategic_analysis)
          technical_result = context.get(:technical_recommendations)
          
          format_risk_analysis_prompt(
            data_result[:comprehensive_data],
            strategic_result,
            technical_result
          )
        end
      end
      
      # Step 5: Generar el reporte MD final
      llm :generate_markdown_report do
        input :collect_comprehensive_data, :strategic_analysis, :technical_recommendations, :risk_analysis
        run_when :risk_analysis
        
        model "gpt-4o"
        temperature 0.1
        max_tokens 3000
        response_format :text # Para generar markdown directamente
        
        system_prompt "Eres un consultor senior que debe crear un reporte ejecutivo profesional en formato Markdown. El reporte debe ser comprehensivo, bien estructurado y accionable para ejecutivos de nivel C."
        
        prompt do |context|
          data_result = context.get(:collect_comprehensive_data)
          strategic_result = context.get(:strategic_analysis)
          technical_result = context.get(:technical_recommendations)
          risk_result = context.get(:risk_analysis)
          
          format_final_report_prompt(
            data_result[:comprehensive_data],
            strategic_result,
            technical_result,
            risk_result
          )
        end
      end
      
      # Step 6: Guardar y distribuir el reporte
      task :save_and_distribute_report do
        input :generate_markdown_report, :collect_comprehensive_data
        run_when :generate_markdown_report
        
        process do |markdown_content, data_result|
          Rails.logger.info "Saving and distributing final report"
          
          comprehensive_data = data_result[:comprehensive_data]
          form_response = FormResponse.find(comprehensive_data[:basic_data][:response][:id])
          
          # Track AI usage
          total_ai_cost = 0.15 # Estimated total cost for comprehensive analysis
          track_ai_usage(context, total_ai_cost, 'comprehensive_report_generation')
          
          result = safe_db_operation do
            # Crear registro del reporte
            report = AnalysisReport.create!(
              form_response: form_response,
              report_type: 'comprehensive_strategic_analysis',
              markdown_content: markdown_content,
              metadata: {
                generated_at: Time.current.iso8601,
                ai_models_used: ['gpt-4o', 'gpt-4o-mini'],
                total_ai_cost: total_ai_cost,
                analysis_depth: 'comprehensive',
                sections_included: [
                  'executive_summary',
                  'strategic_analysis', 
                  'technical_recommendations',
                  'risk_assessment',
                  'implementation_roadmap',
                  'financial_projections'
                ]
              },
              status: 'completed'
            )
            
            # Generar archivo MD para descarga
            filename = generate_report_filename(form_response, 'strategic_analysis')
            file_path = generate_downloadable_report(markdown_content, filename)
            
            # Actualizar form_response con el reporte
            form_response.update!(
              analysis_report_id: report.id,
              final_analysis_completed_at: Time.current
            )
            
            # Actualizar crditos de IA del usuario
            user = form_response.form.user
            user.consume_ai_credit(total_ai_cost) if user.respond_to?(:consume_ai_credit)
            
            {
              report: report,
              file_path: file_path,
              filename: filename,
              download_url: "/reports/#{report.id}/download",
              ai_cost: total_ai_cost
            }
          end
          
          if result[:error]
            return format_error_result("Failed to save report", result[:type], result)
          end
          
          format_success_result({
            report_id: result[:report].id,
            download_url: result[:download_url],
            filename: result[:filename],
            file_size: markdown_content.bytesize,
            ai_cost: result[:ai_cost],
            completed_at: Time.current.iso8601
          })
        end
      end
    end
    
    # Los mtodos privados van FUERA del bloque workflow
    private
    
    def calculate_completion_duration(form_response)
      return 0 unless form_response.started_at && form_response.completed_at
      ((form_response.completed_at - form_response.started_at) / 1.minute).round(2)
    end
    
    def build_structured_responses(form_response)
      responses = {}
      
      form_response.question_responses.includes(:form_question).each do |qr|
        question = qr.form_question
        responses[question.title] = {
          value: qr.answer_data['value'],
          question_type: question.question_type,
          response_time_ms: qr.response_time_ms,
          ai_analysis: qr.ai_analysis_results,
          position: question.position
        }
      end
      
      responses
    end
    
    def collect_ai_analyses(form_response)
      analyses = {
        sentiment_scores: [],
        quality_indicators: [],
        confidence_levels: [],
        key_insights: []
      }
      
      form_response.question_responses.each do |qr|
        if qr.ai_analysis_results.present?
          analysis = qr.ai_analysis_results
          analyses[:sentiment_scores] << analysis['sentiment'] if analysis['sentiment']
          analyses[:quality_indicators] << analysis['quality_indicators'] if analysis['quality_indicators']
          analyses[:confidence_levels] << analysis['confidence_score'] if analysis['confidence_score']
          
          if analysis['insights']
            analyses[:key_insights].concat(analysis['insights'])
          end
        end
      end
      
      analyses
    end
    
    def collect_dynamic_questions_data(form_response)
      dynamic_data = []
      
      form_response.dynamic_questions.includes(:responses).each do |dq|
        dynamic_data << {
          title: dq.title,
          question_type: dq.question_type,
          generation_context: dq.generation_context,
          ai_confidence: dq.ai_confidence,
          answered: dq.responses.any?,
          answer: dq.responses.first&.answer_data,
          generated_from: dq.generated_from_question&.title
        }
      end
      
      dynamic_data
    end
    
    def calculate_completion_percentage(form_response)
      total_questions = form_response.form.form_questions.count
      answered_questions = form_response.question_responses.count
      return 0 if total_questions.zero?
      
      (answered_questions.to_f / total_questions * 100).round(2)
    end
    
    def calculate_response_quality_indicators(form_response)
      responses = form_response.question_responses
      return {} if responses.empty?
      
      {
        avg_response_time: responses.average(:response_time_ms)&.to_f || 0,
        detailed_responses_count: responses.joins(:form_question)
                                          .where(form_questions: { question_type: ['text_long', 'text_short'] })
                                          .count { |qr| qr.answer_data['value'].to_s.length > 50 },
        total_text_length: responses.sum { |qr| qr.answer_data['value'].to_s.length },
        ai_confidence_avg: responses.where.not(ai_confidence_score: nil)
                                  .average(:ai_confidence_score)&.to_f || 0
      }
    end
    
    def format_strategic_analysis_prompt(comprehensive_data)
      responses = comprehensive_data[:structured_responses]
      metadata = comprehensive_data[:metadata]
      enrichment = comprehensive_data[:enrichment_data]
      scoring = comprehensive_data[:scoring_data]
      
      <<~PROMPT
        Analyze the following business evaluation data and provide a deep strategic analysis.
        
        **DATOS DE LA EMPRESA:**
        #{format_company_data(enrichment)}
        
        **RESPUESTAS DEL FORMULARIO:**
        #{format_responses_for_analysis(responses)}
        
        **MTRICAS DE CALIDAD:**
        - Porcentaje de Completitud: #{metadata[:completion_rate]}%
        - Tiempo Promedio por Respuesta: #{metadata[:quality_indicators][:avg_response_time]&.to_i || 0}ms
        - Respuestas Detalladas: #{metadata[:quality_indicators][:detailed_responses_count]}
        
        **PUNTUACIN DE LEAD (si disponible):**
        #{scoring ? format_scoring_data(scoring) : 'No disponible'}
        
        **ANLISIS REQUERIDO (JSON):**
        {
          "executive_summary": "Resumen ejecutivo de mximo 3 prrafos",
          "strategic_positioning": {
            "current_state": "Evaluacin del estado actual",
            "ai_readiness_level": "beginner|intermediate|advanced",
            "competitive_advantages": ["ventaja1", "ventaja2"],
            "strategic_gaps": ["gap1", "gap2"]
          },
          "business_impact_assessment": {
            "primary_value_drivers": ["driver1", "driver2"],
            "estimated_roi_range": "Rango de ROI estimado",
            "timeline_to_value": "3-6 months|6-12 months|12+ months",
            "success_metrics": ["mtrica1", "mtrica2"]
          },
          "transformation_priority": {
            "urgency_level": "low|medium|high|critical",
            "complexity_assessment": "simple|moderate|complex|highly_complex",
            "resource_requirements": "Evaluacin de recursos necesarios",
            "change_management_needs": "Evaluacin de gestin del cambio"
          },
          "next_steps_recommendation": [
            "Paso inmediato 1",
            "Paso inmediato 2",
            "Paso inmediato 3"
          ]
        }
        
        **INSTRUCCIONES:**
        - Be specific and actionable in all recommendations
        - Considera el contexto de la industria y tamao de empresa
        - Evaluate both opportunities and risks
        - Proporciona estimaciones realistas de tiempo y recursos
      PROMPT
    end
    
    def format_technical_recommendations_prompt(comprehensive_data, strategic_analysis)
      responses = comprehensive_data[:structured_responses]
      enrichment = comprehensive_data[:enrichment_data]
      
      <<~PROMPT
        Based on the strategic analysis and technical data, generate specific technical recommendations.
        
        **ANLISIS ESTRATGICO PREVIO:**
        #{strategic_analysis['strategic_positioning']&.to_json || 'No disponible'}
        
        **DATOS TCNICOS DISPONIBLES:**
        #{extract_technical_responses(responses)}
        
        **CONTEXTO DE LA EMPRESA:**
        #{format_company_technical_context(enrichment)}
        
        **RECOMENDACIONES TCNICAS REQUERIDAS (JSON):**
        {
          "architecture_recommendations": {
            "deployment_model": "cloud|hybrid|on_premise",
            "recommended_platforms": ["platform1", "platform2"],
            "integration_approach": "Estrategia de integracin",
            "scalability_considerations": "Consideraciones de escalabilidad"
          },
          "technology_stack": {
            "ai_frameworks": ["framework1", "framework2"],
            "data_infrastructure": ["tool1", "tool2"],
            "development_tools": ["tool1", "tool2"],
            "monitoring_solutions": ["solution1", "solution2"]
          },
          "implementation_phases": [
            {
              "phase": "Phase 1: Foundation",
              "duration": "2-3 months",
              "deliverables": ["deliverable1", "deliverable2"],
              "success_criteria": ["criteria1", "criteria2"]
            }
          ],
          "resource_requirements": {
            "technical_team_size": "Nmero recomendado",
            "skill_requirements": ["skill1", "skill2"],
            "external_support_needed": "Tipo de soporte externo",
            "budget_considerations": "Consideraciones presupuestarias"
          },
          "data_requirements": {
            "data_sources_needed": ["source1", "source2"],
            "data_quality_requirements": "Requisitos de calidad",
            "privacy_compliance": ["GDPR", "CCPA", "etc"],
            "governance_framework": "Marco de gobernanza recomendado"
          }
        }
      PROMPT
    end
    
    def format_risk_analysis_prompt(comprehensive_data, strategic_analysis, technical_recommendations)
      <<~PROMPT
        Perform a comprehensive risk analysis based on all available data.
        
        **ANLISIS DE RIESGOS REQUERIDO (JSON):**
        {
          "technical_risks": [
            {
              "risk": "Descripcin del riesgo tcnico",
              "probability": "low|medium|high",
              "impact": "low|medium|high|critical",
              "mitigation_strategies": ["estrategia1", "estrategia2"]
            }
          ],
          "business_risks": [
            {
              "risk": "Descripcin del riesgo de negocio",
              "probability": "low|medium|high",
              "impact": "low|medium|high|critical",
              "mitigation_strategies": ["estrategia1", "estrategia2"]
            }
          ],
          "organizational_risks": [
            {
              "risk": "Descripcin del riesgo organizacional",
              "probability": "low|medium|high",
              "impact": "low|medium|high|critical",
              "mitigation_strategies": ["estrategia1", "estrategia2"]
            }
          ],
          "financial_risks": [
            {
              "risk": "Descripcin del riesgo financiero",
              "probability": "low|medium|high",
              "impact": "low|medium|high|critical",
              "mitigation_strategies": ["estrategia1", "estrategia2"]
            }
          ],
          "overall_risk_assessment": {
            "risk_level": "low|medium|high|critical",
            "key_risk_factors": ["factor1", "factor2"],
            "recommended_risk_tolerance": "conservative|moderate|aggressive",
            "contingency_planning": "Plan de contingencia recomendado"
          }
        }
      PROMPT
    end
    
    def format_final_report_prompt(comprehensive_data, strategic_analysis, technical_recommendations, risk_analysis)
      basic_data = comprehensive_data[:basic_data]
      
      <<~PROMPT
        Generate a comprehensive executive report in Markdown format using ALL previous analyses.
        
        **ESTRUCTURA REQUERIDA DEL REPORTE:**
        
        # Reporte de Evaluacin Estratgica: Transformacin Digital con IA
        
        **Cliente:** [Extraer de datos]
        **Fecha:** #{Date.current.strftime('%d de %B, %Y')}
        **ID de Evaluacin:** #{basic_data[:response][:id]}
        
        ## Resumen Ejecutivo
        [3-4 prrafos que resuman los hallazgos clave, recomendaciones principales y prximos pasos]
        
        ## 1. Anlisis de la Situacin Actual
        ### 1.1 Perfil de la Organizacin
        [Informacin de la empresa basada en datos enriquecidos]
        
        ### 1.2 Estado de Madurez en IA
        [Evaluacin del nivel actual]
        
        ### 1.3 Desafos Identificados
        [Principales pain points]
        
        ## 2. Anlisis Estratgico
        ### 2.1 Oportunidades de Valor
        [Drivers de valor identificados]
        
        ### 2.2 Posicionamiento Competitivo
        [Anlisis competitivo]
        
        ### 2.3 Alineacin Estratgica
        [Alineacin con objetivos de negocio]
        
        ## 3. Recomendaciones Tcnicas
        ### 3.1 Arquitectura Propuesta
        [Arquitectura tcnica recomendada]
        
        ### 3.2 Stack Tecnolgico
        [Tecnologas especficas]
        
        ### 3.3 Consideraciones de Implementacin
        [Detalles de implementacin]
        
        ## 4. Anlisis de Riesgos y Mitigacin
        ### 4.1 Matriz de Riesgos
        [Tabla de riesgos con probabilidad e impacto]
        
        ### 4.2 Estrategias de Mitigacin
        [Estrategias especficas]
        
        ## 5. Roadmap de Implementacin
        ### 5.1 Fases de Implementacin
        [Cronograma detallado por fases]
        
        ### 5.2 Hitos y Entregables
        [Hitos clave y entregables]
        
        ### 5.3 Recursos Requeridos
        [Recursos humanos y tcnicos]
        
        ## 6. Proyecciones Financieras
        ### 6.1 Inversin Estimada
        [Costos por fase]
        
        ### 6.2 ROI Proyectado
        [Retorno de inversin esperado]
        
        ### 6.3 Modelo de Financiamiento
        [Opciones de financiamiento]
        
        ## 7. Prximos Pasos Recomendados
        ### 7.1 Acciones Inmediatas (0-30 das)
        [Pasos inmediatos]
        
        ### 7.2 Planificacin a Corto Plazo (1-3 meses)
        [Planificacin corto plazo]
        
        ### 7.3 Visin a Largo Plazo (6-12 meses)
        [Visin largo plazo]
        
        ## 8. Conclusiones
        [Conclusiones finales y recomendacin general]
        
        ---
        
        **Nota:** Este reporte ha sido generado mediante anlisis de IA basado en la informacin proporcionada durante la evaluacin. Las recomendaciones deben ser validadas con el contexto especfico de su organizacin.
        
        **INSTRUCCIONES PARA LA GENERACIN:**
        1. Usa TODOS los datos de los anlisis previos
        2. Mantn un tono profesional y ejecutivo
        3. Incluye datos especficos y mtricas cuando estn disponibles
        4. Haz referencias cruzadas entre secciones cuando sea relevante
        5. Asegrate de que el reporte sea accionable y especfico
        6. Incluye tablas en formato Markdown cuando sea apropiado
        7. El reporte debe tener entre 2500-4000 palabras
        8. Cada seccin debe ser sustantiva y detallada
      PROMPT
    end
    
    # Helper methods for formatting data
    def format_company_data(enrichment)
      return "No hay datos de empresa disponibles" if enrichment.blank?
      
      [
        "- Empresa: #{enrichment[:company_name] || 'No especificada'}",
        "- Industria: #{enrichment[:industry] || 'No especificada'}",
        "- Tamao: #{enrichment[:company_size] || 'No especificado'}",
        "- Ubicacin: #{enrichment[:location] || 'No especificada'}",
        "- Website: #{enrichment[:website] || 'No especificado'}"
      ].join("\n")
    end
    
    def format_responses_for_analysis(responses)
      responses.map do |question, data|
        "- #{question}: #{data[:value]} (Tipo: #{data[:question_type]})"
      end.join("\n")
    end
    
    def format_scoring_data(scoring)
      [
        "- Puntuacin General: #{scoring[:overall_score]}/100",
        "- Tier: #{scoring[:tier]}",
        "- Nivel de Confianza: #{scoring[:confidence_level]}",
        "- Valor Estimado: #{scoring[:estimated_value]}"
      ].join("\n")
    end
    
    def extract_technical_responses(responses)
      technical_questions = responses.select do |question, data|
        question.downcase.include?('tecnolog') || 
        question.downcase.include?('sistem') ||
        question.downcase.include?('plataform') ||
        data[:question_type].in?(['multiple_choice', 'checkbox'])
      end
      
      if technical_questions.any?
        technical_questions.map { |q, d| "- #{q}: #{d[:value]}" }.join("\n")
      else
        "No hay informacin tcnica especfica disponible"
      end
    end
    
    def format_company_technical_context(enrichment)
      return "No hay contexto tcnico disponible" if enrichment.blank?
      
      tech_info = []
      tech_info << "- Tecnologas identificadas: #{enrichment[:technologies]&.join(', ')}" if enrichment[:technologies]
      tech_info << "- Industria: #{enrichment[:industry]}" if enrichment[:industry]
      tech_info << "- Tamao de empresa: #{enrichment[:company_size]}" if enrichment[:company_size]
      
      tech_info.any? ? tech_info.join("\n") : "Contexto tcnico limitado"
    end
    
    def generate_report_filename(form_response, report_type)
      company_name = form_response.enrichment_data&.[](:company_name) || 'Unknown_Company'
      sanitized_name = company_name.gsub(/[^a-zA-Z0-9]/, '_')
      timestamp = Time.current.strftime('%Y%m%d_%H%M%S')
      
      "#{sanitized_name}_#{report_type}_#{timestamp}.md"
    end
    
    def generate_downloadable_report(content, filename)
      # Crear directorio si no existe
      reports_dir = Rails.root.join('tmp', 'reports')
      FileUtils.mkdir_p(reports_dir)
      
      # Escribir archivo
      file_path = reports_dir.join(filename)
      File.write(file_path, content)
      
      file_path.to_s
    end
  end
end
</file>

<file path="workflows/forms/response_processing_workflow.rb">
# frozen_string_literal: true

module Forms
  class ResponseProcessingWorkflow < ApplicationWorkflow
    workflow do
      # Step 1: Validate and prepare response data
      validate :validate_response_data do
        input :form_response_id, :question_id, :answer_data, :metadata
        description "Validate incoming response data and prepare for processing"
        
        process do |response_id, question_id, answer_data, metadata = {}|
          Rails.logger.info "Validating response data for response_id: #{response_id}, question_id: #{question_id}"
          
          # Validate required inputs
          validate_required_inputs(context, :form_response_id, :question_id, :answer_data)
          
          # Load and validate form response
          form_response = FormResponse.find(response_id)
          unless form_response
            return format_error_result("FormResponse not found", 'not_found_error', { response_id: response_id })
          end
          
          # Load and validate question
          question = FormQuestion.find(question_id)
          unless question
            return format_error_result("FormQuestion not found", 'not_found_error', { question_id: question_id })
          end
          
          # Verify question belongs to the form
          unless question.form_id == form_response.form_id
            return format_error_result("Question does not belong to this form", 'validation_error')
          end
          
          # Validate answer data structure
          validation_errors = validate_response_structure(answer_data)
          if validation_errors.any?
            return format_error_result("Invalid answer data structure", 'validation_error', { errors: validation_errors })
          end
          
          # Validate answer against question type and rules
          question_validation = question.validate_answer(answer_data)
          unless question_validation[:valid]
            return format_error_result("Answer validation failed", 'validation_error', { 
              errors: question_validation[:errors] 
            })
          end
          
          # Calculate response quality metrics
          quality_metrics = calculate_response_quality(question, answer_data)
          
          # Prepare context data for subsequent steps
          context_data = {
            form_response: form_response,
            question: question,
            answer_data: answer_data,
            metadata: metadata.merge({
              validated_at: Time.current.iso8601,
              quality_metrics: quality_metrics,
              session_id: form_response.session_id
            }),
            form_context: get_form_context(form_response.form_id),
            response_context: get_response_context(response_id),
            question_context: get_question_context(question_id)
          }
          
          Rails.logger.info "Response validation successful for question #{question.title}"
          
          format_success_result({
            valid: true,
            form_response: form_response,
            question: question,
            answer_data: answer_data,
            metadata: context_data[:metadata],
            quality_score: quality_metrics[:completeness_score]
          })
        end
      end
      
      # Step 2: Save question response (conditional on validation)
      task :save_question_response do
        input :validate_response_data
        run_when :validate_response_data, ->(result) { result[:valid] }
        description "Save validated response to database"
        
        process do |validation_result|
          Rails.logger.info "Saving question response for question: #{validation_result[:question].title}"
          
          form_response = validation_result[:form_response]
          question = validation_result[:question]
          answer_data = validation_result[:answer_data]
          metadata = validation_result[:metadata]
          
          # Execute database operation safely
          result = safe_db_operation do
            # Find or create question response
            question_response = QuestionResponse.find_or_initialize_by(
              form_response: form_response,
              form_question: question
            )
            
            # Process the answer data using the question's handler
            processed_answer = question.process_answer(answer_data)
            
            # Update question response attributes
            question_response.assign_attributes(
              answer_data: processed_answer,
              response_time_ms: metadata[:response_time_ms],
              skipped: false,
              metadata: metadata.except(:response_time_ms)
            )
            
            # Save the question response
            question_response.save!
            
            # Update form response progress and activity
            form_response.update!(
              last_activity_at: Time.current,
              updated_at: Time.current
            )
            
            # Return success data
            {
              question_response: question_response,
              form_response: form_response,
              processed_answer: processed_answer,
              quality_score: validation_result[:quality_score]
            }
          end
          
          # Handle database operation result
          if result[:error]
            Rails.logger.error "Failed to save question response: #{result[:message]}"
            return format_error_result("Failed to save response", result[:type], result)
          end
          
          Rails.logger.info "Successfully saved question response with ID: #{result[:question_response].id}"
          
          format_success_result({
            question_response_id: result[:question_response].id,
            question_response: result[:question_response],
            form_response: result[:form_response],
            processed_answer: result[:processed_answer],
            quality_score: result[:quality_score],
            saved_at: Time.current.iso8601
          })
        end
      end
      
      # Step 3: AI Enhancement - Analyze response (conditional)
      llm :analyze_response_ai do
        input :save_question_response, :validate_response_data
        run_if do |context|
          validation_result = context.get(:validate_response_data)
          save_result = context.get(:save_question_response)
          
          # Check if validation and save were successful
          return false unless validation_result&.dig(:valid) && save_result&.dig(:success)
          
          question = validation_result[:question]
          form = question.form
          
          # Check if AI analysis is enabled for this question
          return false unless question.ai_enhanced? && question.has_response_analysis?
          
          # Check if form has AI features enabled
          return false unless form.ai_enhanced?
          
          # Check if user has AI credits available
          user = form.user
          return false unless user.can_use_ai_features?
          
          # Check AI budget for this workflow
          estimated_cost = 0.02 # Estimated cost for response analysis
          return false unless ai_budget_available?(context, estimated_cost)
          
          # Check if answer has sufficient content for analysis
          answer_data = validation_result[:answer_data]
          answer_value = answer_data.is_a?(Hash) ? answer_data['value'] : answer_data
          
          # Skip analysis for very short or empty responses
          case question.question_type
          when 'text_short', 'text_long'
            return false if answer_value.to_s.length < 10
          when 'multiple_choice', 'single_choice', 'checkbox'
            # Always analyze choice questions if AI is enabled
            return true
          when 'rating', 'scale', 'nps_score'
            # Analyze ratings if they're below a certain threshold or if configured
            return true
          else
            return false if answer_value.blank?
          end
          
          Rails.logger.info "AI analysis conditions met for question: #{question.title}"
          true
        end
        
        model { |ctx| ctx.get(:validate_response_data)[:question].form.ai_model || 'gpt-4o-mini' }
        temperature 0.3
        max_tokens 500
        response_format :json
        
        system_prompt "You are an AI assistant analyzing form responses for quality, sentiment, and insights."
        
        prompt do |context|
          validation_result = context.get(:validate_response_data)
          save_result = context.get(:save_question_response)
          
          question = validation_result[:question]
          answer_data = validation_result[:answer_data]
          form_context = validation_result[:form_context]
          
          format_ai_analysis_prompt(question, answer_data, form_context)
        end
      end
      
      # Step 4: Update question response with AI analysis
      task :update_with_ai_analysis do
        input :save_question_response, :analyze_response_ai
        run_when :analyze_response_ai
        description "Update response record with AI analysis results"
        
        process do |save_result, ai_analysis|
          Rails.logger.info "Updating question response with AI analysis"
          
          question_response = save_result[:question_response]
          
          # Track AI usage and cost
          ai_cost = 0.02 # Estimated cost for analysis
          track_ai_usage(context, ai_cost, 'response_analysis')
          
          # Execute database update safely
          result = safe_db_operation do
            # Update question response with AI analysis
            question_response.update!(
              ai_analysis_results: ai_analysis,
              ai_analysis_requested_at: Time.current,
              ai_confidence_score: ai_analysis.dig('confidence_score') || 0.0
            )
            
            # Update user's AI credit usage
            user = question_response.form_response.form.user
            user.consume_ai_credit(ai_cost) if user.respond_to?(:consume_ai_credit)
            
            {
              question_response: question_response,
              ai_analysis: ai_analysis,
              ai_cost: ai_cost
            }
          end
          
          if result[:error]
            Rails.logger.error "Failed to update with AI analysis: #{result[:message]}"
            return format_error_result("Failed to save AI analysis", result[:type], result)
          end
          
          Rails.logger.info "Successfully updated question response with AI analysis"
          
          format_success_result({
            question_response_id: result[:question_response].id,
            ai_analysis: result[:ai_analysis],
            ai_cost: result[:ai_cost],
            confidence_score: ai_analysis.dig('confidence_score'),
            sentiment: ai_analysis.dig('sentiment'),
            flags: ai_analysis.dig('flags') || [],
            updated_at: Time.current.iso8601
          })
        end
      end
      
      # Step 5: Generate dynamic follow-up questions (conditional)
      llm :generate_followup_question do
        input :update_with_ai_analysis, :validate_response_data
        run_if do |context|
          validation_result = context.get(:validate_response_data)
          ai_analysis_result = context.get(:update_with_ai_analysis)
          
          # Check if previous steps were successful
          return false unless validation_result&.dig(:valid) && ai_analysis_result&.dig(:success)
          
          question = validation_result[:question]
          answer_data = validation_result[:answer_data]
          ai_analysis = ai_analysis_result[:ai_analysis]
          
          # Check if question is configured to generate follow-ups
          return false unless question.generates_followups?
          
          # Check AI budget for follow-up generation
          estimated_cost = 0.015 # Estimated cost for follow-up generation
          return false unless ai_budget_available?(context, estimated_cost)
          
          # Use helper method to determine if follow-up should be generated
          should_generate = should_generate_followup?(question, answer_data, ai_analysis)
          
          Rails.logger.info "Follow-up generation conditions: #{should_generate ? 'met' : 'not met'} for question: #{question.title}"
          should_generate
        end
        
        model { |ctx| ctx.get(:validate_response_data)[:question].form.ai_model || 'gpt-4o-mini' }
        temperature 0.7
        max_tokens 300
        response_format :json
        
        system_prompt "You are an expert at generating contextual follow-up questions based on user responses."
        
        prompt do |context|
          validation_result = context.get(:validate_response_data)
          ai_analysis_result = context.get(:update_with_ai_analysis)
          
          question = validation_result[:question]
          answer_data = validation_result[:answer_data]
          form_context = validation_result[:form_context]
          ai_analysis = ai_analysis_result[:ai_analysis]
          
          # Get previous responses for context
          form_response = validation_result[:form_response]
          previous_responses = form_response.answers_hash
          
          format_followup_prompt(question, answer_data, form_context, previous_responses, ai_analysis)
        end
      end
      
      # Step 6: Create dynamic question record
      task :create_dynamic_question do
        input :generate_followup_question, :validate_response_data
        run_when :generate_followup_question
        description "Create and persist dynamic question record"
        
        process do |followup_data, validation_result|
          Rails.logger.info "Creating dynamic question from AI-generated follow-up"
          
          form_response = validation_result[:form_response]
          source_question = validation_result[:question]
          
          # Track AI usage for follow-up generation
          ai_cost = 0.015
          track_ai_usage(context, ai_cost, 'followup_generation')
          
          # Execute database operation safely
          result = safe_db_operation do
            # Extract question data from AI response
            question_data = followup_data.dig('question') || {}
            
            # Create dynamic question record
            dynamic_question = DynamicQuestion.create!(
              form_response: form_response,
              generated_from_question: source_question,
              question_type: question_data['question_type'] || 'text_short',
              title: question_data['title'],
              description: question_data['description'],
              configuration: question_data['configuration'] || {},
              generation_context: {
                source_question_id: source_question.id,
                source_answer: validation_result[:answer_data],
                reasoning: followup_data['reasoning'],
                confidence: followup_data['confidence'],
                priority: followup_data['priority'],
                generated_at: Time.current.iso8601
              },
              generation_prompt: "AI-generated follow-up based on response analysis",
              generation_model: source_question.form.ai_model || 'gpt-4o-mini',
              ai_confidence: followup_data['confidence'] || 0.8
            )
            
            # Update user's AI credit usage
            user = form_response.form.user
            user.consume_ai_credit(ai_cost) if user.respond_to?(:consume_ai_credit)
            
            {
              dynamic_question: dynamic_question,
              followup_data: followup_data,
              ai_cost: ai_cost
            }
          end
          
          if result[:error]
            Rails.logger.error "Failed to create dynamic question: #{result[:message]}"
            return format_error_result("Failed to create dynamic question", result[:type], result)
          end
          
          Rails.logger.info "Successfully created dynamic question with ID: #{result[:dynamic_question].id}"
          
          format_success_result({
            dynamic_question_id: result[:dynamic_question].id,
            dynamic_question: result[:dynamic_question],
            followup_data: result[:followup_data],
            ai_cost: result[:ai_cost],
            created_at: Time.current.iso8601
          })
        end
      end
      
      # Step 7: Real-time UI update via Turbo Streams
      stream :update_form_ui do
        input :save_question_response, :create_dynamic_question
        description "Update form UI in real-time with new content"
        
        target { |ctx| "form_#{ctx.get(:validate_response_data)[:form_response].form.share_token}" }
        turbo_action :append
        partial "responses/question_response"
        
        locals do |ctx|
          validation_result = ctx.get(:validate_response_data)
          save_result = ctx.get(:save_question_response)
          dynamic_question_result = ctx.get(:create_dynamic_question)
          
          form_response = validation_result[:form_response]
          question_response = save_result[:question_response]
          
          locals_hash = {
            form_response: form_response,
            question_response: question_response,
            form: form_response.form,
            progress_percentage: form_response.progress_percentage
          }
          
          # Add dynamic question if it was created
          if dynamic_question_result&.dig(:success)
            locals_hash[:dynamic_question] = dynamic_question_result[:dynamic_question]
            locals_hash[:show_dynamic_question] = true
          end
          
          locals_hash
        end
      end
    end
    
    private
    
    # Helper methods will be implemented in subsequent subtasks
    def validate_response_structure(answer_data)
      errors = []
      
      # Check if answer_data is present
      if answer_data.nil?
        errors << "Answer data cannot be nil"
        return errors
      end
      
      # Ensure answer_data is a hash or can be converted to one
      unless answer_data.is_a?(Hash) || answer_data.is_a?(String) || answer_data.is_a?(Array) || answer_data.is_a?(Numeric)
        errors << "Answer data must be a valid data type (Hash, String, Array, or Numeric)"
      end
      
      # If it's a hash, validate required structure
      if answer_data.is_a?(Hash)
        # Check for suspicious or malicious content
        if answer_data.to_s.length > 50000 # 50KB limit
          errors << "Answer data is too large"
        end
        
        # Validate nested structure depth (prevent deeply nested attacks)
        if answer_data.to_s.count('{') > 10
          errors << "Answer data structure is too deeply nested"
        end
      end
      
      errors
    end
    
    def calculate_response_quality(question, answer_data)
      quality_metrics = {
        completeness_score: 0.0,
        response_length: 0,
        has_content: false,
        estimated_effort: 'low'
      }
      
      # Extract the actual answer value
      answer_value = answer_data.is_a?(Hash) ? answer_data['value'] : answer_data
      
      # Check if answer has content
      quality_metrics[:has_content] = !answer_value.blank?
      
      return quality_metrics unless quality_metrics[:has_content]
      
      # Calculate completeness based on question type
      case question.question_type
      when 'text_short', 'text_long'
        text_length = answer_value.to_s.length
        quality_metrics[:response_length] = text_length
        
        if text_length >= 50
          quality_metrics[:completeness_score] = 1.0
          quality_metrics[:estimated_effort] = 'high'
        elsif text_length >= 20
          quality_metrics[:completeness_score] = 0.8
          quality_metrics[:estimated_effort] = 'medium'
        elsif text_length >= 5
          quality_metrics[:completeness_score] = 0.6
          quality_metrics[:estimated_effort] = 'low'
        else
          quality_metrics[:completeness_score] = 0.3
        end
        
      when 'multiple_choice', 'single_choice', 'checkbox'
        # Choice questions get full score for any selection
        quality_metrics[:completeness_score] = 1.0
        quality_metrics[:estimated_effort] = 'medium'
        
      when 'rating', 'scale', 'nps_score'
        # Rating questions get full score
        quality_metrics[:completeness_score] = 1.0
        quality_metrics[:estimated_effort] = 'low'
        
      when 'email'
        # Validate email format for quality
        if answer_value.match?(/\A[\w+\-.]+@[a-z\d\-]+(\.[a-z\d\-]+)*\.[a-z]+\z/i)
          quality_metrics[:completeness_score] = 1.0
          quality_metrics[:estimated_effort] = 'medium'
        else
          quality_metrics[:completeness_score] = 0.3
        end
        
      when 'phone'
        # Basic phone validation
        clean_phone = answer_value.to_s.gsub(/[^\d+]/, '')
        if clean_phone.length >= 10
          quality_metrics[:completeness_score] = 1.0
          quality_metrics[:estimated_effort] = 'medium'
        else
          quality_metrics[:completeness_score] = 0.5
        end
        
      else
        # Default scoring for other question types
        quality_metrics[:completeness_score] = 0.8
        quality_metrics[:estimated_effort] = 'medium'
      end
      
      quality_metrics
    end
    
    def should_generate_followup?(question, answer_data, ai_analysis)
      # Check AI analysis for follow-up indicators
      if ai_analysis.dig('insights')&.any? { |insight| insight['type'] == 'followup_suggested' }
        return true
      end
      
      # Check confidence score - generate follow-up for low confidence responses
      confidence_score = ai_analysis.dig('confidence_score') || 1.0
      return true if confidence_score < 0.7
      
      # Check for specific question types and answer patterns
      answer_value = answer_data.is_a?(Hash) ? answer_data['value'] : answer_data
      
      case question.question_type
      when 'rating', 'scale', 'nps_score'
        # Generate follow-up for low ratings
        rating_value = answer_value.to_f
        max_rating = question.rating_config[:max] || 5
        return true if rating_value <= (max_rating * 0.6) # Below 60% of max rating
        
      when 'multiple_choice', 'single_choice'
        # Generate follow-up for "Other" selections or specific choices
        return true if answer_value.to_s.downcase.include?('other')
        
      when 'text_short', 'text_long'
        # Generate follow-up for responses that indicate issues or concerns
        negative_keywords = ['problem', 'issue', 'difficult', 'confusing', 'unclear', 'frustrated']
        return true if negative_keywords.any? { |keyword| answer_value.to_s.downcase.include?(keyword) }
      end
      
      false
    end
    
    def format_ai_analysis_prompt(question, answer_data, form_context)
      answer_value = answer_data.is_a?(Hash) ? answer_data['value'] : answer_data
      
      <<~PROMPT
        Analyze the following form response and provide insights in JSON format.

        **Form Context:**
        - Form Name: #{form_context[:form_name]}
        - Form Category: #{form_context[:form_category]}
        - Total Questions: #{form_context[:questions_count]}

        **Question Details:**
        - Question: "#{question.title}"
        - Type: #{question.question_type}
        - Required: #{question.required?}
        - Description: #{question.description || 'None'}

        **User Response:**
        "#{answer_value}"

        **Analysis Required:**
        Please analyze this response and return a JSON object with the following structure:

        {
          "sentiment": "positive|neutral|negative|very_positive|very_negative",
          "confidence_score": 0.0-1.0,
          "quality_indicators": {
            "completeness": 0.0-1.0,
            "relevance": 0.0-1.0,
            "clarity": 0.0-1.0
          },
          "insights": [
            {
              "type": "sentiment|quality|content|behavioral",
              "description": "Brief insight description",
              "confidence": 0.0-1.0
            }
          ],
          "flags": [
            {
              "type": "spam|inappropriate|incomplete|suspicious",
              "reason": "Explanation of the flag",
              "severity": "low|medium|high"
            }
          ],
          "keywords": ["extracted", "key", "terms"],
          "summary": "Brief summary of the response analysis"
        }

        **Guidelines:**
        - Be objective and professional in your analysis
        - Consider the question type when evaluating response quality
        - Flag any potentially problematic content
        - Extract meaningful keywords and themes
        - Provide actionable insights for form optimization
      PROMPT
    end
    
    def format_followup_prompt(question, answer_data, form_context, previous_responses, ai_analysis = {})
      answer_value = answer_data.is_a?(Hash) ? answer_data['value'] : answer_data
      
      <<~PROMPT
        Generate a contextual follow-up question based on the user's response.

        **Form Context:**
        - Form Name: #{form_context[:form_name]}
        - Form Category: #{form_context[:form_category]}
        - Purpose: #{form_context[:settings]&.dig('purpose') || 'General information collection'}

        **Original Question:**
        - Question: "#{question.title}"
        - Type: #{question.question_type}
        - Description: #{question.description || 'None'}

        **User's Response:**
        "#{answer_value}"

        **AI Analysis:**
        - Sentiment: #{ai_analysis.dig('sentiment') || 'neutral'}
        - Confidence: #{ai_analysis.dig('confidence_score') || 'unknown'}
        - Key Insights: #{ai_analysis.dig('insights')&.map { |i| i['description'] }&.join(', ') || 'None'}

        **Previous Responses Context:**
        #{previous_responses.map { |q, a| "- #{q}: #{a}" }.join("\n")}

        **Instructions:**
        Generate a natural, conversational follow-up question that:
        1. Builds on their response to gather more valuable information
        2. Feels like a natural conversation, not an interrogation
        3. Is relevant to the form's purpose and context
        4. Helps qualify or better understand their needs/situation
        5. Is concise and easy to answer

        **Response Format (JSON):**
        {
          "question": {
            "title": "The follow-up question text",
            "description": "Optional helpful description or context",
            "question_type": "text_short|text_long|multiple_choice|rating|yes_no",
            "configuration": {
              // Type-specific configuration (options for choice questions, scale for ratings, etc.)
            },
            "required": false
          },
          "reasoning": "Brief explanation of why this follow-up adds value",
          "confidence": 0.0-1.0,
          "priority": "high|medium|low"
        }

        **Guidelines:**
        - Keep questions conversational and natural
        - Avoid repetitive or obvious questions
        - Focus on gathering actionable insights
        - Consider the user's emotional state from their response
        - Make the question feel valuable, not burdensome
      PROMPT
    end
  end
end
</file>

<file path="workflows/application_workflow.rb">
# frozen_string_literal: true

# Base workflow class for all SuperAgent workflows in this application
class ApplicationWorkflow < SuperAgent::WorkflowDefinition
  include SuperAgent::WorkflowHelpers
  
  # Class method to execute the workflow
  def self.execute(**params)
    # Create a context from the parameters
    context = SuperAgent::Workflow::Context.new(params)
    
    # Use the WorkflowEngine to execute
    engine = SuperAgent::WorkflowEngine.new
    result = engine.execute(self, context)
    
    # Return the result in a format compatible with the controller
    if result.success?
      # Get the final output from the last task
      final_output = result.respond_to?(:final_output) ? result.final_output : {}
      final_output.merge(success: true)
    else
      error_message = result.respond_to?(:error_message) ? result.error_message : result.error.to_s
      error_type = result.respond_to?(:error_type) ? result.error_type : 'workflow_error'
      
      {
        success: false,
        message: error_message,
        error_type: error_type
      }
    end
  rescue StandardError => e
    Rails.logger.error "Workflow execution failed: #{e.message}"
    Rails.logger.error e.backtrace.join("\n")
    {
      success: false,
      message: e.message,
      error_type: 'execution_error'
    }
  end
  
  # Global workflow configuration
  # timeout 300 # 5 minutes default - TODO: Configure when SuperAgent supports it
  # retry_policy max_retries: 2, delay: 1 # TODO: Configure when SuperAgent supports it
  
  # TODO: Global error handling - Enable when SuperAgent supports it
  # on_error do |error, context|
  #   Rails.logger.error "Workflow error in #{self.class.name}: #{error.message}"
  #   Rails.logger.error error.backtrace.join("\n") if Rails.env.development?
  #   
  #   # Track error in Sentry if available
  #   if defined?(Sentry)
  #     Sentry.capture_exception(error, extra: { 
  #       workflow: self.class.name,
  #       context: context.to_h 
  #     })
  #   end
  #   
  #   {
  #     error: true,
  #     error_message: error.message,
  #     error_type: error.class.name,
  #     timestamp: Time.current.iso8601,
  #     workflow: self.class.name
  #   }
  # end
  
  # TODO: Common workflow hooks - Enable when SuperAgent supports it
  # before_all do |context|
  #   Rails.logger.info "Starting workflow #{self.class.name}"
  #   context.set(:workflow_started_at, Time.current)
  #   context.set(:workflow_id, SecureRandom.uuid)
  #   
  #   # Initialize AI usage tracking
  #   context.set(:ai_usage, {
  #     total_cost: 0.0,
  #     operations: [],
  #     budget_limit: Rails.application.config.ai_budget_per_workflow || 1.0
  #   })
  # end
  # 
  # after_all do |context|
  #   started_at = context.get(:workflow_started_at)
  #   duration = started_at ? Time.current - started_at : 0
  #   ai_usage = context.get(:ai_usage)
  #   
  #   Rails.logger.info "Completed workflow #{self.class.name} in #{duration.round(2)}s"
  #   Rails.logger.info "AI usage: $#{ai_usage[:total_cost].round(4)} across #{ai_usage[:operations].length} operations"
  #   
  #   # Store workflow metrics if needed
  #   store_workflow_metrics(context, duration, ai_usage) if respond_to?(:store_workflow_metrics, true)
  # end
  
  protected
  
  # Helper method to track AI usage and costs
  def track_ai_usage(context, cost, operation)
    ai_usage = context.get(:ai_usage)
    
    ai_usage[:total_cost] += cost.to_f
    ai_usage[:operations] << {
      operation: operation,
      cost: cost.to_f,
      timestamp: Time.current.iso8601
    }
    
    context.set(:ai_usage, ai_usage)
    
    Rails.logger.debug "AI operation '#{operation}' cost: $#{cost.round(4)}, total: $#{ai_usage[:total_cost].round(4)}"
    
    ai_usage
  end
  
  # Helper method to check if AI budget is available
  def ai_budget_available?(context, estimated_cost)
    ai_usage = context.get(:ai_usage)
    budget_limit = ai_usage[:budget_limit]
    
    return true if budget_limit.nil? || budget_limit <= 0 # No limit set
    
    projected_total = ai_usage[:total_cost] + estimated_cost.to_f
    available = projected_total <= budget_limit
    
    unless available
      Rails.logger.warn "AI budget exceeded: projected $#{projected_total.round(4)} > limit $#{budget_limit}"
    end
    
    available
  end
  
  # Helper method to get form context
  def get_form_context(form_id)
    form = Form.find(form_id)
    {
      form_id: form.id,
      form_name: form.name,
      form_category: form.category,
      ai_enhanced: form.ai_enhanced?,
      ai_model: form.ai_model || 'gpt-3.5-turbo',
      questions_count: form.form_questions.count,
      settings: form.settings
    }
  rescue ActiveRecord::RecordNotFound
    Rails.logger.error "Form not found: #{form_id}"
    nil
  end
  
  # Helper method to get response context
  def get_response_context(response_id)
    response = FormResponse.find(response_id)
    {
      response_id: response.id,
      form_id: response.form_id,
      status: response.status,
      progress: response.progress_percentage,
      session_id: response.session_id,
      answers_count: response.question_responses.count,
      created_at: response.created_at
    }
  rescue ActiveRecord::RecordNotFound
    Rails.logger.error "FormResponse not found: #{response_id}"
    nil
  end
  
  # Helper method to get question context
  def get_question_context(question_id)
    question = FormQuestion.find(question_id)
    {
      question_id: question.id,
      form_id: question.form_id,
      title: question.title,
      question_type: question.question_type,
      required: question.required?,
      ai_enhanced: question.ai_enhanced?,
      position: question.position,
      configuration: question.question_config
    }
  rescue ActiveRecord::RecordNotFound
    Rails.logger.error "FormQuestion not found: #{question_id}"
    nil
  end
  
  # Helper method to validate workflow inputs
  def validate_required_inputs(context, *required_keys)
    missing_keys = required_keys.select { |key| context.get(key).nil? }
    
    if missing_keys.any?
      error_message = "Missing required inputs: #{missing_keys.join(', ')}"
      Rails.logger.error error_message
      raise ArgumentError, error_message
    end
    
    true
  end
  
  # Helper method to safely execute database operations
  def safe_db_operation
    ActiveRecord::Base.transaction do
      yield
    end
  rescue ActiveRecord::RecordInvalid => e
    Rails.logger.error "Database validation error: #{e.message}"
    { error: true, message: e.message, type: 'validation_error' }
  rescue ActiveRecord::RecordNotFound => e
    Rails.logger.error "Record not found: #{e.message}"
    { error: true, message: e.message, type: 'not_found_error' }
  rescue StandardError => e
    Rails.logger.error "Database operation failed: #{e.message}"
    { error: true, message: e.message, type: 'database_error' }
  end
  
  # Helper method to format workflow results
  def format_success_result(data = {})
    {
      success: true,
      timestamp: Time.current.iso8601,
      workflow: self.class.name
    }.merge(data)
  end
  
  # Helper method to format error results
  def format_error_result(message, type = 'workflow_error', data = {})
    {
      error: true,
      error_message: message,
      error_type: type,
      timestamp: Time.current.iso8601,
      workflow: self.class.name
    }.merge(data)
  end
  
  private
  
  # Store workflow execution metrics
  def store_workflow_metrics(context, duration, ai_usage)
    # This could be extended to store metrics in a dedicated table
    # or send to an analytics service
    Rails.logger.info "Workflow metrics stored for #{self.class.name}"
  end
end
</file>

<file path="workflows/payment_validation_workflow.rb">
# frozen_string_literal: true

class PaymentValidationWorkflow < ApplicationWorkflow
  
  workflow do
    # Step 1: Validate and prepare template for analysis
    task :validate_and_prepare_template do
      process do |context|
        template = context.get(:template)
        
        Rails.logger.info "Starting payment validation workflow for template: #{template&.id}"
        
        # Validate required inputs
        if template.nil?
          raise ArgumentError, "Missing required inputs: template"
        end
        
        # Ensure template exists and is valid
        unless template.respond_to?(:id) && template.id.present?
          raise ArgumentError, "Invalid template provided"
        end
        
        # Check if template has questions to analyze
        questions_count = if template.respond_to?(:questions_config)
                           template.questions_config.length
                         elsif template.respond_to?(:form_questions)
                           template.form_questions.count
                         elsif template.respond_to?(:questions)
                           template.questions.count
                         else
                           0
                         end
        
        if questions_count == 0
          Rails.logger.warn "Template #{template.id} has no questions to analyze"
          {
            template: template,
            questions_count: 0,
            has_questions: false,
            validation_status: 'no_questions'
          }
        else
        
        Rails.logger.info "Template validation successful - #{questions_count} questions found"
        
        {
          template: template,
          questions_count: questions_count,
          has_questions: true,
          validation_status: 'valid'
        }
        end
      end
    end

    # Step 2: Analyze payment requirements using TemplateAnalysisService
    task :analyze_payment_requirements do
      process do |context|
        validation_result = context.get(:validate_and_prepare_template)
        template = validation_result[:template]
        
        # Skip analysis if no questions
        if !validation_result[:has_questions]
          {
            has_payment_questions: false,
            required_features: [],
            setup_complexity: 'none',
            analysis_status: 'skipped_no_questions'
          }
        else
        
        Rails.logger.info "Analyzing payment requirements for template #{template.id}"
        
        begin
          # Use TemplateAnalysisService to analyze payment requirements
          analysis_service = TemplateAnalysisService.call(template: template)
          
          unless analysis_service.success?
            raise "Template analysis failed: #{analysis_service.errors.full_messages.join(', ')}"
          end
          
          analysis_result = analysis_service.result
          
          # Validate analysis result structure
          unless analysis_result.is_a?(Hash)
            raise "Invalid analysis result format from TemplateAnalysisService"
          end
          
          required_keys = [:has_payment_questions, :required_features, :setup_complexity]
          missing_keys = required_keys.select { |key| !analysis_result.key?(key) }
          
          if missing_keys.any?
            raise "Missing keys in analysis result: #{missing_keys.join(', ')}"
          end
          
          Rails.logger.info "Payment analysis completed - has_payment_questions: #{analysis_result[:has_payment_questions]}"
          
          {
            has_payment_questions: analysis_result[:has_payment_questions],
            required_features: analysis_result[:required_features] || [],
            setup_complexity: analysis_result[:setup_complexity] || 'none',
            analysis_status: 'completed',
            payment_question_types: analysis_result[:payment_question_types] || []
          }
          
        rescue StandardError => e
          Rails.logger.error "Payment requirements analysis failed: #{e.message}"
          
          # Return safe defaults on analysis failure
          {
            has_payment_questions: false,
            required_features: [],
            setup_complexity: 'unknown',
            analysis_status: 'failed',
            analysis_error: e.message
          }
        end
        end
      end
    end

    # Step 3: Validate user setup using PaymentSetupValidationService
    task :validate_user_setup do
      process do |context|
        user = context.get(:user)
        requirements_result = context.get(:analyze_payment_requirements)
        
        Rails.logger.info "Validating user setup for user: #{user&.id}"
        
        # Validate required inputs
        if user.nil?
          raise ArgumentError, "Missing required inputs: user"
        end
        
        # Skip validation if no payment requirements
        unless requirements_result[:has_payment_questions]
          {
            setup_valid: true,
            missing_requirements: [],
            setup_actions: [],
            validation_status: 'no_payment_requirements'
          }
        else
        
        required_features = requirements_result[:required_features]
        
        begin
          # Use PaymentSetupValidationService to validate user setup
          validation_service = PaymentSetupValidationService.call(user: user, required_features: required_features)
          
          unless validation_service.success?
            raise "User setup validation failed: #{validation_service.errors.full_messages.join(', ')}"
          end
          
          validation_result = validation_service.result
          
          # Validate service result structure
          unless validation_result.is_a?(Hash)
            raise "Invalid validation result format from PaymentSetupValidationService"
          end
          
          required_keys = [:valid, :missing_requirements, :setup_actions]
          missing_keys = required_keys.select { |key| !validation_result.key?(key) }
          
          if missing_keys.any?
            raise "Missing keys in validation result: #{missing_keys.join(', ')}"
          end
          
          Rails.logger.info "User setup validation completed - valid: #{validation_result[:valid]}"
          
          {
            setup_valid: validation_result[:valid],
            missing_requirements: validation_result[:missing_requirements] || [],
            setup_actions: validation_result[:setup_actions] || [],
            validation_status: 'completed',
            user_capabilities: validation_result[:user_capabilities] || {}
          }
          
        rescue StandardError => e
          Rails.logger.error "User setup validation failed: #{e.message}"
          
          # Return conservative defaults on validation failure
          {
            setup_valid: false,
            missing_requirements: ['validation_failed'],
            setup_actions: [{
              type: 'validation_error',
              message: 'Unable to validate payment setup',
              action_url: nil,
              action_text: 'Contact Support'
            }],
            validation_status: 'failed',
            validation_error: e.message
          }
        end
        end
      end
    end

    # Step 4: Generate user guidance based on validation results
    task :generate_user_guidance do
      process do |context|
        requirements_result = context.get(:analyze_payment_requirements)
        validation_result = context.get(:validate_user_setup)
        template_result = context.get(:validate_and_prepare_template)
        
        Rails.logger.info "Generating user guidance"
        
        # If no payment requirements, provide success guidance
        if !requirements_result[:has_payment_questions]
          {
            guidance_type: 'no_payment_setup_needed',
            message: 'This template does not require payment configuration.',
            can_proceed: true,
            setup_required: false,
            actions: [],
            guidance_status: 'completed'
          }
        # If setup is valid, provide success guidance
        elsif validation_result[:setup_valid]
          {
            guidance_type: 'setup_complete',
            message: 'Your payment configuration is complete. You can use this template.',
            can_proceed: true,
            setup_required: false,
            actions: [],
            guidance_status: 'completed'
          }
        else
        
        # Generate guidance for incomplete setup
        missing_requirements = validation_result[:missing_requirements] || []
        setup_actions = validation_result[:setup_actions] || []
        
        # Determine guidance type based on missing requirements
        guidance_type = case missing_requirements.length
                       when 0
                         'setup_complete'
                       when 1
                         case missing_requirements.first
                         when 'stripe_configuration'
                           'stripe_setup_required'
                         when 'premium_subscription'
                           'premium_upgrade_required'
                         else
                           'single_requirement_missing'
                         end
                       else
                         'multiple_requirements_missing'
                       end
        
        # Generate appropriate message
        message = generate_guidance_message(guidance_type, missing_requirements, requirements_result[:setup_complexity])
        
        # Enhance setup actions with additional context
        enhanced_actions = setup_actions.map do |action|
          action.merge(
            template_id: template_result[:template].id,
            required_features: requirements_result[:required_features],
            setup_complexity: requirements_result[:setup_complexity]
          )
        end
        
        Rails.logger.info "User guidance generated - type: #{guidance_type}, actions: #{enhanced_actions.length}"
        
        {
          guidance_type: guidance_type,
          message: message,
          can_proceed: false,
          setup_required: true,
          missing_requirements: missing_requirements,
          actions: enhanced_actions,
          setup_complexity: requirements_result[:setup_complexity],
          estimated_setup_time: estimate_setup_time(missing_requirements, requirements_result[:setup_complexity]),
          guidance_status: 'completed'
        }
        end
      end
    end
  end

  private

  def generate_guidance_message(guidance_type, missing_requirements, setup_complexity)
    case guidance_type
    when 'stripe_setup_required'
      "To use this payment-enabled template, you need to configure Stripe for payment processing."
    when 'premium_upgrade_required'
      "This template includes premium payment features. Upgrade to Premium to use payment questions."
    when 'multiple_requirements_missing'
      requirements_text = missing_requirements.map do |req|
        case req
        when 'stripe_configuration'
          'Stripe payment configuration'
        when 'premium_subscription'
          'Premium subscription'
        else
          req.humanize
        end
      end.join(' and ')
      
      "To use this payment-enabled template, you need: #{requirements_text}."
    when 'single_requirement_missing'
      requirement = missing_requirements.first&.humanize || 'payment setup'
      "To use this template, you need to complete: #{requirement}."
    else
      "Payment setup is required to use this template."
    end
  end

  def estimate_setup_time(missing_requirements, setup_complexity)
    base_time = case setup_complexity
               when 'simple'
                 5
               when 'moderate'
                 10
               when 'complex'
                 20
               else
                 10
               end
    
    # Add time for each missing requirement
    additional_time = missing_requirements.length * 3
    
    total_minutes = base_time + additional_time
    
    if total_minutes <= 5
      "5 minutes"
    elsif total_minutes <= 15
      "10-15 minutes"
    elsif total_minutes <= 30
      "20-30 minutes"
    else
      "30+ minutes"
    end
  end
end
</file>

</files>
