# frozen_string_literal: true

require 'rails_helper'

RSpec.describe Ai::DatabaseOptimizationService, type: :service do
  let(:user) { create(:user) }
  let(:form_data) do
    {
      name: 'Test AI Form',
      description: 'Generated by AI',
      category: 'lead_generation',
      ai_enabled: true
    }
  end
  let(:questions_data) do
    [
      {
        title: 'What is your name?',
        question_type: 'text_short',
        required: true
      },
      {
        title: 'Email address',
        question_type: 'email',
        required: true
      }
    ]
  end

  describe '.create_form_with_questions_optimized' do
    it 'creates form and questions in a single transaction' do
      expect {
        result = described_class.create_form_with_questions_optimized(user, form_data, questions_data)
        
        expect(result[:form]).to be_persisted
        expect(result[:questions].length).to eq(2)
        expect(result[:form].form_questions.count).to eq(2)
      }.to change(Form, :count).by(1)
        .and change(FormQuestion, :count).by(2)
    end

    it 'rolls back transaction on error' do
      # Force an error by making questions_data invalid
      invalid_questions_data = [{ title: nil, question_type: 'invalid' }]
      
      expect {
        expect {
          described_class.create_form_with_questions_optimized(user, form_data, invalid_questions_data)
        }.to raise_error(ActiveRecord::RecordInvalid)
      }.not_to change(Form, :count)
    end

    it 'updates form metadata with question count' do
      result = described_class.create_form_with_questions_optimized(user, form_data, questions_data)
      
      expect(result[:form].metadata['questions_count']).to eq(2)
      expect(result[:form].metadata['last_optimized_at']).to be_present
    end
  end

  describe '.find_ai_enabled_forms_for_user' do
    let!(:ai_form) { create(:form, user: user, ai_enabled: true, status: 'published') }
    let!(:regular_form) { create(:form, user: user, ai_enabled: false) }
    let!(:other_user_form) { create(:form, ai_enabled: true, status: 'published') }

    it 'returns only AI-enabled forms for the user' do
      forms = described_class.find_ai_enabled_forms_for_user(user.id)
      
      expect(forms).to include(ai_form)
      expect(forms).not_to include(regular_form)
      expect(forms).not_to include(other_user_form)
    end

    it 'includes form_questions and user associations' do
      forms = described_class.find_ai_enabled_forms_for_user(user.id)
      
      expect(forms.first.association(:form_questions)).to be_loaded
      expect(forms.first.association(:user)).to be_loaded
    end

    it 'respects the limit parameter' do
      create_list(:form, 10, user: user, ai_enabled: true, status: 'published')
      
      forms = described_class.find_ai_enabled_forms_for_user(user.id, limit: 5)
      
      expect(forms.length).to eq(5)
    end
  end

  describe '.load_responses_with_ai_analysis' do
    let(:form) { create(:form, user: user) }
    let!(:analyzed_response) do
      create(:form_response, 
        form: form, 
        status: 'completed',
        ai_analysis: { sentiment: 'positive', score: 0.8 }
      )
    end
    let!(:unanalyzed_response) do
      create(:form_response, 
        form: form, 
        status: 'completed',
        ai_analysis: {}
      )
    end

    it 'returns only responses with AI analysis' do
      responses = described_class.load_responses_with_ai_analysis(form.id)
      
      expect(responses).to include(analyzed_response)
      expect(responses).not_to include(unanalyzed_response)
    end

    it 'includes question_responses and form associations' do
      responses = described_class.load_responses_with_ai_analysis(form.id)
      
      expect(responses.first.association(:question_responses)).to be_loaded
      expect(responses.first.association(:form)).to be_loaded
    end
  end

  describe '.users_approaching_ai_limit' do
    let!(:user_near_limit) do
      create(:user, ai_credits_used: 8.0, monthly_ai_limit: 10.0, active: true)
    end
    let!(:user_under_limit) do
      create(:user, ai_credits_used: 2.0, monthly_ai_limit: 10.0, active: true)
    end
    let!(:inactive_user) do
      create(:user, ai_credits_used: 9.0, monthly_ai_limit: 10.0, active: false)
    end

    it 'returns users approaching their AI limit' do
      users = described_class.users_approaching_ai_limit(threshold_percentage: 0.8)
      
      expect(users).to include(user_near_limit)
      expect(users).not_to include(user_under_limit)
      expect(users).not_to include(inactive_user)
    end

    it 'includes forms association' do
      users = described_class.users_approaching_ai_limit
      
      expect(users.first.association(:forms)).to be_loaded
    end
  end

  describe '.batch_update_ai_analysis' do
    let(:form) { create(:form, user: user) }
    let!(:responses) { create_list(:form_response, 3, form: form) }
    let(:analysis_data) { { sentiment: 'positive', confidence: 0.9 } }

    it 'updates all specified responses' do
      response_ids = responses.map(&:id)
      
      described_class.batch_update_ai_analysis(response_ids, analysis_data)
      
      responses.each do |response|
        response.reload
        expect(response.ai_analysis).to eq(analysis_data.stringify_keys)
      end
    end

    it 'handles empty response_ids gracefully' do
      expect {
        described_class.batch_update_ai_analysis([], analysis_data)
      }.not_to raise_error
    end
  end

  describe '.with_optimized_connection' do
    it 'yields a database connection' do
      described_class.with_optimized_connection do |connection|
        expect(connection).to respond_to(:execute)
      end
    end

    it 'sets AI-specific connection parameters' do
      described_class.with_optimized_connection do |connection|
        # Test that work_mem is set (this would require checking the connection state)
        expect(connection).to be_present
      end
    end
  end

  describe '.batch_process_ai_operations' do
    let(:operations) { (1..10).to_a }

    it 'processes operations in batches' do
      results = described_class.batch_process_ai_operations(operations, batch_size: 3) do |operation|
        operation * 2
      end
      
      expect(results).to eq([2, 4, 6, 8, 10, 12, 14, 16, 18, 20])
    end

    it 'uses optimized connections for each batch' do
      connection_count = 0
      
      described_class.batch_process_ai_operations(operations, batch_size: 5) do |operation|
        connection_count += 1
        operation
      end
      
      expect(connection_count).to eq(10)
    end
  end

  describe '.calculate_form_analytics_optimized' do
    let(:form) { create(:form, user: user) }
    let!(:completed_response) do
      create(:form_response, 
        form: form, 
        status: 'completed',
        time_spent_seconds: 120,
        ai_score: 0.8,
        qualified_lead: true
      )
    end
    let!(:abandoned_response) do
      create(:form_response, 
        form: form, 
        status: 'abandoned',
        time_spent_seconds: 30
      )
    end

    it 'calculates analytics using optimized query' do
      analytics = described_class.calculate_form_analytics_optimized(form.id)
      
      expect(analytics['total_responses']).to eq(2)
      expect(analytics['completed_responses']).to eq(1)
      expect(analytics['abandoned_responses']).to eq(1)
      expect(analytics['qualified_leads']).to eq(1)
    end

    it 'respects date range parameter' do
      date_range = 1.day.ago..Time.current
      
      analytics = described_class.calculate_form_analytics_optimized(form.id, date_range: date_range)
      
      expect(analytics).to be_present
    end
  end

  describe '.preload_form_for_ai_workflow' do
    let(:form) { create(:form, user: user) }
    let!(:question) { create(:form_question, form: form) }
    let!(:response) { create(:form_response, form: form) }
    let!(:question_response) { create(:question_response, form_response: response, form_question: question) }

    it 'preloads all necessary associations' do
      preloaded_form = described_class.preload_form_for_ai_workflow(form.id)
      
      expect(preloaded_form.association(:user)).to be_loaded
      expect(preloaded_form.association(:form_questions)).to be_loaded
      expect(preloaded_form.association(:form_responses)).to be_loaded
      expect(preloaded_form.form_responses.first.association(:question_responses)).to be_loaded
    end
  end

  describe '.optimize_database_for_ai' do
    it 'returns list of optimizations performed' do
      optimizations = described_class.optimize_database_for_ai
      
      expect(optimizations).to be_an(Array)
      expect(optimizations).to include('created_ai_partial_indexes')
      expect(optimizations).to include('updated_table_statistics')
      expect(optimizations).to include('configured_ai_parameters')
    end
  end

  describe '.monitor_ai_database_performance' do
    it 'returns performance metrics' do
      metrics = described_class.monitor_ai_database_performance
      
      expect(metrics).to have_key(:timestamp)
      expect(metrics).to have_key(:connection_pool_stats)
      expect(metrics).to have_key(:query_performance)
      expect(metrics).to have_key(:index_usage)
      expect(metrics).to have_key(:table_sizes)
    end

    it 'tracks performance metrics' do
      expect(Ai::UsageAnalyticsService).to receive(:track_event).with(
        hash_including(event_type: 'database_performance_monitoring')
      )
      
      described_class.monitor_ai_database_performance
    end
  end
end